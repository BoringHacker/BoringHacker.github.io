<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">数据结构100题 21~30题 | BoringHacker&#39;s Blog</title>
  
    <link rel="shortcut icon" href="https://i.loli.net/2020/02/06/fvXuYw6p9PDCOR3.png">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
    <style>
  .emoji-coda {
      display: inline-block !important;
      position: relative;
      width: 45px;
      top: 2px;
      margin: -3px 3px !important;
      padding: 0;
  }
  </style>

  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "BoringHacker'sBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "https://www.orchid-any.cf/";
  mashiro_option.v_appId = "8Hho6gvnedMT9NMEhnEx3UOg-gzGzoHsz";
  mashiro_option.v_appKey = "gU70zYoblzxCmc6iL697pp69";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://i.loli.net/2020/02/06/QA9iLJO3bxechgl.jpg,https://i.loli.net/2020/02/06/y7XPcCUKonORjNf.jpg,https://i.loli.net/2020/02/06/x5iQL7yYCS6s4aN.jpg,https://i.loli.net/2020/02/06/ASPhQ5EZOHjy4m2.jpg,https://i.loli.net/2020/02/06/vChPneTKf6xF7dw.jpg,https://i.loli.net/2020/02/06/ciZsjA4hQEqYvUk.jpg,https://i.loli.net/2020/02/06/ymPMJQchwzRLBCl.jpg,https://i.loli.net/2020/02/06/FulkGY4BE175moj.jpg".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
   <div class="skin-menu no-select" id="mainskin" style="position: fixed;bottom:65px;left:31px;">
    <div class="theme-controls row-container">
          <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> background <i style="color:grey" class="fa fa-chevron-right"></i></p>
        <ul class="menu-list"> <li id="white-bg"> 
            <i class="fa fa-television" aria-hidden="true">
            </i>
            </li> 
            <li id="sakura-bg"> 
                <i class="iconfont icon-sakura">
                </i>
            </li>
            <li id="gribs-bg">
                <i class="fa fa-slack" aria-hidden="true">
                </i>
            </li>
            <li id="KAdots-bg">
                <i class="iconfont icon-dots">
                </i>
            </li>
            <li id="totem-bg">
                <i class="fa fa-optin-monster" aria-hidden="true">
                </i>
            </li>
            <li id="pixiv-bg">
                <i class="iconfont icon-pixiv">
                </i>
            </li>
            <li id="bing-bg">
                <i class="iconfont icon-bing">
                </i>
            </li>
            <li id="dark-bg">
                <i class="fa fa-moon-o" aria-hidden="true">
                </i>
            </li>
        </ul>
    </div>
      <hr>
  <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> font <i style="color:grey" class="fa fa-chevron-right"></i></p>
  <div class="font-family-controls row-container">
    <button type="button" class="control-btn-serif " data-mode="serif" onclick="mashiro_global.font_control.change_font()">Serif</button>
    <button type="button" class="control-btn-sans-serif" data-mode="sans-serif" onclick="mashiro_global.font_control.change_font()">Sans Serif</button>
  </div>
  <hr>
  <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> script <i style="color:grey" class="fa fa-chevron-right"></i></p>
  <div class="theme-controls row-container">
  <ul class="menu-list">
    <li id="empty-effect">
      <i class="fa fa-ban">
      </i>
    </li>
    <li id="sakura-rain-effect">
      <i class="iconfont icon-sakura">
      </i>
    </li>
    <li id="snowy-effect">
      <i class="fa fa-snowflake-o">
      </i>
    </li>
    <li id="lines-effect">
      <i class="fa fa-chevron-left">
      </i>
    </li>
    <li id="colorful-belts-effect">
      <i class="fa fa-map"></i>
      </i>
    </li>
    <li id="words-rain-effect">
      <i class="fa fa-font"></i>
    </li>
    <li id="point-rain-effect">
      <i class="iconfont icon-dots"></i>
    </li>
    <li id="rain-drop-effect">
      <i class="fa fa-tint"></i>
    </li>
  </ul>
  </div>

    <canvas id="night-mode-cover">
    </canvas>
</div>
 
 <div class="changeSkin-gear no-select" style="background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%; visibility: visible; bottom: 0px;"> 
  <div class="keys" id="setbtn"> 
    <button id="open-skinMenu">
        <style>
        button#open-skinMenu{
            transition: all 0.2s linear 0s;
            outline:none;
            position:fixed;
            bottom:13px;
            left:15px;
            font-size:16px;
            background-color: rgba(255,255,255,.95);
            border-radius: 20px;
            box-shadow: 0 3px 8px 0 rgba(0,0,0,0.1), 0 3px 8px 0 rgba(0,0,0,0.1);
        }
        button#open-skinMenu:hover{
            transition: all 0.2s linear 0s;
            background-color: rgb(255, 165, 0);
            color: rgba(255,255,255);
        }
        </style>
        <i class="iconfont icon-gear inline-block rotating">
      </i> 
        SCHEME TOOL | 主题工具 
    </button>
  </div> 
</div>


  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://www.orchid-any.cf/">
          <img src="https://i.loli.net/2020/02/06/fuc7zI8iylU5ANt.jpg">
        </a>
      </div>
      <div class="header-info">
        <p>Stay Hungry, Stay Foolish</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/boringhacker" target="_blank" class="social-github" title="github">
                    <img src="https://i.loli.net/2020/02/06/JWRHC7AUqzseoDV.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://music.163.com/#/user/home?id=1842865470" target="_blank" class="social-github" title="NetEase">
                    <img src="https://i.loli.net/2020/02/06/JA28YeoESRvpQZk.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/boringhacker" target="_blank" class="social-github" title="zhihu">
                    <img src="https://i.loli.net/2020/02/06/YzfiMGnHqW12Tp7.png">
                  </a>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <!-- <div id="video-btn" class="loadvideo videolive">
    </div> -->
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <!-- <span class="sakurasono">BoringHacker&#39;s</span>
            <span class="shironeko">Blog</span> -->
            <img src = https://i.loli.net/2020/02/06/hfRpABJw9jXScay.png>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    Home
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    Archives
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/categories/Note/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          Notes
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/Solution">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          Solution
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="javascript:;">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
                    Lists
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/tags/悦读/">
                          <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                          Books
                        </a>
                      </li>
                    
                      <li>
                        <a href="/bangumi/">
                          <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                          Animes
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    Comments
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    Links
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    About
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          Me
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Blog
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>

  <div class="pattern-center single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://i.loli.net/2020/02/08/iXSqlWCpTkrsDt6.jpg);" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://i.loli.net/2020/02/08/iXSqlWCpTkrsDt6.jpg">
    </div>
    <header class="pattern-header single-header" style="text-shadow: 0 0 7px #000,0 0 7px #000">

      <h1 class="entry-title">
      数据结构100题 21~30题</h1>
      <p class="entry-census">
        <span>
          <a href="/">
            <img src="https://i.loli.net/2020/02/06/fuc7zI8iylU5ANt.jpg">
          </a>
        </span>
        <span>
          <a href="/">BoringHacker</a>
        </span>
        <span class="bull">
        ·</span>
        2020-2-8<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
      
        
          <div>
            <ul class="spfk-ul">
              &nbsp<i class="fa fa-tag" aria-hidden="true"></i>&nbsp&nbsp&nbsp&nbsp
              <li class="spfk-li"><a href="/tags/DS100P/" class="butterfly-tags">DS100P</a></li>
            </ul>
          </div>
          <script>
              function colorInit(c,num){for(var i=1;i<=num;++i)c.push(i+'');}
              function paintTags(){
                  var colorNumber=8,tagColors=[],tags=document.getElementsByClassName('butterfly-tags');
                  for(var i = 0 ; i < tags.length ; ++i){
                      if(!tagColors.length)colorInit(tagColors,colorNumber);
                      var j=Math.floor(Math.random()*tagColors.length);
                      tags[i].classList.add("spfk-color"+tagColors[j]);
                      tagColors.splice(j,1);
                  }
              }
              paintTags()
          </script>
        
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="21-P4172-WC2006-水管局长"><a href="#21-P4172-WC2006-水管局长" class="headerlink" title="21.P4172 [WC2006]水管局长"></a>21.P4172 [WC2006]水管局长</h1><p>SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦），嘟嘟作为水管局长的工作就是：每天供水公司可能要将一定量的水从 $x$ 处送往 $y$ 处，嘟嘟需要为供水公司找到一条从 $A$ 至 $B$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。</p>
<p>在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。</p>
<p>不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。</p>
<hr>
<p>这道题只有删边操作，我们可以把这个过程看做是加边操作，这样好处理一点。</p>
<p>题目保证了图无论怎么删边都保证联通，所以我们可以先把图删完。删完后我们呢求出图的MST, 那么任意两点在这颗MST上走都是最优的<del>别问我怎么证贪心是用来证的吗</del>。我们可以用LCT来维护这颗MST，Splay维护区间最大值(也就是链上的最大值)</p>
<p>考虑加边操作。上面我提到了一个贪心：任意两点在这颗MST上走都是最优的。如果此时我们在MST上任意加一条边都会形成一个环。我们可以从任意一点入环，任意一点出环，方向随意。可以发现我们的最优解始终能避开最长的一条边！</p>
<p>考察这个环，用lct的split操作提出<code>链</code>的信息，查出最大的权值。发现我们可以通过删除权值最大的边来保证<code>环</code>上的最优。</p>
<p>怎么求出这条边呢？显然我们可以二分来找</p>
<p>再来考虑一个问题：如何维护边呢？</p>
<p>考虑用一个点来表示一条边。</p>
<p>最后<code>逆序</code>加边，把答案<code>逆序</code>输出即可</p>
<p>(<del>良心题解</del>)</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
#ifndef _DEBUG_
    #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#else
    #define gc() getchar()
#endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

namespace LinkCutTree {
    const int SIZE = 12e4 + 5;
    struct SPLAY {
        int ch[2];
        int fa;
        int key;
        int maxValue;
        int lazyTag;
    } T[SIZE];
    stack &lt; int &gt; MemoryWaste; 
    #define ls T[x].ch[0]
    #define rs T[x].ch[1]
    #define WhichSon(x) (T[T[x].fa].ch[1] == x)
    #define IsRoot(x) (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x)

    void UpdateMessage(int x) {
        T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue);
    }

    void UpdateSons(int x) {
        if (T[x].lazyTag) {
            ls ^= rs ^= ls ^= rs;
            T[x].lazyTag = 0;
            T[ls].lazyTag ^= 1;
            T[rs].lazyTag ^= 1;
        }
    }

    void RotateNode(int x) {
        int y = T[x].fa;
        if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x;
        bool k = WhichSon(x);
        T[x].fa = T[y].fa;
        T[y].fa = x;
        T[y].ch[k] = T[x].ch[k ^ 1];
        T[T[y].ch[k]].fa = y;
        T[x].ch[k ^ 1] = y;
        UpdateMessage(y);
        UpdateMessage(x);
    }

    void LinkSplay(int x) {
        int u = x;
        while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa;
        MemoryWaste.push(u);
        while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop();
        for (; !IsRoot(x); RotateNode(x)) {
            int y = T[x].fa;
            if (!IsRoot(y))
                RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y);
        }
    }
    void AccessEdge(int x) {
        for (int u = x, y = 0; u; y = u, u = T[u].fa) {
            LinkSplay(u);
            T[u].ch[1] = y;
            UpdateMessage(u);
        }
    }

    void MakeRoot(int x) {
        AccessEdge(x);
        LinkSplay(x);
        T[x].lazyTag ^= 1;
    }

    void SplitTree(int x, int y) {
        MakeRoot(x);
        AccessEdge(y);
        LinkSplay(y);
    }

    void LinkTree(int x, int y) {
        MakeRoot(x);
        T[x].fa = y;
    }

    void CutTree(int x, int y) {
        MakeRoot(x);
        AccessEdge(y);
        LinkSplay(y);
        T[x].fa = T[y].ch[0] = 0;
    }

    int FindByKey(int x, int u) {
        if (T[x].key == u) return x;
        else if (T[ls].maxValue == u) return FindByKey(ls, u);
        else return FindByKey(rs, u);
    }
} // namespace LinkCutTree

using namespace LinkCutTree;

int F[1005][1005], U[101000], V[101000];
int OP[101000], ans[101000], n, m, QueryNumber;
struct EdgeNode {
    int x, y;
    int val, key;
    EdgeNode() { key = 1; }
    friend bool operator &lt; (EdgeNode X, EdgeNode Y) {
        return X.val &lt; Y.val;
    }
} e[101000];
struct UnionFindSet {
    int fa[1010];

    int find(int x) {
        if (x ^ fa[x]) fa[x] = find(fa[x]);
        return fa[x];
    }

    void merge(int x, int y) {
        int u = find(x), v = find(y);
        if (u ^ v) fa[u] = v;
    }

    void init(int n, int m) {
        for (int i = 1; i &lt;= n; ++i)
            fa[i] = i;
        for (int i = 1; i &lt;= m; ++i) {
            if (e[i].key &amp;&amp; find(e[i].x) ^ find(e[i].y)) {
                merge(e[i].x, e[i].y);
                LinkTree(e[i].x, n + i);
                LinkTree(e[i].y, n + i);
            }
        }
    }
} ufs;

signed main() {
    read(n, m, QueryNumber);
    for (int i = 1; i &lt;= m; ++i)
        read(e[i].x, e[i].y, e[i].val);
    sort(e + 1, e + 1 + m);
    for (int i = 1; i &lt;= m; ++i) {
        F[e[i].x][e[i].y] = i;
        F[e[i].y][e[i].x] = i;
        T[n + i].key = e[i].val;
    }
    for (int i = 1; i &lt;= QueryNumber; ++i) {
        read(OP[i], U[i], V[i]);
        if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0;
    }
    ufs.init(n, m);
    int EdgeCount = 0;
    for (int i = QueryNumber; i &gt;= 1; --i) {
        SplitTree(U[i], V[i]);
        if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue;
        else {
            int Temporary = FindByKey(V[i], T[V[i]].maxValue);
            if (T[F[U[i]][V[i]] + n].key &lt; T[V[i]].maxValue) {
                CutTree(e[Temporary - n].x, Temporary);
                CutTree(e[Temporary - n].y, Temporary);
                LinkTree(U[i], F[U[i]][V[i]] + n);
                LinkTree(V[i], F[U[i]][V[i]] + n);
            }    
        }
    }
    for (int i = EdgeCount; i &gt;= 1; --i)
        write(io_l, ans[i]);
    return 0;
}
</code></pre>
<h1 id="22-P3302-SDOI2013-森林"><a href="#22-P3302-SDOI2013-森林" class="headerlink" title="22.P3302 [SDOI2013]森林"></a>22.P3302 [SDOI2013]森林</h1><p>小Z有一片森林，含有N个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有M条边。</p>
<p>小Z希望执行T个操作，操作有两类：</p>
<ol>
<li><code>Q x y k</code>查询点x到点y路径上所有的权值中，第k小的权值是多少。此操作保证点x和点y连通，同时这两个节点的路径上至少有k个点。</li>
<li><code>L x y</code>在点x和点y之间连接一条边。保证完成此操作后，仍然是一片森林。</li>
</ol>
<p>为了体现程序的在线性，我们把输入数据进行了加密。设lastans为程序上一次输出的结果，初始的时候lastans为0。</p>
<ul>
<li>对于一个输入的操作<code>Q x y k</code>,其真实操作为<code>Q x^lastans y^lastans k^lastans</code>。</li>
<li>对于一个输入的操作<code>L x y</code>，其真实操作为<code>L x^lastans y^lastans</code>。其中^运算符表示异或，等价于pascal中的xor运算符。</li>
</ul>
<p>请写一个程序來帮助小Z完成这些操作。</p>
<hr>
<p>查询操作显然可以用主席树来完成，然而连接树的操作又让我们想到了lct。怎么办呢？<del>主席树+LCT？</del>(据说还真有人这么干)</p>
<p>启发式合并！</p>
<p>没错，我们用选择用主席树来完成这道题，合并时采用启发式合并。</p>
<p>具体来说就是每次合并时都用大小较小的树往大的合并，然后暴力遍历大小较小的树更新倍增数组和主席树即可</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size)
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
#define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 9e4 + 5;
const int LSIZE = SIZE &lt;&lt; 7;
const int GSIZE = SIZE &lt;&lt; 1;
int n, m, q, waste;
int tot, rt[LSIZE], b[SIZE];
int pri_n, edge_tot, a[SIZE];
int Head[GSIZE], Next[GSIZE];
int Vertex[GSIZE], Weight[GSIZE];
int f[SIZE][LSIZE / SIZE &gt;&gt; 2];
int dp[SIZE], fa[SIZE], id[SIZE];
int size[SIZE], vis[SIZE];
struct TreeNode {
    int l, r;
    int size;
} tr[LSIZE];

void add(int x, int y, int z = 1) {
    Vertex[++edge_tot] = y, Weight[edge_tot] = z;
    Next[edge_tot] = Head[x], Head[x] = edge_tot;
}

int find_set(int x) {
    return x == fa[x] ? x : fa[x] = find_set(fa[x]);
}

int make(int l, int r) {
    int u = ++tot;
    if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u;
    else return 0;
}

void modify(int &amp;u, int pre, int l, int r, int x) {
    u = ++tot;
    tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1};
    if (l ^ r)
        if (mid &gt;= x) modify(tr[u].l, tr[pre].l, l, mid, x);
        else modify(tr[u].r, tr[pre].r, mid + 1, r, x);
    else return ;
}

int query(int x, int y, int lca, int fa_lca, int l, int r, int k) {
    if (l ^ r)
        if (_size_ &gt;= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k);
        else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_);
    else return l;
}

void dfs(int x, int _rt_) {
    for (int i = 1; i &lt; 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1];
    modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]);
#define y Vertex[i]
    for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_);
#undef y
}

int get_lca(int x, int y) {
    if (dp[x] &lt; dp[y]) x ^= y ^= x ^= y;
    for (int i = 16; i &gt;= 0; --i) if (f[x][i] &amp;&amp; dp[f[x][i]] &gt;= dp[y]) x = f[x][i];
    if (x == y) return x;
    for (int i = 16; i &gt;= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}

signed main() {
    read(waste, n, m, q);
    for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i];
    sort(b + 1, b + 1 + n);
    pri_n = unique(b + 1, b + 1 + n) - b - 1;
    for (int i = 1; i &lt;= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b;
    for (int i = 1, x, y; i &lt;= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1);
    *rt = make(1, pri_n);
    for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i;
    int ans = 0, lastans = 0;
    for (int enum_q = 0; enum_q &lt; q; ++enum_q) {
        char opt[5];
        int x, y, k, lca;
        read(opt), read(x, y);
        x ^= lastans, y ^= lastans;
        if (*opt == &#39;Q&#39;) read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]);
        else {
            add(x, y, 1);
            add(y, x, 1);
            int u = find_set(x);
            int v = find_set(y);
            if (size[u] &lt; size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v;
            f[y][0] = x;
            fa[y] = x;
            dp[y] = dp[x] + 1;
            vis[y] = true;
            size[u]++;
            dfs(y, v);
        }
    }
    return 0;
}
</code></pre>
<h1 id="23-P3250-HNOI2016-网络"><a href="#23-P3250-HNOI2016-网络" class="headerlink" title="23.P3250 [HNOI2016]网络"></a>23.P3250 [HNOI2016]网络</h1><p>一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。</p>
<p>由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：</p>
<ol>
<li><p>在某两个服务器之间出现一条新的数据交互请求；</p>
</li>
<li><p>某个数据交互结束请求；</p>
</li>
<li><p>某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。</p>
</li>
</ol>
<p>你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。</p>
<hr>
<p>提供 $\Theta(n\log^3n)$ 的暴力树剖打法。</p>
<p>本来我想搞树套树+树剖的，但发现Splay常数过大容易T爆，fhq-treap也炸了。</p>
<p>后来我幡然醒悟我们只需要开两个优先队列一个放添加的值，一个放删除的值。</p>
<p>碰到查询操作时先比较两个堆的堆顶，如果相同显然它被删掉了，两个栈同时弹出；不相同时添加元素队列的队首就是答案。</p>
<p>而且这道题开O2效果特别明显，2.x s 能变成 xxx ms!</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define CheckSize ((d[top[x]] &lt; d[top[y]]) &amp;&amp; (x ^= y ^= x ^= y))
#define ForGraph int i = Head[x], y = Vertex[i]; i; i = Next[i], y = Vertex[i]
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
// #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

namespace HNOI2016_Network {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    const int SIZE = 2e5 + 5;
    const int GSIZE = SIZE &lt;&lt; 1;

    namespace SegmentTree {
        priority_queue &lt; int &gt; I[SIZE&lt;&lt;1], D[SIZE&lt;&lt;1];
        #define ls (k &lt;&lt; 1)
        #define rs (k &lt;&lt; 1 | 1)

        void DoModify(int k, int l, int r, int x, int y, int val, int opt) {
            if (!(l &gt; y || r &lt; x))
                if (l &gt;= x &amp;&amp; r &lt;= y)
                    if (opt) I[k].push(val);
                    else D[k].push(val);
                else DoModify(ls, l, mid, x, y, val, opt), DoModify(rs, mid + 1, r, x, y, val, opt);
        }

        int GetAnswer(int k, int l, int r, int x) {
            while (I[k].size() &amp;&amp; D[k].size() &amp;&amp; I[k].top() == D[k].top()) I[k].pop(), D[k].pop();
            int res = I[k].size() ? I[k].top() : -1;
            if (l ^ r)
                if (mid &gt;= x) res = max(res, GetAnswer(ls, l, mid, x));
                else res = max(res, GetAnswer(rs, mid + 1, r, x));
            return res;
        }
    } // namespace SegmentTree

    namespace TreeChainSplitting {
        int tx[SIZE], ty[SIZE], tk[SIZE];
        int Head[SIZE], Vertex[GSIZE];
        int Next[GSIZE], EdgeCount;
        int fa[SIZE], size[SIZE];
        int d[SIZE], son[SIZE];
        int dfn[SIZE], rnk[SIZE];
        int top[SIZE], tot;
        int edge_tot = 0, n, m;
        struct Vector2 {
            int x; int y;

            friend bool operator &lt; (Vector2 rhs1, Vector2 rhs2) { return rhs1.x &lt; rhs2.x; }
        } Vec2[SIZE];

        void add(int x, int y) {
            Vertex[++edge_tot] = y;
            Next[edge_tot] = Head[x];
            Head[x] = edge_tot;
        }

        void dfs1(int x, int fa) {
            size[x] = 1, TreeChainSplitting::fa[x] = fa, d[x] = d[fa] + 1;
            for (ForGraph) if (y ^ fa) dfs1(y, x), size[x] += size[y], ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y));
        }

        void dfs2(int x, int tp) {
            top[x] = tp, dfn[x] = ++tot, rnk[tot] = x;
            if (son[x]) dfs2(son[x], tp);
            for (ForGraph) if (y ^ fa[x] &amp;&amp; y ^ son[x]) dfs2(y, y);
        }

        void ModifySubTree(int x, int y, int val, int opt, int tp = 0) {
            while (top[x] ^ top[y]) CheckSize, Vec2[++tp] = {dfn[top[x]], dfn[x]}, x = fa[top[x]];
            if (dfn[x] &gt; dfn[y]) x ^= y ^= x ^= y;
            Vec2[++tp] = {dfn[x], dfn[y]};
            sort(Vec2 + 1, Vec2 + 1 + tp);
            int Sys = 1;
            for (int i = 1; i &lt;= tp; ++i) ((Sys &lt; Vec2[i].x) &amp;&amp; (SegmentTree::DoModify(1, 1, n, Sys, Vec2[i].x - 1, val, opt), 1)), Sys = Vec2[i].y + 1;
            if (Sys &lt;= n) SegmentTree::DoModify(1, 1, n, Sys, n, val, opt);
        }

        void main() {
            read(n, m);
            for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x);
            dfs1(1, 0), dfs2(1, 1);
            for (int i = 1, x, y, k, t, opt; i &lt;= m; ++i) {
                read(opt);
                if (opt == 0) read(x, y, k), ModifySubTree(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;
                else if (opt == 1) read(t), ModifySubTree(tx[t], ty[t], tk[t], 0);
                else if (opt == 2) read(x), write(io_l, SegmentTree::GetAnswer(1, 1, n, dfn[x]));
            }
        }
    } // namespace TreeChainSplittin
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
} // namespace HNOI2016_Network

signed main() {
    HNOI2016_Network::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::TreeChainSplitting::main();
}
</code></pre>
<h1 id="24-P4211-LNOI2014-LCA"><a href="#24-P4211-LNOI2014-LCA" class="headerlink" title="24.P4211 [LNOI2014]LCA"></a>24.P4211 [LNOI2014]LCA</h1><p>给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。<br>设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。<br>有q次询问，每次询问给出l r z，求$\sum_{l \leq i \leq r}dep[LCA(i,z)]$</p>
<hr>
<p>问题可以转化为求点到根的距离+1，询问l到r的结点到根的距离和。</p>
<p>这相当于是在求结点到根的点权+1的和。</p>
<p>那么该怎么办呢？</p>
<p>显然我们可以离线得到所有的询问，然后将差分询问，也就是查询 $[1,r]-[1,l-1]$</p>
<p>我们可以在l-1和r处打标记，然后遍历树的结点有标记就执行查询操作。</p>
<p>方便起见我们可以用树链剖分来维护，时间复杂度n乘上一个Log方n。</p>
<p>(对了我的代码特别玄学，查询部分循环版本在luogu上T了，在lojA了，递归版本在luoguA了，在lojT了！)</p>
<p>(我对这份代码除了缓缓地打出一个问号也不能说什么了)</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define IT vector &lt; int &gt;::iterator
#define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i]
#define CheckSize ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define TCS TreeChainSplitting
#define CFS ChainForwardStar
#define PS ProblemSolver
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e4 + 5;
namespace ChainForwardStar {
    const int SIZE = ::SIZE;
    int tot_, Vert[SIZE];
    int Head[SIZE], Next[SIZE];

    void AddLine(int x, int y) {
        Vert[++tot_] = y;
        Next[tot_] = Head[x];
        Head[x] = tot_;
    }
} // namespace ChainForwardStar

using CFS::Head;
using CFS::Vert;
using CFS::Next;
using CFS::AddLine;

namespace TreeChainSplitting {
    const int SIZE = ::SIZE;
    const int MOD = 201314;
    int n, m, tot, d[SIZE];
    int fa[SIZE], size[SIZE];
    int son[SIZE], top[SIZE];
    int dfn[SIZE], rnk[SIZE];
    int ask[SIZE], ans[SIZE];
    vector &lt; int &gt; GFY[SIZE];
    vector &lt; int &gt; FI[SIZE];
    int sum[SIZE &lt;&lt; 2], lf[SIZE &lt;&lt; 2];

    void Prepare(int x) {
        size[x] = 1, d[x] = d[fa[x]] + 1;
        for (ForGraph)
            Prepare(y), size[x] += size[y], CheckSize;
    }

    void Prepare(int x, int tp) {
        rnk[dfn[x] = ++tot] = x, top[x] = tp;
        if (son[x]) Prepare(son[x], tp);
        for (ForGraph) if (y ^ son[x]) Prepare(y, y);
    }

    #define ls (k &lt;&lt; 1)
    #define rs (k &lt;&lt; 1 | 1)
    #define L_RECUR ls, l, mid, x, y
    #define R_RECUR rs, mid + 1, r, x, y
    #define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD,                    \
                                sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k],                    \
                                lf[rs] += lf[k], lf[k] = 0
    #define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD
    void ModifyChain(int k, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k];
        else {
            UpdateSons(k, l, r);
            if (mid &gt;= x) ModifyChain(L_RECUR);
            if (mid &lt; y) ModifyChain(R_RECUR);
            UpdateMessages(k);
        }
    }

    void ModifySubTree(int x) {
        if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]);
    }

    int QueryChain(int k, int l, int r, int x, int y, int res = 0) {
        if (l &gt;= x &amp;&amp; r &lt;= y) return sum[k];
        UpdateSons(k, l, r);
        if (mid &gt;= x) res += QueryChain(L_RECUR, 0);
        if (mid &lt; y) res += QueryChain(R_RECUR, 0);
        return res;
    }

    int QuerySubTree(int x, int res = 0) { // luogu-only 
        if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res;
    }

//    int QuerySubTree(int x, int res = 0) { // loj-only
//        while (x) {
//            res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]);
//            x = fa[top[x]];
//        }
//        return res;
//    }
} // namespace TreeChainSplitting

namespace ProblemSolver {
    void main() {
        read(TCS::n), read(TCS::m);
        for (int i = 2; i &lt;= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i);
        TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1);
        int L, R;
        for (int i = 1; i &lt;= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i];
        for (int i = 1; i &lt;= TCS::n; ++i) {
            TCS::ModifySubTree(i);
            for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]);
            for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]);
        }
        for (int i = 1; i &lt;= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD);
    }
} // namespace ProblemSover

signed main() {
    PS::main();
}
</code></pre>
<h1 id="25-「2018-集训队互测-Day-3」北校门外的未来"><a href="#25-「2018-集训队互测-Day-3」北校门外的未来" class="headerlink" title="25.「2018 集训队互测 Day 3」北校门外的未来"></a>25.「2018 集训队互测 Day 3」北校门外的未来</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题绝对是我目前来说做题用时最长的一道题（总共花了我五天时间左右）</p>
<p>说一下我这几天的心路历程吧：</p>
<blockquote>
<p>Day1:嗯？我好像发现了一道有趣的题目？洛谷上好像没有。。算了，做一下试试。。。</p>
<p>Day2:cow，这道题是道什么题？口胡一下LCT？算了算了看看题解。。。笛卡尔树是什么？？学吧学吧。。。</p>
<p>Day3：上半天：cow学不动了。。。更一下博客吧(<a href="https://www.orchid-any.cf/">广告位</a>)；下半天：继续吧。。。</p>
<p>Day4:上半天：好像有点想法了。。。完善一下。。找找锅。。；下半天(确切的说是晚上。。)：开始码咯！</p>
<p>Day5：上半天：调了5个小时后过了；下半天：写写题解咯</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>如果你不想阅读故事，请直接跳到题意部分。</p>
</blockquote>
<p>转眼间，已是三年流转。</p>
<p>夏日法桐的绿荫，代替了秋季的萧索，衬托着 LCR 和神犇成长的背影。</p>
<p>身后的北校门，也不再是当年学生试图摧毁的，束缚自由的枷锁，而成了青春记忆的符号。</p>
<p>又到了神犇和 LCR 相遇的地方 —— 北校门外的树下。这棵神奇的树早已不是 K 项树的形态。每时每刻，它都以新的独特方式演绎着生命。</p>
<p>谁也没有开口，他和她静静地注视着魔法般生长的自然种子。初始时，这棵树只有一个点，LCR 将其标号为 $1$。此后，每过一段时间，就会有一个新节点从原有的某个点出生长出来，LCR 会给它分配一个尚未使用过的不超过 $n$ 的正整数编号。</p>
<p>树中生活着一些小精灵。它们总停留在节点上，如果一个精灵在编号 $u$ 的节点，那么它可以一步跳到任何编号 $v$ 的满足 $u,v$ 之间的简单路径上不存在异于 $u,v$ 的编号大于 $\min(u,v)$ 的点处。</p>
<p>在观察这棵树的过程中，LCR 产生了一些疑问。她想知道，对于一对节点编号 $u,v$，从节点 $u$ 跳到节点 $v$ 最少需要几步。</p>
<p>神犇轻松地解决了这些问题。最终，树渐渐停止了生长，但神犇仍然陶醉其中。</p>
<p>一只飘渺的手搭上了神犇的肩膀。他回过头，看到 LCR 正在微笑。</p>
<p><em>“亲爱的少年，神犇君。”</em></p>
<p><em>“你是否想过，为什么精灵会依照我编号的法则而运动呢？”</em></p>
<p>神犇一时语塞。瞬间，LCR 的手变得虚幻了起来，如同明灭的火炬。</p>
<p><em>“你的成长，是这变化世界的一个切面。感谢你与我度过的时光。不要留恋 …… 我的随风飘散，正是与你们同在。”</em></p>
<p><em>“再见了，神犇君。”</em></p>
<p>LCR 消失了，神犇机械地转过身，却发现背后的树也已消失无踪。</p>
<p><em>“神犇，神犇 ……”</em> 茫然若失的神犇背后传来了渐行渐近的呼叫。神犇转过身，发现机房里的蒟蒻 LCA 正向他跑来。</p>
<p><em>“又是一年毕业季了呢。学长你还好吗？”</em></p>
<p><em>“也许吧。”</em> 神犇望向校门外的树原先的位置，<em>“LCR 走了，但她的背影会吸引着我们的人生。”</em></p>
<p>LCA 沉默了。他和神犇一同望向树消失的地方，持续片刻。</p>
<p><em>“所谓中二的幻想，才是我们相对的有限的主观能动性唯一的立场吧，不要给自己设限啊，LCA。我们去追寻她 …… 追寻自然的精灵。也许这就是我们的初心也说不定。”</em></p>
<p>这次是 LCA 目送神犇的背影渐行渐远了。</p>
<p><em>“再见了，学长。”</em></p>
<p>某少女附中，又迎来了新的一年。</p>
<p>那么，你能够回答 LCR 提出的问题吗？</p>
<hr>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于一棵树 $T=(V,E)$，$V$ 中每个点有一个互不相同的正整数标号。我们用点 $i$ 表示编号为 $i$ 的点。</p>
<p>定义这棵树的<strong>谷图</strong>为 $G(T)=(V,E’)$。$G(T)$ 是无向简单图。存在边 $(u,v)\in E’$ 当且仅当在 $T$ 中，不存在一个异于 $u,v$ 的点 $x$ 满足 $x$ 在从 $u$ 到 $v$ 的简单路径上且其编号大于 $\min(u,v)$。</p>
<p>有一棵树 $T$，初始时只有一个点，编号为 $1$，接下来有 $q$ 次操作，操作有以下两种：</p>
<ul>
<li>$\texttt{1 u v}$ 表示加入一个编号为 $v$ 的节点并与当前编号为 $u$ 的节点相连（保证任何时刻不会有两个编号相同的节点）；</li>
<li>$\texttt{2 u v}$ 表示查询 $G(T)$ 中点 $u$ 到 $v$ 的最短路（每条边长度均为 $1$）。</li>
</ul>
<p>请你回答所有查询。</p>
<hr>
<p>题目好长咳咳咳。。。（最关键的是我读完过后重读一遍发现背景与题目无关。。。靠!</p>
<p>不扯了说正事儿。。。</p>
<p>动态问题其实很烦人对吧？这里我们可以假设原问题为静态问题。</p>
<p>静态问题就很好处理对吧？都是显然做法。那么问题又回到动态问题，对于加点操作，事实上我的做法十分**，利用Splay的性质乱搞。打出了一个像模拟一样的东西</p>
<p>其实我也不太清楚我是怎么过的。。。因为我的做法很玄学+暴力，所以。。。大家意会一下。</p>
<p>如果实在要看题解的话，我这里有一篇，不过估计也没人能看懂，反正你看了就知道了。至于其他的题解<del>想都别想了我翻墙去隔壁Google都没找到</del>，基本上是找不<br>道的。。。<a href="https://www.codeleading.com/article/774394821/" target="_blank" rel="noopener">Link</a></p>
<p>放个代码，大家意会一下。。。(404行好评)</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define SIZE_CHECKER ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
//  #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e5 + 5;
vector &lt; vector &lt; int &gt; &gt; G(SIZE);
int n, m, st[SIZE], tp, F[SIZE];
int _time[SIZE], _down[SIZE];
int OP[SIZE], U[SIZE], V[SIZE];

void init(int n) {
    for (int i = 1; i &lt;= n; ++i)
        F[i] = i;
}

int find(int x) {
    if (x ^ F[x]) F[x] = find(F[x]);
    return F[x];
}

namespace CartesianTree {
    vector &lt; vector &lt; int &gt; &gt; GCT(SIZE);
    int son[SIZE], fa[SIZE];
    int top[SIZE], size[SIZE];
    int low[SIZE], d[SIZE];
    int tot, ls[SIZE], rs[SIZE];

    void Prepare1(int x) {
        while (_time[st[tp]] &gt; _time[x] &amp;&amp; tp) _down[st[tp--]] = x;
        st[++tp] = x;
        size[x] = 1;
        d[x] = d[fa[x]] + 1;
        for (auto y : GCT[x])
            Prepare1((fa[y] = x, y)), size[x] += size[y], SIZE_CHECKER;
    }

    void Prepare2(int x) {
        ls[x] = ++tot;
        if (!top[x]) top[x] = x;
        if (!son[x]) return (void)(rs[x] = tot);
        top[son[x]] = top[x];
        for (auto y : GCT[x]) Prepare2(y);
        rs[x] = tot;
    }

    int GetLCA(int x, int y) {
        while (top[x] ^ top[y])
            d[top[x]] &gt; d[top[y]] ? x = fa[top[x]] : y = fa[top[y]];
        return d[x] &lt; d[y] ? x : y;
    }

    int Behavior(int x, int y) {
        while (top[x] ^ top[y]) if (fa[x = top[x]] ^ y) x = fa[x]; else return x;
        return son[y];
    }

    bool FindRule(int x, int y) {
        return ls[x] &lt; ls[y];
    }

    bool CheckForFun(int x, int y) {
        int std = *(upper_bound(GCT[y].begin(), GCT[y].end(), x, FindRule) - 1);
        return !(ls[low[std]] &gt; rs[x] || ls[x] &gt; ls[low[std]]);
    }

    void Main() {
        init(n);
        for (int i = 1; i &lt;= n; ++i)
            for (auto j : G[i])
                if (i &gt; find(j)) GCT[i].pub(find(j)), F[find(j)] = i;
        Prepare1(n), Prepare2(n);
        for (int i = 1; i &lt;= n; ++i)
            for (auto j : G[i])
                if (i &gt; j) low[Behavior(j, i)] = j;
    }
} // namespace CartesianTree
#define CT CartesianTree

namespace LinkCutTree {
    struct SPLAY {
        int ch[2];
        int fa;
        int sum;
        int key;
    } data[SIZE];
    int next[SIZE], root[SIZE];
    #define WhichSon(x) (data[data[x].fa].ch[1] == x)

    void UpdateMessages(int x) {
        data[x].sum = data[data[x].ch[0]].sum + data[data[x].ch[1]].sum + data[x].key;
    }

    void RotateNode(int x) {
        int y = data[x].fa, z = data[y].fa;
        int k = WhichSon(x);
        if (root[y]) root[y] = 0, root[x] = root[y] ^ 1;
        else data[z].ch[data[z].ch[1] == y] = x;
        data[x].fa = data[y].fa;
        data[y].ch[k] = data[x].ch[k ^ 1];
        if (data[y].ch[k]) data[data[x].ch[k ^ 1]].fa = y;
        data[x].ch[k ^ 1] = y;
        data[y].fa = x;
        UpdateMessages(y), UpdateMessages(x);
    }

    void SplayToRoot(int x) {
        for (int y; !root[x]; RotateNode(x))
            if (!root[y = data[x].fa])
                RotateNode(data[data[y].fa].ch[0] ^ y ^ data[y].ch[0] ^ x ? x : y);
    }

    void AccessEdge(int x) {
        for (int y = 0; x; x = data[y = x].fa) {
            SplayToRoot(x);
            if (data[x].ch[1]) root[data[x].ch[1]] = 1;
            if (data[x].ch[1] = y) root[y] = 0;
            UpdateMessages(x);
        }
    }

    void Behavior(int u, int v) {
        if (u &gt; v) {
            F[v] = u;
            data[v].fa = u;
            data[v].key = 1;
            data[v].sum = 1;
            return ;
        }
        int x = _down[v], rhs = u;
        SplayToRoot(x);
        int rsp = 0, cpy = 0, now = data[x].ch[0];
        if (now) {
            while (data[now].ch[1]) now = data[now].ch[1];
            SplayToRoot(now);
            while (data[x].fa ^ now) RotateNode(x);
            root[x] = 1;
            data[now].ch[1] = 0;
            UpdateMessages(now);
        }
        now = data[x].fa;
        if (next[now] == x) next[now] = v;
        data[v].key = data[v].sum = data[x].key;
        if (now) next[v] = x;
        SplayToRoot(x);
        data[x].fa = v;
        data[v].fa = now;
        data[x].key = 0;
        UpdateMessages(x);

        while (u) {
            SplayToRoot(u);
            if (data[u].ch[1]) root[data[u].ch[1]] = 1;
            data[u].ch[1] = rsp;
            if (data[u].ch[1]) root[rsp] = 0;
            UpdateMessages(u);
            if (data[u].sum) {
                x = u;
                while (233)
                    if (data[x].ch[1] &amp;&amp; data[data[x].ch[1]].sum) x = data[x].ch[1];
                    else if (!data[x].key) x = data[x].ch[0];
                    else break;
                SplayToRoot(x);
                if (x &gt;= v) break;
                u = data[x].ch[0];
                if (u) {
                    while (data[u].ch[1]) u = data[u].ch[1];
                    SplayToRoot(u);
                    data[u].ch[1] = 0;
                    root[x] = 1;
                    UpdateMessages(u);
                }
                else u = data[x].fa;
                if (u &gt;= v) break;
                SplayToRoot(rhs);
                if (now = data[rhs].ch[1]) root[now] = 1, data[rhs].ch[1] = 0;
                if (now = next[rhs]) {
                    SplayToRoot(now);
                    data[now].fa = u;
                    data[now].key = 1;
                    UpdateMessages(now);
                    next[rhs] = 0;
                }
                u = F[x];
                rhs = F[x];
                data[x].key = 0;
                UpdateMessages(x);
                SplayToRoot(x);
                while (data[x].ch[1]) x = data[x].ch[1];
                SplayToRoot(x);
                data[x].ch[1] = cpy;
                if (data[x].ch[1]) {
                    data[cpy].fa = x, root[cpy] = 0, data[x].ch[1] = cpy;
                    while (data[cpy].ch[0]) cpy = data[cpy].ch[0];
                    next[x] = cpy;
                    SplayToRoot(cpy);
                }
                SplayToRoot(x);
                cpy = x;
                rsp = 0;
            }
            else rsp = u, u = data[u].fa;
        }
        F[v] = F[_down[v]];
        F[_down[v]] = v;
        if (!F[v]) {
            SplayToRoot(v);
            x = v;
            while (data[x].ch[1]) x = data[x].ch[1];
            if (cpy) {
                data[x].ch[1] = cpy;
                root[cpy] = 0;
                data[cpy].fa = x;
                while (data[cpy].ch[0]) cpy = data[cpy].ch[0];
                next[x] = cpy;
                SplayToRoot(cpy);
            }
            SplayToRoot(v);
            x = data[v].ch[1];
            while (data[x].ch[0]) x = data[x].ch[0];
            data[x].key = 1;
            UpdateMessages(x);
            SplayToRoot(x);
        }
        else if (cpy) {
            x = cpy;
            while (data[x].ch[0]) x = data[x].ch[0];
            data[x].key = 1;
            UpdateMessages(x);
            SplayToRoot(x);
            data[x].fa = v;
        }
    }

    pii GetDis(int x, int t) {
        if (x ^ t) {
            AccessEdge(x);
            SplayToRoot(x);
            int st = x;
            int fir = 0, sec = 0;
            while (x)
                if (x &lt; t) sec = x, x = data[x].ch[0];
                else x = data[x].ch[1];
            SplayToRoot(sec);
            x = data[sec].ch[1];
            fir = data[x].sum;
            if (!fir) return mp(0, st);
            while (233) {
                if (data[data[x].ch[0]].sum) x = data[x].ch[0];
                else if (!data[x].key) sec = x, x = data[x].ch[1];
                else {
                    if (data[x].ch[0]) {
                        x = data[x].ch[0];
                        while (data[x].ch[1]) x = data[x].ch[1];
                        sec = x;
                    }
                    break;
                }
            }
            return mp(fir, sec);
        }
        else return mp(0, x);
    }

    int GetAnswers(int x, int y) {
        if (x ^ y) {
            if (x &gt; y) x ^= y ^= x ^= y;
            int sys = CT::GetLCA(x, y);
            if (sys ^ y) {
                pii t1 = GetDis(x, sys);
                pii t2 = GetDis(y, sys);
                return t1.fir + t2.fir + ((CT::CheckForFun(t1.sec, sys)
                     &amp;&amp; CT::CheckForFun(t2.sec, sys)) ^ 1) + 2;
            }
            else {
                pii t = GetDis(x, sys);
                return t.fir + (CT::CheckForFun(t.sec, sys) ^ 1) + 1;
            }
        }
        else return 0;
    }
} // namespace LinkCutTree
#define LCT LinkCutTree

namespace SOLVER {
    void Main() {
        read(m), read(m);
        n = 1;
        for (int i = 1; i &lt;= m; ++i) {
            read(OP[i], U[i], V[i]);
            if (OP[i] ^ 1) continue;
            G[U[i]].pub(V[i]);
            G[V[i]].pub(U[i]);
            _time[V[i]] = i;
            n = max(n, V[i]);
        }
        for (int i = 1; i &lt;= n; ++i) LCT::root[i] = true;
        CT::Main();
        F[1] = 0;
        for (int i = 1; i &lt;= m; ++i) {
            if (OP[i] ^ 2) LCT::Behavior(U[i], V[i]);
            else write(io_l, LCT::GetAnswers(U[i], V[i]));
        }
    }
}

signed main() {
    SOLVER::Main();
}
</code></pre>
<h1 id="26-P1121-环状最大两段子段和"><a href="#26-P1121-环状最大两段子段和" class="headerlink" title="26.P1121 环状最大两段子段和"></a>26.P1121 环状最大两段子段和</h1><p>给出一段环状序列，即认为$A_1$和$A_N$是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。</p>
<hr>
<p>一共三个关键词:</p>
<blockquote>
<p>环状</p>
<p>最大</p>
<p>两段子段和</p>
</blockquote>
<p>显然这是一道DP题。。。然而我们可以把它搞成线段树!</p>
<p>普通的最大子段和相信大家都能够用线段树来完成。</p>
<p>无非就是记录区间和、区间最大子段和、区间最大前缀和、区间最大后缀和</p>
<p>然后合并时更新信息即可</p>
<p>那么两段子段和该怎么搞呢?</p>
<p>其实也不费脑子<del>废笔</del></p>
<p>首先套路的讨论这两段的位置，我们可以发现有5种情况（画画图示意一下可能很丑反正意思你们能懂就行</p>
<p><img src="https://i.loli.net/2020/02/07/cM8KnGyrefCLwRk.png" alt="Annotation 2020-02-07 210659.png"></p>
<p>总结出来我们需要在线段树里维护的东西有：</p>
<ol>
<li>区间和</li>
<li>区间最大前缀</li>
<li>区间最大后缀</li>
<li>区间最大子段和</li>
<li>区间最大前缀+后缀</li>
<li>区间最大中间+后缀</li>
<li>区间最大前缀+中间</li>
<li>区间两段最大子段和</li>
</ol>
<p><del>每行长度不下降看着还是很爽的。。。</del></p>
<p>具体实现看代码中的注释</p>
<pre><code class="lang-cpp">// 省略快读和一堆预处理命令

const int SIZE = 4e5 + 5;
const int INF = ~0U &gt;&gt; 1;
struct TreeNode { // 这里的意思应该很明确
    int sum;
    int maxSum;
    int maxSumDouble;
    int maxPrefixSum;
    int maxSuffixSum;
    int maxPrePlusSuf;
    int maxPrePlusMid;
    int maxSufPlusMid;
} data[SIZE&lt;&lt;2];
int ints[SIZE&lt;&lt;1], ans = -INF, n;

TreeNode UpdateMessages(TreeNode x, TreeNode y) { // 这是重点
    TreeNode res;
    res.sum = x.sum + y.sum; // 区间和标记上传
    res.maxSum = max(x.maxSum, y.maxSum); // // 区间最大子段和标记上传
    res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // 再把自己和两个儿子的最大前/后缀和的和比较
    res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // 其实下面都差不多
    res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // 实在不懂看上面的图
    res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // 看了就明白了。。。
    res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf);
    res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid);
    res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum);
    res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum);
    res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid);
    res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum);
    res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum);
    res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid);
    return res;
}

void Initialization(int k, int l) { // 给线段树结点赋初值
    data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l];
    data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF;
} 

void BuildTree(int k, int l, int r) {
    if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]);
    else Initialization(k, l);
}

TreeNode GetAnswers(int k, int l, int r, int x, int y) {
    if (l ^ x || r ^ y) {
        if (mid &gt;= y) return GetAnswers(ls, l, mid, x, y);
        if (mid &lt; x) return GetAnswers(rs, mid + 1, r, x, y);
        return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y));
    } else return data[k];
}

signed main() {
    read(n);
    for (int i = 1; i &lt;= n; ++i) read(ints[i]), ints[i + n] = ints[i];
    BuildTree(1, 1, n &lt;&lt; 1);
    for (int i = 1; i &lt;= n; ++i) ans = max(ans, GetAnswers(1, 1, n &lt;&lt; 1, i, i + n - 1).maxSumDouble);
    write(io_l, ans);
}
</code></pre>

          
            <hr>
            <center><img class="lazyload" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.7.9/lazyload.gif" data-src="https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.0.3/emojis/gif/23.gif"></center>
            <p style="font-size:32px;text-align:center;margin-top:-2px">施工中...</p>
                        
        </div>
        <!-- .entry-content -->
        <!-- <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="/img/custom/donate/AliPayQR.jpg"></li>
                <li class="wechat-code"><img src="/img/custom/donate/WeChanQR.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer>. -->
        <!-- entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2020/02/08/DS100P-31-40-P/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://i.loli.net/2020/02/08/oC8G7Zu2UknzYpJ.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://i.loli.net/2020/02/08/oC8G7Zu2UknzYpJ.jpg">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                数据结构100题 31~40题</h3>
                <br>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2020/02/08/DS100P-11-20-P/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://i.loli.net/2020/02/08/xTNR8Kl3C7IiYd6.jpg" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://i.loli.net/2020/02/08/xTNR8Kl3C7IiYd6.jpg">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                数据结构100题 11~20题</h3>
                <br>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "8Hho6gvnedMT9NMEhnEx3UOg-gzGzoHsz",
        appKey: "gU70zYoblzxCmc6iL697pp69",
        path: window.location.pathname,
        placeholder: "Come And Get Your Love~"
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <a href="/" class="profile gravatar"><img src="https://i.loli.net/2020/02/06/fuc7zI8iylU5ANt.jpg" itemprop="image" alt="BoringHacker" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="/" itemprop="url" rel="author">BoringHacker</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>不会打DS的OIER不是萌妹子！</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>

<script>
  var spoiler=document.getElementsByClassName('spoiler');
  for(var i=0;i<spoiler.length;++i)
  spoiler[i].onclick=function(){this.classList.toggle("revealed");};
  </script>  


  <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/latest.js?config=TeX-MML-AM_CHTML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>

    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 BoringHacker<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>



<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <!-- <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://i.loli.net/2020/02/06/fuc7zI8iylU5ANt.jpg">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">BoringHacker'sBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/honjun" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="http://weibo.com/mashirozx?is_all=1" class="fa fa-weibo" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            Home
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            Archives
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/categories/Note/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  Notes
                </a>
              </li>
            
              <li>
                <a href="/categories/Solution">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  Solution
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="javascript:;">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-list-ul faa-vertical" aria-hidden="true"></i>
            Lists
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/tags/悦读/">
                  <i class="fa fa-th-list faa-bounce" aria-hidden="true"></i>
                  Books
                </a>
              </li>
            
              <li>
                <a href="/bangumi/">
                  <i class="fa fa-film faa-vertical" aria-hidden="true"></i>
                  Animes
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            Comments
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            Links
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            About
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  Me
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Blog
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script> -->
</body>
</html>