<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="DS100P,">


<meta name="description" content="31.P2163 [SHOI2007]园丁的烦恼]很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。 有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它">
<meta name="keywords" content="DS100P">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构100题 31~40题">
<meta property="og:url" content="www.orchid-any.cf/2020/02/08/DS100P-31-40-P/index.html">
<meta property="og:site_name" content="BoringHacker&#39;s Blog">
<meta property="og:description" content="31.P2163 [SHOI2007]园丁的烦恼]很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。 有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它">
<meta property="og:locale" content="zh-cn">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png">
<meta property="og:updated_time" content="2020-03-22T03:17:13.661Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构100题 31~40题">
<meta name="twitter:description" content="31.P2163 [SHOI2007]园丁的烦恼]很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。 有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png">



  <link rel="alternate" href="/atom.xml" title="BoringHacker's Blog" type="application/atom+xml">




  <link rel="canonical" href="www.orchid-any.cf/2020/02/08/DS100P-31-40-P/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>数据结构100题 31~40题 | BoringHacker's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BoringHacker's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-31-40-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构100题 31~40题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:33+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png" rel="gallery_ck8wtuwuh0012xgvrsusaw6gk" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        <h1 id="31-P2163-SHOI2007-园丁的烦恼"><a href="#31-P2163-SHOI2007-园丁的烦恼" class="headerlink" title="31.P2163 [SHOI2007]园丁的烦恼]"></a>31.P2163 [SHOI2007]园丁的烦恼]</h1><p>很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。</p>
<p>有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”</p>
<p>“那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。</p>
<p>“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”</p>
<p>“是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。</p>
<p>“该死的，你究竟是什么来头？”</p>
<p>“陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。</p>
<p>看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。</p>
<p>这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。</p>
<hr>
<p>这道题拿到一看，第一个想法是二维树状数组。</p>
<p>单点修改，区间查询。</p>
<p><del>很标准的模板题嘛</del></p>
<p>这个数据范围可不模板……</p>
<p>就算离散化之后还剩$500000*500000$</p>
<p>连数组都开不下。</p>
<p>所以我们要寻找新的做法。</p>
<p>我们可以看到，所有的询问都会在修改的后面。</p>
<p>所以整个问题是静态的。</p>
<p>那么我们可以使用主席树来解决这个问题。</p>
<p>主席树第$i$个版本统计横坐标为$1-i$的所有树木的纵坐标在权值线段树上的体现。</p>
<p>这个权值线段树维护每个值域有多少个元素。</p>
<p>那么我们就可以在离散化后按照横坐标顺序插入。</p>
<p>查询时利用查分。只需要查询第$xr$个版本时和第$xl-1$个版本时$yl$到$yr$这个区间里有的元素个数，再相减就能得到答案了。</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,root[1500010],s,e,tot;
struct tree
{
    int x,y;
}tre[500010];
struct query
{
    int X1,X2,Y1,Y2;
}q[500010];
struct node
{
    int l,r,num;
}nodes[50000010];
vector&lt;int&gt; pril,prih,inslist[1500010];
void ins(int l,int r,int pre,int &amp;now,int pos)
{
    now=++tot;
    nodes[now]=nodes[pre];
    ++nodes[now].num;
    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    ins(l,mid,nodes[pre].l,nodes[now].l,pos);
        else    ins(mid+1,r,nodes[pre].r,nodes[now].r,pos);
    }
}
int find(int l,int r,int v1,int v2,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[v2].num-nodes[v1].num;
    int mid=(l+r)&gt;&gt;1;
    return find(l,mid,nodes[v1].l,nodes[v2].l,fr,ba)+find(mid+1,r,nodes[v1].r,nodes[v2].r,fr,ba);
}
void read(int &amp;hhh)
{
    int x=0;
    char c=getchar();
    while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)&amp;&amp;c^&#39;-&#39;)    c=getchar();
    if(c^&#39;-&#39;)    x=c^&#39;0&#39;;
    char d=getchar();
    while((d&lt;=&#39;9&#39;)&amp;(d&gt;=&#39;0&#39;))
    {
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(d^&#39;0&#39;);
        d=getchar();
    }
    if(c^&#39;-&#39;)    hhh=x;
    else    hhh=-x;
}
void writing(int x)
{
    if(!x)    return;
    writing(x/10);
    putchar((x%10)+&#39;0&#39;);
}
void write(int x)
{
    if(x&lt;0)
    {
        putchar(&#39;-&#39;);
        x=-x;
    }
    else if(!x)
    {
        putchar(&#39;0&#39;);
        putchar(&#39;\n&#39;);
        return;
    }
    writing(x);
    putchar(&#39;\n&#39;);
}
int main()
{
    read(n);
    read(m);
    for(int i=1;i&lt;=n;++i)
    {
        read(tre[i].x);
        read(tre[i].y);
        pril.push_back(tre[i].x);
        prih.push_back(tre[i].y);
    }
    for(int i=1;i&lt;=m;++i)
    {
        read(q[i].X1);
        read(q[i].Y1);
        read(q[i].X2);
        read(q[i].Y2);
        --q[i].X1;
        pril.push_back(q[i].X1);
        prih.push_back(q[i].Y1);
        pril.push_back(q[i].X2);
        prih.push_back(q[i].Y2);
    }
    sort(pril.begin(),pril.end());
    sort(prih.begin(),prih.end());
    pril.erase(unique(pril.begin(),pril.end()),pril.end());
    prih.erase(unique(prih.begin(),prih.end()),prih.end());
    s=prih.size();
    e=pril.size();
    for(int i=1;i&lt;=n;++i)
    {
        tre[i].x=lower_bound(pril.begin(),pril.end(),tre[i].x)-pril.begin()+1;
        tre[i].y=lower_bound(prih.begin(),prih.end(),tre[i].y)-prih.begin()+1;
        inslist[tre[i].x].push_back(tre[i].y);
    }
    for(int i=1;i&lt;=m;++i)
    {
        q[i].X1=lower_bound(pril.begin(),pril.end(),q[i].X1)-pril.begin()+1;
        q[i].Y1=lower_bound(prih.begin(),prih.end(),q[i].Y1)-prih.begin()+1;
        q[i].X2=lower_bound(pril.begin(),pril.end(),q[i].X2)-pril.begin()+1;
        q[i].Y2=lower_bound(prih.begin(),prih.end(),q[i].Y2)-prih.begin()+1;
    }
    for(int i=1;i&lt;=e;++i)
    {
        root[i]=root[i-1];
        int WHILEMAX=inslist[i].size();
        for(int j=0;j^WHILEMAX;++j)    ins(1,s,root[i],root[i],inslist[i][j]);
    }
    for(int i=1;i&lt;=m;++i)    write(find(1,s,root[q[i].X1],root[q[i].X2],q[i].Y1,q[i].Y2));
    return 0;
}
</code></pre>
<h1 id="32-P2471-SCOI2007-降雨量"><a href="#32-P2471-SCOI2007-降雨量" class="headerlink" title="32.P2471 [SCOI2007]降雨量"></a>32.P2471 [SCOI2007]降雨量</h1><p>我们常常会说这样的话：“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意Y&lt;Z&lt;X，Z年的降雨量严格小于X年。例如2002，2003，2004和2005年的降雨量分别为4920，5901，2832和3890，则可以说“2005年是自2003年以来最多的”，但不能说“2005年是自2002年以来最多的”由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。</p>
<hr>
<p>这道题要求查询一个数是否是继另一个数后的最大值。</p>
<p>然而中间有很多数是未知的。</p>
<p>要判断这个结论一定成立，我们要知道中间的数是不是都知道。</p>
<p>那我们是不是要把所有的数都放进线段树里呢？</p>
<p>肯定不行，因为年份的范围是$1e9$。</p>
<p>那我们怎么离散化呢？</p>
<p>这里我们只用把与每个年份相邻的两个年份也加进来就好了，再顺便把查询的端点和往内一个数也加进来，不然找端点的时候容易锅……</p>
<p>因为如果查询时这里没有数，那么肯定就被查到了。</p>
<p>如果这里有，那么这里的这个数就会又把它两边的数加进来。一直到要查询到的那个数为止。</p>
<p>那么我们应该怎么判断呢？</p>
<p>这里就要分类讨论了：查询为$(p,q)$</p>
<p>$1.p &gt; q$：肯定不成立，他们的位置都不对，$p$根本不在$q$前面。</p>
<p>$2.p=q$：<del>显然</del>成立。</p>
<p>$3.$继续分类。</p>
<p>$\ \ \ \ \ $$1).$两个端点都已知。</p>
<p>$\ \ \ \ \ \ \ \ \ \ <script type="math/tex">1>.</script>p$的降雨量小于$q$：肯定不对，不符合定义。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$如果$p,q$中间有数比$q$的降雨量大或等于：也不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$3&gt;.$如果$p,q$中间有数未知:那么我们无法确定这些未知的数是否小于$q$的降雨量，输出也许。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$4&gt;.$以上条件均不满足：说明满足了所有条件，是对的。</p>
<p>$\ \ \ \ \ $$2).$知道$p$的降雨量。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$1&gt;.$如果$p,q$中间有数大于$p$的降雨量或等于：不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$否则无论中间是否全部已知，由于$q$未知，都不能确定。</p>
<p>$\ \ \ \ \ $$3).$知道$q$的降雨量。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$1&gt;.$如果$p,q$中间有数大于$q$的降雨量或等于：不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$否则无论中间是否全部已知，由于$p$未知，都不能确定。</p>
<p>$\ \ \ \ \ $$4).$两个都未知：无论中间是否全部已知，由于不能确定中间的数是否小于他们，所以输出也许。</p>
<p>关于判断中间是否有数大于某数，我们需要查询中间的最大值。</p>
<p>关于判断中间是否有数未知，我们需要查询区间里有多少数。</p>
<p>所以我们要开两棵线段树，一棵记录区间最大值，一棵记录区间里的元素个数。</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; pri;
map&lt;int,int&gt; mp;
int n,m,s,y[50010],r[50010],p[10010],q[10010],siz[1000010],nodes[1000010];
int getID(int val)
{
    return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1;
}
void ins(int l,int r,int x,int pos,int val)
{
    ++siz[x];
    if(l==r)    nodes[x]=val;
    else
    {
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    ins(l,mid,x&lt;&lt;1,pos,val);
        else    ins(mid+1,r,x&lt;&lt;1|1,pos,val);
        nodes[x]=max(nodes[x&lt;&lt;1],nodes[x&lt;&lt;1|1]);
    }
}
int findsiz(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return siz[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return findsiz(l,mid,x&lt;&lt;1,fr,ba)+findsiz(mid+1,r,x&lt;&lt;1|1,fr,ba);
    }
}
int findmax(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return max(findmax(l,mid,x&lt;&lt;1,fr,ba),findmax(mid+1,r,x&lt;&lt;1|1,fr,ba));
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;y[i],&amp;r[i]);
        pri.push_back(y[i]-1);
        pri.push_back(y[i]);
        pri.push_back(y[i]+1);
        mp[y[i]]=r[i];
    }
    scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;p[i],&amp;q[i]);
        pri.push_back(p[i]);
        pri.push_back(p[i]+1);
        pri.push_back(q[i]);
        pri.push_back(q[i]-1);
    }
    sort(pri.begin(),pri.end());
    pri.erase(unique(pri.begin(),pri.end()),pri.end());
    s=pri.size();
    for(int i=1;i&lt;=n;++i)    ins(1,s,1,getID(y[i]),r[i]);
    for(int i=1;i&lt;=m;++i)
    {
        int L=getID(p[i]);
        int R=getID(q[i]);
        if(p[i]&gt;q[i])    printf(&quot;false\n&quot;);
        else if(p[i]==q[i])    printf(&quot;true\n&quot;);
        else if(mp[p[i]]&amp;&amp;mp[q[i]])
        {
            if(mp[p[i]]&lt;mp[q[i]])    printf(&quot;false\n&quot;);
            else
            {
                if(findmax(1,s,1,L+1,R-1)&lt;mp[q[i]])
                {
                    if(findsiz(1,s,1,L,R)==R-L+1)    printf(&quot;true\n&quot;);
                    else    printf(&quot;maybe\n&quot;);
                }
                else    printf(&quot;false\n&quot;);
            }
        }
        else if(mp[p[i]])
        {
            if(findmax(1,s,1,L+1,R)&gt;=mp[p[i]])    printf(&quot;false\n&quot;);
            else    printf(&quot;maybe\n&quot;);
        }
        else if(mp[q[i]])
        {
            if(findmax(1,s,1,L,R-1)&gt;=mp[q[i]])    printf(&quot;false\n&quot;);
            else    printf(&quot;maybe\n&quot;);
        }
        else    printf(&quot;maybe\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="33-P2824-HEOI2016-TJOI2016-排序"><a href="#33-P2824-HEOI2016-TJOI2016-排序" class="headerlink" title="33.P2824 [HEOI2016/TJOI2016]排序"></a>33.P2824 [HEOI2016/TJOI2016]排序</h1><p>在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  </p>
<p>这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  </p>
<ul>
<li><code>0 l r</code> 表示将区间 $[l,r]$ 的数字升序排序  </li>
<li><code>1 l r</code> 表示将区间 $[l,r]$ 的数字降序排序  </li>
</ul>
<p>注意，这里是对<strong>下标</strong>在区间 $[l,r]$ 内的数排序。<br>最后询问第 $q$ 位置上的数字。</p>
<hr>
<p>这道题很有意思，需要一定的技巧。</p>
<p>首先我们知道，对于一个长度为 $n$ 整数序列排序需要 $\Theta(n\log n)$ 的时间。</p>
<p>但是，如果我们把序列中的数字从所有的数转移到0和1两个数上，是不是就容易很多呢？</p>
<p>对于一个01串升序排序显然只需要 $\Theta(n)$ 的时间。我们只需要统计出序列中所以1的个数 $cnt$。</p>
<p>然后把 $A_{i},i\in [1,n-cnt]$ 改为零，把 $A_{i},i\in [n-cnt+1,n]$ 改为1即可。</p>
<p>降序排序则完全同理。</p>
<p>不仅如此，我们还可以把时间从 $\Theta(n)$ 降到 $\Theta(\log n)$。</p>
<p>我们可以把统计区间中1的个数看作区间求和，那么我们就可以用线段树来维护区间赋值和区间求和的操作，复杂度 $\Theta(\log n)$。</p>
<p>好，接下来我们思考一个问题——如何把一个普通的序列转化为01序列呢？我们可以按大小来划分。</p>
<p>假设我们现在正在二分，那么我们不妨把所有大于等于 $mid$ 的数置为1，否则置为0。这样整个序列就变成了一个01序列。</p>
<p>排序后判断第 $q$ 个位置是不是1就行了。</p>
<p>这里还有一个问题——为什么这个二分是满足单调性的呢？</p>
<p>其实这个问题很简单，就留给大家吧）））</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)

template &lt; typename Type &gt;
void read(Type&amp; a) {
    a = 0; bool f = 0; char ch;
    while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1;
    while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc();
    a = (f ? -a : a);
}

template &lt; typename Type, typename... Args &gt;
void read(Type&amp; t, Args&amp;... args) {
    read(t), read(args...);
}

#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
// #define mid ((l + r) &gt;&gt; 1)
const int MAXN = 1e5 + 5;
int nodes[MAXN &lt;&lt; 2];
int marks[MAXN &lt;&lt; 2];
int ints[MAXN], bit[MAXN];
int n, m, q;
struct QueryNode {
    int l, r;
    int type;
    QueryNode(){}
    QueryNode(int L, int R, int T) : l(L), r(R), type(T) {}
} asks[MAXN];

void pushdown(int k, int l, int r) {
    if (~marks[k]) {
        int mid = (l + r) &gt;&gt; 1;
        nodes[ls] = (mid - l + 1) * marks[k];
        marks[ls] = marks[k];
        nodes[rs] = (r - mid) * marks[k];
        marks[rs] = marks[k];
        marks[k] = -1;
    }
}

void construct(int k, int l, int r) {
    int mid = ((l + r) &gt;&gt; 1);
    if (l ^ r) {
        construct(ls, l, mid);
        construct(rs, mid + 1, r);
        nodes[k] = nodes[ls] + nodes[rs];
    }
    else
        nodes[k] = bit[l];
}

void update(int k, int l, int r, int x, int y, int v) {
    int mid = ((l + r) &gt;&gt; 1);
    if (l &gt; y || r &lt; x) return ;
    if (l &gt;= x &amp;&amp; r &lt;= y) nodes[k] = (r - l + 1) * v, marks[k] = v;
    else {
        pushdown(k, l, r);
        if (mid &gt;= x) update(ls, l, mid, x, y, v);
        if (mid &lt; y) update(rs, mid + 1, r, x, y, v);
        nodes[k] = nodes[ls] + nodes[rs];
    }
}

int queryf(int k, int l, int r, int x, int y) {
    int mid = ((l + r) &gt;&gt; 1);
    pushdown(k, l, r);
    if (l &gt; y || r &lt; x) return 0;
    else if (l &gt;= x &amp;&amp; r &lt;= y) return nodes[k];
    else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y);
}

bool check(int x) {
    for (int i = 1; i &lt;= n; ++i) bit[i] = (ints[i] &gt;= x);
    memset(marks, -1, sizeof marks);
    memset(nodes, 0, sizeof nodes);
    construct(1, 1, n);
    for (int i = 1; i &lt;= m; ++i) {
        int sum = queryf(1, 1, n, asks[i].l, asks[i].r);
        if (asks[i].type == 1) update(1, 1, n, asks[i].l, asks[i].l + sum - 1, 1), update(1, 1, n, asks[i].l + sum, asks[i].r, 0);
        else update(1, 1, n, asks[i].l, asks[i].r - sum, 0), update(1, 1, n, asks[i].r - sum + 1, asks[i].r, 1);
    }
    return queryf(1, 1, n, q, q);
}

signed main() {
    read(n, m);
    for (int i = 1; i &lt;= n; ++i) read(ints[i]);
    for (int i = 1; i &lt;= m; ++i) read(asks[i].type, asks[i].l, asks[i].r);
    read(q);
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        int mid = ((l + r) &gt;&gt; 1);
        if (check(mid)) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h1 id="34-P1712-NOI2016-区间"><a href="#34-P1712-NOI2016-区间" class="headerlink" title="34.P1712 [NOI2016]区间"></a>34.P1712 [NOI2016]区间</h1><p>在数轴上有 $N$ 个闭区间 $[l_1,r_1],[l_2,r_2],…,[l_n,r_n]$ 。现在要从中选出 $M$ 个区间，使得这 $M$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间$[l_i,r_i]$ ，都有 $l_i≤x≤r_i$ 。</p>
<p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间$[l_i,r_i]$ 的长度定义为$r_i-l_i$ ，即等于它的右端点的值减去左端点的值。</p>
<p>求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$ 。</p>
<hr>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>题意已经很清楚了，就不再说了</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们首先考虑怎么去选择这 $M$ 个区间才能使得最终的花费最小。</p>
<p>不难想到我们需要尽量选择 <strong>长度尽量靠近</strong> 的 $M$ 个区间，换句话说就是我们需要按照区间的长度进行排序。</p>
<p>原因很显然，我们如果选择的区间的长度不靠近，那么就会造成最小的区间长度变小，最大的区间长度变大。然而答案就是长度最大的区间和长度最小的区间，所以我们需要让这两个区间的长度尽量靠近。</p>
<p>排完序后我们就依次把每个区间加入到答案所在的集合里。</p>
<p>具体来说就是维护一个数组 $A$，每当我们加入一个区间 $[l_{i},r_{i}]$，就令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部加一。如果存在某一个 $A_{p}$ 使得 $M\le A_{p}$，我们就更新答案，并且删除最先加入进来的区间，也就是令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部减一。</p>
<p>一些细节：</p>
<ol>
<li><p>要离散化（废话</p>
</li>
<li><p>线段树开8倍（每个区间有两个端点</p>
</li>
<li><p>没了</p>
</li>
</ol>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int SIZE = 500000 + 5;
int MAX[SIZE &lt;&lt; 3];
int mark[SIZE &lt;&lt; 3];
vector &lt; int &gt; disc;
int n, m, holyans = -1;
struct interval {
    int l, r;
    int len;
    interval(){}
    interval(int L, int R, int S) : l(L), r(R), len(S){}
    bool operator &lt; (const interval&amp; rhs) const {
        return len &lt; rhs.len;
    }
} seg[SIZE];
#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
#define mid ((l + r) &gt;&gt; 1)

#define pushdown(k)             \
    if (mark[k]) {                \
        MAX[ls] += mark[k];        \
        MAX[rs] += mark[k];        \
        mark[ls] += mark[k];    \
        mark[rs] += mark[k];    \
        mark[k] = 0;            \
    }

#define pushup(k) MAX[k] = max(MAX[ls], MAX[rs])
#define GetID(x) (lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1)

void modify(int k, int l, int r, int x, int y, int v) {
    if (l &gt;= x &amp;&amp; r &lt;= y) mark[k] += v, MAX[k] += v;
    else {
        pushdown(k);
        if (mid &gt;= x) modify(ls, l, mid, x, y, v);
        if (mid &lt; y) modify(rs, mid + 1, r, x, y, v);
        pushup(k);
    }
}

void discretization() {
    for (int i = 1; i &lt;= n; ++i) disc.push_back(seg[i].l), disc.push_back(seg[i].r);
    sort(disc.begin(), disc.end());
    sort(seg + 1, seg + 1 + n);
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    for (int i = 1; i &lt;= n; ++i) seg[i].l = GetID(seg[i].l), seg[i].r = GetID(seg[i].r);
}

signed main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1, x, y; i &lt;= n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), seg[i] = interval(x, y, y - x + 1);
    discretization();
    int size = disc.size();
    int max_id = n;
    for (int i = n; i &gt;= 1; --i) {
        while (MAX[1] &gt;= m &amp;&amp; max_id &gt; i) {
            modify(1, 1, size, seg[max_id].l, seg[max_id].r, -1);
            --max_id;
            if (MAX[1] &gt;= m) {
                if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
                else holyans = seg[max_id].len - seg[i].len;
            }
        }
        modify(1, 1, size, seg[i].l, seg[i].r, 1);
        if (MAX[1] &gt;= m) {
            if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
            else holyans = seg[max_id].len - seg[i].len;
        }
    }
    printf(&quot;%d\n&quot;, holyans);
    return 0;
}
</code></pre>
<h1 id="P5524-Ynoi2012-NOIP2015洋溢着希望"><a href="#P5524-Ynoi2012-NOIP2015洋溢着希望" class="headerlink" title="P5524 [Ynoi2012]NOIP2015洋溢着希望"></a>P5524 [Ynoi2012]NOIP2015洋溢着希望</h1><p>给出一个长度为 $n$ 的整数序列 $a_1,a_2,\ldots,a_n$，进行 $m$ 次操作，操作分为两类。</p>
<p>操作 $1$：给出 $l,r,v$，将 $a_l,a_{l+1},\ldots,a_r$ 分别加上 $v$。</p>
<p>操作 $2$：给出 $l,r$，询问 $\sum\limits_{i=l}^{r}\sin(a_i)$。</p>
<hr>
<p>唯一一道我能做的Ynoi……</p>
<p>修改操作很模板，略。</p>
<p>对于询问，直接维护是不理智的。相信大家都学过三角函数，和差角公式应该很熟悉。</p>
<p>对于这道题我们可以用这两个公式来维护询问：</p>
<script type="math/tex; mode=display">
\sin(\alpha+\beta)=\sin\ \alpha\times\cos\ \beta+\cos\ \alpha\times\sin\ \beta</script><script type="math/tex; mode=display">
\cos(\alpha+\beta)=\cos\ \alpha\times\cos\ \beta-\sin\ \alpha\times\sin\ \beta</script><p>这样，我们再维护一个加法标记，就能解决询问了。</p>
<p>挺水的对吧。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

const int MAXN = 2e5 + 5;
int n, m, integer[MAXN];
long long nodes[MAXN &lt;&lt; 2];
double sum_sinx[MAXN &lt;&lt; 2];
double sum_cosx[MAXN &lt;&lt; 2];

#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
#define mid ((l + r) &gt;&gt; 1)

void update(int k, double sinx, double cosx) {
    double tsum_sinx = sum_sinx[k];
    double tsum_cosx = sum_cosx[k];
    sum_sinx[k] = tsum_sinx * cosx + tsum_cosx * sinx;
    sum_cosx[k] = tsum_cosx * cosx - tsum_sinx * sinx;
}

void pushup(int k) {
    sum_sinx[k] = sum_sinx[ls] + sum_sinx[rs];
    sum_cosx[k] = sum_cosx[ls] + sum_cosx[rs];
}

void pushdown(int k) {
    if (nodes[k]) {
        nodes[ls] += nodes[k];
        nodes[rs] += nodes[k];
        double t_sinx = sin(nodes[k]);
        double t_cosx = cos(nodes[k]);
        nodes[k] = 0;
        update(ls, t_sinx, t_cosx);
        update(rs, t_sinx, t_cosx);
    }
}

void build(int k, int l, int r) {
    if (l ^ r) build(ls, l, mid), build(rs, mid + 1, r), pushup(k);
    else sum_sinx[k] = sin(integer[l]), sum_cosx[k] = cos(integer[l]);
}

void modify(int k, int l, int r, int x, int y, int v, double sinx, double cosx) {
    if (l &gt;= x &amp;&amp; r &lt;= y) update(k, sinx, cosx), nodes[k] += v;
    else {
        pushdown(k);
        if (mid &gt;= x) modify(ls, l, mid, x, y, v, sinx, cosx);
        if (mid &lt; y) modify(rs, mid + 1, r, x, y, v, sinx, cosx);
        pushup(k);
    }
}

double queryf(int k, int l, int r, int x, int y) {
    if (l &gt;= x &amp;&amp; r &lt;= y) return sum_sinx[k];
    else {
        pushdown(k);
        double res = 0;
        if (mid &gt;= x) res += queryf(ls, l, mid, x, y);
        if (mid &lt; y) res += queryf(rs, mid + 1, r, x, y);
        return res;
    }
}
signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;integer[i]);
    build(1, 1, n);
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 0, opt, x, y, v; i &lt; m; ++i) {
        scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y);
        if (opt == 1) scanf(&quot;%d&quot;, &amp;v), modify(1, 1, n, x, y, v, sin(v), cos(v));
        else printf(&quot;%.1lf\n&quot;, queryf(1, 1, n, x, y));
    }
    return 0;
}
</code></pre>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DS100P/" rel="tag"># DS100P</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/02/08/DS100P-21-30-P/" rel="next" title="数据结构100题 21~30题">
                <i class="fa fa-chevron-left"></i> 数据结构100题 21~30题
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/02/08/DS100P-41-50-P/" rel="prev" title="数据结构100题 41~50题">
                数据结构100题 41~50题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BoringHacker</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#31-P2163-SHOI2007-园丁的烦恼"><span class="nav-number">1.</span> <span class="nav-text">31.P2163 [SHOI2007]园丁的烦恼]</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#32-P2471-SCOI2007-降雨量"><span class="nav-number">2.</span> <span class="nav-text">32.P2471 [SCOI2007]降雨量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#33-P2824-HEOI2016-TJOI2016-排序"><span class="nav-number">3.</span> <span class="nav-text">33.P2824 [HEOI2016/TJOI2016]排序</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#34-P1712-NOI2016-区间"><span class="nav-number">4.</span> <span class="nav-text">34.P1712 [NOI2016]区间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#题意简述"><span class="nav-number">4.1.</span> <span class="nav-text">题意简述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题解"><span class="nav-number">4.2.</span> <span class="nav-text">题解</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#P5524-Ynoi2012-NOIP2015洋溢着希望"><span class="nav-number">5.</span> <span class="nav-text">P5524 [Ynoi2012]NOIP2015洋溢着希望</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BoringHacker</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
