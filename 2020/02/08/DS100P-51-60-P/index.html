<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  
  <title itemprop="name">数据结构100题 51~60题 | BoringHacker&#39;s Blog</title>
  
    <link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/favicon.png">
  
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+SerifMerriweather|Merriweather+Sans|Source+Code+Pro|Ubuntu:400,700|Noto+Serif+SC" media="all">
  <link rel="dns-prefetch" href="//cdn.jsdelivr.net">
  <link rel="stylesheet" id="saukra_css-css" href="/css/style.css" type="text/css" media="all">
  <link rel="stylesheet" href="/css/lib.min.css" media="all">
  <link rel="stylesheet" href="/css/font.css" media="all">
  <link rel="stylesheet" href="/css/insight.css" media="all">
  <link rel="stylesheet" href="/css/jquery.fancybox.min.css" media="all">
  <link rel="stylesheet" href="/css/zoom.css" media="all">
    <style>
  .emoji-coda {
      display: inline-block !important;
      position: relative;
      width: 45px;
      top: 2px;
      margin: -3px 3px !important;
      padding: 0;
  }
  </style>

  <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<!--   <link rel="stylesheet" id="saukra_css-css" href="https://2heng.xin/wp-content/cache/autoptimize/css/autoptimize_ad42a61f4c7d4bdd9f91afcff6b5dda5.css
" type="text/css" media="all"> -->
  <script>
  /*Initial Variables*/
  var mashiro_option = new Object();
  var mashiro_global = new Object();
  mashiro_option.NProgressON = true;
  /* 
   * 邮箱信息之类的东西可以填在这里，这些js变量基本都作用于sakura-app.js
   * 这样的设置仅是为了方便在基于PHP开发的主题中设置js变量，既然移植到了Node上，我想或许可以精简这一逻辑吧
   */
  mashiro_option.email_domain = "";
  mashiro_option.email_name = "";
  mashiro_option.cookie_version_control = "";
  mashiro_option.qzone_autocomplete = false;
  mashiro_option.site_name = "BoringHacker'sBlog";
  mashiro_option.author_name = "Blog";
  mashiro_option.site_url = "https://www.orchid-any.cf/";
  mashiro_option.v_appId = "8Hho6gvnedMT9NMEhnEx3UOg-gzGzoHsz";
  mashiro_option.v_appKey = "gU70zYoblzxCmc6iL697pp69";
  mashiro_option.mathjax = "1";
  mashiro_option.qq_api_url = "https://api.mashiro.top/qqinfo/"; 
  mashiro_option.qq_avatar_api_url = "https://api.mashiro.top/qqinfo/";

  // mashiro_option.jsdelivr_css_src = "https://cdn.jsdelivr.net/gh/moezx/cdn@3.4.5/css/lib.min.css";
  // mashiro_option.float_player_on = true;

  /*End of Initial Variables*/
  </script>
  <script type="text/javascript">
  var bg = "https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index1.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index2.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index3.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index4.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index5.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index6.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index7.png,https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/index8.png".split(",");
  var bgindex = Math.floor(Math.random()*bg.length);
  if (!!window.ActiveXObject || "ActiveXObject" in window) { //is IE?
    alert('朋友，IE浏览器未适配哦~');
  }
  </script>
  <style type="text/css">
  .hljs-ln{border-collapse:collapse}.hljs-ln td{padding:0}.hljs-ln-n:before{content:attr(data-line-number)}
  </style>
  <style type="text/css">.site-top .lower nav{display:block !important;}.author-profile i,.post-like a,.post-share .show-share,.sub-text,.we-info a,span.sitename,.post-more i:hover,#pagination a:hover,.post-content a:hover,.float-content i:hover{color:#FE9600}.feature i,.download,.navigator i:hover,.links ul li:before,.ar-time i,span.ar-circle,.object,.comment .comment-reply-link,.siren-checkbox-radio:checked + .siren-checkbox-radioInput:after{background:#FE9600}::-webkit-scrollbar-thumb{background:#FE9600}.download,.navigator i:hover,.link-title,.links ul li:hover,#pagination a:hover,.comment-respond input[type='submit']:hover{border-color:#FE9600}.entry-content a:hover,.site-info a:hover,.comment h4 a,#comments-navi a.prev,#comments-navi a.next,.comment h4 a:hover,.site-top ul li a:hover,.entry-title a:hover,#archives-temp h3,span.page-numbers.current,.sorry li a:hover,.site-title a:hover,i.iconfont.js-toggle-search.iconsearch:hover,.comment-respond input[type='submit']:hover{color:#FE9600}.comments .comments-main{display:block !important;}.comments .comments-hidden{display:none !important;}background-position:center center;background-attachment:inherit;}
  </style>
</head>
</html>
<body class="page-template page-template-user page-template-page-analytics page-template-userpage-analytics-php page page-id-1297 chinese-font serif isWebKit">
  <style type="text/css">
    @import url("/code.css");
  </style>
   <div class="skin-menu no-select" id="mainskin" style="position: fixed;bottom:65px;left:31px;">
    <div class="theme-controls row-container">
          <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> background <i style="color:grey" class="fa fa-chevron-right"></i></p>
        <ul class="menu-list"> <li id="white-bg"> 
            <i class="fa fa-television" aria-hidden="true">
            </i>
            </li> 
            <li id="sakura-bg"> 
                <i class="iconfont icon-sakura">
                </i>
            </li>
            <li id="gribs-bg">
                <i class="fa fa-slack" aria-hidden="true">
                </i>
            </li>
            <li id="KAdots-bg">
                <i class="iconfont icon-dots">
                </i>
            </li>
            <li id="totem-bg">
                <i class="fa fa-optin-monster" aria-hidden="true">
                </i>
            </li>
            <li id="pixiv-bg">
                <i class="iconfont icon-pixiv">
                </i>
            </li>
            <li id="bing-bg">
                <i class="iconfont icon-bing">
                </i>
            </li>
            <li id="dark-bg">
                <i class="fa fa-moon-o" aria-hidden="true">
                </i>
            </li>
        </ul>
    </div>
      <hr>
  <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> font <i style="color:grey" class="fa fa-chevron-right"></i></p>
  <div class="font-family-controls row-container">
    <button type="button" class="control-btn-serif " data-mode="serif" onclick="mashiro_global.font_control.change_font()">Serif</button>
    <button type="button" class="control-btn-sans-serif" data-mode="sans-serif" onclick="mashiro_global.font_control.change_font()">Sans Serif</button>
  </div>
  <hr>
  <p style="text-align:center;font-family:'Monaco';font-weight:bold;color:#444"><i style="color:grey" class="fa fa-chevron-left"></i> script <i style="color:grey" class="fa fa-chevron-right"></i></p>
  <div class="theme-controls row-container">
  <ul class="menu-list">
    <li id="empty-effect">
      <i class="fa fa-ban">
      </i>
    </li>
    <li id="sakura-rain-effect">
      <i class="iconfont icon-sakura">
      </i>
    </li>
    <li id="snowy-effect">
      <i class="fa fa-snowflake-o">
      </i>
    </li>
    <li id="lines-effect">
      <i class="fa fa-chevron-left">
      </i>
    </li>
    <li id="colorful-belts-effect">
      <i class="fa fa-map"></i>
      </i>
    </li>
    <li id="words-rain-effect">
      <i class="fa fa-font"></i>
    </li>
    <li id="point-rain-effect">
      <i class="iconfont icon-dots"></i>
    </li>
    <li id="rain-drop-effect">
      <i class="fa fa-tint"></i>
    </li>
  </ul>
  </div>

    <canvas id="night-mode-cover">
    </canvas>
</div>
 
 <div class="changeSkin-gear no-select" style="background: rgba(0, 0, 0, 0) none repeat scroll 0% 0%; visibility: visible; bottom: 0px;"> 
  <div class="keys" id="setbtn"> 
    <button id="open-skinMenu">
        <style>
        button#open-skinMenu{
            transition: all 0.2s linear 0s;
            outline:none;
            position:fixed;
            bottom:13px;
            left:15px;
            font-size:16px;
            background-color: rgba(255,255,255,.95);
            border-radius: 20px;
            box-shadow: 0 3px 8px 0 rgba(0,0,0,0.1), 0 3px 8px 0 rgba(0,0,0,0.1);
        }
        button#open-skinMenu:hover{
            transition: all 0.2s linear 0s;
            background-color: rgb(255, 165, 0);
            color: rgba(255,255,255);
        }
        </style>
        <i class="iconfont icon-gear inline-block rotating">
      </i> 
        SCHEME TOOL | 主题工具 
    </button>
  </div> 
</div>


  <div class="scrollbar" id="bar">
  </div>
  <a href="#" class="cd-top faa-float animated"></a>
  <section id="main-container">
    <div class="headertop ">
  <div id="banner_wave_1"></div>
  <div id="banner_wave_2"></div>
  <figure id="centerbg" class="centerbg">
    <div class="focusinfo no-select">
      <div class="header-tou">
        <a href="https://www.orchid-any.cf/">
          <img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/avatar.png">
        </a>
      </div>
      <div class="header-info">
        <p>Stay Hungry, Stay Foolish</p>
        <div class="top-social_v2">
          <li id="bg-pre">
            <img class="flipx" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
          
            
              
                <li>
                  <a href="http://github.com/boringhacker" target="_blank" class="social-github" title="github">
                    <img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/github.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://music.163.com/#/user/home?id=1842865470" target="_blank" class="social-github" title="NetEase">
                    <img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/music.png">
                  </a>
                </li>
              
            
              
                <li>
                  <a href="https://www.zhihu.com/people/boringhacker" target="_blank" class="social-github" title="zhihu">
                    <img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/zhihu.png">
                  </a>
                </li>
              
            
          
          <li id="bg-next">
            <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/next-b.svg">
          </li>
        </div>
      </div>
    </div>
  </figure>
  <div id="video-container" style="">
    <video style="object-fit: fill" id="bgvideo" class="video" video-name="" src="" width="auto" preload="auto">
    </video>
    <!-- <div id="video-btn" class="loadvideo videolive">
    </div> -->
    <div id="video-add">
    </div>
    <div class="video-stu">
    </div>
  </div>
  <div class="headertop-down faa-float animated" onclick="headertop_down()">
    <span>
      <i class="fa fa-chevron-down" aria-hidden="true">
      </i>
    </span>
  </div>
</div>
    <div id="page" class="site wrapper">
      <header class="site-header no-select gizle sabit" role="banner">
  <div class="site-top">
    <div class="site-branding">
      <span class="site-title">
        <span class="logolink moe-mashiro">
          <a href="/">
            <!-- <span class="sakurasono">BoringHacker&#39;s</span>
            <span class="shironeko">Blog</span> -->
            <img src = https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/icons/borhac.png>
          </a>
        </span>
      </span>
    </div>
    <div class="searchbox search-form-submit">
      <i class="iconfont js-toggle-search iconsearch icon-search">
      </i>
    </div>
    <div id="show-nav" class="showNav mobile-fit">
      <div class="line line1">
      </div>
      <div class="line line2">
      </div>
      <div class="line line3">
      </div>
    </div>
    <div class="lower-cantiner">
      <div class="lower">
        <nav class="mobile-fit-control hide">
          <ul id="menu-new" class="menu">
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
                    Home
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/archives">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
                    Archives
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/Tools/">
                          <i class="fa fa-cogs" aria-hidden="true"></i>
                          Tools
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/Note/">
                          <i class="fa fa-book" aria-hidden="true"></i>
                          Notes
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/Solution">
                          <i class="fa fa-code" aria-hidden="true"></i>
                          Solution
                        </a>
                      </li>
                    
                      <li>
                        <a href="/categories/Others">
                          <i class="fa fa-sellsy" aria-hidden="true"></i>
                          Others
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/tags/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-tags" aria-hidden="true"></i>
                    Tags
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/comment/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
                    Comments
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/links/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
                    Links
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/game/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-gamepad" aria-hidden="true"></i>
                    Game
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/pandownload/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-gamepad" aria-hidden="true"></i>
                    PanDown
                  </span>
                </a>
                
              </li>
            
              <li>
                <a href="/">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
                    About
                  </span>
                </a>
                
                  <ul class="sub-menu">
                    
                      <li>
                        <a href="/about/">
                          <i class="fa fa-meetup" aria-hidden="true"></i>
                          Me
                        </a>
                      </li>
                    
                      <li>
                        <a href="/lab/">
                          <i class="fa fa-bath" aria-hidden="true"></i>
                          Blog
                        </a>
                      </li>
                    
                  </ul>
                
              </li>
            
              <li>
                <a href="/atom.xml">
                  <span class="faa-parent animated-hover">
                    <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
                    RSS
                  </span>
                </a>
                
              </li>
            
          </ul>
        </nav>
      </div>
    </div>
  </div>
</header>

      <link rel="stylesheet" type="text/css" href="/css/sharejs.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
<div class="pattern-center-blank"></div>
<script>
var spoiler=document.getElementsByClassName('spoiler');
for(var i=0;i<spoiler.length;++i)
spoiler[i].onclick=function(){this.classList.toggle("revealed");};
</script>

  <div class="pattern-center-sakura single-center">
    <!-- 有配图默认渲染第一张 -->
    <div class="pattern-attachment-img lazyload" style="background-image: url(https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-36.png);" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-36.png">
    </div>
    <header class="pattern-header single-header" style="text-shadow: 0 0 7px #000,0 0 7px #000">

      <h1 class="entry-title">
      数据结构100题 51~60题</h1>
      <p class="entry-census">
        <span>
          <a href="/">
            <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/icons/avatar.png">
          </a>
        </span>
        <span>
          <a href="/">BoringHacker</a>
        </span>
        <span class="bull">
        ·</span>
        2020-2-8<span class="bull">
        ·</span>
      <span id="busuanzi_value_page_pv"></span>次阅读</p>
      
        
          <div>
            <ul class="spfk-ul">
              &nbsp<i class="fa fa-tag" aria-hidden="true"></i>&nbsp&nbsp&nbsp&nbsp
              <li class="spfk-li"><a href="/tags/DS100P/" class="butterfly-tags">DS100P</a></li>
            </ul>
          </div>
          <script>
              function colorInit(c,num){for(var i=1;i<=num;++i)c.push(i+'');}
              function paintTags(){
                  var colorNumber=8,tagColors=[],tags=document.getElementsByClassName('butterfly-tags');
                  for(var i = 0 ; i < tags.length ; ++i){
                      if(!tagColors.length)colorInit(tagColors,colorNumber);
                      var j=Math.floor(Math.random()*tagColors.length);
                      tags[i].classList.add("spfk-color"+tagColors[j]);
                      tagColors.splice(j,1);
                  }
              }
              paintTags()
          </script>
        
    </header>
  </div>

<div id="content" class="site-content">
  <div id="primary" class="content-area">
    <main id="main" class="site-main" role="main">
      <article id="post-1" class="post-1 post type-post status-publish format-standard has-post-thumbnail hentry category-uncategorized">
        <div class="toc"></div>
        <!--<div class="toc-entry-content"><!-- 套嵌目录使用（主要为了支援评论）-->
        
        <div class="entry-content">
          <h1 id="纪念"><a href="#纪念" class="headerlink" title="纪念"></a>纪念</h1><p>数据结构一百题50题了呢，该过半周年啦~~~~</p>
<p>LYC和WGY半年的努力让这个几乎玩笑一般的系列到了现在。</p>
<p>今后也请多多关照啦。</p>
<p><del>祝愿dp100p早日过半</del></p>
<h1 id="51-CF1000F-One-Occurrence"><a href="#51-CF1000F-One-Occurrence" class="headerlink" title="51.CF1000F One Occurrence"></a>51.CF1000F One Occurrence</h1><p>给定一个长度为$n$序列，$m$个询问，每次询问给定一个区间$[l,r]$，如果这个区间里存在只出现一次的数，输出这个数（如果有多个就输出任意一个），没有就输出0。$n,m\le 5e5$</p>
<hr>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定一个序列，每次询问输出一个区间 $[l,r]$ 中只出现一次的数。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题其实比较有意思。他让你输出只出现一次的数，讲道理你让我维护个数都还好办，这个就比较好玩了。</p>
<p>我这里给出一种不用吸氧的卡常莫队做法。</p>
<p>其实莫队需要维护的东西很简单，就是一个数的出现次数，我们用一个数组 <code>cnt</code> 来记录。</p>
<p>每次我们算加贡献的时候，<code>cnt</code> 的计算方法很显然。我们同时维护一个栈，算加贡献的时候如果这个数的出现次数为1，我们就把他放到栈顶上去。我们顺手维护一个数组 <code>pos</code> 表示这个数在栈里的位置。</p>
<p>算减贡献的时候 <code>cnt</code> 的计算方法依旧显然。我们把栈顶元素放到删除的数的位置上即可。</p>
<p>每次询问的答案就是栈顶元素，由于不合法的情况输出零，所以没必要特判。</p>
<p>光这样是过不了的，会T飞。</p>
<p>我们需要一个针对于莫队的优化，叫做奇偶性排序优化（瞎编的一个名字），具体来说就是在对询问排序的时候分块的奇偶性，具体实现看代码。这种排序的方式理论来说有 $\Theta(\frac{1}{2})$ 的常数。</p>
<p>这样还是会T。容易发现输出答案的循环可以用unroll循环展开，我设的unroll的参是10，已经能过了。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int Maxn = 5e5 + 5, Each = 720;
int n, m, top, isa[ Maxn ], cnt[ Maxn ], pos[ Maxn ], htl[ Maxn ], ans[ Maxn ];
struct Query_Node
{
    int l, r, id, pos;
    Query_Node( int L = 0, int R = 0, int ID = 0 ) { l = L, r = R, id = ID; }
} Q[ Maxn ];

inline int read( )
{
    int a = 0, minus = 0;
    char ch = getchar( );
    while( !isdigit( ch ) )
    {
        if( ch == &#39;-&#39; )     minus = 1;
        ch = getchar( );
    }
    while( isdigit( ch ) )
    {
        a = a * 10 + ch - &#39;0&#39;;
        ch = getchar( );
    }
    if( minus )     return -a;
    else    return a;
}

inline void write( int x )
{
    if( x &lt; 0 )
    {
        x = -x;
        putchar( &#39;-&#39; );
    }
    if( x &gt; 9 )     write( x / 10 );
    putchar( x % 10 + &#39;0&#39; );
}

inline bool cmp( Query_Node rhs, Query_Node shr )
{
    if( rhs.pos != shr.pos )    return rhs.l &lt; shr.l;
    else if( rhs.pos &amp; 1 )    return rhs.r &lt; shr.r;
    else     return rhs.r &gt; shr.r;
}

inline void Make_Cont( int x, int t )
{
    x = isa[ x ];
    if( t == 1 ) ++ cnt[ x ];
    else    --cnt[ x ];
    if( cnt[ x ] == 1 )
    {
        htl[ ++ top ] = x;
        pos[ x ] = top;
    }
    else if( ( t == 1 ) ? ( cnt[ x ] == 2 ) : ( cnt[ x ] == 0 ) )
    {
        htl[ pos[ x ] ] = htl[ top ];
        pos[ htl[ top ] ] = pos[ x ];
        pos[ x ] = htl[ top -- ] = 0;
    }
}

inline void Contribute( )
{
    int l = 1, r = 0;
    for( int i = 0; i &lt; m; ++ i )
    {
        while( l &lt; Q[ i ].l )    Make_Cont( l ++, 0 );
        while( l &gt; Q[ i ].l )    Make_Cont( -- l, 1 );
        while( r &lt; Q[ i ].r )    Make_Cont( ++ r, 1 );
        while( r &gt; Q[ i ].r )    Make_Cont( r --, 0 );
        ans[ Q[ i ].id ] = htl[ top ];
    }
}

signed main( )
{
    n = read( );
    for( int i = 1; i &lt;= n; ++ i )         isa[ i ] = read( );
    m = read( );
    for( int i = 0; i &lt; m; ++ i )
    {
        Q[ i ].l = read( );
        Q[ i ].r = read( );
        Q[ i ].id = i;
        Q[ i ].pos = Q[ i ].l / Each;
    }
    sort( Q, Q + m, cmp );
    Contribute( );
    if( m &lt;= 10 )
    {
        for( int i = 0; i &lt; m; ++ i )        write( ans[ i ] ), putchar( &#39;\n&#39; );
        return 0;
    }
    #pragma unroll 10
    for( int i = 0; i &lt; m; ++ i )        write( ans[ i ] ), putchar( &#39;\n&#39; );
    return 0;
}
</code></pre>
<h1 id="52-P5046-Ynoi2019模拟赛-Yuno-loves-sqrt-technology-I"><a href="#52-P5046-Ynoi2019模拟赛-Yuno-loves-sqrt-technology-I" class="headerlink" title="52.P5046 [Ynoi2019模拟赛]Yuno loves sqrt technology I"></a>52.P5046 [Ynoi2019模拟赛]Yuno loves sqrt technology I</h1><p><img src="https://cdn.luogu.com.cn/upload/pic/44003.png" alt></p>
<p>给你一个长为 $n$ 的<strong>排列</strong>，$m$ 次询问，每次查询一个区间的逆序对数，强制在线。</p>
<hr>
<h2 id="题意简述-1"><a href="#题意简述-1" class="headerlink" title="题意简述"></a>题意简述</h2><p>无修改区间求逆序对。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>首先有一个显然的 $\Theta(N\sqrt{N}\log_{2}N)$ 做法，由于过不了所以我就不废话。</p>
<p>其实有了 $\Theta(N\sqrt{N}\log_{2}N)$ 的过不去做法，我们就可以根据这个思路然后预处理解决问题。</p>
<p>我们需要处理的信息有：</p>
<ol>
<li><p>散块的逆序对数量</p>
</li>
<li><p>以块为单位的区间逆序对数量</p>
</li>
</ol>
<p>那么我们需要处理的数组就有以下几个：</p>
<ol>
<li><p><code>previous[i]</code> 表示 $i$ 到 该块开头的逆序对数量。</p>
</li>
<li><p><code>suffix[i]</code> 同理。</p>
</li>
<li><p><code>block[i][j]</code> 表示前 $i$ 个块中 $\leq j$ 元素个数。</p>
</li>
<li><p><code>intervals[i][j]</code> 表示以块为单位的区间 $[i,j]$ 中的逆序对数量。</p>
</li>
</ol>
<p>讲讲预处理方法。</p>
<ol>
<li><p><code>previous[i]</code> 和 <code>suffix[i]</code> 的处理方法都很显然，可以一直扫着然后FWT扫就行。</p>
</li>
<li><p><code>block[i][j]</code> 可以递推，递推式为 <code>block[i][j]=block[i+1][j]+block[i][j-1]-block[i+1][j-1]+cont(i,j)</code>。其中 <code>cont(i,j)</code> 表示计算对应块的逆序对数。</p>
</li>
<li><p><code>intervals[i][j]</code> 每次循环到块的开头继承上一个块的贡献即可。</p>
</li>
</ol>
<p>计算贡献的方法很简单，归并即可。mrsrz讲得也挺清楚的，我这里就不再赘述，主要讲讲怎么卡常。</p>
<p>首先我们可以把主函数里的所有循环全部展开，经过实践参数传8的时候跑得比较快。</p>
<p>然后八聚氧先加上，luogu O2也开着。</p>
<p>再其次快读fread快输fwrite，这些都是卡常的标配。</p>
<p>然后就把能拿出来的结构体拿出来，实在不能就不管了。</p>
<p>然后去STL，pair vector能去就去。</p>
<p>然后long long开在正确的地方，不要无脑replace。</p>
<p>函数inline，循环register。虽然可能作用不大但是可以先加上。</p>
<p>然后调块长，经过无数次实践发现取150~170较为优秀。</p>
<p>然后加了过后发现就算rp再好也只有60pts。</p>
<p>然后谷歌搜索硫酸的化学式H₂SO₄，给评测机喂硫酸（idea来自SyadouHayami）。</p>
<p>然后本来交了5页都过不了，这下再交两次就过了。</p>
<pre><code class="lang-cpp">// 省略八聚氧
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;

using namespace std;

const int Maxn = 1e5 + 5;
const int Maxm = 650;
const int each = 160;
int n, m, blocks, Lp[Maxn], Rp[Maxn], isa[Maxn], head[Maxn], tail[Maxn], sorted[Maxn], belong[Maxn], previous[Maxn], suffix[Maxn], block[Maxm][Maxn];
long long intervals[Maxm][Maxn];
struct Holy_Pair
{
    int first, second;

    bool operator &lt; (const Holy_Pair&amp; rhs) const
    {
        return first &lt; rhs.first;
    }
} current[Maxn];
struct Fenwick_Tree
{
    int fwt[Maxn];

    inline void Modify(int x, int v)
    {
        for (; x + 5 &lt;= Maxn; x += x &amp; -x)    fwt[x] += v;
    }

    inline int Query(int x)
    {
        int ret = 0;
        for (; x; x ^= x &amp; -x)    ret += fwt[x];
        return ret;
    }
} FWT;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
namespace Fast_IO
{
... // 省略快读
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

inline Holy_Pair make_pair(int first, int second)
{
    Holy_Pair ret;
    ret.first = first;
    ret.second = second;
    return ret;
}

inline int Merge_Vct(int rhs[], int shr[], int szl, int szr)
{
    int itl = 1, itr = 1;
    int ret = 0, ctr = 1;
    while (itl &lt;= szl &amp;&amp; itr &lt;= szr)
    {
        if (rhs[itl] &lt; shr[itr])     ++itl, ++ctr;
        else
        {
            ret += szl - ctr + 1;
            ++itr;
        }
    }
    return ret + szr - szr;
}

inline int Merge_Idx(int st1, int st2, int sz1, int sz2)
{
    int ret = 0, id1 = st1 + 1, id2 = st2 + 1;
    sz1 += st1, sz2 += st2;
    while (id1 &lt;= sz1 &amp;&amp; id2 &lt;= sz2)
    {
        if (sorted[id1] &lt; sorted[id2])        ++id1;
        else
        {
            ret += sz1 - id1 + 1;
            ++id2;
        }
    }
    return ret;
}

inline void Behavior(int l, int r, long long &amp;ans)
{
    int itl = 0, itr = 0;
    if (belong[l] == belong[r])
    {
        for (int i = head[belong[l]]; i &lt;= tail[belong[r]]; ++i)
        {
            if (current[i].second &gt;= l &amp;&amp; current[i].second &lt;= r)    Rp[++itr] = sorted[i];
            else if (current[i].second &lt; l)        Lp[++itl] = sorted[i];
        }
        if (l == head[belong[l]])    ans = previous[r] - Merge_Vct(Lp, Rp, itl, itr);
        else     ans = previous[r] - previous[l - 1] - Merge_Vct(Lp, Rp, itl, itr);
    }
    else
    {
        ans = intervals[belong[l] + 1][belong[r] - 1] + previous[r] + suffix[l];
        for (int i = head[belong[l]]; i &lt;= tail[belong[l]]; ++i)
        {
            if (current[i].second &gt;= l)
            {
                Lp[++itl] = sorted[i];
                ans += block[belong[r] - 1][1] - block[belong[r] - 1][sorted[i]] - block[belong[l]][1] + block[belong[l]][sorted[i]];
            }
        }
        for (int i = head[belong[r]]; i &lt;= tail[belong[r]]; ++i)
        {
            if (current[i].second &lt;= r)
            {
                Rp[++itr] = sorted[i];
                ans += block[belong[r] - 1][sorted[i] + 1] - block[belong[l]][sorted[i] + 1];
            }
        }
        ans += Merge_Vct(Lp, Rp, itl, itr);
    }
    write(io_l, ans);
}

signed main()
{
    read(n, m), blocks = (n - 1) / each + 1;
    if (n &lt;= 8)
    {
        for (int i = 1; i &lt;= n; ++i)
        {
            read(isa[i]);
            current[i] = make_pair(isa[i], i);
        }
    }
    else
    {
        #pragma unroll 8
        for (int i = 1; i &lt;= n; ++i)
        {
            read(isa[i]);
            current[i] = make_pair(isa[i], i);
        }
    }
    if (blocks &lt;= 8)
    {
        for (int i = 1; i &lt;= blocks; ++i)
        {
            head[i] = tail[i - 1] + 1;
            tail[i] = tail[i - 1] + each;
            if (i == blocks)     tail[i] = n;
        }
    }
    else
    {
        #pragma unroll 8
        for (int i = 1; i &lt;= blocks; ++i)
        {
            head[i] = tail[i - 1] + 1;
            tail[i] = tail[i - 1] + each;
            if (i == blocks)     tail[i] = n;
        }
    }
    if (blocks &lt;= 8)
    {
        for (int i = 1; i &lt;= blocks; ++i)
        {
            memcpy(block[i], block[i - 1], sizeof(block[0]));
            sort(current + head[i], current + 1 + tail[i]);
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                ++block[i][isa[j]];
                belong[j] = i;
                sorted[j] = current[j].first;
            }
            int satisfy = 0;
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                FWT.Modify(isa[j], 1);
                satisfy += FWT.Query(n) - FWT.Query(isa[j]);
                previous[j] = satisfy;
            }
            intervals[i][i] = satisfy;
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                suffix[j] = satisfy;
                FWT.Modify(isa[j], -1);
                satisfy -= FWT.Query(isa[j] - 1);
            }
        }
    }
    else
    {
        #pragma unroll 8
        for (int i = 1; i &lt;= blocks; ++i)
        {
            memcpy(block[i], block[i - 1], sizeof(block[0]));
            sort(current + head[i], current + 1 + tail[i]);
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                ++block[i][isa[j]];
                belong[j] = i;
                sorted[j] = current[j].first;
            }
            int satisfy = 0;
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                FWT.Modify(isa[j], 1);
                satisfy += FWT.Query(n) - FWT.Query(isa[j]);
                previous[j] = satisfy;
            }
            intervals[i][i] = satisfy;
            for (int j = head[i]; j &lt;= tail[i]; ++j)
            {
                suffix[j] = satisfy;
                FWT.Modify(isa[j], -1);
                satisfy -= FWT.Query(isa[j] - 1);
            }
        }
    }
    if (blocks &lt;= 8)
    {
        for (int dis = 1; dis &lt;= blocks; ++dis)
        {
            for (int i = n - 1; i; --i)        block[dis][i] += block[dis][i + 1];
            for (int l = 1, r = dis + 1; r &lt;= blocks + 1; ++l, ++r)
                intervals[l][r] = intervals[l + 1][r] + intervals[l][r - 1] - intervals[l + 1][r - 1] +
                                    Merge_Idx(head[l] - 1, head[r] - 1, tail[l] - head[l] + 1, tail[r] - head[r] + 1);
        }
    }
    else
    {
        #pragma unroll 8
        for (int dis = 1; dis &lt;= blocks; ++dis)
        {
            for (int i = n - 1; i; --i)        block[dis][i] += block[dis][i + 1];
            for (int l = 1, r = dis + 1; r &lt;= blocks + 1; ++l, ++r)
                intervals[l][r] = intervals[l + 1][r] + intervals[l][r - 1] - intervals[l + 1][r - 1] +
                                    Merge_Idx(head[l] - 1, head[r] - 1, tail[l] - head[l] + 1, tail[r] - head[r] + 1);
        }
    }

    if (m &lt;= 8)
    {
        long long lastans = 0;
        for (int i = 0; i &lt; m; ++i)
        {
            long long l, r;
            read(l, r);
            l ^= lastans;
            r ^= lastans;
            Behavior(l, r, lastans);
        }
    }
    else
    {
        long long lastans = 0;
        #pragma unroll 8
        for (int i = 0; i &lt; m; ++i)
        {
            long long l, r;
            read(l, r);
            l ^= lastans;
            r ^= lastans;
            Behavior(l, r, lastans);
        }
    }
    return 0;
}
</code></pre>
<h1 id="53-SP20644-ZQUERY-Zero-Query"><a href="#53-SP20644-ZQUERY-Zero-Query" class="headerlink" title="53.SP20644 ZQUERY - Zero Query"></a>53.SP20644 ZQUERY - Zero Query</h1><p>长度为$n$的序列，序列中的值为$1$或$-1$<br>有$m$个询问，询问在$[L,R]$中<strong>区间和</strong>为$0$的区间的<strong>最大长度</strong></p>
<hr>
<h2 id="题意简述-2"><a href="#题意简述-2" class="headerlink" title="题意简述"></a>题意简述</h2><p>求区间中区间和为0的最长区间。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>首先前缀和基本操作，然后问题转化为：</p>
<p>给定询问区间 $[l,r]$，求区间中相同的数的最远间隔距离，即P5906。</p>
<p>考虑莫队来整。</p>
<p>可以维护两个东西，一个是 <code>pre[x]</code> 表示当前的询问区间 $[l,r]$ 中 $x$ 最早出现的位置。</p>
<p>还有一个是 <code>suf[x]</code> 表示当前的询问区间 $[l,r]$ 中 $x$ 最后出现的位置。</p>
<p>在莫队加贡献的时候这些很好整，分别像这样维护：</p>
<p>如果加贡献时出现了数 $x$ 那么 <code>pre[x]=p</code>，$p$ 表示加贡献时计算的位置。</p>
<p><code>suf[x]</code> 同理。</p>
<p>那么询问的答案就是 $\max_{i\in [l,r]}\{suf_{a_{x}}-pre_{a_{x}}\}$。</p>
<p>中间有个特殊情况就是需要判断还没被更新过的时候，自己打代码的时候注意点。</p>
<p>然后发现一个神奇的事情：减贡献我们做不来了！</p>
<p>既然我们不会做减法，那就不做吧。</p>
<p>正常的莫队的询问区间左右指针 $l,r$ 一般初值为 $l=1,r=0$。</p>
<p>我们这里换一种方式。</p>
<p>首先我们把询问分块，然后排序，这是莫队的常规操作。</p>
<p>然后再枚举每个块，我们首先处理询问的左端点在当前块中的询问，思考一下询问分块的排序方式就可以知道这种算法的正确性。</p>
<p>然后我们把指针的初值设为 $l=R_{i}+1,r=R_{i}-1$，其中数组 $R$ 表示块的左端点。</p>
<p>然后如果询问区间在一个块中就暴力。</p>
<p>由于询问区间在一个块中的询问我们已经暴力处理过了，所以剩下的询问右端点一定在其他块。</p>
<p>然后 $r$ 指针正常右移，这一步只需要加贡献。</p>
<p>所以 $l$ 指针只需要左移，我们就可以合并两次的贡献，就是这次询问的答案。</p>
<p>由于排序的规则，剩下的询问右端点一定在当前询问右端点的右边，所以我们的 $r$ 指针可以不用管，就放到当前询问的位置。</p>
<p>但是 $l$ 是无序的，所以我们需要撤销计算 $l$ 产生的贡献，这很简单，不赘述。</p>
<p>这种算法叫回滚莫队。</p>
<p>但是这种trick我在之前一道莫队题中想到过，不过觉得太麻烦就没打。</p>
<p>后来发现有这个东西的板子，又重学了一遍。</p>
<p>还是挺好玩的吧，数据结构。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

const int Maxn = 2e5 + 5;
int n, m, each, cube, isa[Maxn], pre[Maxn], nxt[Maxn], vio[Maxn], ans[Maxn], bel[Maxn], head[Maxn], tail[Maxn];
struct Query_Node
{
    int l, r, id;
} Q[Maxn];

bool cmp(Query_Node rhs, Query_Node shr)
{
    if (bel[rhs.l] == bel[shr.l])    return rhs.r &lt; shr.r;
    else     return bel[rhs.l] &lt; bel[shr.l];
}

void Contribute(int las = 0)
{
    for (int k = 1; k &lt;= cube; ++k)
    {
        int l = tail[k] + 1, r = tail[k], ret = 0;
        vector &lt; int &gt; vctr;
        for (int c = las + 1; bel[Q[c].l] == k; ++c)
        {
            int ql = Q[c].l, qr = Q[c].r, now = 0;
            if (bel[ql] == bel[qr])
            {
                for (int i = ql; i &lt;= qr; ++i)    vio[isa[i]] = 0;
                for (int i = ql; i &lt;= qr; ++i)
                {
                    if (!vio[isa[i]])    vio[isa[i]] = i;
                    else    now = max(now, i - vio[isa[i]]);
                }
                ans[Q[c].id] = now;
                las = c;
            }
            else
            {
                while (r &lt; qr)
                {
                    ++r;
                    nxt[isa[r]] = r;
                    if (pre[isa[r]] == 0)
                    {
                        pre[isa[r]] = r;
                        vctr.push_back(isa[r]);
                    }
                    ret = max(ret, nxt[isa[r]] - pre[isa[r]]);
                }
                now = ret;
                while (l &gt; ql)
                {
                    --l;
                    if (nxt[isa[l]] == 0)    nxt[isa[l]] = l;
                    else    ret = max(ret, nxt[isa[l]] - l);
                }
                while (l &lt; tail[k] + 1)
                {
                    if (nxt[isa[l]] == l)    nxt[isa[l]] = 0;
                    ++l;
                }
                ans[Q[c].id] = ret;
                ret = now;
                las = c;
            }
        }
        for (unsigned i = 0; i &lt; vctr.size(); ++i)    pre[vctr[i]] = nxt[vctr[i]] = 0;
    }
}

signed main()
{
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    ++n;
    each = pow(n, 0.5);
    cube = (n - 1) / each + 1;
    for (int i = 2; i &lt;= n; ++i)
    {
        scanf(&quot;%d&quot;, &amp;isa[i]);
        isa[i] += isa[i - 1];
    }
    for (int i = 1; i &lt;= n; ++i)    isa[i] += 50005;
    for (int i = 1; i &lt;= cube; ++i)
    {
        head[i] = tail[i - 1] + 1;
        tail[i] = tail[i - 1] + each;
        for (int j = head[i]; j &lt;= tail[i]; ++j)    bel[j] = i;
        if (i == cube)    tail[i] = n;
    }
    for (int i = 1; i &lt;= m; ++i)
    {
        scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r);
        Q[i].r += 1;
        Q[i].id = i;
    }
    sort(Q + 1, Q + 1 + m, cmp);
    Contribute();
    for (int i = 1; i &lt;= m; ++i)    printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</code></pre>
<h1 id="54-P5268-SNOI2017-一个简单的询问"><a href="#54-P5268-SNOI2017-一个简单的询问" class="headerlink" title="54.P5268 [SNOI2017]一个简单的询问"></a>54.P5268 [SNOI2017]一个简单的询问</h1><p>给你一个长度为 $N$ 的序列 $a_i$，$1\leq i\leq N$，和 $q$ 组询问，每组询问读入 $l_1,r_1,l_2,r_2$，需输出</p>
<script type="math/tex; mode=display">
\sum\limits_{x=0}^\infty \text{get}(l_1,r_1,x)\times \text{get}(l_2,r_2,x)</script><p>$ \text{get}(l,r,x)$ 表示计算区间 $[l,r]$ 中，数字 $x$ 出现了多少次。</p>
<hr>
<h2 id="题意简述-3"><a href="#题意简述-3" class="headerlink" title="题意简述"></a>题意简述</h2><p>求式子</p>
<h2 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h2><p>纯算式子nt行为，由于是出现次数，满足区间加减性，所以我们可以这样表达 $\mathrm{get}(l,r,x)$（省略 $x$）:</p>
<script type="math/tex; mode=display">
\mathrm{get}(l,r)=\mathrm{get}(1,r)-\mathrm{get}(1,l-1)</script><p>那么我们代进原式，化一波式子：</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\infty}\mathrm{get}(l_{1},r_{1},x)\times\mathrm{get}(l_{2},r_{2},x)</script><script type="math/tex; mode=display">
\sum_{i=1}^{\infty}(\mathrm{get}(1,r_{1})-\mathrm{get}(1,l_{1}-1))\times(\mathrm{get}(1,r_{2})-\mathrm{get}(1,l_{2}-1))</script><script type="math/tex; mode=display">
\sum_{i=1}^{\infty}\mathrm{get}(r_{1})\times\mathrm{get}(r_{2})-\mathrm{get}(r_{1})\times\mathrm{get}(l_{2}-1)-\mathrm{get}(l_{1}-1)\times\mathrm{get}(r_{2})+\mathrm{get}(l_{1}-1))\times\mathrm{get}(l_{2}-1)</script><script type="math/tex; mode=display">
\mathrm{let}\ F(x,y)=\sum_{d}\mathrm{get}(1,l,d)\times\mathrm{get}(1,r,d)</script><p>则答案为:</p>
<script type="math/tex; mode=display">
F(r_{1},r_{2})-F(r_{1},l_{2}-1)-F(l_{1}-1,r_{2})+F(l_{1}-1,l_{2}-1)</script><p>考虑怎么更新，比如从 $l$ 更新到 $l+1$，则：</p>
<script type="math/tex; mode=display">
\mathrm{get(1,l)}\times\mathrm{get}(1,r)</script><script type="math/tex; mode=display">
\mathrm{get(1,l+1)}\times\mathrm{get}(1,r)</script><script type="math/tex; mode=display">
\mathrm{get(1,l)}\times\mathrm{get}(1,r)+\mathrm{cont}(a_{l})</script><p>其中 $\mathrm{cont}(a_{l})$ 表示 $a_{l}$ 的出现次数。</p>
<p>则我们就知道怎么更新了，由于我们维护和的是前缀信息，所以姿势和普通莫队有点不一样。</p>
<p>维护两个数组 <code>cntl[x]</code> 和 <code>cntr[y]</code> 表示答案式子</p>
<script type="math/tex; mode=display">
F(r_{1},r_{2})-F(r_{1},l_{2}-1)-F(l_{1}-1,r_{2})+F(l_{1}-1,l_{2}-1)</script><p>中 $F(x,y)$ 的值。</p>
<p>式子和表达可能有些玄学，自己意会一下吧。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;algorithm&gt;

using namespace std;

const int Maxn = 50000 + 5;
int n, m, q, each, cube, isa[Maxn], bel[Maxn], cntl[Maxn], cntr[Maxn];
long long now, ans[Maxn];
struct Query_Node
{
    int l, r, id, typ;
    Query_Node(int tl = 0, int tr = 0, int tid = 0, int tpyt = 0)
    {
        l = tl;
        r = tr;
        id = tid;
        typ = tpyt;
    }
} Q[Maxn &lt;&lt; 2];

bool cmp(Query_Node rhs, Query_Node shr)
{
    if (bel[rhs.l] == bel[shr.l])    return rhs.r &lt; shr.r;
    else     return rhs.l &lt; shr.l;
}

void Contribute()
{
    int l = 0, r = 0;
    for (int i = 1; i &lt;= m; ++i)
    {
        while (l &lt; Q[i].l)
        {
            ++cntl[isa[++l]];
            now += cntr[isa[l]];
        }
        while (l &gt; Q[i].l)
        {
            --cntl[isa[l]];
            now -= cntr[isa[l--]];
        }
        while (r &lt; Q[i].r)
        {
            ++cntr[isa[++r]];
            now += cntl[isa[r]];
        }
        while (r &gt; Q[i].r)
        {
            --cntr[isa[r]];
            now -= cntl[isa[r--]];
        }
        ans[Q[i].id] += Q[i].typ * now;
    }
}

signed main()
{
    scanf(&quot;%d&quot;, &amp;n);
    each = 230;
    for (int i = 1; i &lt;= n; ++i)
    {
        scanf(&quot;%d&quot;, &amp;isa[i]);
        bel[i] = (i - 1) / each + 1;
    }
    scanf(&quot;%d&quot;, &amp;q);
    for (int i = 1; i &lt;= q; ++i)
    {
        int l1, r1, l2, r2;
        scanf(&quot;%d %d %d %d&quot;, &amp;l1, &amp;r1, &amp;l2, &amp;r2);
        Q[++m] = Query_Node(r1, r2, i, 1);
        Q[++m] = Query_Node(r1, l2 - 1, i, -1);
        Q[++m] = Query_Node(l1 - 1, r2, i, -1);
        Q[++m] = Query_Node(l1 - 1, l2 - 1, i, 1);
    }
    for (int i = 1; i &lt;= m; ++i)
    {
        if (Q[i].l &lt; Q[i].r)    swap(Q[i].l, Q[i].r);
    }
    sort(Q + 1, Q + 1 + m, cmp);
    Contribute();
    for (int i = 1; i &lt;= q; ++i)    printf(&quot;%lld\n&quot;, ans[i]);
    return 0;
}
</code></pre>
<h1 id="55-P3466-POI2008-KLO-Building-blocks"><a href="#55-P3466-POI2008-KLO-Building-blocks" class="headerlink" title="55.P3466 [POI2008]KLO-Building blocks"></a>55.P3466 [POI2008]KLO-Building blocks</h1><p>有 $n$ 柱砖,每柱砖有一个高度，我们现在希望有连续 $k$ 柱的高度是一样的。</p>
<p>你可以选择以下两个动作：</p>
<p>1:从某柱砖的顶端拿一块砖出来,丢掉不要了。</p>
<p>2:从仓库中拿出一块砖,放到另一柱，仓库是无限大的。</p>
<p>现在希望用最小次数的动作完成任务，除此之外你还要求输出结束状态时,每柱砖的高度。</p>
<hr>
<h2 id="题意简述-4"><a href="#题意简述-4" class="headerlink" title="题意简述"></a>题意简述</h2><p>给定一个长度为 $n$ 的序列，支持单点减一，单点加法的操作，问把一个长度为 $k$ 的区间里的值变成同样的最小操作数。</p>
<h2 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h2><p>挺好的一道平衡树练手+猜结论题。（雾</p>
<p>化简一下题意，我们需要找到一个值 $m$ 且 $m$ 使得 $\sum_{i=1}^{r}\mid a_{i}-x\mid$ 最小。</p>
<p>其中 $r-l+1=k$。</p>
<p>大约可以猜到这里需要取中位数。</p>
<p>感性理解一下，把 $a_{l},a_{l+1},\cdots,a_{r}$ 排序后如果每个数要取最小只能取中位数。</p>
<p>可以当成一个结论式的东西积累起来。</p>
<p>那么我们就需要一个数据结构，支持插入，删除，查 $k_{th}$。</p>
<p>这里我选择的是Zip-Tree，也就是国内常说的FHQ-Treap。</p>
<p>具体的做法是，枚举每个长度为 $k$ 的区间 $[l,r]$，首先我们把 $a_{1},a_{2},\cdots,a_{k}$ 插入平衡树，然后根据 $k$ 的奇偶性用 $k_{th}$ 操作找到中位数（序列的中位数根据序列的长度奇偶性不同有区别）。</p>
<p>然后计算贡献即可，顺手记录一下区间的位置，方便输出答案。</p>
<p>贡献的计算可以分成大于中位数，小于中位数，等于中位数的情况。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;ctime&gt;
#include &lt;climits&gt;
#define int long long

const int Maxn = 1e5 + 5;
int n, k, rt, tot, isa[Maxn];
struct Treap
{
    int l, r, siz, sum, key, val;
} t[Maxn];

int newnode(int val)
{
    t[++tot].val = val;
    t[tot].sum = val;
    t[tot].key = rand();
    t[tot].siz = 1;
    return tot;
}

void maintain(int x)
{
    t[x].siz = t[t[x].l].siz + t[t[x].r].siz + 1;
    t[x].sum = t[t[x].l].sum + t[t[x].r].sum + t[x].val;
}

void Split(int now, int val, int &amp;x, int &amp;y)
{
    if (now == 0)    x = y = 0;
    else
    {
        if (val &gt;= t[now].val)
        {
            x = now;
            Split(t[now].r, val, t[now].r, y);
        }
        else
        {
             y = now;
             Split(t[now].l, val, x, t[now].l);
        }
        maintain(now);
    }
}

int Merge(int x, int y)
{
    if (x == 0 || y == 0)    return x + y;
    else
    {
        if (t[x].key &gt; t[y].key)
        {
            t[x].r = Merge(t[x].r, y);
            maintain(x);
            return x;
        }
        else
        {
            t[y].l = Merge(x, t[y].l);
            maintain(y);
            return y;
        }
    }
}

int rt1, rt2, rt3;
void Insert(int val)
{
    Split(rt, val, rt1, rt2);
    rt = Merge(rt1, Merge(newnode(val), rt2));
}

void Remove(int val)
{
    Split(rt, val, rt1, rt3);
    Split(rt1, val - 1, rt1, rt2);
    rt2 = Merge(t[rt2].l, t[rt2].r);
    rt = Merge(rt1, Merge(rt2, rt3));
}

int Find_Kth(int rnk)
{
    int now = rt;
    while (now)
    {
        if (t[t[now].l].siz + 1 == rnk)     break;
        else if (t[t[now].l].siz &gt;= rnk)     now = t[now].l;
        else
        {
            rnk -= t[t[now].l].siz + 1;
            now = t[now].r;
        }
    }
    return t[now].val;
}

int Query(int mid)
{
    Split(rt, mid, rt1, rt3);
    Split(rt1, mid - 1, rt1, rt2);
    int lth = rt1, mth = rt3;
    int cont_l = t[lth].siz * mid - t[lth].sum;
    int cont_r = t[mth].sum - t[mth].siz * mid;
    rt = Merge(rt1, Merge(rt2, rt3));
    return cont_l + cont_r;
}

signed main()
{
    srand((unsigned)(time(NULL)));
    int MID, LEFT, RIGHT, ANS = LONG_LONG_MAX;
    scanf(&quot;%lld %lld&quot;, &amp;n, &amp;k);
    for (int i = 1; i &lt;= n; ++i)    scanf(&quot;%lld&quot;, &amp;isa[i]);
    for (int i = 1; i &lt;= k; ++i)     Insert(isa[i]);
    int l = 1, r = k;
    for (int i = k; i &lt;= n; ++i)
    {
        int mid;
        if (k &amp; 1)    mid = Find_Kth((k &gt;&gt; 1) + 1);
        else     mid = (Find_Kth(k &gt;&gt; 1) + Find_Kth((k &gt;&gt; 1) + 1)) &gt;&gt; 1;
        int xxx = Query(mid);
        if (ANS &gt; xxx)
        {
            ANS = xxx;
            MID = mid;
            LEFT = l - 1;
            RIGHT = r + 1;
        }
        l++, r++;
        Remove(isa[l - 1]);
        Insert(isa[r]);
    }
    printf(&quot;%lld\n&quot;, ANS);
    for (int i = 1; i &lt;= LEFT; ++i)     printf(&quot;%lld\n&quot;, isa[i]);
    for (int i = LEFT + 1; i &lt;= RIGHT - 1; ++i)     printf(&quot;%lld\n&quot;, MID);
    for (int i = RIGHT; i &lt;= n; ++i)     printf(&quot;%lld\n&quot;, isa[i]);
    return 0;
}
</code></pre>
<h1 id="56-P5610-Ynoi2013-大学"><a href="#56-P5610-Ynoi2013-大学" class="headerlink" title="56.P5610 [Ynoi2013]大学"></a>56.P5610 [Ynoi2013]大学</h1><p>一个长为 $n$ 的<strong>非负</strong>整数序列 $a$，支持以下两个操作：</p>
<ul>
<li><code>1 l r x</code>：把区间 $[l,r]$ 中所有 $x$ 的倍数除以 $x$。</li>
<li><code>2 l r</code>：查询区间 $[l,r]$ 的和。</li>
</ul>
<p>本题强制在线，每次的 $l,r,x$ 需要 xor 上上次答案，如果之前没有询问，则上次答案为 $0$。</p>
<hr>
<h2 id="题意简述-5"><a href="#题意简述-5" class="headerlink" title="题意简述"></a>题意简述</h2><p>区间查 $x$ 的倍数并除掉，区间查和。</p>
<h2 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h2><p>平衡树。</p>
<p>首先有个基本的想法就是按 $a_{i}$ 开平衡树，即对于每个 $a_{i}$ 都开一棵平衡树，共5e5棵，第 $i$ 棵平衡树维护的值是所有 $a_{i}$ 的倍数在原数组中的下标，用处后面讲。</p>
<p>注意到一个小性质，一个正整数 $A$ 最多被整除 $\log_{2}A$ 次，这个很好想，每次都至少减少一半。可以当成一个 trick 记下来。</p>
<p>整个区间的数最多被除 $\sum_{i=1}^{n}\log_{2}a_{i}$ 次，区间和的操作可以用树状数组操作实现，则整体的操作复杂度为 $\Theta(\sum_{i=1}^{n}\log_{2}a_{i}+\log_{2}a_{i})$。</p>
<p>开头提到了对于每个 $a_{i}$ 我们都开一棵平衡树，作用就体现在这里。因为如果要保证正确的时间复杂度，我们需要快速的找到需要执行操作的数。</p>
<p>这里我采用的是 FHQ-Treap。</p>
<p>我们可以用两次 <code>split</code> 操作在 $x$ 的平衡树中提取出当前的询问区间，由于我们是以下标为平衡树维护的权值，所以我们用按值分裂即可提取出区间。</p>
<p>然后我们就在提取出的子树中 DFS 遍历，然后暴力操作，把操作后依然是 $x$ 的倍数的数记录下来，操作完后用这个数组再建一棵临时树然后和之前 <code>split</code> 出来的子树一起合并回去。</p>
<p>【记得配图，解释一下】</p>
<p>操作之前记得预处理每个数的所有约数，这个简单，直接用 vector 即可。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;algorithm&gt;
#include &lt;ctime&gt;
#include &lt;queue&gt;

using namespace std;
typedef long long t_t;

const int Maxn = 1e5 + 5;
const int Maxa = 5e5 + 5;
int n, m, xxx, zip, tot, isa[Maxn], bin[Maxa], root[Maxa];
struct Treap
{
    int l, r, key, val;
} t[Maxa * 230];
struct Fenwick_Tree
{
    t_t bit[Maxn];

    void ins(int x, t_t v)
    {
        for (; x &lt;= n; x += x &amp; -x)     bit[x] += v;    
    }

    t_t sum(int x)
    {
        t_t ret = 0;
        for (; x; x -= x &amp; -x)    ret += bit[x];
        return ret;
    }
} fwt;
vector &lt; int &gt; vec[Maxa];

int newnode(int val)
{
    t[++tot].val = val;
    t[tot].key = rand();
    return tot;
}

void split(int now, int val, int &amp;x, int &amp;y)
{
    if (now == 0)    x = y = 0;
    else
    {
        if (t[now].val &lt;= val)
        {
            x = now;
            split(t[now].r, val, t[now].r, y);
        }
        else
        {
            y = now;
            split(t[now].l, val, x, t[now].l);
        }
    }
}

int merge(int x, int y)
{
    if (x == 0 || y == 0)    return x | y;
    if (t[x].key &gt; t[y].key)
    {
        t[x].r = merge(t[x].r, y);
        return x;
    }
    else
    {
        t[y].l = merge(x, t[y].l);
        return y;
    }
}

int build(int l, int r)
{
    if (l &gt; r)    return 0;
    int mid = (l + r) &gt;&gt; 1;
    int now = newnode(bin[mid]);
    t[now].l = build(l, mid - 1);
    t[now].r = build(mid + 1, r);
    return now;
}

void dfs(int now, int val)
{
    if (now == 0)    return ;
    dfs(t[now].l, val);
    if (isa[t[now].val] % val == 0)
    {
        fwt.ins(t[now].val, -isa[t[now].val]);
        isa[t[now].val] /= val;
        fwt.ins(t[now].val, isa[t[now].val]);
    }
    if (isa[t[now].val] % val == 0)    bin[++zip] = t[now].val;
    dfs(t[now].r, val);
}

int tx, ty, tp;
void change(int l, int r, int x)
{
    if (x == 1)     return ;
    split(root[x], r, tx, tp);
    split(tx, l - 1, tx, ty);
    zip = 0;
    dfs(ty, x);
    root[x] = merge(tx, merge(build(1, zip), tp));
}

signed main()
{
    srand((114514 - 1) / 3 - 4);
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i)
    {
        scanf(&quot;%d&quot;, &amp;isa[i]);
        fwt.ins(i, isa[i]);
        xxx = max(xxx, isa[i]);
    }
    for (int i = 1; i &lt;= n; ++i)
    {
        for (int j = 1; j * j &lt;= isa[i]; ++j)
        {
            if (isa[i] % j == 0)
            {
                vec[j].push_back(i);
                if (j * j != isa[i])    vec[isa[i] / j].push_back(i);
            }
        }
    }
    for (int i = 1; i &lt;= xxx; ++i)
    {
        zip = 0;
        for (unsigned j = 0; j &lt; vec[i].size(); ++j)    bin[++zip] = vec[i][j];
        root[i] = build(1, zip);
    }
    for (int i = 0; i &lt; m; ++i)
    {
        int t, l, r, x;
        scanf(&quot;%d %d %d&quot;, &amp;t, &amp;l, &amp;r);
        if (t == 1)
        {
            scanf(&quot;%d&quot;, &amp;x);
            change(l, r, x);
        }
        else    printf(&quot;%lld\n&quot;, fwt.sum(r) - fwt.sum(l - 1));
    }
    return 0;
}
</code></pre>
<h1 id="57-CF803G-Periodic-RMQ-Problem"><a href="#57-CF803G-Periodic-RMQ-Problem" class="headerlink" title="57.CF803G Periodic RMQ Problem"></a>57.CF803G Periodic RMQ Problem</h1><p>给你一个序列$a$ 让你支持</p>
<p>$1$  $l$  $r$  $x$ 区间赋值</p>
<p>$2$  $l$  $r$  询问区间最小值</p>
<p>我们觉得这个问题太水了,所以我们不会给你序列$a$  </p>
<p>而是给你序列一个长度为$n$ 的序列$b$ ,把$b$ 复制粘贴$k$ 次就可以得到$a$  </p>
<p>$n\le10^5,k\le10^4,q\le10^5,b_i\le10^9$  </p>
<p>$1\le l\le r\le n\times k$  </p>
<hr>
<p><strong>题目解释：</strong></p>
<p>有一个由给定序列不断首尾拼接而成的序列（很长，存不下）。</p>
<p>要求实现两个操作：区间赋值和查询区间最小值。</p>
<hr>
<p>这个序列很长不好操作，所以我们要进行离散化，缩小一下操作的范围。</p>
<p>把每个操作的左端点减一和右端点加入离散化数组$pri$（这里下标从1开始）。</p>
<p>离散化后第i个块的左端点是$pri[i-1]+1$,右端点是$pri[i]$。（离散化还要插入$0$和最后一个位置的下标，不然有些位置没有被覆盖到）</p>
<p>但是离散化之后我们不知道每个离散化出来的块内的最小值，这样就无法初始化。</p>
<p>我们可以利用之前给出用来首尾拼接的序列求出来。</p>
<p>对每个块分类讨论：（设给定用来拼接的序列长为$n$）</p>
<p>1).块长大于等于$n$：</p>
<p>此时这个块已经覆盖了整个给定序列，那它的最小值直接就是给定序列的最小值。</p>
<p>2).块长小于$n$：</p>
<p>又要分两种情况:</p>
<p>$\ \ \ \ $A).左端点投射到序列中的位置在右端点的后面（由于是由同一序列首尾拼接而成，我们可以把它们投射到一个序列上）。</p>
<p>$\ \ \ \ $就是说：这个块覆盖的给定序列的前面的一部分和后面的一部分。</p>
<p>$\ \ \ \ $就像这样：</p>
<p><img src="https://s1.ax1x.com/2020/07/28/aAX7GQ.png" alt></p>
<p>$\ \ \ \ $投射到给定序列上就像这样：</p>
<p><img src="https://s1.ax1x.com/2020/07/28/aAXTPg.png" alt></p>
<p>$\ \ \ \ $那么我们直接查询（涂色的）这两段的最小值再取个$min$就好了。</p>
<p>$\ \ \ \ $其实就是从他们中间的序列尾（就是更上面的那张图L,R中间那条黑线）分开来求两边的最小值再取$min$，就得到了他们之间的最小值。</p>
<p>$\ \ \ \ $B).左端点投射到序列中的位置在右端点的前面。</p>
<p>$\ \ \ \ $仿照上个情况，投射到序列上查询他们之间的最小值即可。</p>
<p>由于是以操作的左右端点做的离散化，所以一个块内要么一起被询问，要么一起被修改。</p>
<p>所以我们用上面的方法处理出这个离散化后的序列每个块的初始值之后，就可以用线段树把它当板题做了！</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; pri;
const int INF=1e9+1;
int n,q,k,a[100010],ori[400010],op[100010],opl[100010],opr[100010],opx[100010],nodes[1000010],tag[2000010],s;
void buildori(int l,int r,int x)//对于给定序列的线段树建树。 
{
    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        buildori(l,mid,x&lt;&lt;1);
        buildori(mid+1,r,x&lt;&lt;1|1);
        ori[x]=min(ori[x&lt;&lt;1],ori[x&lt;&lt;1|1]);
    }
    else    ori[x]=a[l];
}
int findori(int l,int r,int x,int fr,int ba)//查询给定序列里的区间最小值。 
{
    if(l&gt;ba||r&lt;fr)    return INF;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return ori[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return min(findori(l,mid,x&lt;&lt;1,fr,ba),findori(mid+1,r,x&lt;&lt;1|1,fr,ba));
    }
}
void build(int l,int r,int x)//对离散化后的序列建树。 
{
    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        build(l,mid,x&lt;&lt;1);
        build(mid+1,r,x&lt;&lt;1|1);
        nodes[x]=min(nodes[x&lt;&lt;1],nodes[x&lt;&lt;1|1]);
    }
    else
    {
        if(pri[l]-pri[l-1]&gt;=n)    nodes[x]=ori[1];//情况1). 
        else
        {
            int one=(pri[l-1]+1)%n;
            if(one==0)    one=n;
            int two=pri[l]%n;
            if(two==0)    two=n;
            if(one&gt;two)    nodes[x]=min(findori(1,n,1,one,n),findori(1,n,1,1,two));//情况2).A). 
            else    nodes[x]=findori(1,n,1,one,two);//情况2).B). 
        }
    }
}
//后面的就是模板操作。 
void pushdown(int x)
{
    if(tag[x])
    {
        nodes[x]=tag[x];
        tag[x&lt;&lt;1]=tag[x&lt;&lt;1|1]=tag[x];
        tag[x]=0;
    }
}
void update(int l,int r,int x,int fr,int ba,int val)
{
    if(l&gt;ba||r&lt;fr)    return;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    tag[x]=val;
    else
    {
        int mid=(l+r)&gt;&gt;1;
        pushdown(x);
        update(l,mid,x&lt;&lt;1,fr,ba,val);
        update(mid+1,r,x&lt;&lt;1|1,fr,ba,val);
        pushdown(x&lt;&lt;1);
        pushdown(x&lt;&lt;1|1);
        nodes[x]=min(nodes[x&lt;&lt;1],nodes[x&lt;&lt;1|1]);
    }
}
int find(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return INF;
    pushdown(x);
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return min(find(l,mid,x&lt;&lt;1,fr,ba),find(mid+1,r,x&lt;&lt;1|1,fr,ba));
    }
}
int main()
{
    scanf(&quot;%d %d&quot;,&amp;n,&amp;k);
    for(int i=1;i&lt;=n;++i)    scanf(&quot;%d&quot;,&amp;a[i]);
    buildori(1,n,1);
    scanf(&quot;%d&quot;,&amp;q);
    pri.push_back(0);
    pri.push_back(n*k);//插入0和最后一个位置的下标。 
    for(int i=1;i&lt;=q;++i)
    {
        scanf(&quot;%d %d %d&quot;,&amp;op[i],&amp;opl[i],&amp;opr[i]);
        if(op[i]==1)    scanf(&quot;%d&quot;,&amp;opx[i]);
        pri.push_back(opl[i]-1);
        pri.push_back(opr[i]);//把每个操作的左端点减一和右端点加入离散化数组pri。 
    }
    sort(pri.begin(),pri.end());
    pri.erase(unique(pri.begin(),pri.end()),pri.end());
    s=pri.size();
    build(1,s,1);//0下标的位置没有前一个，所以从1开始建树。 
    for(int i=1;i&lt;=q;++i)
    {
        //lower_bound返回大于等于给定值的下标，插入操作时是插入的opl[i]-1和opr[i]，所以查询大于等于opl[i]的下标可以查询到opl[i]所在的块。 
        if(op[i]==1)    update(1,s,1,lower_bound(pri.begin(),pri.end(),opl[i])-pri.begin(),lower_bound(pri.begin(),pri.end(),opr[i])-pri.begin(),opx[i]);
        else    printf(&quot;%d\n&quot;,find(1,s,1,lower_bound(pri.begin(),pri.end(),opl[i])-pri.begin(),lower_bound(pri.begin(),pri.end(),opr[i])-pri.begin()));
    }
    return 0;
}
</code></pre>
<h1 id="58-P5305-GXOI-GZOI2019-旧词"><a href="#58-P5305-GXOI-GZOI2019-旧词" class="headerlink" title="58.P5305 [GXOI/GZOI2019]旧词"></a>58.P5305 [GXOI/GZOI2019]旧词</h1><p>&gt; 浮生有梦三千场<br>&gt; 穷尽千里诗酒荒<br>&gt; 徒把理想倾倒<br>&gt; 不如早还乡<br>&gt;<br>&gt; 温一壶风尘的酒<br>&gt; 独饮往事迢迢<br>&gt; 举杯轻思量<br>&gt; 泪如潮青丝留他方<br>&gt;<br>&gt; ——乌糟兽/愚青《旧词》</p>
<p>你已经解决了五个问题，不妨在这大树之下，吟唱旧词一首抒怀。最后的问题就是关于这棵树的，它的描述很简单。</p>
<p>给定一棵 $n$ 个点的有根树，节点标号 $1 \sim n$，$1$ 号节点为根。<br>给定常数 $k$。<br>给定 $Q$ 个询问，每次询问给定 $x,y$。<br>求：</p>
<script type="math/tex; mode=display">\sum\limits_{i \le x} \text{depth}(\text{lca}(i,y))^k</script><p>$\text{lca}(x,y)$ 表示节点 $x$ 与节点 $y$ 在有根树上的最近公共祖先。<br>$\text{depth}(x)$ 表示节点 $x$ 的深度，根节点的深度为 $1$。<br>由于答案可能很大，你只需要输出答案模 $998244353$ 的结果。</p>
<hr>
<p>这道题目非常简洁：要求 $\sum_{i\le x}depth(lca(i,y))^k$ <del>（都写在题面里了）</del></p>
<p>要直接解决这个问题是有点困难的，那么——</p>
<p><strong>我们先看它的弱化版</strong>：<a href="https://www.luogu.com.cn/problem/P4211" target="_blank" rel="noopener">[LNOI2014]LCA</a></p>
<p>要求 $\sum_{i=l}^rdepth(lca(i,z))$</p>
<p><del>少了个k次方呢！</del></p>
<p>首先转化一下   $\sum_{i=l}^rdepth(lca(i,z))=\sum_{i=1}^rdepth(lca(i,z))-\sum_{i=1}^{l-1}depth(lca(i,z))$</p>
<p>可以用前缀和来解决这个问题。</p>
<p>把每个询问拆成 $(1,l-1)$ 和 $(1,r)$ 分别解决。</p>
<p>那么我们可以按顺序把 $1$ 到 $n$ 的点加进来，同时计算加到每个点时的询问答案。</p>
<p>那么现在考虑加到第 $i$ 个点时如何计算贡献。</p>
<p>先上张图举个例子~</p>
<p><img src="https://s1.ax1x.com/2020/07/28/aEbJr6.png" alt></p>
<p>其中涂成红色的点就是已经加入的点。</p>
<p>我们先计算一下每个节点的子树中有多少已经加入的点，用 $siz[x]$ 表示。没有加入的节点对当前询问肯定没有贡献。所以我们直接统计加入的节点就好了</p>
<p>那么 $siz[1]=4$ , $siz[2]=2$,  $siz[3]=1$, $siz[4]=1$ ,  $siz[5]=1$ , $siz[6]=0$ .</p>
<p>现在考虑计算当前加入的节点到4的LCA深度和。</p>
<p>$ans=siz[4]\times dep[4]+(siz[2]-siz[4])\times dep[2]+(siz[1]-siz[2])\times dep[1]$</p>
<p>即加入的节点中在 $4$ 的子树中的到 $4$ 的 $LCA$ 肯定为 $4$。在 $2$ 的子树但不在 $4$ 的子树中的到 $4$ 的 $LCA$ 肯定为 $2$，在 $1$ 的子树但不在 $2$ 的子树中的到 $4$ 的 $LCA$ 肯定为 $1$。</p>
<p>把式子拆开化简得到:</p>
<p>$ans=siz[4]\times (dep[4]-dep[2])+siz[2]\times (dep[2]-dep[1])+siz[1]$</p>
<p>$ans=siz[4]+siz[2]+siz[1]$</p>
<p>于是我们发现其实答案就是该节点到根路径的节点子树大小之和。</p>
<p>普遍形式：设查询节点到根的路径为 $\{v_1,v_2,v_3\dots v_k\}$。</p>
<p>$ans=siz[v_1]\times dep[v_1]+(siz[v_2]-siz[v_1])\times dep[v_2]+(siz[v_3]-siz[v_2])\times dep[v_3]+\dots +(siz[v_k]-siz[v_{k-1}])\times dep[v_k]$</p>
<p>由于是到根节点的路径，所以 $dep[v_i]=dep[v_{i+1}]+1$</p>
<p>于是化简得</p>
<p>$ans=siz[v_1]\times (dep[v_1]-dep[v_2])+siz[v_2]\times (dep[v_2]-dep[v_3])+siz[v_3]\times (dep[v_3]-dep[v_4])+\dots +siz[v_k]\times dep[v_k]$</p>
<p>$ans=siz[v_1]+siz[v_2]+siz[v_3]+\dots +siz[v_k]$</p>
<p>就此得出结论：答案就是该节点到根路径的节点子树大小之和。</p>
<p>查询直接查询要查询的节点到根路径上的节点的子树大小之和。</p>
<p>加入节点时只有它到根的路径上的节点的子树大小加了一。</p>
<p>使用树链剖分加线段树维护即可。</p>
<hr>
<p><strong>回到本题</strong></p>
<p>本题没有 $l$ 的限制，所以我们不用前缀和拆询问处理了。</p>
<p>那么我们抬出之前的式子改成这道题的样子。</p>
<p>$ans=siz[v1]\times dep[v1]^k+(siz[v2]-siz[v1])\times dep[v2]^k+(siz[v3]-siz[v2])\times dep[v3]^k+\dots+(siz[vk]-siz[vk-1])\times dep[vk]^k$</p>
<p>化简一下，得到：</p>
<p>$ans=siz[v_1]\times (dep[v_1]^k-dep[v_2]^k)+siz[v_2]\times (dep[v_2]^k-dep[v_3]^k)+siz[v_3]\times (dep[v_3]^k-dep[v4]^k)+\dots  siz[v_k]\times dep[v_k]^k$</p>
<p>可以发现，$dep[v_2]$ 总等于 $dep[v_1]-1$（因为是从查询节点到根节点的路径嘛）。</p>
<p>所以对于$(dep[v_i]^k-dep[v_{i+1}]^k)$这种东西，我们可以对它进行预处理。</p>
<p>设对于点i的预处理答案为 $val[i]$。</p>
<p>则答案为:</p>
<p>$ans=siz[v_1]\times  val[v_1]+siz[v_2]\times  val[v_2]+siz[v_3]\times  val[v_3]+…siz[v_k]\times  val[v_k]$</p>
<p>就是在线段树维护时多加一个权值的问题了。</p>
<p>在线段树的每个节点上附加一个权值，表示这个区间里所有点的 $val$ 之和。</p>
<p>这样就可以区间修改和下传标记了。</p>
<p><del>跟上面那道弱化版差得不多吧</del>~</p>
<p>代码：</p>
<pre><code class="lang-cpp">//直接用LCA代码改的，可能有点迷惑（？ 
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;long long&gt; e[50010];
struct node
{
    long long bas,sum,tag;//bas为附加的权值
}nodes[400010];
struct ask
{
    long long pos,val,ID,nag;
}q[100010];
bool cmp(ask one,ask ano)
{
    return one.pos&lt;ano.pos;
}
long long n,m,s,opl,opr,opz,f,cnt,tot,waste,ans[50010],kkk,dep[50010],fa[50010],son[50010],siz[50010],hb[50010],dfn[50010],ton[50010],power[50010],bruh;
const long long mod=998244353;
long long qpow(long long bas,long long tim)//快速幂用来处理val 
{
    long long res=1,fur=bas;
    while(tim)
    {
        if(tim&amp;1)    res=(res*fur)%mod;
        fur=(fur*fur)%mod;
        tim&gt;&gt;=1;
    }
    return res;
}
void dfs(long long x,long long las)
{
    fa[x]=las;
    dep[x]=dep[las]+1;
    siz[x]=1;
    long long b=0,s=0;
    for(long long i=0;i&lt;e[x].size();++i)
    {
        long long y=e[x][i];
        dfs(y,x);
        siz[x]+=siz[y];
        if(siz[y]&gt;b)
        {
            b=siz[y];
            s=y;
        }
    }
    son[x]=s;
}
void dfs2(long long x,long long las,long long heavy)//树剖dfs
{
    if(heavy)    hb[x]=hb[las];
    else    hb[x]=x;
    dfn[x]=++cnt;
    ton[cnt]=x;
    if(son[x])    dfs2(son[x],x,1);
    for(long long i=0;i&lt;e[x].size();++i)
    {
        long long y=e[x][i];
        if(y^son[x])    dfs2(y,x,0);
    }
}
void pushdown(long long x)
{
    if(nodes[x].tag)
    {
        //(siz[x]+a)*val[x]+(siz[y]+a)*val[y]+...+(siz[z]+a)*val[z]
        //=siz[x]*val[x]+siz[y]*val[y]+...+siz[z]*val[z]+a*(val[x]+val[y]+...+val[z])
        nodes[x].sum+=(nodes[x].bas*nodes[x].tag);
        nodes[x].sum%=mod;
        nodes[x&lt;&lt;1].tag+=nodes[x].tag;
        nodes[x&lt;&lt;1].tag%=mod;
        nodes[x&lt;&lt;1|1].tag+=nodes[x].tag;
        nodes[x&lt;&lt;1|1].tag%=mod;
        nodes[x].tag=0;
    }
}
void build(long long l,long long r,long long x)//预处理val区间和 
{
    if(l^r)
    {
        long long mid=(l+r)&gt;&gt;1;
        build(l,mid,x&lt;&lt;1);
        build(mid+1,r,x&lt;&lt;1|1);
        nodes[x].bas=(nodes[x&lt;&lt;1].bas+nodes[x&lt;&lt;1|1].bas)%mod;
    }
    else    nodes[x].bas=power[dep[ton[l]]]-power[dep[ton[l]]-1];
//    printf(&quot; %lld %lld %lld\n&quot;,l,r,nodes[x].bas);
} 
void update(long long l,long long r,long long x,long long fr,long long ba)
{
    if(l&gt;ba||r&lt;fr)    return;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    nodes[x].tag=(nodes[x].tag+1)%mod;
    else
    {
        pushdown(x);
        long long mid=(l+r)&gt;&gt;1;
        update(l,mid,x&lt;&lt;1,fr,ba);
        update(mid+1,r,x&lt;&lt;1|1,fr,ba);
        pushdown(x&lt;&lt;1);
        pushdown(x&lt;&lt;1|1);
        nodes[x].sum=(nodes[x&lt;&lt;1].sum+nodes[x&lt;&lt;1|1].sum)%mod;
    }
}
long long find(long long l,long long r,long long x,long long fr,long long ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    pushdown(x);
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[x].sum;
    else
    {
        long long mid=(l+r)&gt;&gt;1;
        return (find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,x&lt;&lt;1|1,fr,ba))%mod;
    }
}
void output(long long l,long long r,long long x)
{
    pushdown(x);
    printf(&quot; %lld %lld %lld\n&quot;,l,r,nodes[x].sum);
    if(l^r)
    {
        long long mid=(l+r)&gt;&gt;1;
        output(l,mid,x&lt;&lt;1);
        output(mid+1,r,x&lt;&lt;1|1);
    }
}
void update_LCA(long long x,long long y)
{
    long long fx=hb[x],fy=hb[y];
    while(fx^fy)
    {
        if(dep[fx]&lt;dep[fy])
        {
            swap(fx,fy);
            swap(x,y);
        }
        update(1,s,1,dfn[fx],dfn[x]);
        x=fa[fx];
        fx=hb[x];
    }
    update(1,s,1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));
}
long long find_LCA(long long x,long long y)
{
    long long res=0;
    long long fx=hb[x],fy=hb[y];
    while(fx^fy)
    {
        if(dep[fx]&lt;dep[fy])
        {
            swap(fx,fy);
            swap(x,y);
        }
        res+=find(1,s,1,dfn[fx],dfn[x]);
        res%=mod;
        x=fa[fx];
        fx=hb[x];
    }
    res+=find(1,s,1,min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));
    res%=mod;
    return res;
}
int main()
{
    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;bruh);
    s=n;
    for(long long i=1;i&lt;=n;++i)    power[i]=qpow(i,bruh);
    for(long long i=2;i&lt;=n;++i)
    {
        scanf(&quot;%lld&quot;,&amp;f);
        e[f].push_back(i);
    }
    dfs(1,1);
    dfs2(1,1,0);
    build(1,s,1);
    for(long long i=1;i&lt;=m;++i)
    {
        scanf(&quot;%lld %lld&quot;,&amp;opr,&amp;opz);
        q[++tot].ID=i;
        q[tot].nag=1;
        q[tot].pos=opr;
        q[tot].val=opz;
    }
    sort(q+1,q+1+tot,cmp);
    while(q[kkk].pos&lt;=0&amp;&amp;kkk&lt;=tot)
    {
        ans[q[kkk].ID]+=(q[kkk].nag*0);
        ++kkk;
    }
    for(long long i=1;i&lt;=n;++i)
    {
        update_LCA(1,i);
        while(q[kkk].pos&lt;=i&amp;&amp;kkk&lt;=tot)
        {
            ans[q[kkk].ID]+=(q[kkk].nag*find_LCA(1,q[kkk].val));
            ans[q[kkk].ID]%=mod;
            ++kkk;
        }
//        puts(&quot;&quot;);
//        output(1,s,1);
//        puts(&quot;\n&quot;);
    }
    for(long long i=1;i&lt;=m;++i)    printf(&quot;%lld\n&quot;,((ans[i]%mod)+mod)%mod);
    return 0;
}
</code></pre>

          
            <hr>
            <center><img class="lazyload" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/ctz45562/cdn@1.7.9/lazyload.gif" data-src="https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.0.3/emojis/gif/23.gif"></center>
            <p style="font-size:32px;text-align:center;margin-top:-2px">施工中...</p>
                        
        </div>
        <!-- .entry-content -->
        <!-- <div class="single-reward">
          <div class="reward-open">赏
            <div class="reward-main">
              <ul class="reward-row">
                <li class="alipay-code"><img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/img/custom/donate/AliPayQR.jpg"></li>
                <li class="wechat-code"><img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/img/custom/donate/WeChanQR.jpg"></li>
              </ul>
            </div>
          </div>
        </div>
        <div style="text-align:center; width: 100%" class="social-share share-mobile" data-disabled="diandian, tencent"></div>
        <footer class="post-footer">
          <div class="post-lincenses"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="nofollow"><i class="fa fa-creative-commons" aria-hidden="true"></i> 知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a></div>
          <div class="post-tags">
          </div>
          <div class="post-share">
            <div class="social-share sharehidden share-component"></div>
            <i class="iconfont show-share icon-forward"></i>
          </div>
        </footer>. -->
        <!-- entry-footer -->
      </article>
      <!-- #post-## -->
      <div class="toc" style="background: none;"></div>
      <section class="post-squares nextprev">
        
          
            <div class="post-nepre half previous">
          
            <a href="/2020/02/08/DS100P-61-70-P/" rel="prev">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-37.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-37.png">
              </div>
              <span class="label">
              Previous Post</span>
              <div class="info">
                <h3>
                数据结构100题 61~70题</h3>
              </div>
            </a>
          </div>
        
        
          
            <div class="post-nepre half next">
          
            <a href="/2020/02/08/DS100P-41-50-P/" rel="next">
              <div class="background">
                <img class="lazyload" src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/loader/orange.progress-bar-stripe-loader.svg" data-src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-35.png" style="width: 100%; height: 100%; object-fit: cover; pointer-events: none;" onerror="imgError(this,3)" src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-35.png">
              </div>
              <span class="label">
              Next Post</span>
              <div class="info">
                <h3>
                数据结构100题 41~50题</h3>
              </div>
            </a>
          </div>
        
      </section>
      
<div id="vcomments"></div>
<script>
  window.onload = function(){
      var valine = new Valine();
      valine.init({
        el: '#vcomments',
        appId: "8Hho6gvnedMT9NMEhnEx3UOg-gzGzoHsz",
        appKey: "gU70zYoblzxCmc6iL697pp69",
        path: window.location.pathname,
        placeholder: "Come And Get Your Love~"
      })
  }
</script>

      <section class="author-profile">
        <div class="info" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <a href="/" class="profile gravatar"><img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/icons/avatar.png" itemprop="image" alt="BoringHacker" height="70" width="70"></a>
          <div class="meta">
            <span class="title">Author</span>
            <h3 itemprop="name">
            <a href="/" itemprop="url" rel="author">BoringHacker</a>
            </h3>
          </div>
        </div>
        <hr>
        <p><i class="iconfont icon-write"></i>不会打DS的OIER不是萌妹子！</p>
      </section>
    </main><!-- #main -->
  </div><!-- #primary -->
</div>

<script>
  var spoiler=document.getElementsByClassName('spoiler');
  for(var i=0;i<spoiler.length;++i)
  spoiler[i].onclick=function(){this.classList.toggle("revealed");};
  </script>  


  <script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/latest.js?config=TeX-MML-AM_CHTML"></script>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
  </script>

    </div>    
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="请输入关键词..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            // PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
    <!-- <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 BoringHacker<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer> -->
<footer id="colophon" class="site-footer" role="contentinfo">
  <div class="site-info">
    <div class="footertext">
      <div class="img-preload">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/wordpress-rotating-ball-o.svg">
        <img src="https://cdn.jsdelivr.net/gh/honjun/cdn@1.6/img/other/disqus-preloader.svg">
      </div>
      <p style="color: #666666;">&copy 2018</p>
    </div>
    <div class="footer-device">
    <p style="font-family: 'Ubuntu', sans-serif;">
        <span style="color: #b9b9b9;">Theme <a href="https://github.com/honjun/hexo-theme-sakura" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Sakura</a> <i class="iconfont icon-sakura rotating" style="color: #ffc0cb;display:inline-block"></i> by <a href="https://2heng.xin/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Mashiro</a>&<a href="https://www.hojun.cn/" target="_blank" style="color: #b9b9b9;;text-decoration: underline dotted rgba(0, 0, 0, .1);">Hojun</a>, Powered by Hexo, Hosted by Coding Pages</a>
        </span>
      </p>
    </div>
  </div><!-- .site-info -->
</footer>

<!-- <script src="/js/tocbot.js"></script> -->
<script type="text/javascript" src="/js/lib.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script type="text/javascript" src="/js/InsightSearch.js"></script>
<script type="text/javascript" src="/js/jquery.fancybox.min.js"></script>
<script type="text/javascript" src="/js/zoom.min.js"></script>
<script type="text/javascript" src="/js/sakura-app.js"></script>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<!-- <script src='//unpkg.com/valine@1.3.4/dist/Valine.min.js'></script> -->
<script src="https://cdn.jsdelivr.net/gh/ctz45562/cdn@2.0.2/js/volantis.min.js"></script>
<script src="/js/botui.js"></script>
<!-- 不蒜子 网页计数器 -->
<script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script> -->
<script type="text/javascript">
/* <![CDATA[ */
if (/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"close"},"windowheight":"fixed","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
} else {
  var Poi = {"pjax":"1","movies":{"url": "https://cdn.jsdelivr.net/gh/honjun/hojun@1.2","name":"Unbroken.mp4","live":"open"},"windowheight":"auto","codelamp":"close","ajaxurl":"","order":"asc","formpostion":"bottom"};
}
/* ]]> */

</script>
<script>
$(document).ready(function() {
  if ($(".toc").length > 0 && document.body.clientWidth > 1200) {
    if ($(".pattern-center").length > 0) { //有图的情况
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -400,
          scrollSmoothOffset: -85
      });
    } else {
      tocbot.init({
          // Where to render the table of contents.
          tocSelector: '.toc', // 放置目录的容器
          // Where to grab the headings to build the table of contents.
          contentSelector: '.entry-content', // 正文内容所在
          // Which headings to grab inside of the contentSelector element.
          scrollSmooth: true,
          headingSelector: 'h1, h2, h3, h4, h5', // 需要索引的标题级别
          headingsOffset: -85,
          scrollSmoothOffset: -85
      });
    }
    var offsetTop = $('.toc').offset().top - 95;
    window.onscroll = function() {
      var scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      if (scrollTop >= offsetTop) {
        $('.toc').addClass('toc-fixed');
      } else {
        $('.toc').removeClass('toc-fixed');
      }
    }
  }
});
</script>

    <div class="openNav no-select" style="height: 50px;">
      <div class="iconflat no-select" style="width: 50px; height: 50px;">
        <div class="icon"></div>
      </div>
      <div class="site-branding search-form-submit">
        <i class="iconfont js-toggle-search iconsearch icon-search"></i>
      </div>
    </div>
  </section>
  <!-- <div id="mo-nav" class="">
  <div class="m-avatar">
    <img src="https://cdn.jsdelivr.net/gh/BoringHacker/cdn/images/icons/avatar.png">
  </div>
  <p style="text-align: center; color: #333; font-weight: 900; font-family: 'Ubuntu', sans-serif; letter-spacing: 1.5px">BoringHacker'sBlog</p>
  <p style="text-align: center; word-spacing: 20px;">
    
      
        <a href="http://github.com/honjun" class="fa fa-github" target="_blank" style="color: #333; margin-left:20px"></a>
      
        <a href="http://weibo.com/mashirozx?is_all=1" class="fa fa-weibo" target="_blank" style="color: #dd4b39; margin-left:20px"></a>
      
        <a href="https://wpa.qq.com/msgrd?v=3&uin=954655431&site=qq&menu=yes" class="fa fa-qq" target="_blank" style="color: #25c6fe; margin-left:20px"></a>
      
    
  </p>
  <ul id="menu-new-1" class="menu">
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-fort-awesome faa-shake" aria-hidden="true"></i>
            Home
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/archives">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-archive faa-shake" aria-hidden="true"></i>
            Archives
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/Tools/">
                  <i class="fa fa-cogs" aria-hidden="true"></i>
                  Tools
                </a>
              </li>
            
              <li>
                <a href="/categories/Note/">
                  <i class="fa fa-book" aria-hidden="true"></i>
                  Notes
                </a>
              </li>
            
              <li>
                <a href="/categories/Solution">
                  <i class="fa fa-code" aria-hidden="true"></i>
                  Solution
                </a>
              </li>
            
              <li>
                <a href="/categories/Others">
                  <i class="fa fa-sellsy" aria-hidden="true"></i>
                  Others
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/tags/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-tags" aria-hidden="true"></i>
            Tags
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/comment/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-pencil-square-o faa-tada" aria-hidden="true"></i>
            Comments
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/links/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-link faa-shake" aria-hidden="true"></i>
            Links
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/game/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-gamepad" aria-hidden="true"></i>
            Game
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/pandownload/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-gamepad" aria-hidden="true"></i>
            PanDown
          </span>
        </a>
        
      </li>
    
      <li>
        <a href="/">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-leaf faa-wrench" aria-hidden="true"></i>
            About
          </span>
        </a>
        
          <ul class="sub-menu">
            
              <li>
                <a href="/about/">
                  <i class="fa fa-meetup" aria-hidden="true"></i>
                  Me
                </a>
              </li>
            
              <li>
                <a href="/lab/">
                  <i class="fa fa-bath" aria-hidden="true"></i>
                  Blog
                </a>
              </li>
            
          </ul>
        
      </li>
    
      <li>
        <a href="/atom.xml">
          <span class="faa-parent animated-hover">
            <i class="fa  fa-rss faa-pulse" aria-hidden="true"></i>
            RSS
          </span>
        </a>
        
      </li>
    
  </ul>
  <p style="text-align: center; font-size: 13px; color: #b9b9b9;">&copy 2019 hexo-sakura</p>
</div>
<button onclick="topFunction()" class="mobile-cd-top" id="moblieGoTop" title="Go to top" style="display: none;"><i class="fa fa-chevron-up" aria-hidden="true"></i></button>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
<script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
<!-- require MetingJS -->
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
<style>
  .aplayer .aplayer-lrc {
    height: 35px;
  }
  .aplayer .aplayer-lrc p{
    font-size: 16px;
    font-weight: 700;
    line-height: 18px !important;
  }
  .aplayer .aplayer-lrc p.aplayer-lrc-current{
    color: #FF1493;
  }
  .aplayer.aplayer-narrow .aplayer-body{
    left: -66px !important;
  }
  .aplayer.aplayer-fixed .aplayer-lrc {
    display: none;
  }
  .aplayer .aplayer-lrc.aplayer-lrc-hide {
      display:none !important;
  }
  .aplayer.aplayer-fixed .lrc-show {
    display: block;
    background: rgba(255, 255, 255, 0.8);
  }
</style>
<meting-js

    id="2660651585"

    server="netease"

    type="playlist"

    fixed="true"

    autoplay="false"

    loop="all"

    order="random"

    preload="auto"

    volume="0.7"

    mutex="true"

</meting-js>
<script>
  $(function(){
    $('body').on('click', '.aplayer', function(){
      if($('.aplayer-button').hasClass('aplayer-play')) {
        $('.aplayer-lrc').removeClass('lrc-show');
      } else {
        $('.aplayer-lrc').addClass('lrc-show');
      }
    })
  });
</script> -->
</body>
</html>