{"meta":{"title":"BoringHacker's Blog","subtitle":"Stay Hungry, Stay Foolish","description":null,"author":"BoringHacker","url":"www.orchid-any.cf"},"pages":[{"title":"Comments","date":"2020-01-17T07:04:09.000Z","updated":"2020-01-17T07:05:20.286Z","comments":true,"path":"Comments/index.html","permalink":"www.orchid-any.cf/Comments/index.html","excerpt":"","text":"éšä¾¿è¯´ç‚¹ä»€ä¹ˆå§(è®°å¾—æ”¹æ˜µç§°)233â€¦"},{"title":"Tools","date":"2020-02-15T09:56:00.000Z","updated":"2020-02-20T03:54:56.314Z","comments":true,"path":"Tools/index.html","permalink":"www.orchid-any.cf/Tools/index.html","excerpt":"","text":"For ljes(æ»‘ç¨½)å‡½æ•°æ±‚å¯¼å·¥å…· å‡½æ•°è¾“å…¥æ¡†: è‡ªå˜é‡: é˜¶æ•°: 0 1 2 3 4 5 6 7 8 9 10 ä¸å®šç§¯åˆ†è®¡ç®—å™¨ è¯·è¾“å…¥ä½ éœ€è¦ç§¯åˆ†çš„å‡½æ•°è¡¨è¾¾å¼: è‡ªå˜é‡: å®šç§¯åˆ†è®¡ç®—å™¨ è¯·è¾“å…¥ä½ éœ€è¦ç§¯åˆ†çš„å‡½æ•°è¡¨è¾¾å¼: è‡ªå˜é‡: ä»: åˆ°: æé™è®¡ç®—å™¨ è¯·è¾“å…¥ä¸€ä¸ªå‡½æ•°å¹¶è®¡ç®—æé™: æé™å˜é‡: xè¶‹å‘äº: æé™ç±»å‹ åŒä¾§æé™ å³ä¾§æé™ å·¦ä¾§æé™ å‡½æ•°å›¾åƒç»˜åˆ¶å·¥å…·å‡½æ•°è¾“å…¥æ¡†: X åæ ‡, ä»: åˆ°: Y åæ ‡, ä»: åˆ°: åˆ†æ•°è®¡ç®—å™¨ è¾“å…¥ä¸€ä¸ªåˆ†æ•°è¡¨è¾¾å¼: æ–¹ç¨‹æ±‚è§£ è¾“å…¥é€—å·ä»¥åˆ†éš”å¤šä¸ªæ–¹ç¨‹: è¡¨è¾¾å¼åŒ–ç®€ è¾“å…¥ä¸€ä¸ªè¡¨è¾¾å¼æ¥ç®€åŒ–: å› å¼åˆ†è§£å·¥å…· è¯·è¾“å…¥æ‚¨éœ€è¦åˆ†è§£å› å¼çš„è¡¨è¾¾å¼ï¼š: é˜¶ä¹˜è®¡ç®—å™¨ è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ç»„åˆæ•°è®¡ç®—å™¨ ç»„åˆæ•°è®¡ç®—æ–¹æ³•ï¼Œä»Né¡¹ä¸­é€‰å‡ºMé¡¹. æ˜¯å¦å…·æœ‰é¡ºåº? æ˜¯ å¦ å…ƒç´ æ˜¯å¦å¯ä»¥é€‰æ‹©ä¸€æ¬¡ä»¥ä¸Š? æ˜¯ å¦ N = M = åå‡½æ•°è®¡ç®—å™¨ è¾“å…¥å‡½æ•°æ¥è®¡ç®—å…¶åå‡½æ•°: è¡¨è¾¾å¼è®¡ç®—å™¨ è¾“å…¥è¦è®¡ç®—çš„è¡¨è¾¾å¼: è´¨æ•°å‘ç”Ÿå™¨å’Œæ ¡éªŒå™¨ è¾“å…¥ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œå¹¶é€‰æ‹©ç›¸åº”çš„åŠŸèƒ½: æ£€éªŒæ˜¯å¦ä¸ºè´¨æ•° ä¸‹ä¸€ä¸ªè´¨æ•° ä¸Šä¸€ä¸ªè´¨æ•° æ•´æ•°åˆ†è§£å·¥å…· è¯·è¾“å…¥æ‚¨éœ€è¦åˆ†è§£çš„æ•´æ•°: æ–æ³¢é‚£å¥‘æ•°è®¡ç®—å·¥å…· è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ä¼¯åŠªåˆ©æ•°å‘ç”Ÿå™¨ è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: æ¬§æ‹‰æ•°è®¡ç®—å·¥å…· è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ç»Ÿè®¡è®¡ç®—å™¨ è¾“å…¥ä¸€ä¸ªç©ºæ ¼ï¼Œé€—å·æˆ–æ–°è¡Œåˆ†éš”çš„æ•°å­—: å¹³å‡æ•° ä¸­ä½æ•° è°ƒå’Œå¹³å‡æ•° å‡ ä½•å¹³å‡æ•° æœ€å° æœ€å¤§ èŒƒå›´ æ–¹å·® æ›´æ­£æ–¹å·® æ ‡å‡†åå·® æ›´æ­£çš„æ ‡å‡†åå·® å˜å¼‚ç³»æ•° å¹³å‡åå·® ä¸­ä½æ•°åå·® ååº¦ çŸ©é˜µè®¡ç®—å™¨ è¾“å…¥çŸ©é˜µ A: çŸ©é˜µçš„è¡Œåˆ—å¼ è½¬ç½®çŸ©é˜µ çŸ©é˜µè¿¹ çŸ©é˜µçš„ç§© é€†çŸ©é˜µ ç‰¹å¾å€¼ ä¸‹ä¸‰è§’çŸ©é˜µ A2 çŸ©é˜µè¿ç®— è¾“å…¥çŸ©é˜µ A:è¾“å…¥çŸ©é˜µ B: åŠ æ³• å‡æ³• ä¹˜æ³•","keywords":null},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-04-02T02:02:21.804Z","comments":false,"path":"about/index.html","permalink":"www.orchid-any.cf/about/index.html","excerpt":"","text":"BoringHacker ä¸&nbsp; BoringHacker&nbsp; ï¼ˆ BoringHacker ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":"å…³äº"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"www.orchid-any.cf/client/index.html","excerpt":"","text":"ç›´æ¥ä¸‹è½½ or æ‰«ç ä¸‹è½½ï¼š","keywords":"Androidå®¢æˆ·ç«¯"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"donate/index.html","permalink":"www.orchid-any.cf/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"Game","date":"2020-02-05T11:21:36.000Z","updated":"2020-02-20T03:54:56.306Z","comments":false,"path":"game/index.html","permalink":"www.orchid-any.cf/game/index.html","excerpt":"","text":"ä»ctzé‚£é‡Œå‰½æ¥çš„ä¸œè¥¿ 2048 flappy bird äº”å­æ£‹ ç”Ÿç«é—´ æ°´æœå¿è€…","keywords":null},{"title":"Blog","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-08T10:34:13.512Z","comments":false,"path":"lab/index.html","permalink":"www.orchid-any.cf/lab/index.html","excerpt":"","text":"å’•å’•å’•ã€‚ã€‚ã€‚","keywords":"åšå®¢æ˜¯æ€æ ·è¯ç”Ÿçš„"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-03-13T02:12:59.937Z","comments":true,"path":"links/index.html","permalink":"www.orchid-any.cf/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"www.orchid-any.cf/music/index.html","excerpt":"","text":"","keywords":"å–œæ¬¢çš„éŸ³ä¹"},{"title":"pandownload","date":"2020-04-18T13:03:07.000Z","updated":"2020-04-18T13:03:07.085Z","comments":false,"path":"pandownload/index.html","permalink":"www.orchid-any.cf/pandownload/index.html","excerpt":"","text":"","keywords":null},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"www.orchid-any.cf/rss/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-05T10:46:24.855Z","comments":true,"path":"comment/index.html","permalink":"www.orchid-any.cf/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯ äººæ¸£çš„æœ¬æ„¿ï¼Œè‹è”çš„è§£ä½“ã€‚ ã€ç°ä»£ã€‘noipæ¯’ç˜¤ã€Šæ´›è°·Â·ä¸ªäººä¸»é¡µã€‹","keywords":"ç•™è¨€æ¿"},{"title":"Animes","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-20T03:54:56.300Z","comments":false,"path":"bangumi/index.html","permalink":"www.orchid-any.cf/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"www.orchid-any.cf/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜Sakuraï¼Œæ„Ÿè°¢åŸä½œè€…Mashiro","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"tags","date":"2020-02-08T06:03:27.000Z","updated":"2020-03-03T05:28:27.790Z","comments":true,"path":"tags/index.html","permalink":"www.orchid-any.cf/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"www.orchid-any.cf/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} ç•ªç»„è®¡åˆ’ è¿™é‡Œå°†æ˜¯æ°¸è¿œçš„å›å¿† window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"ã€Œæ‚é¡¹ã€å…³äºè¿™ä¸ªç½‘ç«™","slug":"OTHE-ABOUT-THIS-WEBSITE","date":"2020-03-28T06:16:51.000Z","updated":"2020-04-12T05:59:21.557Z","comments":true,"path":"2020/03/28/OTHE-ABOUT-THIS-WEBSITE/","link":"","permalink":"www.orchid-any.cf/2020/03/28/OTHE-ABOUT-THIS-WEBSITE/","excerpt":"","text":"è¿™é‡Œæ˜¯æˆ‘çš„å°ç«™ï¼Œæˆ‘æ˜¯BoringHackerï¼ˆç°åœ¨å–œæ¬¢ä¸Šäº†AtarashiHitomiè¿™ä¸ªIDï¼‰ï¼ˆä¸ï¼Œæ˜¯AtarashiNyarukoï¼‰ã€‚ è¿™é‡Œæ˜¯æˆ‘å†™å†™ç®—æ³•å­¦ä¹ ç¬”è®°ï¼Œæ”¾æ”¾é¢˜è§£çš„åœ°æ–¹ã€‚ è¿˜æœ‰ä¸€äº›æ—¥å¸¸ç³»çš„éšç¬”ã€‚ æ—¢ç„¶éƒ½æ¥äº†ä¸å¦‚å»è¯„è®ºåŒºè¯´å‡ å¥è¯ï¼Œå˜²è®½ï¼Œåæ§½éƒ½å¯ä»¥å‘€ã€‚ å¦‚æœä½ æƒ³åŠ å‹é“¾çš„è¯ï¼Œè¿™é‡Œè¯·ï¼ˆ","categories":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}],"tags":[],"keywords":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}]},{"title":"ã€Œç¬”è®°ã€å¿«é€Ÿæ•°è®ºå˜æ¢","slug":"NOTE-FAST-NUMBER-THEORY-TRANSFORM","date":"2020-03-26T00:48:45.000Z","updated":"2020-04-13T23:59:18.819Z","comments":true,"path":"2020/03/26/NOTE-FAST-NUMBER-THEORY-TRANSFORM/","link":"","permalink":"www.orchid-any.cf/2020/03/26/NOTE-FAST-NUMBER-THEORY-TRANSFORM/","excerpt":"","text":"0x00 å‰è¨€å­¦äº†FFTå°±æƒ³å­¦NTTï¼ˆæ‚è„¸ 0x01 åŸæ ¹é˜¶è®¾ä¸¤æ•° $r,n\\in \\mathbb{Z},r\\neq 0,n&gt;0,(r,n)=1$ ä½¿å¾— $r^{x}\\equiv 1(\\operatorname{mod} n)$ æˆç«‹çš„æœ€å°æ­£æ•´æ•° $x$ å³ä¸º $r$ æ¨¡ $n$ çš„é˜¶ã€‚ è®°ä½œ $\\operatorname{ord}_{n}r$ æ¯”å¦‚è¯´æˆ‘ä»¬è¦è®¡ç®— $\\operatorname{ord}_{n}r$ é‚£ä¹ˆ 3^{1}=3(\\operatorname{mod}10)3^{2}=1(\\operatorname{mod}10)æ‰€ä»¥ $\\operatorname{ord}_{n}r=2$ åŸæ ¹åŸæ ¹çš„å®šä¹‰æ˜¯å½“ $(r,n)=1$ æ—¶ï¼Œ$\\operatorname{ord}_{n}r=\\varphi(n)$ï¼Œåˆ™ç§° $r$ æ˜¯æ¨¡ $n$ çš„åŸæ ¹ã€‚ å…¶ä¸­ $\\varphi$ æ˜¯æ•°è®ºçš„æ¬§æ‹‰å‡½æ•°ã€‚ å…¶å®åŸæ ¹è¿˜æœ‰ä¸€ç§å®šä¹‰ã€‚ å¯¹äº $g,p\\in \\mathbb{Z}$ï¼Œå¦‚æœ $\\forall i,j(1\\leq i&lt;j\\leq p-1),g^{i}\\operatorname{mod}p\\neq g^{j}\\operatorname{mod}p$ åˆ™ç§° $g$ æ˜¯æ¨¡ $p$ çš„åŸæ ¹ã€‚ å…¶å®å·®qiuä¸å¤š å¥½äº†åŸæ ¹æ²¡äº†ï¼ˆï¼ˆ NTTçš„æ¨¡æ•°é€šå¸¸æ¥è¯´åªèƒ½æ˜¯988244353ã€‚ ä¸ºä»€ä¹ˆä¸èƒ½æ˜¯æŸé•¿è€…ç”Ÿæ—¥ é¡ºå¸¦ä¸€æLFçš„OJç™»å½•é‚®ç®±lifanåé¢çš„ä¸€ä¸²æ•°å­—æ˜¯ä¸ªè´¨æ•° 0x02 ä»FFTåˆ°NTTå…¶å®NTTå°±æ˜¯æŠŠFFTçš„å•ä½æ ¹æ¢æˆäº†åŸæ ¹ã€‚ ä½ æƒ³å•Šï¼ŒFFTæ¯æ¬¡è®¡ç®—éƒ½è¦ç”¨ä¸‰è§’å‡½æ•°ï¼Œå¸¸æ•°++ã€‚ ç„¶åå¤æ•°è¿ç®—ï¼Œå¸¸æ•°++ï¼Œç²¾åº¦â€”ç„¶åä¸èƒ½å–æ¨¡ã€‚ æ‰€ä»¥åŸæ ¹å°±å¥½å¤šäº†å¯¹å§ã€‚ æ•´æ•°è¿ç®—ï¼Œç²¾åº¦ä¸å˜ï¼Œå¸¸æ•°è¾ƒå°ç„¶åå¯ä»¥å–æ¨¡ã€‚ ä¸ç”¨ä¸‰è§’å‡½æ•°ï¼Œå¸¸æ•°è¾ƒå°ã€‚ ä½†æ˜¯å–æ¨¡ä¸€èˆ¬åªèƒ½å–998244353ï¼Œæ­¤æ—¶çš„åŸæ ¹ä¸º3ã€‚åˆ«é—®ï¼Œé—®å°±æ˜¯æš´ç®—ã€‚ å…·ä½“æ¥è¯´ï¼Œæ¯”å¦‚å½“åŒºé—´ä¸­ç‚¹ä¸º $mid$ï¼Œé•¿åº¦ä¸º $len=mid\\times 2$ æ—¶ï¼Œæˆ‘ä»¬çš„å•ä½æ ¹æ˜¯ $\\cos\\frac{\\pi}{mid}+i\\sin\\frac{\\pi}{mid}$ã€‚æ­¤æ—¶åŸæ ¹å°±æ˜¯ $g^{\\frac{p-1}{2\\times mid}}$ã€‚ é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œæˆ‘ä»¬ä¸ºä»€ä¹ˆèƒ½ç”¨åŸæ ¹ä»£æ›¿å•ä½æ ¹å‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯å› ä¸ºè¯æ˜DFTå’ŒIDFTè¿‡ç¨‹ä¸­ç”¨åˆ°çš„å•ä½æ ¹æ€§è´¨åŸæ ¹åŒæ ·æ»¡è¶³ã€‚å¤§å®¶å¯ä»¥è‡ªå·±å»è¯ä¸€ä¸‹ï¼Œè¿˜æ˜¯æ¯”è¾ƒeasyçš„ã€‚ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int MAXN = 5000000 + 5; const int MOD = 998244353; int n, m, a[MAXN], b[MAXN], rev[MAXN &lt;&lt; 2]; int fast_pow(int x, int y) { long long res = 1; long long base = (long long)x; for (; y; y &gt;&gt;= 1, base = (base * base) % MOD) res = ((!(y &amp; 1)) * res) + ((y &amp; 1) * (res * base) % MOD); return (int)res % MOD; } void get_rev() { int lim = 0; while ((1 &lt;&lt; lim) &lt; n) lim++; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lim - 1)); } void ntt(int *f, int inv) { get_rev(); for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(f[i], f[rev[i]]); for (int mid = 1; mid &lt; n; mid &lt;&lt;= 1) { int baseform, t = fast_pow(3, (MOD - 1) / (mid &lt;&lt; 1)); if (~inv) baseform = t; else baseform = fast_pow(t, MOD - 2); for (int i = 0; i &lt; n; i += (mid &lt;&lt; 1)) { int omega = 1; for (int j = 0; j &lt; mid; ++j) { int first = f[i + j]; int second = 1ll * omega * f[i + j + mid] % MOD; f[i + j] = ((first + second) % MOD + MOD) % MOD; f[i + j + mid] = ((first - second) % MOD + MOD) % MOD; omega = 1ll * omega * baseform % MOD; } } } } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 0; i &lt;= m; ++i) scanf(&quot;%d&quot;, &amp;b[i]); for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1) ; ntt(a, 1); ntt(b, 1); for (int i = 0; i &lt; n; ++i) a[i] = (1ll * a[i] * b[i]) % MOD; ntt(a, -1); for (int i = 0; i &lt;= m; ++i) printf(&quot;%lld &quot;, 1ll * a[i] * fast_pow(n, MOD - 2) % MOD); return 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"www.orchid-any.cf/tags/æ•°å­¦/"},{"name":"NTT","slug":"NTT","permalink":"www.orchid-any.cf/tags/NTT/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"ã€Œç¬”è®°ã€å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","slug":"NOTE-FAST-FOURIER-TRANSFORM","date":"2020-03-21T09:37:58.000Z","updated":"2020-04-13T23:43:53.657Z","comments":true,"path":"2020/03/21/NOTE-FAST-FOURIER-TRANSFORM/","link":"","permalink":"www.orchid-any.cf/2020/03/21/NOTE-FAST-FOURIER-TRANSFORM/","excerpt":"","text":"0x00 å‰è¨€è¿™ç¯‡ä¸»è¦æ˜¯é’ˆå¯¹æœ‰åŸºç¡€çš„åŒå­¦çš„ï¼ŒåŸºç¡€çŸ¥è¯†ç›¸ä¿¡å¤§å®¶éƒ½å­¦è¿‡ã€‚ è¿™ç¯‡blogçš„è¯ç”Ÿæ˜¯å› ä¸ºmyhè¦å­¦FFTï¼Œç”šè‡³ç–¯ç‹‚åˆ°äº†è¦æ‰¾åˆ«äººè¯­éŸ³è§£ç­”çš„åœ°æ­¥ã€‚ ç„¶åæˆ‘å°±æƒ³èµ·è¿œå¤æ—¶å€™WGYå¥½åƒå­¦è¿‡è¿™ä¹ˆä¸ªä¸œè¥¿ï¼Œå°±å†™äº†ç¯‡blogå‡ºæ¥ç»™myhå„ä½çœ‹ï¼Œé¡ºä¾¿å¤ä¹ ä¸€ä¸‹ã€‚ è¯´ä¸€ä¸‹å­¦äº†è¿™ä¸œè¥¿çš„æ„Ÿæ‚Ÿå§ã€‚æˆ‘è§‰å¾—åªè¦å­¦äº†ä¸€æ¬¡å‡½æ•°å’Œä¸‰è§’å‡½æ•°å°±èƒ½çœ‹æ‡‚è¿™ç¯‡ã€‚ åœ¨é‚£ä¸ªè¿œå¤æ—¶ä»£ï¼Œå‘¨xå¥è¿˜æ²¡è®²ä¸€æ¬¡å‡½æ•°ï¼Œæˆ‘å¤©å¤©æŠ±ç€å•ƒæ²¡å•ƒæ‡‚â€¦â€¦ åæ¥ï¼Œå‘¨xå¥è®²äº†ä¸€æ¬¡å‡½æ•°ï¼Œæˆ‘åˆåœ¨ç‰©ç«é‚£å«–äº†äº›ä¸‰è§’å‡½æ•°ã€‚ ç„¶åæ•´ä¸ªäººå¿ƒæ€éƒ½å˜äº†ï¼Œå‡ ä¸ªå°æ—¶ä¸‹æ¥æ„Ÿè§‰FFTä¹Ÿå°±é‚£æ ·ã€‚ï¼ˆç”šè‡³ä¸å¦‚NTTæœ‰ç”¨ æ‰€ä»¥å¤§å®¶ä¸è¦ç•éš¾ï¼Œåœ¨åº§å„ä½çš„æ•°å­¦éƒ½æœæ–­åŠæ‰“WGYå¯¹å§ã€‚ æç°ä¹‹å‰ä¹Ÿåœ¨OJå‘è¿‡FFTçš„noteï¼Œä½†æ˜¯é€’å½’è½¬å¾ªç¯åŸºæœ¬å°±æ˜¯æ”¾äº†ä¸ªä»£ç ï¼Œè¿˜ç•™ä¸‹äº†ä¸å°‘å‘ã€‚ æˆ‘è¿™é‡Œä¹Ÿå¡«äº†ä¸å°‘æç°çš„å‘ï¼Œä½†æ˜¯ä¸€äº›åŸºç¡€çš„å•ä½æ ¹æ€§è´¨çš„è¯æ˜ä¹‹ç±»çš„ä¸œè¥¿æˆ‘è¿™é‡Œå°±æ‡’å¾—ç»™äº†ï¼Œè‡ªå·±è€ƒæç°çš„å¤å§ã€‚ å› ä¸ºæ—¶é—´åŸå› ä¸€äº›å¯ä»¥ä»å‡ ä½•æ„ä¹‰ä¸Šæ¥ç†è§£çš„ä¸œè¥¿æˆ‘æ²¡ç»™å›¾ï¼Œå¤§å®¶å¯ä»¥è‡ªå·±æ‰‹%ä¸€ä¸‹ã€‚ (å¥½ç½¢ä¸»è¦æ˜¯ç»™myhçœ‹çš„æ‰‹åŠ¨@ybmyh) 0x01 ç‚¹å€¼è¡¨ç¤ºæ³•ä¼—æ‰€å‘¨çŸ¥ï¼Œä¸€ä¸ª F(x)=\\sum_{i=0}^{n}a_{i}\\times x^{i}å½¢å¼çš„ $n$ æ¬¡å¤šé¡¹å¼å¯ä»¥åœ¨å¹³é¢ç›´è§’åæ ‡ç³»ä¸­è¢« $n+1$ ä¸ªç‚¹å”¯ä¸€çš„è¡¨ç¤ºå‡ºæ¥ã€‚ ç‚¹å€¼è¡¨ç¤ºçš„ä¸¤ä¸ªå¤šé¡¹å¼å¯ä»¥åœ¨çº¿æ€§æ—¶é—´å¤æ‚åº¦ä¸­è§£å†³ç›¸ä¹˜ï¼Œå°±æ˜¯å¯¹åº”çš„ $y$ ä¹˜èµ·æ¥ã€‚ ä½†æ˜¯æš´åŠ›çš„æŠŠç³»æ•°è¡¨ç¤ºæ³•è½¬åŒ–ä¸ºç‚¹å€¼è¡¨ç¤ºæ³•ä¾ç„¶æ˜¯ $\\Theta(n^{2})$ çš„ã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿ 0x02 å¤æ•°å’Œå•ä½æ ¹è¯´è¿‡ä¸è®²ï¼Œæˆ‘å°±æ”¾åœ¨è¿™é‡Œæ–¹ä¾¿æˆ‘ç¿»ã€‚ $(a+bi)+(c+di)=(a+c)+(b+d)i$ $(a+bi)-(c+di)=(a-c)+(b-d)i$ $(a+bi)\\times(c+di)=ac+adi+bci-bd=(ac-bd)+(ad+bc)i$ é™¤æ³•å¯ä»¥ä¸ç”¨ï¼Œå…¶å®ä¹Ÿä¸ç”¨è®²ï¼Œè‡ªç„¶è€Œç„¶çš„ä¸œè¥¿ã€‚ æ–¹ç¨‹ $x^{n}=1$ çš„æ ¹ï¼Œç§°ä½œå•ä½æ ¹ç”¨ $\\omega_{n}^{k}$ è¡¨ç¤ºã€‚ $k$ è¡¨ç¤ºç¬¬ $k$ ä¸ª $n$ æ¬¡å•ä½æ ¹ï¼Œä»0å¼€å§‹æ ‡å·ï¼Œ$\\omega^{0}_{n},\\omega^{1}_{n},\\cdots,\\omega^{n-1}_{n},$ã€‚å…¶ä¸­ $\\omega^{0}_{n}=1$ã€‚ è™½ç„¶è¿™æ ·è¯´ï¼Œä½†æ˜¯ $k\\geq n$ ä»¥åŠ $k &lt; 0$ çš„æƒ…å†µæ˜¯è¢«å…è®¸çš„ã€‚ åŸå› çœ‹åˆ°åé¢å°±çŸ¥é“äº†ã€‚ ä»å‡ ä½•æ„ä¹‰ä¸Šæ¥ç†è§£å•ä½æ ¹å³å¤æ•°çš„åæ ‡ç³»å•ä½åœ†çš„ $n$ ç­‰åˆ†ç‚¹ã€‚ å¤æ•°ç›¸ä¹˜çš„æ€§è´¨ï¼šæ¨¡é•¿ç›¸ä¹˜ï¼Œè¾è§’ç›¸åŠ ã€‚ æ¨¡é•¿æŒ‡ä¸€ä¸ªå¤æ•°åˆ°åŸç‚¹çš„è·ç¦»ï¼Œ$t=a+bi$ çš„æ¨¡é•¿è®°ä½œ $|t|$ è¾è§’æŒ‡åŸç‚¹åˆ°ç‚¹çš„è¿çº¿ä¸ $x$ è½´çš„æ­£æ–¹å‘çš„å¤¹è§’ï¼Œè®°ä½œ $\\arg(a+bi)$ æ¥ä¸‹æ¥åˆ—ä¸¾éœ€è¦ç”¨åˆ°çš„å…¬å¼ã€‚ \\begin{align*}\\label{2} & \\omega^{k}_{n}=e^{\\frac{2k\\pi}{n}i}=\\cos\\frac{2k\\pi}{n}i+i\\sin\\frac{2k\\pi}{n} \\tag{2.1} \\\\ & \\omega^{0}_{n}=1 \\tag{2.2} \\\\ & \\omega^{k}_{n}=\\omega^{k\\operatorname{mod} n} \\tag{2.3} \\\\ & \\omega^{k}_{n}\\times\\omega^{j}_{n}=\\omega^{k+j}_{n} \\tag{2.4} \\\\ & (\\omega^{1}_{n})^{k}=\\omega^{k}_{n} \\tag{2.5} \\\\ & \\omega^{pk}_{pn}=\\omega^{k}_{n} \\tag{2.6} \\\\ & \\omega^{k+\\frac{n}{2}}_{n}=-\\omega^{k}_{n} \\tag{2.7} \\\\ \\end{align*}é è¿™æ®µåœ¨vscä¸Šæ˜¾ç¤ºä¸å‡ºæ¥æˆ‘è‡ªæ¯™ 0x03 ç»§ç»­ç ”ç©¶å¤šé¡¹å¼æˆ‘ä»¬è®¾ä¸€ä¸ªå¤šé¡¹å¼ F(x)=\\sum_{i=0}^{n-1}a_{i}\\times x^{i}ä¿è¯ $n=2^{p}+1$ æˆ‘ä»¬æŒ‰ $i$ çš„å¥‡å¶æ€§æŠŠ $F$ åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† F(x)=\\sum_{i=0}^{n-1}a_{i}\\times x^{i}=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\times x^{2i}+\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\times x^{2i+1}ç»§ç»­å®šä¹‰ L(x)=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\times x^{i}R(x)=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\times x^{i}ä¹Ÿå°±æ˜¯è¯´ F(x)=\\sum_{i=0}^{n-1}a_{i}\\times x^{i}=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\times x^{2i}+\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\times x^{2i+1}=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\times (x^{2})^{i}+\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\times (x^{2})^{i}\\times x=\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i}\\times x^{2i}+\\sum_{i=0}^{\\frac{n}{2}-1}a_{2i+1}\\times x^{2i+1}=L(x^{2})+xR(x^{2})æˆ‘ä»¬å¯ä»¥ä»£å…¥ä¸€ä¸ªæ•°è¿›å»ã€‚ä¸€èˆ¬æˆ‘ä»¬è‚¯å®šæƒ³ç€ä»£ä¸ªçœ‹èµ·æ¥å¯çˆ±çš„æ•°å­—ã€‚ çœ‹çœ‹ï¼Œè¿™å°±æ˜¯æˆ‘ç­‰å‡¡äººä¸å‚…é‡Œå¶è¿™ç­‰ç¥ä»™çš„åŒºåˆ«ã€‚äººå®¶ä»£å…¥çš„æ˜¯ä»€ä¹ˆï¼Ÿæ²¡é”™ï¼Œå•ä½æ ¹ï¼ï¼ˆä¸ç„¶æˆ‘TMå‰é¢ç½—åˆ—ä¸€å¤§å †å•ä½æ ¹çš„æ€§è´¨å¹²å˜›ï¼‰ F(x)=L(x^{2})+xR(x^{2})F(\\omega^{k}_{n})=L(\\omega^{2k}_{n})+\\omega^{k}_{n}R(\\omega^{2k}_{n})F(\\omega^{k}_{n})=L(\\omega^{2k}_{2\\times \\frac{1}{2}n})+\\omega^{k}_{n}R(\\omega^{2k}_{2\\times \\frac{1}{2}n})ç”±å…¬å¼ (2.6) F(\\omega^{k}_{n})=L(\\omega^{k}_{\\frac{1}{2}n})+\\omega^{k}_{n}R(\\omega^{k}_{\\frac{1}{2}n}) \\tag{3.1}å›åˆ° F(x)=L(x^{2})+xR(x^{2})æ­¤æ—¶æˆ‘ä»¬ä»£å…¥ $\\omega^{k+\\frac{n}{2}}_{n}$ åŒç†å¯å¾— F(\\omega^{k+\\frac{n}{2}}_{n})=L(\\omega^{k}_{\\frac{n}{2}})-R(\\omega^{k}_{\\frac{n}{2}}) \\tag{3.2}å¯ä»¥å‘ç° (3.1) å’Œ (3.2) åªå·®äº†ç¬¦å·ï¼Œä¹Ÿå°±æ˜¯è¯´åªè¦çŸ¥é“äº† $L(\\omega^{k}_{\\frac{n}{2}})$ å’Œ $R(\\omega^{k}_{\\frac{n}{2}})$ æˆ‘ä»¬å°±å¯ä»¥åŒæ—¶å¾—åˆ° $F(\\omega^{k}_{n})$ å’Œ $F(\\omega^{k+\\frac{n}{2}}_{n})$ã€‚ç„¶åå°±é€’å½’æ±‚è§£ã€‚ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨ $\\Theta(n\\log_{2}n)$ æ±‚å–å¤šé¡¹å¼çš„ç‚¹å€¼è¡¨ç¤ºäº†ã€‚ ç®—æ³•åå«DFTã€‚ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;complex&gt; using namespace std; const double PI = acos(-1); const int MAXN = 1e6 + 3e5 + 5; int n; struct Complex { double real; double imag; Complex(double t_real = 0, double t_imag = 0) { real = t_real, imag = t_imag; } Complex operator + (Complex const&amp; rhs) const { return Complex(real + rhs.real, imag + rhs.imag); } Complex operator - (Complex const&amp; rhs) const { return Complex(real - rhs.real, imag - rhs.imag); } Complex operator * (Complex const&amp; rhs) const { return Complex(real * rhs.real - imag * rhs.imag, real * rhs.imag + imag * rhs.real); } void to_real(const double t_real) { real = t_real; } void to_imag(const double t_imag) { imag = t_imag; } double to_real() { return real; } double to_imag() { return imag; } } F[MAXN &lt;&lt; 2], t[MAXN &lt;&lt; 2]; void dft(Complex *f, int __n) { if (__n == 1) return ; Complex *L = f; Complex *R = f + (__n &gt;&gt; 1); for (int k = 0; k &lt; __n; ++k) t[k] = f[k]; for (int k = 0; k &lt; (__n &gt;&gt; 1); ++k) L[k] = t[k &lt;&lt; 1], R[k] = t[k &lt;&lt; 1 | 1]; dft(L, (__n &gt;&gt; 1)); dft(R, (__n &gt;&gt; 1)); Complex omega; Complex now; omega.to_real(cos(2 * PI / __n)); omega.to_imag(sin(2 * PI / __n)); now.to_real(1); now.to_imag(0); for (int k = 0; k &lt; (__n &gt;&gt; 1); ++k) { t[k] = L[k] + now * R[k]; t[k + (__n &gt;&gt; 1)] = L[k] - now * R[k]; now = now * omega; } for (int k = 0; k &lt; __n; ++k) f[k] = t[k]; } signed main() { scanf(&quot;%d&quot;, &amp;n); int temp = n; double x; for (n = 1; n &lt; temp; n &lt;&lt;= 1) ; for (int i = 0; i &lt; temp; ++i) scanf(&quot;%lf&quot;, &amp;x), F[i].to_real(x), F[i].to_imag(0); dft(F, n); for (int i = 0; i &lt; n; ++i) printf(&quot;(%.2lf %.2lf)\\n&quot;, F[i].to_real(), F[i].to_imag()); return 0; } subarashi ä½†æ˜¯æˆ‘ä»¬ç°åœ¨æ±‚åˆ°çš„åªæ˜¯ä¸€å †æ²¡ç”¨çš„ç‚¹å€¼ï¼Œè¿˜éœ€è¦æ±‚åˆ°çš„ç‚¹å€¼è¡¨ç¤ºè¿˜åŸæˆç³»æ•°è¡¨ç¤ºã€‚ ç»“è®ºæ˜¯æŠŠä»£å…¥çš„ $\\omega^{k}_{n}$ æ¢æˆ $\\omega^{-k}_{n}$ ç„¶åé™¤ä»¥ $n$ã€‚ å³DFTçš„é€†è¿ç®—IDFTã€‚ IDFTçš„è¯æ˜æ¯”è¾ƒç¹çï¼Œæ¶‰åŠåˆ°åˆ†ç±»è®¨è®ºã€‚ç”±äºæˆ‘æœ€è¿‘è¢«æ•°å­¦ä½œä¸šçš„å¤šç­”æ¡ˆè®¨è®ºå’Œæ™ºéšœç çš„60ç§æƒ…å†µæ¯’ç˜¤äº†ï¼Œæ•…æ‡’å¾—ç»™å‡ºè¯æ˜ã€‚åæ­£æˆ‘ç›¸ä¿¡çœ‹æˆ‘blogçš„äººäººå‡ä¼šå•ä½æ ¹åæ¼” æˆ‘ä»¬è®° $\\mathcal{F}(F(x))$ æ˜¯ $F(x)$ çš„ç¦»æ•£å‚…é‡Œå¶å˜æ¢/å‚…é‡Œå¶å˜æ¢ï¼Œ$\\mathcal{Fâ€™}(F(x))$ æ˜¯ $F(x)$ çš„é€†ç¦»æ•£å‚…é‡Œå¶å˜æ¢/å‚…é‡Œå¶å˜æ¢ã€‚ ç”¨çœ‹èµ·æ¥å¾ˆé«˜å¤§ä¸Šå¾ˆnbçš„æ•°å­¦è¯­è¨€è¡¨ç¤ºå°±æ˜¯ è®° G=\\mathcal{F}(F(x))åˆ™ n\\times f_{k}=\\sum_{i=0}^{n-1}\\omega^{-ki}_{n}g_{i}å…¶ä¸­ $f_{i}$ã€$g_{i}$ åˆ†åˆ«ä¸º $F$ã€$G$ çš„ç¬¬ $i$ é¡¹ç³»æ•°ã€‚ æˆ‘ä»¬åªéœ€è¦æ”¹ä¸€ä¸‹ä»£ç å°±å¥½äº†ã€‚ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;complex&gt; using namespace std; const double PI = acos(-1); const int MAXN = 1e6 + 3e5 + 5; int n, m; struct Complex { double real; double imag; Complex(double t_real = 0, double t_imag = 0) { real = t_real, imag = t_imag; } Complex operator + (Complex const&amp; rhs) const { return Complex(real + rhs.real, imag + rhs.imag); } Complex operator - (Complex const&amp; rhs) const { return Complex(real - rhs.real, imag - rhs.imag); } Complex operator * (Complex const&amp; rhs) const { return Complex(real * rhs.real - imag * rhs.imag, real * rhs.imag + imag * rhs.real); } void to_real(const double t_real) { real = t_real; } void to_imag(const double t_imag) { imag = t_imag; } double to_real() { return real; } double to_imag() { return imag; } } A[MAXN &lt;&lt; 2], B[MAXN &lt;&lt; 2], t[MAXN &lt;&lt; 2]; void dft(Complex *f, int __n, int flag) { if (__n == 1) return ; Complex *L = f; Complex *R = f + (__n &gt;&gt; 1); for (int k = 0; k &lt; __n; ++k) t[k] = f[k]; for (int k = 0; k &lt; (__n &gt;&gt; 1); ++k) L[k] = t[k &lt;&lt; 1], R[k] = t[k &lt;&lt; 1 | 1]; dft(L, (__n &gt;&gt; 1), flag); dft(R, (__n &gt;&gt; 1), flag); Complex omega; Complex now; omega.to_real(cos(2 * PI / __n)); omega.to_imag(sin(2 * PI / __n) * flag); now.to_real(1); now.to_imag(0); for (int k = 0; k &lt; (__n &gt;&gt; 1); ++k) { t[k] = L[k] + now * R[k]; t[k + (__n &gt;&gt; 1)] = L[k] - now * R[k]; now = now * omega; } for (int k = 0; k &lt; __n; ++k) f[k] = t[k]; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); double x; for (int i = 0; i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;x), A[i].to_real(x), A[i].to_imag(0); for (int i = 0; i &lt;= m; ++i) scanf(&quot;%lf&quot;, &amp;x), B[i].to_real(x), B[i].to_imag(0); for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1) ; dft(A, n, 1); dft(B, n, 1); for (int i = 0; i &lt; n; ++i) A[i] = A[i] * B[i]; dft(A, n, -1); for (int i = 0; i &lt;= m; ++i) printf(&quot;%d &quot;, (int)(A[i].real / n + 0.49)); return 0; } é€’å½’ç‰ˆå¸¸æ•°è¿‡å¤§ï¼Œæˆ‘ä»¬æƒ³æƒ³èƒ½ä¸èƒ½æŠŠé€’å½’è½¬ä¸ºå¾ªç¯ï¼ˆè¿­ä»£ï¼‰ã€‚ è¿™é‡Œç»™ä¸€ä¸ªç»“è®ºï¼Œç»™å‡ºä¸€ä¸ªåºåˆ—ã€‚æ¯”å¦‚ $\\texttt{0 1 2 3 4 5 6 7}$ã€‚ å¯¹å…¶è¿›è¡ŒDFTåï¼š$\\texttt{0 4 2 6 1 5 3 7}$ã€‚å¤šè¯•å‡ ç»„å¯ä»¥å‘ç°DFTåæ¯ä¸ªä½ç½®æ•°æ˜¯åŸåºåˆ—å¯¹åº”ä½ç½®ä¸Šçš„æ•°çš„äºŒè¿›åˆ¶åè½¬åçš„ç»“æœã€‚ \\texttt{0 1 2 3 4 5 6 7}\\texttt{(000) (001) (010) (011) (100) (101) (110) (111)}\\texttt{(000) (100) (010) (110) (001) (101) (011) (111)}\\texttt{0 4 2 6 1 5 3 7}è¯æ˜ä¹Ÿå¥½è¯ï¼Œç•™ä½œæ€è€ƒå§ã€‚ ç„¶åæˆ‘ä»¬å°±å¯ä»¥é¢„å¤„ç†å‡ºåºåˆ—DFTåçš„ä½ç½®ï¼Œç„¶åå‘ä¸Šåˆå¹¶ã€‚å°±ä¸ç”¨ä»ä¸Šè‡³ä¸‹é€’å½’äº†ã€‚ å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬è®¾ $rev_{i}$ ä¸ºæ•°å­— $i$ çš„äºŒè¿›åˆ¶ç¿»è½¬ï¼Œ$lim$ ä¸ºæœ€å¤šçš„äºŒè¿›åˆ¶ä½æ•°ã€‚ ç¿»è½¬æ“ä½œç›¸å½“äºæŠŠå½“å‰æ•°çš„äºŒè¿›åˆ¶æœ€åä¸€ä½æ¥åˆ°ä¹‹å‰éƒ¨åˆ†ç¿»è½¬çš„å‰é¢ã€‚ ä¹‹å‰éƒ¨åˆ†çš„ç¿»è½¬å³ $rev_{i\\operatorname{shr} 1}\\operatorname{shr} 1$ å…¶ä¸­ $\\operatorname{shr}$ ç›¸å½“äºå³ç§»æ“ä½œï¼Œ$\\operatorname{shl}$ åŒç†ã€‚ ç„¶ååˆ¤ä¸€ä¸‹æœ€åä¸€ä½ï¼Œæ˜¯1çš„è¯å°±è®© $2^{lim-1}$ å¯¹ $rev_{i\\operatorname{shr} 1}\\operatorname{shr} 1$ æŒ‰ä½ä¸ã€‚å› ä¸º $2^{p}$ çš„äºŒè¿›åˆ¶ä½å§‹ç»ˆæ˜¯1åé¢è·Ÿç€ $p$ ä¸ª0ã€‚ è¿™é‡Œå»ºè®®è‡ªå·±æ‰‹æ¨ä¸€ä¸‹ã€‚ int lim = 0; while ((1 &lt;&lt; lim) &lt; n) ++lim; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lim - 1)); å®Œæ•´ä»£ç  #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;complex&gt; using namespace std; const double PI = acos(-1); const int MAXN = 1e6 + 3e5 + 5; int n, m; struct Complex { double real; double imag; Complex(double t_real = 0, double t_imag = 0) { real = t_real, imag = t_imag; } Complex operator + (Complex const&amp; rhs) const { return Complex(real + rhs.real, imag + rhs.imag); } Complex operator - (Complex const&amp; rhs) const { return Complex(real - rhs.real, imag - rhs.imag); } Complex operator * (Complex const&amp; rhs) const { return Complex(real * rhs.real - imag * rhs.imag, real * rhs.imag + imag * rhs.real); } void to_real(const double t_real) { real = t_real; } void to_imag(const double t_imag) { imag = t_imag; } double to_real() { return real; } double to_imag() { return imag; } } A[MAXN &lt;&lt; 2], B[MAXN &lt;&lt; 2], t[MAXN &lt;&lt; 2]; int rev[MAXN &lt;&lt; 2]; void get_rev() { int lim = 0; while ((1 &lt;&lt; lim) &lt; n) ++lim; for (int i = 0; i &lt; n; ++i) rev[i] = (rev[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (lim - 1)); } void fft(Complex *f, int __n, int flag) { for (int i = 0; i &lt; n; ++i) if (i &lt; rev[i]) swap(f[i], f[rev[i]]); for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) { Complex omega; omega.to_real(cos(PI / mid)); omega.to_imag(sin(PI / mid) * flag); for (int i = 0; i &lt; n; i += (mid &lt;&lt; 1)) { Complex now; now.to_real(1); now.to_imag(0); for (int j = 0; j &lt; mid; ++j) { Complex first = f[i + j]; Complex second = now * f[i + j + mid]; f[i + j] = first + second; f[i + j + mid] = first - second; now = now * omega; } } } } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); double x; for (int i = 0; i &lt;= n; ++i) scanf(&quot;%lf&quot;, &amp;x), A[i].to_real(x), A[i].to_imag(0); for (int i = 0; i &lt;= m; ++i) scanf(&quot;%lf&quot;, &amp;x), B[i].to_real(x), B[i].to_imag(0); for (m += n, n = 1; n &lt;= m; n &lt;&lt;= 1) ; get_rev(); fft(A, n, 1); fft(B, n, 1); for (int i = 0; i &lt; n; ++i) A[i] = A[i] * B[i]; fft(A, n, -1); for (int i = 0; i &lt;= m; ++i) printf(&quot;%d &quot;, (int)(A[i].real / n + 0.49)); return 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"www.orchid-any.cf/tags/FFT/"},{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"www.orchid-any.cf/tags/æ•°å­¦/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"ã€Œæ‚é¡¹ã€CQBZOJå‘å¸–æ ¼å¼å»ºè®®","slug":"OTHE-BLOG-FORMAT-GUIDE","date":"2020-03-21T06:50:55.000Z","updated":"2020-03-21T09:33:01.597Z","comments":true,"path":"2020/03/21/OTHE-BLOG-FORMAT-GUIDE/","link":"","permalink":"www.orchid-any.cf/2020/03/21/OTHE-BLOG-FORMAT-GUIDE/","excerpt":"","text":"0x00 å‰è¨€è¿™ç¯‡å¸–å­åªä»£è¡¨æˆ‘çš„ä¸ªäººè§‚ç‚¹ï¼Œç›®çš„æ˜¯å¸Œæœ›OJçš„ åŸåˆ›ã€é«˜è´¨é‡ çš„åšå®¢è¶Šæ¥è¶Šå¤šï¼Œæ–¹ä¾¿å¤§å®¶çš„äº¤æµã€‚ 0x01 æ ¼å¼å…³äºæ ¼å¼æˆ‘çš„çœ‹æ³•æ˜¯ï¼š é™¤äº†åšå®¢çš„å°æ ‡é¢˜ï¼Œä¸ç”¨æ ‡é¢˜å­—ä½“ï¼Œçœ‹èµ·æ¥å¾ˆæ‰çœ¼ã€‚ ä¸è¦æœ‰æ— æ„ä¹‰çš„æ¢è¡Œï¼Œç†ç”±è¿˜æ˜¯çœ‹èµ·æ¥ä¸çˆ½ï¼Œå¹¶ä¸”æµªè´¹ç¿»é¡µçš„æ—¶é—´ã€‚ å¦‚æœç¡®å®éœ€è¦å¼ºè°ƒï¼Œè¯·ä½¿ç”¨****æ¥å¼ºè°ƒè€Œä¸æ˜¯æ ‡é¢˜å­—ä½“ã€‚ ä¸è¦ç”¨èŠ±é‡Œèƒ¡å“¨çš„é¢œè‰²ï¼Œå¾ˆéš¾çœ‹å¥½ä¸å¥½ã€‚ è¯·æ–‡ç« çš„æ¯ä¸ªå°éƒ¨åˆ†éƒ½æ‰“ä¸€ä¸ªå°æ ‡é¢˜ï¼Œè¿™æ ·çœ‹èµ·æ¥ä¼šå¥½çœ‹å¾ˆå¤šã€‚ ä»£ç å—è¯·å¥½å¥½åŠ ï¼Œä¸ç„¶æ²¡æœ‰é«˜äº®å¾ˆéš¾çœ‹ã€‚ å†æ¬¡å¼ºè°ƒä¸€éï¼Œé™¤äº†å°æ ‡é¢˜ä¸è¦ç”¨æ ‡é¢˜å­—ä½“ï¼Œéš¾çœ‹åˆ°çˆ†ã€‚ æ¯å¥è¯åé¢è¯·åŠ ä¸Šå¥å·ã€‚ ä¸è¦æŠŠæ²¡å†™å®Œçš„è´´å­å‘å‡ºæ¥ï¼Œé’“åˆ«äººèƒƒå£å¾ˆç¼ºå¾·ã€‚å»ºè®®å…ˆå­˜å‚¨åˆ°æœ¬åœ°ã€‚æ¨èçš„æœ¬åœ°markdownç¼–è¾‘å™¨æœ‰ï¼šTyporaã€vsc+markdown all in oneã€stack edit chromeæœ¬åœ°å®‰è£…ç‰ˆã€‚ 0x02 $\\LaTeX$å…³äº $\\LaTeX$ æˆ‘çš„çœ‹æ³•æ˜¯ï¼š ä¸è¦åœ¨æ— æ„ä¹‰çš„åœ°æ–¹æ·»åŠ  $\\LaTeX$ï¼Œæ¯”å¦‚äººåã€ç®—æ³•åã€æ•°å­—ä¹‹ç±»çš„ã€‚ è¯·åœ¨ä½¿ç”¨äº† $\\LaTeX$ çš„åœ°æ–¹ä¸¤è¾¹æ·»åŠ ç©ºæ ¼ï¼Œæ¯”å¦‚ ç¤ºä¾‹æ–‡æœ¬ $\\int_{a}^{b}f(x)dx$ ç¤ºä¾‹æ–‡æœ¬ã€‚ è¯¥ç”¨ $\\LaTeX$ å°±ç”¨ï¼Œå°¤å…¶æ˜¯æ±‚å’Œä¹‹ç±»çš„ç¬¦å·ï¼Œä¸è¦ç”¨è¾“å…¥æ³•çš„ç‰¹æ®Šç¬¦å·ï¼Œéš¾çœ‹çš„æˆ‘è‡ªæ¯™å¥½å§ã€‚ è¯¥ä½¿ç”¨ \\mathrm{} å­—ä½“çš„åœ°æ–¹å¥½å¥½ç”¨ï¼Œæ¯”å¦‚ $\\mathrm{gcd}$ã€$\\mathrm{lcm}$ï¼Œ$\\mathrm{mod}$ ä¹‹ç±»çš„ï¼Œæ¯” $gcd$ã€$lcm$ã€$mod$ çœ‹èµ·æ¥æ­£ç»å¤šäº†ã€‚ æ›´å¤šçš„è§„èŒƒå¯ä»¥å‚è€ƒStudyingFatherçš„åšå®¢ click here 0x03 é¢˜è§£å…³äºé¢˜è§£æˆ‘çš„çœ‹æ³•æ˜¯ï¼š å¦‚æœä½ ä¸æƒ³æ”¾ä»£ç ï¼Œå°±ä¸è¦æ”¾ã€‚ å¦‚æœä½ æ”¾ä»£ç ï¼Œå°±è¯·ä¸è¦æŒ–å‘ã€‚å¯¹äºä¸€äº›å®ç°æ‰æ˜¯éš¾ç‚¹çš„é¢˜ç›®å¯¹ä»£ç æŒ–å‘æ˜¯ä¸€ç§å¾ˆæ²¡æœ‰å¿…è¦ã€å¾ˆæ— èŠçš„è¡Œä¸ºã€‚ é¢˜è§£è¦å†™å°±å†™è¯¦ç»†ï¼Œè¦ä¹ˆå°±ä¸å†™ã€‚å…³äºè¿™ä¸€ç‚¹å…¶å®æˆ‘ä¹‹å‰ä¹Ÿåšçš„ä¸å¥½ï¼Œä½†ç°åœ¨å¥½å¤šäº†ä¸æ˜¯å—ï¼Ÿï¼ˆå¿«å¤¸å¤¸æˆ‘ï¼‰ å¦‚æœä½ è‡ªå·±éƒ½æ˜¯æŠ„çš„é¢˜è§£é‚£ä¹Ÿä¸è¦å‘äº†ï¼Œå‘äº†ä¹Ÿæ˜¯è¾£åˆ«äººçœ¼ç›ã€‚ å½“ç„¶ï¼Œå¦‚æœæ˜¯åœ¨å…¶ä»–é¢˜è§£çš„å¯å‘ä¸‹å®Œæˆçš„é¢˜ç›®ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ä½†æ˜¯ä¸€å®šè¦æ³¨æ˜æ€è·¯çš„æ¥æºã€‚ æœ€ä½é™åº¦ä»£ç è¦æ˜¯è‡ªå·±æ‰“çš„ï¼Œcopy-pasteå¾ˆå¥½ç©æ˜¯å—ï¼Ÿ æ›´å¤šçš„è§„èŒƒå¯ä»¥å‚è€ƒStudyingFatherçš„åšå®¢ click here 0x04 å­¦ä¹ ç¬”è®°å…³äºå­¦ä¹ ç¬”è®°æˆ‘çš„çœ‹æ³•æ˜¯ï¼š å­¦ä¹ ç¬”è®°é¦–å…ˆè¦ä¿è¯è‡ªå·±èƒ½çœ‹æ‡‚ï¼Œå¹¶ä¸”å¦‚æœè‡ªå·±éƒ½è¿˜æ²¡å®Œå…¨ç†è§£ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼Œé‚£å°±ä¸è¦å†™ï¼Œå†™äº†ä¹Ÿæ˜¯ä¸¢äººç°çœ¼ï¼Œåé¢ä¾‹å­å°±æ˜¯æˆ‘çš„LCTç¬”è®°ã€‚ ä¸è¦æœ‰å¤ªå¤šæ— æ„ä¹‰çš„å†…å®¹ï¼Œæˆ‘è¦çš„æ˜¯ä½ çš„è®²è§£ï¼Œä¸æ˜¯ä½ è‡ªè®¤ä¸ºçš„å¹½é»˜ã€‚ å½“ç„¶ï¼Œæœ‰è¶£çš„è®²è§£å¾€å¾€èƒ½å¸å¼•æ›´å¤šäººï¼Œæ‰€ä»¥åœ¨å­¦ä¹ çš„åŸºè°ƒä¸ŠåŠ ä¸€äº›é€‚å½“çš„æ¢—ã€ç®—æ³•æœ‰å…³å°ç¬‘è¯ä¹Ÿæ˜¯å¾ˆå¥½çš„ã€‚ å¦‚æœæ˜¯æ•°å­¦å‘çš„æ–‡ç«  å¿…é¡» ç»™å‡ºä¸¥æ ¼çš„è¯æ˜ï¼Œå¦åˆ™åŸºæœ¬æ²¡ä»€ä¹ˆæ„ä¹‰ã€‚ ä¸è¦æœ‰å¤ªå¤šçš„å¼•ç”¨ï¼Œå°¤å…¶æ˜¯å¼•ç”¨ç™¾åº¦ç™¾ç§‘ã€ç»´åŸºç™¾ç§‘ä¹‹ç±»çš„ï¼Œæ²¡æœ‰æ„ä¹‰ã€‚å¤ªå¤šçš„å¼•ç”¨â‰ˆæŠ„è¢­ã€‚ å¦‚æœæœ‰å¼•ç”¨è¯·æ³¨æ˜æ¥æºï¼Œå‚è€ƒæ–‡ç« ä¹Ÿä¸€æ ·ã€‚ä¸ç»ä»–äººåŒæ„å°±è½¬è½½è¿˜ä¸æ ‡æ˜åŸä½œè€…ï¼ŒæŠŠåˆ«äººçš„ä¸œè¥¿å½“æˆæ˜¯è‡ªå·±çš„æ˜¯ä¸€ç§kimochiwarui(æ¶å¿ƒ)çš„è¡Œä¸ºã€‚ å¦‚æœä½ è‡ªå­¦äº†ä¸€ä¸ªæœ‰ä¸€å®šå«é‡‘é‡çš„æ–°ç®—æ³•ï¼Œå¤§å¯ä»¥å†™ä¸€ç¯‡å­¦ä¹ ç¬”è®°æ€»ç»“ä¸€ä¸‹ã€‚ä¸ä»…ç»™åˆ«äººçœ‹ï¼Œä¹Ÿæ˜¯ç»™è‡ªå·±çœ‹ã€‚ å¦‚æœæ˜¯å¤§ç¯‡copyçš„ï¼Œå»ºè®®å°±ä¸è¦å‘äº†ï¼Œå‘äº†ä¹Ÿæ˜¯è¢«éª‚ï¼Œæ²¡ç†ç”±è¿˜å˜´çš„é‚£ç§ã€‚ 0x05 æ€»ç»“æ€»è€Œè¨€ä¹‹ï¼ŒåŒå­¦ä»¬å–œæ¬¢åœ¨OJé‡Œé¢è®¨è®ºæ˜¯ä¸€ä»¶å¾ˆå¥½çš„äº‹æƒ…ï¼Œæˆ‘å¸Œæœ›æˆ‘ä»¬OJçš„å­¦æœ¯æ°›å›´è¶Šæ¥è¶Šæµ“çƒˆï¼Œåšå®¢è´¨é‡è¶Šæ¥è¶Šé«˜ï¼Œè¿™ä¹Ÿæ˜¯è¿™ç¯‡å¸–å­çš„ç›®çš„ã€‚ æœ¬è´´é‡Œä¸¾çš„ä¸€äº›åé¢ä¾‹å­ï¼Œæˆ‘ä¸è¯´å‡ºæ¥ï¼Œå¤§å®¶å¿ƒé‡Œéƒ½çŸ¥é“ã€‚æˆ‘ä¹Ÿæ˜¯ç»™ä½ ç•™ä¸ªé¢å­ï¼Œä½†æ„¿ä»¥åèƒ½æ”¹è¿‡è‡ªæ–°ï¼Œä¸ºOJæä¾›æ›´å¤šçš„é«˜è´¨é‡åšå®¢å§ã€‚ ä»¥ä¸Šã€‚","categories":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}],"tags":[{"name":"æ—¥å¸¸","slug":"æ—¥å¸¸","permalink":"www.orchid-any.cf/tags/æ—¥å¸¸/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P5659æ ‘ä¸Šçš„æ•°","slug":"SOL-P5659","date":"2020-03-15T11:52:24.000Z","updated":"2020-03-15T12:03:24.720Z","comments":true,"path":"2020/03/15/SOL-P5659/","link":"","permalink":"www.orchid-any.cf/2020/03/15/SOL-P5659/","excerpt":"","text":"Part 0 å¤§è‡´æ€è·¯ ä¸»è¦çš„æ€è·¯å°±æ˜¯é€ä¸ªæ‰“ç ´ï¼Œç ”ç©¶ç‰¹æ®Šçš„æ•°æ®å¾—åˆ°æ™®é€šçš„ç»“è®ºã€‚ Part 1 æš´åŠ›çš„éƒ¨åˆ†åˆ† æš´åŠ›çš„éƒ¨åˆ†åˆ†å¾ˆå¥½æ‹¿ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥æŠŠå…¨æ’åˆ—ï¼Œç„¶å $\\Theta(n)$ åˆ¤æ–­æ›´æ–°ç­”æ¡ˆã€‚ æ­å–œæ‚¨æ‹¿åˆ°èµ›åœºæ»¡åˆ† namespace SubtaskForce { int cmp[MAXN], ans[MAXN]; bool vis[MAXN]; void dfs(int now) { // å…¨æ’åˆ— if (now == n) { // æ›´æ–°ç­”æ¡ˆ for (R int i = 1; i &lt;= n; ++i) cmp[id[i]] = i; for (R int i = 1; i &lt;= n; ++i) { if (cmp[i] &lt; ans[i]) { for (R int j = 1; j &lt;= n; ++j) ans[j] = cmp[j]; break; } if (cmp[i] &gt; ans[i]) break; } return ; } for (R int i = 1; i &lt; n; ++i) { if (!vis[i]) { vis[i] = 1; swap(id[nodes[i].x], id[nodes[i].y]); dfs(now + 1); swap(id[nodes[i].x], id[nodes[i].y]); vis[i] = 0; } } } void main() { // åˆå§‹åŒ– for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) ans[i] = n - i + 1; dfs(1); for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } Part 2 èŠèŠ±å›¾çš„éƒ¨åˆ†åˆ† å°±è¿™é“é¢˜è€Œè¨€ï¼ŒèŠèŠ±å›¾å…¶å®æ˜¯æ¯”é“¾çš„æ•°æ®å¥½æƒ³ä¸€äº›çš„ã€‚ æˆ‘ä»¬ç§°èŠèŠ±å›¾ä¸­åº¦æ•°ä¸º $n-1$ çš„ç»“ç‚¹ä¸º $rt$ ç½¢ã€‚ æˆ‘ä»¬å¯ä»¥å‘ç°åœ¨èŠèŠ±å›¾ä¸Šåˆ é™¤è¾¹ä¸€å®šæ˜¯æŸä¸ªç»“ç‚¹å’Œ $rt$ ä¹‹é—´ã€‚ ä¹Ÿå°±æ˜¯è¯´æ— è®ºæˆ‘ä»¬æŒ‰æ€æ ·çš„é¡ºåºåˆ è¾¹ï¼Œæœ€åéƒ½ä¼šå˜æˆä¸€ä¸ªç¯ã€‚ æˆ‘åšäº†ä¸€ä¸ªåŠ¨å›¾æ¼”ç¤ºï¼Œå¦‚æœæ´›è°·åšå®¢ä¸æ”¯æŒgifçš„è¯å°±ç›´æ¥åˆ°è¿™ä¸ªç½‘å€ Click Here æœ‰äº†ç¯è¿™ä¸ªç»“è®ºï¼Œå°±æœ‰ä¸€ä¸ªå¾ˆæ˜¾ç„¶çš„è´ªå¿ƒæ„é€ ç¯çš„æ–¹æ³•ï¼š æŒ‰ç…§ $1,2,\\cdots,n$ çš„é¡ºåºæ¯ä¸ªæ•°å­—é€‰æ‹©ç¯ä¸Šè‡ªå·±çš„ä¸‹ä¸€ä¸ªç‚¹ã€‚ åœ¨ç¼–å†™ä»£ç çš„æ—¶å€™è¿˜éœ€è¦æ³¨æ„è¿˜æ²¡æœ‰è¿åˆ° $Y_{n}$ å°±æå‰è‡ªæ¯™è‡ªé—­å°é—­çš„æƒ…å†µã€‚ namespace SubtaskAss { // èŠèŠ±çš„å•è¯å¤ªé•¿äº†ï¼Œå°±å–äº†ä¸ªå·®ä¸å¤šçš„/xyx bool vis[MAXN]; int ans[MAXN]; struct UninoFindSet { int fa[MAXN]; void init(int limit) { for (R int i = 1; i &lt;= limit; ++i) fa[i] = i; } int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { x = find(x); y = find(y); if (x ^ y) fa[x] = y; } } ufs; void main() { ufs.init(n); for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) { for (R int j = 1; j &lt;= n; ++j) { if (!vis[j] &amp;&amp; (i == n || ufs.find(j) != ufs.find(id[i]))) { vis[j] = 1; ans[i] = j; ufs.merge(j, id[i]); break; } } } for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } part 3 é“¾çš„éƒ¨åˆ†åˆ† è¯´å®è¯é“¾çš„éƒ¨åˆ†åˆ†å…¶å®ä¹ŸæŒºå¥½æ‹¿çš„ï¼Œä½†æ˜¯è¿˜æ˜¯æ¯”èŠèŠ±å›¾éš¾æƒ³ä¸€äº›ã€‚ é¦–å…ˆï¼Œç”¨dfsåºæŠŠé“¾æ‹æˆæ ‘æ˜¯å›ºå®šæ“ä½œäº†ã€‚ é“¾æœ‰ä¸€ä¸ªæ€§è´¨ï¼Œå°±æ˜¯æ¯ä¸ªç»“ç‚¹(ä¸¤ç«¯ç‚¹é™¤å¤–)çš„åº¦æ•°éƒ½æœ‰ä¸”åªæœ‰äºŒã€‚ ä¹Ÿå°±æ˜¯è¯´é™¤ç«¯ç‚¹å¤–ï¼Œæ¯ä¸ªç»“ç‚¹éƒ½æœ‰ä¸¤æ¡è¾¹ã€‚è€Œä¸”è¿™ä¸¤æ¡è¾¹çš„è¢«åˆ é™¤æ—¶é—´ä¸€å®šä¸ä¸€æ ·ï¼ˆåºŸè¯ ä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªç»“ç‚¹çš„ä¸¤æ¡è¾¹è¢«åˆ é™¤çš„æƒ…å†µä¸€å…±æœ‰ä¸‰ç§ã€‚ æˆ‘ä»¬å®šä¹‰ $order_{i}$ ä¸ºç»“ç‚¹ $i$ çš„å·¦å³ä¸¤è¾¹çš„åˆ é™¤æƒ…å†µï¼š 0ï¼š0è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹çš„å·¦å³è¾¹éƒ½è¿˜æ²¡è¢«åˆ é™¤ 1ï¼š1è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹çš„å·¦è¾¹å…ˆè¢«åˆ é™¤ 2ï¼š2è¡¨ç¤ºè¿™ä¸ªç»“ç‚¹çš„å³è¾¹å…ˆè¢«åˆ é™¤ ç°åœ¨æˆ‘ä»¬å‡è®¾å·¦è¾¹çš„ç»“ç‚¹ $u$ è¦è·‘åˆ°å³è¾¹çš„ç»“ç‚¹ $v$ é‚£é‡Œå»ï¼Œé‚£ä¹ˆåœ¨ $u$ å’Œ $v$ ä¹‹é—´çš„ç»“ç‚¹ä¸€å®šæ˜¯å·¦è¾¹å…ˆè¢«åˆ é™¤ï¼Œæ‰€ä»¥ $order_i=1,i\\in (u,v)$ å¯¹äº $u$ å’Œ $v$ ä¸¤ä¸ªç»“ç‚¹ï¼Œä¸€å®šæ˜¯å³è¾¹å…ˆè¢«åˆ é™¤ï¼Œå¦åˆ™å°±ä¸çŸ¥é“è·‘å“ªé‡Œå»äº† æ‰€ä»¥ $order_{u}=order_{v}=2$ è‡³äºä»å³è·‘åˆ°å·¦å°±å®Œå…¨åŒç†äº†ã€‚ ç­”æ¡ˆåˆ™åŒæ ·æ˜¯ä»å°æšä¸¾åˆ°å¤§(æˆ‘æ˜¯ä»å°æšä¸¾åˆ°å¤§çš„/xyx) æ¯”å¦‚è¯´æˆ‘ä»¬å½“å‰æšä¸¾åˆ°äº†ç»“ç‚¹ $x$ï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒèƒ½å»å°½é‡å°çš„ä¸€ä¸ªç‚¹ å‡è®¾å½“å‰ $x$ åœ¨ $P_{x}$ï¼Œæˆ‘ä»¬ç›´æ¥æš´åŠ›æšä¸¾ä¸€ä¸ª $P_{y}$ã€‚ åˆ¤æ–­ä¸€ä¸ªæ–¹æ¡ˆæ˜¯å¦å¯è¡Œåªéœ€è¦åˆ¤æ–­å®ƒä¸å‰é¢çš„åˆ è¾¹é¡ºåºå†²çªå³å¯ã€‚ è¿™æ ·åšæ˜¯ $\\Theta(N^3)$ çš„ã€‚æˆ‘ä»¬å¯ä»¥åœ¨dfsçš„æ—¶å€™æ ‡è®°ï¼Œè¿™æ ·å°±æ˜¯ $\\Theta(n^2)$ äº†ã€‚ namespace SubtaskChain { int rnk[MAXN], ans[MAXN], dfn[MAXN]; int sbc_tot, order[MAXN], vis[MAXN]; void dfs(int x, int fa) { rnk[dfn[x] = ++sbc_tot] = x; for (R int i = head[x]; i; i = nxt[i]) if (to[i] ^ fa) dfs(to[i], x); } void mark_node(int p1, int p2, int tg) { if (p1 != 1 &amp;&amp; p1 != n) order[p1] = tg + 1; if (p2 != 1 &amp;&amp; p2 != n) order[p2] = tg + 1; for (R int i = (tg ? p1 + 1 : p2 + 1); i &lt; (tg ? p2 : p1); ++i) order[i] = ((tg ^ 1) + 1); } int iterate(int x, int tg) { int res = n + 1; if (order[dfn[x]] == tg + 1) return res; for (R int i = dfn[x] + (tg ? -1 : 1); tg ? (i &gt;= 1) : (i &lt;= n); i += (tg ? -1 : 1)) { if (order[i] == (tg ^ 1) + 1) { if (!vis[i]) res = min(res, rnk[i]); break; } if (!order[i] &amp;&amp; !vis[i]) res = min(res, rnk[i]); } return res; } int inver_id[MAXN]; void main() { for (R int i = 1; i &lt;= n; ++i) rnk[i] = 0; for (R int i = 1; i &lt;= n; ++i) dfn[i] = 0; for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) order[i] = 0; for (R int i = 1; i &lt;= n; ++i) inver_id[id[i]] = i; sbc_tot = 0; for (R int i = 1; i &lt;= n; ++i) { if (in[i] == 1) { dfs(i, 0); break; } } for (R int i = 1; i &lt;= n; ++i) { int left = iterate(inver_id[i], 1); int right = iterate(inver_id[i], 0); if (left &lt; right) mark_node(dfn[inver_id[i]], dfn[left], 0); else left = right, mark_node(dfn[inver_id[i]], dfn[left], 1); ans[i] = left; vis[dfn[left]] = 1; } for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } Part 4 æ­£è§£ æ‹¼å‡‘å‡ºçš„æ­£è§£ ï¼ˆæˆ‘èƒ½è¯´è¿™å‰©ä¸‹çš„40ptsæˆ‘çœ‹é¢˜è§£éƒ½çœ‹äº†åŠå¤©å—ï¼‰ å‰©ä¸‹çš„40ptsæ˜¯æˆ‘çœ‹äº†è¿™ç¯‡é¢˜è§£æ‰ä¼šçš„Click Here å…¶å®ä¼šäº†é“¾çš„æ•°æ®åŸºæœ¬å°±ç¦»æˆåŠŸä¸è¿œäº†ã€‚ ä»”ç»†æƒ³æƒ³ï¼Œæˆ‘ä»¬åœ¨å¤„ç†é“¾çš„æ—¶å€™ï¼Œè§„å®šäº†ä¸ä¸€ä¸ªç»“ç‚¹çš„è¾¹çš„åˆ é™¤é¡ºåºçš„æ•°å€¼ã€‚ å¦‚æœæ”¾åˆ°ä¸€èˆ¬çš„æƒ…å†µæ¥çœ‹ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šä¸€ä¸ªç±»ä¼¼äºæ‹“æ‰‘åºçš„åˆ é™¤é¡ºåºï¼Œå³æŸä¸€æ¡è¾¹éœ€è¦åœ¨æŸä¸€æ¡è¾¹åˆ é™¤è¿‡åæ‰èƒ½è¢«åˆ é™¤ã€‚ æ¯”å¦‚ä¸‹å›¾ï¼š å½“æˆ‘ä»¬æŠŠè¿™ä¸€åˆ é™¤é¡ºåºå†™å‡ºæ¥ï¼Œå°±å¯ä»¥å‘ç°è¿™å…¶å®æ„æˆäº†ä¸€ä¸ªé“¾ã€‚ å¯¹å§ï¼å¯¹å§ï¼ å‡è®¾æˆ‘ä»¬ç°åœ¨éœ€è¦æŠŠ $x$ åˆ åˆ° $y$ ç»“ç‚¹ä¸Šã€‚ é‚£ä¹ˆåˆ¤æ–­æ³•åˆ™å¦‚ä¸‹ï¼š ä¸åˆæ³•çš„æƒ…å†µï¼š æœ‰ä¸€ä¸ªæ•°å·²ç»ä» $x$ å‡ºå»è¿‡äº† æœ‰ä¸€ä¸ªæ•°å·²ç»åˆ°è¿‡ $y$ è¿™é‡Œäº† æœ‰ä¸€ä¸ªæ•°ä»ç›¸åŒæ–¹å‘è¿‡äº† $x$ çš„ä¸€æ¡å‡ºè¾¹ æœ‰ä¸€ä¸ªæ•°ä»ç›¸åŒæ–¹å‘è¿‡äº† $y$ çš„ä¸€æ¡å‡ºè¾¹ å‡º/å…¥è¾¹ä»»æ„ä¸€æ¡è¢«åˆ«çš„æ•°å­—ä»ç›¸åŒæ–¹å‘èµ°äº†ä¸€æ¬¡ åŠ ä¸Šå½“å‰æ•°æ„æˆçš„é“¾ $x$ æœ‰ä»»æ„ä¸€è¾¹å‡ºè¾¹ä¸åœ¨ä¸Šé¢ åŠ ä¸Šå½“å‰æ•°æ„æˆçš„é“¾ $y$ æœ‰ä»»æ„ä¸€è¾¹å‡ºè¾¹ä¸åœ¨ä¸Šé¢ åŠ ä¸Šå½“å‰æ•°åï¼Œç»è¿‡ $x$ çš„æ•°å­—è‡ªé—­äº†(å½¢æˆäº†ä¸€ä¸ªç¯) åŠ ä¸Šå½“å‰æ•°åï¼Œå½¢æˆäº†ä¸€æ¡é“¾ï¼Œ$x$ æœ‰ä»»æ„ä¸€æ¡å‡ºè¾¹ä¸åœ¨ä¸Šé¢ åˆæ³•çš„æƒ…å†µ æ’é™¤ä»¥ä¸Šæ‰€æœ‰æƒ…å†µå³åˆæ³• ç›´æ¥è´ªå¿ƒä¼šæ­»å¾—å¾ˆæƒ¨çƒˆã€‚ æˆ‘ä»¬å¯ä»¥é€šè¿‡dfsæ‰¾å‡ºç¼–å·æœ€å°çš„ä½œä¸ºæœ¬è½®çš„ç­”æ¡ˆã€‚ namespace SubtaskRandom { int mark[MAXN][MAXN], inver_id[MAXN]; int lave_unwalked[MAXN], fa[MAXN]; int lave_in[MAXN], lave_out[MAXN]; int node_from[MAXN], node_to[MAXN]; int header[MAXN][MAXN], footer[MAXN][MAXN]; bool vis[MAXN]; void dfs(int x, int rt) { for (R int i = head[x]; i; i = nxt[i]) { int y = to[i]; if (y ^ fa[x]) { fa[y] = x; vis[y] = 1; if (x ^ rt) { if (mark[x][y] == x || mark[fa[x]][x] == fa[x]) vis[y] = 0; if (mark[x][y] == 0 || mark[fa[x]][x] == 0) vis[y] = 0; if (header[x][fa[x]] == node_to[x] &amp;&amp; footer[x][y] == node_from[x] &amp;&amp; lave_out[x] + lave_in[x] + (lave_unwalked[x] &lt;&lt; 1) &gt; 2) vis[y] = 0; if (footer[x][y] == fa[x]) vis[y] = 0; } else { if (mark[x][y] == x) vis[y] = 0; if (mark[x][y] == 0) vis[y] = 0; if (node_from[x]) { if (footer[x][y] == node_from[x] &amp;&amp; lave_unwalked[x] + lave_in[x] + lave_out[x] != 1) vis[y] = 0; } } vis[y] &amp;= vis[x]; dfs(y, rt); } } if (rt ^ x) { if (node_from[x]) vis[x] = 0; if (node_to[x]) { if (footer[x][node_to[x]] == fa[x] &amp;&amp; lave_unwalked[x] + lave_in[x] + lave_out[x] != 1) vis[x] = 0; } } else { vis[x] = 0; } } void main() { for (R int i = 1; i &lt;= n; ++i) node_from[i] = 0; for (R int i = 1; i &lt;= n; ++i) node_to[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_in[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_out[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_unwalked[i] = 0; for (R int i = 1; i &lt;= n; ++i) inver_id[id[i]] = i; for (R int i = 1; i &lt; n; ++i) { lave_unwalked[nodes[i].x]++; lave_unwalked[nodes[i].y]++; mark[nodes[i].x][nodes[i].y] = -1; mark[nodes[i].y][nodes[i].x] = -1; header[nodes[i].x][nodes[i].y] = nodes[i].y; header[nodes[i].y][nodes[i].x] = nodes[i].x; footer[nodes[i].x][nodes[i].y] = nodes[i].y; footer[nodes[i].y][nodes[i].x] = nodes[i].x; } for (R int i = 1; i &lt;= n; ++i) { for (R int j = 1; j &lt;= n; ++j) fa[j] = 0; vis[inver_id[i]] = 1; dfs(inver_id[i], inver_id[i]); int res = 0; for (R int j = 1; j &lt;= n; ++j) { if (vis[j]) { res = j; break; } } printf(&quot;%d &quot;, res); node_from[res] = fa[res]; while (fa[res] ^ inver_id[i]) { if (~mark[fa[res]][res]) { mark[fa[res]][res] = mark[res][fa[res]] = 0; lave_in[res]--; lave_out[fa[res]]--; } else { mark[fa[res]][res] = mark[res][fa[res]] = fa[res]; lave_unwalked[res]--; lave_out[res]++; lave_unwalked[fa[res]]--; lave_in[fa[res]]++; } int t = res; res = fa[res]; header[res][footer[res][t]] = header[res][fa[res]]; footer[res][header[res][fa[res]]] = footer[res][t]; } if (~mark[fa[res]][res]) { mark[fa[res]][res] = 0; mark[res][fa[res]] = 0; lave_in[res]--; lave_out[inver_id[i]]--; } else { mark[fa[res]][res] = fa[res]; mark[res][fa[res]] = fa[res]; lave_unwalked[res]--; lave_out[res]++; lave_unwalked[inver_id[i]]--; lave_in[inver_id[i]]++; } node_to[inver_id[i]] = res; } puts(&quot;&quot;); } } å®Œæ•´ä»£ç ï¼š #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is() (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) #define R register template &lt; class Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is())) if (ch == &#39;-&#39;) f = 1; while (is()) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; class Type, class... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } const int MAXN = 2000 + 5; int T, n, max_in, id[MAXN]; int head[MAXN], nxt[MAXN &lt;&lt; 1]; int tot, in[MAXN], to[MAXN &lt;&lt; 1]; struct EdgeNode { int x, y; } nodes[MAXN]; EdgeNode make_edge(int x, int y) { EdgeNode res; res.x = x; res.y = y; return res; } void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } namespace SubtaskForce { int cmp[MAXN], ans[MAXN]; bool vis[MAXN]; void dfs(int now) { if (now == n) { for (R int i = 1; i &lt;= n; ++i) cmp[id[i]] = i; for (R int i = 1; i &lt;= n; ++i) { if (cmp[i] &lt; ans[i]) { for (R int j = 1; j &lt;= n; ++j) ans[j] = cmp[j]; break; } if (cmp[i] &gt; ans[i]) break; } return ; } for (R int i = 1; i &lt; n; ++i) { if (!vis[i]) { vis[i] = 1; swap(id[nodes[i].x], id[nodes[i].y]); dfs(now + 1); swap(id[nodes[i].x], id[nodes[i].y]); vis[i] = 0; } } } void main() { for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) ans[i] = n - i + 1; dfs(1); for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } namespace SubtaskAss { bool vis[MAXN]; int ans[MAXN]; struct UninoFindSet { int fa[MAXN]; void init(int limit) { for (R int i = 1; i &lt;= limit; ++i) fa[i] = i; } int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { x = find(x); y = find(y); if (x ^ y) fa[x] = y; } } ufs; void main() { ufs.init(n); for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) { for (R int j = 1; j &lt;= n; ++j) { if (!vis[j] &amp;&amp; (i == n || ufs.find(j) != ufs.find(id[i]))) { vis[j] = 1; ans[i] = j; ufs.merge(j, id[i]); break; } } } for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } namespace SubtaskChain { int rnk[MAXN], ans[MAXN], dfn[MAXN]; int sbc_tot, order[MAXN], vis[MAXN]; void dfs(int x, int fa) { rnk[dfn[x] = ++sbc_tot] = x; for (R int i = head[x]; i; i = nxt[i]) if (to[i] ^ fa) dfs(to[i], x); } void mark_node(int p1, int p2, int tg) { if (p1 != 1 &amp;&amp; p1 != n) order[p1] = tg + 1; if (p2 != 1 &amp;&amp; p2 != n) order[p2] = tg + 1; for (R int i = (tg ? p1 + 1 : p2 + 1); i &lt; (tg ? p2 : p1); ++i) order[i] = ((tg ^ 1) + 1); } int iterate(int x, int tg) { int res = n + 1; if (order[dfn[x]] == tg + 1) return res; for (R int i = dfn[x] + (tg ? -1 : 1); tg ? (i &gt;= 1) : (i &lt;= n); i += (tg ? -1 : 1)) { if (order[i] == (tg ^ 1) + 1) { if (!vis[i]) res = min(res, rnk[i]); break; } if (!order[i] &amp;&amp; !vis[i]) res = min(res, rnk[i]); } return res; } int inver_id[MAXN]; void main() { for (R int i = 1; i &lt;= n; ++i) rnk[i] = 0; for (R int i = 1; i &lt;= n; ++i) dfn[i] = 0; for (R int i = 1; i &lt;= n; ++i) vis[i] = 0; for (R int i = 1; i &lt;= n; ++i) order[i] = 0; for (R int i = 1; i &lt;= n; ++i) inver_id[id[i]] = i; sbc_tot = 0; for (R int i = 1; i &lt;= n; ++i) { if (in[i] == 1) { dfs(i, 0); break; } } for (R int i = 1; i &lt;= n; ++i) { int left = iterate(inver_id[i], 1); int right = iterate(inver_id[i], 0); if (left &lt; right) mark_node(dfn[inver_id[i]], dfn[left], 0); else left = right, mark_node(dfn[inver_id[i]], dfn[left], 1); ans[i] = left; vis[dfn[left]] = 1; } for (R int i = 1; i &lt;= n; ++i) printf(&quot;%d &quot;, ans[i]); puts(&quot;&quot;); } } namespace SubtaskRandom { int mark[MAXN][MAXN], inver_id[MAXN]; int lave_unwalked[MAXN], fa[MAXN]; int lave_in[MAXN], lave_out[MAXN]; int node_from[MAXN], node_to[MAXN]; int header[MAXN][MAXN], footer[MAXN][MAXN]; bool vis[MAXN]; void dfs(int x, int rt) { for (R int i = head[x]; i; i = nxt[i]) { int y = to[i]; if (y ^ fa[x]) { fa[y] = x; vis[y] = 1; if (x ^ rt) { if (mark[x][y] == x || mark[fa[x]][x] == fa[x]) vis[y] = 0; if (mark[x][y] == 0 || mark[fa[x]][x] == 0) vis[y] = 0; if (header[x][fa[x]] == node_to[x] &amp;&amp; footer[x][y] == node_from[x] &amp;&amp; lave_out[x] + lave_in[x] + (lave_unwalked[x] &lt;&lt; 1) &gt; 2) vis[y] = 0; if (footer[x][y] == fa[x]) vis[y] = 0; } else { if (mark[x][y] == x) vis[y] = 0; if (mark[x][y] == 0) vis[y] = 0; if (node_from[x]) { if (footer[x][y] == node_from[x] &amp;&amp; lave_unwalked[x] + lave_in[x] + lave_out[x] != 1) vis[y] = 0; } } vis[y] &amp;= vis[x]; dfs(y, rt); } } if (rt ^ x) { if (node_from[x]) vis[x] = 0; if (node_to[x]) { if (footer[x][node_to[x]] == fa[x] &amp;&amp; lave_unwalked[x] + lave_in[x] + lave_out[x] != 1) vis[x] = 0; } } else { vis[x] = 0; } } void main() { for (R int i = 1; i &lt;= n; ++i) node_from[i] = 0; for (R int i = 1; i &lt;= n; ++i) node_to[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_in[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_out[i] = 0; for (R int i = 1; i &lt;= n; ++i) lave_unwalked[i] = 0; for (R int i = 1; i &lt;= n; ++i) inver_id[id[i]] = i; for (R int i = 1; i &lt; n; ++i) { lave_unwalked[nodes[i].x]++; lave_unwalked[nodes[i].y]++; mark[nodes[i].x][nodes[i].y] = -1; mark[nodes[i].y][nodes[i].x] = -1; header[nodes[i].x][nodes[i].y] = nodes[i].y; header[nodes[i].y][nodes[i].x] = nodes[i].x; footer[nodes[i].x][nodes[i].y] = nodes[i].y; footer[nodes[i].y][nodes[i].x] = nodes[i].x; } for (R int i = 1; i &lt;= n; ++i) { for (R int j = 1; j &lt;= n; ++j) fa[j] = 0; vis[inver_id[i]] = 1; dfs(inver_id[i], inver_id[i]); int res = 0; for (R int j = 1; j &lt;= n; ++j) { if (vis[j]) { res = j; break; } } printf(&quot;%d &quot;, res); node_from[res] = fa[res]; while (fa[res] ^ inver_id[i]) { if (~mark[fa[res]][res]) { mark[fa[res]][res] = mark[res][fa[res]] = 0; lave_in[res]--; lave_out[fa[res]]--; } else { mark[fa[res]][res] = mark[res][fa[res]] = fa[res]; lave_unwalked[res]--; lave_out[res]++; lave_unwalked[fa[res]]--; lave_in[fa[res]]++; } int t = res; res = fa[res]; header[res][footer[res][t]] = header[res][fa[res]]; footer[res][header[res][fa[res]]] = footer[res][t]; } if (~mark[fa[res]][res]) { mark[fa[res]][res] = 0; mark[res][fa[res]] = 0; lave_in[res]--; lave_out[inver_id[i]]--; } else { mark[fa[res]][res] = fa[res]; mark[res][fa[res]] = fa[res]; lave_unwalked[res]--; lave_out[res]++; lave_unwalked[inver_id[i]]--; lave_in[inver_id[i]]++; } node_to[inver_id[i]] = res; } puts(&quot;&quot;); } } signed main() { for (read(T); T; --T) { read(n); for (R int i = 1, x; i &lt;= n; ++i) read(x), id[x] = i; for (R int i = 1; i &lt;= n; ++i) head[i] = in[i] = 0; tot = 0, max_in = 0; for (R int i = 1; i &lt; n; ++i) { int x, y; read(x, y); add(x, y); add(y, x); ++in[x], ++in[y]; nodes[i] = make_edge(x, y); max_in = max(max_in, max(in[x], in[y])); } if (n &lt;= 10) SubtaskForce::main(); else if (max_in == n - 1) SubtaskAss::main(); else if (max_in == 2) SubtaskChain::main(); else SubtaskRandom::main(); } }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","permalink":"www.orchid-any.cf/tags/å¹¶æŸ¥é›†/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"www.orchid-any.cf/tags/è´ªå¿ƒ/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œé¢˜è§£ã€å®˜æ–¹NOI Online","slug":"SOL-NOI-ONLINE","date":"2020-03-11T03:26:45.000Z","updated":"2020-03-11T03:32:48.339Z","comments":true,"path":"2020/03/11/SOL-NOI-ONLINE/","link":"","permalink":"www.orchid-any.cf/2020/03/11/SOL-NOI-ONLINE/","excerpt":"","text":"NOI-Online-T1-åºåˆ— å…¶å®è¿™é“é¢˜æ˜¯å…¨åœºæœ€éš¾çš„â€¦â€¦ æˆ‘è¿™é‡Œç»™å‡ºä¸€ç§å¹¶æŸ¥é›†çš„åšæ³•ã€‚ é¦–å…ˆæˆ‘ä»¬æŠŠæ“ä½œ2ä¸­çš„ $u$ å’Œ $v$ åˆå¹¶ å¯¹äºæ“ä½œ1æˆ‘ä»¬å¯ä»¥æŠŠä»–è½¬åŒ–ä¸ºæ“ä½œ2æ¥åšã€‚ æ¯”å¦‚æˆ‘ä»¬é’ˆå¯¹æ“ä½œ1ç»™å‡º $(u,v)$ å’Œ $(v,t)$ ä¸¤æ¡è¾¹ï¼Œå¯¹ $(u,v)$ è¿›è¡ŒåŒå¢ï¼Œå¯¹ $(v,t)$ è¿›è¡ŒåŒå‡ã€‚ è¿™æ ·å°±å˜æˆäº† $u++,tâ€”$ äº†ã€‚ ç„¶åæˆ‘ä»¬æŠŠæ“ä½œ2ç¼©ç‚¹ï¼Œç„¶åæŠŠæ“ä½œ1çš„è¾¹è¿åˆ°æ“ä½œ2ç¼©çš„ç‚¹ä¸Šã€‚ ç„¶åå¯¹æ“ä½œ1åˆå¹¶ã€‚ æ­¤æ—¶ï¼Œå›¾ä¸­çš„æ¯ä¸ªç‚¹çš„åº¦æ•°æœ€å¤šä¸ºä¸€ã€‚ é‚£ä¹ˆå¯¹äºä¸€æ¡è¾¹ $(x,y)$ å¦‚æœ $a_{x}-b_{x}=a_{y}-b_{y}$ é‚£ä¹ˆå°±æ˜¯YESï¼› å¯¹äºä¸€ä¸ªè‡ªç¯ $(x,x)$ å¦‚æœ $(a_{x}-b_{x})$ ä¸ºå¶æ•°ï¼Œé‚£ä¹ˆå°±æ˜¯YESï¼› å¯¹äºä¸€ä¸ªåº¦æ•°ä¸ºé›¶çš„ç‚¹ $x$ å¦‚æœ $a_{x}=b_{x}$ é‚£ä¹ˆå°±æ˜¯YESï¼› #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p2 == p1 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } const int MAXN = 2e5 + 5; int T, n, m, vis[MAXN]; int u[MAXN], v[MAXN]; int a[MAXN], b[MAXN]; int nxt[MAXN], to[MAXN]; int head[MAXN], tot; struct UnionFindSet { int fa[MAXN]; void init(int n) { for (int i = 1; i &lt;= n; ++i) fa[i] = i; } int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { int u = find(x); int v = find(y); if (u ^ v) { fa[v] = u; a[u] += a[v]; b[u] += b[v]; } } } ufs; void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } signed main() { for (read(T); T; --T) { read(n, m); tot = 0; memset(head, 0, sizeof head); ufs.init(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); for (int i = 1; i &lt;= n; ++i) read(b[i]); for (int i = 1, opt; i &lt;= m; ++i) { read(opt, u[i], v[i]); if (opt ^ 1) vis[i] = 1, ufs.merge(u[i], v[i]), --i, --m; } for (int i = 1; i &lt;= m; ++i) { add(ufs.find(u[i]), ufs.find(v[i])); add(ufs.find(v[i]), ufs.find(u[i])); } for (int i = 1; i &lt;= n; ++i) { int t = ufs.find(to[head[i]]); for (int x = nxt[head[i]]; x; x = nxt[x]) ufs.merge(t, ufs.find(to[x])); } for (int i = 1; i &lt;= n; ++i) { if (head[i]) { int x = ufs.find(i); int y = ufs.find(to[head[i]]); if (x ^ y) { if ((a[x] - b[x]) ^ (a[y] - b[y])) { puts(&quot;NO&quot;); goto there; } } else { if ((a[x] - b[y]) &amp; 1) { puts(&quot;NO&quot;); goto there; } } } else if (ufs.fa[i] == i) { if (a[i] ^ b[i]) { puts(&quot;NO&quot;); goto there; } } } puts(&quot;YES&quot;); there: ; } } NOI-Online-T2-å†’æ³¡æ’åºè¿™é“é¢˜æˆ‘åœ¨è€ƒåœºä¸Šçš„åšæ³•å¾ˆç„ï¼Œæœ¬æ¥æ˜¯å¥”ç€40ptsçš„éƒ¨åˆ†åˆ†å»çš„ï¼Œç»“æœçˆ†é›¶äº†(è‡³ä»Šæ²¡æ‰¾åˆ°åŸå› ) æˆ‘ä»¬è®¾ bigger_{i}=\\sum_{j=1}^{i-1}[a_{j}>a_{i}]æ˜¾ç„¶é€†åºå¯¹æ•°é‡ä¸º $\\sum bigger$ äºæ˜¯é—®é¢˜å°±è½¬åŒ–ä¸ºäº†åŠ¨æ€ç»´æŠ¤ $bigger$ã€‚ æ‰‹ç©å‡ ç»„æ•°æ®åæˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæ¯è½®å†’æ³¡ $bigger$ éƒ½ä¼šæœ‰ä¸€ä¸‹çš„å˜åŒ–ï¼š bigger_{i}=\\max\\{bigger_{i}-1,0\\}äºæ˜¯æ ‘çŠ¶æ•°ç»„ç»´æŠ¤å³å¯ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is() (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is())) if (ch == &#39;-&#39;) f = 1; while (is()) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } using namespace std; const int MAXN = 2e5 + 5; int n, m, bigger[MAXN], bucket[MAXN], a[MAXN]; long long bit[MAXN], init_inver_tot; void Update(int x, long long y) { for (; x &lt;= n; x += x &amp; -x) bit[x] += y; } long long GetAnswers(int x) { long long res = 0; for (; x; x -= x &amp; -x) res += bit[x]; return res; } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(a[i]), init_inver_tot += (bigger[i] = i - 1 - GetAnswers(a[i])), bucket[bigger[i]]++, Update(a[i], 1); memset(bit, 0, sizeof bit), Update(1, init_inver_tot), init_inver_tot = 0; for (int i = 0; i &lt; n; ++i) init_inver_tot += 1LL * bucket[i], Update(i + 1 + 1, init_inver_tot - n); for (int i = 0, op, x; i &lt; m; ++i) { read(op, x); if (n - 1 &lt; x) x = n - 1; if (op ^ 2) { if (a[x + 1] &gt; a[x]) { swap(a[x], a[x + 1]); swap(bigger[x], bigger[x + 1]); Update(1, 1); Update(bigger[x + 1]++ + 2, -1); } else { swap(a[x], a[x + 1]); swap(bigger[x], bigger[x + 1]); Update(1, -1); Update(--bigger[x] + 2, 1); } } else printf(&quot;%lld\\n&quot;, GetAnswers(x + 1)); } return 0; } NOI-Online-T3-æœ€å°ç¯å…¨åœºæœ€æ°´çš„ä¸€é“é¢˜ï¼Œä½†æ˜¯å¯æ€•çš„å¿ƒç†ä½œç”¨è¿˜æ˜¯è®©æˆ‘æ”¾å¼ƒäº†è¿™é“é¢˜ã€‚ é¦–å…ˆæœ‰ä¸€ä¸ªæ˜¾ç„¶çš„ç»“è®ºï¼Œæˆ‘ä»¬éœ€è¦æŠŠè¿™ $n$ ä¸ªæ•°åˆ†ä¸º $\\gcd(n,k)$ ä¸ªç¯ã€‚ è™½è¯´æ˜¯æ˜¾ç„¶ä½†æ˜¯ä¸ç”»ç”»å›¾è¿˜çœŸçš„ç©ä¸åŠ¨ ç»™ä¸€ä¸‹å›¾ç¤ºæ„ä¸€ä¸‹ï¼š å›¾ä¸­é‚£ä¸ªçœ‹èµ·æ¥åƒä¸ªäº”è§’æ˜Ÿçš„ä¸œè¥¿å…¶å®å°±æ˜¯ä¸ªç¯ è¿™ä¸ªå›¾ä¸­æœ‰ $\\gcd(n,k)$ ä¸ªç¯ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬çš„ç»“è®ºã€‚ å…·ä½“åˆ°å®ç°ï¼Œæˆ‘ä»¬é‡‡ç”¨çš„æ˜¯é¢„å¤„ç†å‡ºæ‰€æœ‰ç­”æ¡ˆã€‚ è¿˜æœ‰ $k=0$ çš„æƒ…å†µéœ€è¦ç‰¹æ®Šå¤„ç†ä¸€ä¸‹ #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; using namespace std; const int MAXN = 5e5 + 5; vector &lt; int &gt; integer(MAXN); vector &lt; long long &gt; ans(MAXN); int gcd(int x, int y) { return !y ? x : gcd(y, x % y); } signed main() { int n, k; scanf(&quot;%d %d&quot;, &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;integer.at(i)), ans.at(0) += (long long)integer.at(i) * (long long)integer.at(i); sort(integer.begin() + 1, integer.begin() + 1 + n); for (int i = 1; i &lt;= (n &gt;&gt; 1); ++i) { if (!(n % i)) { int t = n / i; vector &lt; int &gt; process(MAXN); int tot = 0; for (int j = 2; j &lt; t; j += 2) process.at(++tot) = j; process.at(++tot) = t; for (int j = t - 1 - (t &amp; 1); j &gt; 0; j -= 2) process.at(++tot) = j; for (int j = t + 1; j &lt;= n; ++j) process.at(j) = process.at(j - t) + t; for (int j = 1; j &lt;= n; ++j) if (!(j % t)) ans.at(i) += (long long)integer.at(process.at(j)) * (long long)integer.at(process.at(j + 1 - t)); else ans.at(i) += (long long)integer.at(process.at(j)) * (long long)(integer.at(process.at(j + 1))); } } for (int i = 0, x; i &lt; k; ++i) scanf(&quot;%d&quot;, &amp;x), printf(&quot;%lld\\n&quot;, ans.at(x ? gcd(n, x) : 0)); return 0; } æ€»ç»“ï¼ˆå…¶å®æˆ‘ä¸æ˜¯å¾ˆä¼šå†™è¿™ç©æ„å„¿ï¼‰ æœç„¶å¿ƒç†ç´ è´¨è¿˜æ˜¯ä¸è¡Œâ€¦â€¦é”™è¿‡äº†T3è¿™æ ·çš„æ°´é¢˜ã€‚ æ€»ä½“æ¥è¯´ï¼ŒæŠŠæ¡ä½æœºä¼šï¼ŒæŠŠé¢˜ç›®éƒ½å½“ä½œå¤§ç™½èœï¼ˆé›¾ï¼‰ã€‚ ç„¶åå°±æ˜¯å¤šå»åšé¢˜å§ï¼Œé¢˜é‡å¤šå°‘éƒ½ä¸å«Œå¤šã€‚ å°±è¿™æ ·ï¼ˆ æ™®åŠç»„å£èƒ¡è¯´äº†æ˜¯å£èƒ¡æ‰€ä»¥æ²¡ä»£ç ä¸ä¿è¯æ­£ç¡®/xyx è‡³äºé¢˜ç›®éš¾åº¦è¿™æ˜¯NOIOLä¸æ˜¯NOIpOLç»™äº†æ¬å‡ºé¢˜äººæ”¾é£è‡ªæˆ‘çš„ç©ºé—´ã€‚ T1ï¼šæ™®é€šNOIpæ™®åŠéš¾åº¦ï¼Œå„ä½å·¨ä½¬éšä¾¿åˆ‡ T2: åŸºç¡€å¤šé¡¹å¼ï¼Œä¼šçš„äººå°±å¾ˆå¥—è·¯ã€‚ä¸ä¼šçš„è¯å°±næ–¹dpéª—éª—åˆ† T3: è¿™é“é¢˜æˆ‘ä¸å¤ªç¡®å®šï¼Œåº”è¯¥æ˜¯Floyd+çŸ©é˜µã€‚ å®Œç»“æ’’å…­èŠ±","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"å¹¶æŸ¥é›†","slug":"å¹¶æŸ¥é›†","permalink":"www.orchid-any.cf/tags/å¹¶æŸ¥é›†/"},{"name":"æ ‘çŠ¶æ•°ç»„","slug":"æ ‘çŠ¶æ•°ç»„","permalink":"www.orchid-any.cf/tags/æ ‘çŠ¶æ•°ç»„/"},{"name":"è´ªå¿ƒ","slug":"è´ªå¿ƒ","permalink":"www.orchid-any.cf/tags/è´ªå¿ƒ/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P1852è·³è·³æ£‹","slug":"SOL-P1852","date":"2020-03-05T10:45:54.000Z","updated":"2020-03-05T10:52:12.393Z","comments":true,"path":"2020/03/05/SOL-P1852/","link":"","permalink":"www.orchid-any.cf/2020/03/05/SOL-P1852/","excerpt":"","text":"é¢˜æ„ç®€è¿°åœ¨ä¸€ä¸ªæ•°è½´ä¸Šç»™ä½ ä¸‰ä¸ªç‚¹ï¼Œç§»åŠ¨æ–¹æ³•æ˜¯å½¼æ­¤ä¸ºä¸­ç‚¹è¿›è¡Œè·³è·ƒï¼Œä¸èƒ½åŒæ—¶è¶Šè¿‡ä¸¤é¢—æ£‹å­ã€‚ ç»™å‡ºåˆå§‹çŠ¶æ€å’Œç›®æ ‡çŠ¶æ€ï¼Œé—®èƒ½å¦ä»åˆå§‹çŠ¶æ€è·³åˆ°ç›®æ ‡çŠ¶æ€ã€‚è‹¥èƒ½ï¼Œè¾“å‡ºæœ€å°‘æ­¥æ•°ã€‚ æ£‹å­ä¹‹é—´äº’ç›¸æ²¡æœ‰å·®åˆ«ã€‚ é¢˜è§£è¿™é“é¢˜æ˜¯æˆ‘ä»¬å»å¹´å­¦å€å¢çš„æ—¶å€™LFç»™æˆ‘ä»¬æ”¾çš„ä¸€é“é¢˜ï¼ˆå®é™…ä¸Šå’Œå€å¢æ²¡æœ‰åŠæ¯›é’±çš„å…³ç³»ã€‚ å•Šå¯¹æˆ‘å°±æ˜¯ä¸€é“é¢˜ä»å»å¹´åšåˆ°ä»Šå¹´ï¼ˆæˆ‘ä¸ç®¡åšå‡ºæ¥äº†å°±æ˜¯æˆ‘çš„é¢˜é‡XD/xyx ä¸æ‰¯äº†è¯´æ­£äº‹å„¿ã€‚ å…¶å®æ‹¿åˆ°è¿™é“é¢˜æˆ‘æ˜¯å¾ˆæ‡µçš„ï¼Œå®Œå…¨ä¸çŸ¥é“è¯¥æ€ä¹ˆå…¥æ‰‹ã€‚ ç„¶åæˆ‘ä»¬æ‹¿å‡ºä¼ ç»Ÿæ‰‹è‰ºæ‰‹ç©æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥å‘ç°å¯¹äºä¸€ä¸ªä¸‰å…ƒç»„ $(x,y,z)$ åªæœ‰ä¸‰ç§ç§»åŠ¨çš„æ–¹æ¡ˆï¼š ï¼ˆå•Šå¯¹äº†ï¼Œè¯´ä¸€ä¸‹è¿™é‡Œçš„ä¸‰å…ƒç»„è¡¨ç¤ºçš„æ˜¯ä¸€ç§ä½ç½®å…³ç³»ï¼Œå³ $x$ åœ¨å·¦ $y$ åœ¨ä¸­é—´ $z$ åœ¨å³ï¼‰ ä¸­é—´å¾€ä¸¤è¾¹è·³ $y$ ä»¥ $x$ ä¸ºä¸­ç‚¹è¿›è¡Œè·³è·ƒï¼Œä¸‰å…ƒç»„å˜ä¸ºï¼š$(x-(y-x),x,z)\\implies(2x-y,x,z)$ $y$ ä»¥ $z$ ä¸ºä¸­ç‚¹è¿›è¡Œè·³è·ƒï¼Œä¸‰å…ƒç»„å˜ä¸ºï¼š$(x,z,z+(z-y))\\implies(x,z,2z-y)$ ä¸¤è¾¹å¾€ä¸­é—´è·³ è¿™é‡Œæ–¹ä¾¿è®¨è®ºæˆ‘ä»¬ä¸å¦¨è®¾ $dis_{1}$ ä¸º $x$ å’Œ $y$ ä¹‹é—´çš„è·ç¦»ï¼Œ$dis_{2}$ ä¸º $y$ å’Œ $z$ ä¹‹é—´çš„è·ç¦»ã€‚ å½“ $dis_{1} &gt; dis_{2}$ $x$ ä»¥ $y$ ä¸ºä¸­ç‚¹è¿›è¡Œè·³è·ƒï¼Œä¸‰å…ƒç»„å˜ä¸ºï¼š$(y,y+dis_{1},z)\\implies(y,2y-x,z)$ å½“ $dis_{1} &lt; dis_{2}$ $z$ ä»¥ $y$ ä¸ºä¸­ç‚¹è¿›è¡Œè·³è·ƒï¼Œä¸‰å…ƒç»„å˜ä¸ºï¼š$(x,y-dis_{2},y)\\implies(x,2y-z,y)$ å½“ $dis_{1}=dis_{2}$ æ— æ³•ç»§ç»­è·³ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„è¾¹ç•Œã€‚ å¥½ï¼Œç°åœ¨æŠŠæ‰€æœ‰æˆ‘ä»¬å·²çŸ¥çš„æ¡ä»¶ä¸²èµ·æ¥çœ‹ï¼šè¿™ä¸å°±æ˜¯ä¸€æ£µäºŒå‰æ ‘å—ï¼Ÿ å¯¹å‘€ï¼Œè¿™å°±æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼ˆæˆ‘åœ¨è¯´ä»€ä¹ˆ ä¸ºä»€ä¹ˆè¿™ä¸€å®šæ˜¯ä¸€æ£µæ ‘å‘¢ï¼Ÿæƒ³ä¸€æƒ³å°±æ˜ç™½äº†ï¼Œå°±åƒæ•°å­¦ä¸­çš„æ”¶æ•›ä¸€æ ·ï¼Œæœ€åä¸€å®šä¼šå‡ºç° $dis_{1}=dis_{2}$ çš„æƒ…å†µã€‚ è€Œä¸”è¿™æ£µæ ‘æ˜¯å”¯ä¸€ç¡®å®šçš„ã€‚ é‚£ä¹ˆè¿™é“é¢˜çš„ç­”æ¡ˆæ˜¯ä»€ä¹ˆå°±å¾ˆæ˜ç¡®äº†ã€‚ é¦–å…ˆåˆ¤æ–­YESæˆ–NOçš„æƒ…å†µæˆ‘ä»¬åªéœ€è¦åˆ¤æ–­åˆå§‹çŠ¶æ€å’Œç›®æ ‡çŠ¶æ€æ˜¯å¦åœ¨ç»Ÿä¸€æ£µçŠ¶æ€æ ‘ä¸Šå³å¯ã€‚ æœ€å°çš„æ­¥æ•°å°±æ˜¯ä»–ä»¬ä¸¤ä¸ªåœ¨æ ‘ä¸Šçš„è·ç¦»ã€‚ æš´åŠ›è‚¯å®šæ˜¯ä¸å¯å–çš„ã€‚ ä½†æ˜¯æˆ‘ä»¬å¯ä»¥é€šè¿‡æ¨¡æ‹Ÿæš´åŠ›çš„æƒ…æ™¯æ¥å¾—åˆ°ä¼˜åŒ–çš„ç­–ç•¥ã€‚ æ¯”å¦‚æˆ‘ä»¬æ€è€ƒä¸€ä¸ªæ•°æ®ï¼š$x,y,z$ã€‚ å…¶ä¸­ $y$ æ˜¯ä¸€ä¸ª è¿œå¤§äº $x$ çš„æ•°ã€‚ æ–¹ä¾¿èµ·è§æˆ‘ä»¬ä»¤ $z=y+1$ æš´åŠ›æ­¤æ—¶ä¼šä¸åœçš„è®© $z$ ä»¥ $y$ ä¸ºä¸­ç‚¹è·³ã€‚ æ­¤æ—¶æˆ‘ä»¬å›é¡¾ä¸€ä¸‹é¢˜é¢ï¼š æ£‹å­ä¹‹é—´äº’ç›¸æ²¡æœ‰å·®åˆ«ã€‚ æ²¡é”™ï¼Œæ¯é¢—æ£‹å­ä¹‹é—´å…¶å®æ˜¯æ²¡æœ‰ä»»ä½•å·®åˆ«çš„ã€‚ æ‰“ä¸ªæ¯”æ–¹è¯´ï¼Œç°åœ¨ $z$ ä»¥ $y$ ä¸ºä¸­ç‚¹è¿›è¡Œäº†è·³è·ƒï¼Œå…¶æœ¬è´¨å°±æ˜¯ $z$ å’Œ $y$ ä¸€èµ·å¾€å·¦å¹³ç§»äº† $z-y$ æ­¥ã€‚ è¿™å°±æ„å‘³ç€ï¼Œæˆ‘ä»¬ä¸éœ€è¦è€è€å®å®çš„æ¯æ¬¡éƒ½è·³ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è·å¾— $z$ è·³è·ƒçš„æ¬¡æ•°å³ $(y-x)\\div(z-y)$ æ¬¡ã€‚ å†æ¨ä¸€ä¸‹å°±æ˜¯æ¬§å‡ é‡Œå¾—æœ€å¤§å…¬çº¦æ•°çš„å½¢å¼äº†ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬åœ¨ $log_{2}$ çš„å¤æ‚åº¦è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚ æœ€åäºŒåˆ†ä¸€ä¸‹åˆ°LCAçš„è·ç¦»ï¼Œè¿™é“é¢˜å°±è¢«ä½ æš´åˆ‡å•¦ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; int a, b, c; int x, y, z; void sort(int&amp; x, int&amp; y, int&amp; z) { vector &lt; int &gt; vec; vec.push_back(x); vec.push_back(y); vec.push_back(z); sort(vec.begin(), vec.end()); x = vec[0], y = vec[1], z = vec[2]; } void Initialization() { scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c); scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); sort(a, b, c); sort(x, y, z); } int GetRoot(int&amp; x, int&amp; y, int&amp; z) { int dis1 = y - x; int dis2 = z - y; if (dis1 ^ dis2) { int temp; if (dis1 &lt; dis2) { temp = dis2 / dis1; if (!(dis2 % dis1)) --temp; x += temp * dis1; y += temp * dis1; } else { temp = dis1 / dis2; if (!(dis1 % dis2)) --temp; z -= temp * dis2; y -= temp * dis2; } return temp + GetRoot(x, y, z); } else return 0; } void ArriveK(int&amp; x, int&amp; y, int&amp; z, int key) { int dis1 = y - x; int dis2 = z - y; if (dis1 &lt; dis2) { int temp = dis2 / dis1; if (!(dis2 % dis1)) --temp; if (temp &gt;= key) { x += key * dis1; y += key * dis1; } else { x += temp * dis1; y += temp * dis1; ArriveK(x, y, z, key - temp); } } else { int temp = dis1 / dis2; if (!(dis1 % dis2)) --temp; if (temp &gt;= key) { z -= key * dis2; y -= key * dis2; } else { z -= temp * dis2; y -= temp * dis2; ArriveK(x, y, z, key - temp); } } } signed main() { Initialization(); int a0 = a, b0 = b; int c0 = c, x0 = x; int y0 = y, z0 = z; int rt1 = GetRoot(x0, y0, z0); int rt2 = GetRoot(a0, b0, c0); if (a0 ^ x0 || b0 ^ y0 || c0 ^ z0) return puts(&quot;NO&quot;) &amp; 0; if (rt1 &lt; rt2) ArriveK(a, b, c, rt2 - rt1); else ArriveK(x, y, z, rt1 - rt2); int l = 0, r = min(rt1, rt2); while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; a0 = a, b0 = b, c0 = c; x0 = x, y0 = y, z0 = z; ArriveK(x0, y0, z0, mid); ArriveK(a0, b0, c0, mid); if (x0 == a0 &amp;&amp; y0 == b0 &amp;&amp; z0 == c0) r = mid; else l = mid + 1; } printf(&quot;YES\\n%d\\n&quot;, max(rt1, rt2) - min(rt1, rt2) + (l &lt;&lt; 1)); return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"äºŒåˆ†","slug":"äºŒåˆ†","permalink":"www.orchid-any.cf/tags/äºŒåˆ†/"},{"name":"LCA","slug":"LCA","permalink":"www.orchid-any.cf/tags/LCA/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œæ‚é¡¹ã€èŠæ–‹å¿—æ—¥å¸¸","slug":"OTHE-DIARY","date":"2020-02-27T08:59:38.000Z","updated":"2020-04-13T08:23:52.418Z","comments":true,"path":"2020/02/27/OTHE-DIARY/","link":"","permalink":"www.orchid-any.cf/2020/02/27/OTHE-DIARY/","excerpt":"","text":"æ— èŠæå‡ºæ¥çš„ï¼Ÿ å¯èƒ½æ˜¯ç”¨æ¥è®°å½•è‡ªå·±çš„æˆå¤©è¢«è™çš„å¿ƒè·¯å†ç¨‹å§ åæ­£æ²¡å¿ƒæ²¡è‚ºå°±å¯¹äº† ä¹Ÿå¯ä»¥ç®€å•ç†è§£ä¸ºæ—¥è®°ï¼Ÿ æ€»ä¹‹å¾ˆæ— èŠå°±å¯¹äº†â€¦â€¦è’Ÿè’»çš„æ—¥å¸¸æ²¡ä»€ä¹ˆå¯çœ‹çš„ 2020.2.4å•Šå•Šå•Šåšå®¢è®¿é—®æ…¢æ­»äº†ï¼Œå·²ç»è¢«åŒæœºæˆ¿åæ§½çš„ä½“æ— å®Œè‚¤äº†â€¦â€¦ ç”¨äº†ä¸€ä¸‹jsDeliveråŠ é€Ÿå¥½åƒç”¨å¤„ä¸å¤§â€¦â€¦ ä½†æ˜¯æœ¬åœ°ç®¡ç†å›¾ç‰‡è¿˜æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼ˆä»å›¾åºŠæŠŠå›¾ç‰‡æ¬ä¸‹æ¥å°±èŠ±äº†ä¸å°‘åŠ›æ°” å¯¹äº†ï¼Œå®‰åˆ©ä¸€ä¸‹ä¸€ä¸ªç½‘é¡µå›¾ç‰‡æ‰¹é‡ä¸‹è½½chromeæ‰©å±•ï¼šFatkun èƒ–å¤ï¼Ÿ 2020.2.29æˆåŠŸç”¨åŠ¨æ€å¼€ç‚¹æ°´è¿‡ä¸»å¸­æ ‘â€¦â€¦ ï¼ˆæˆ‘å¥½åƒå°±æ²¡æœ‰æ‰“è¿‡ä»€ä¹ˆæ­£ç»é¢˜ ç®—äº†ç®—äº†å‡†å¤‡ä¸€ä¸‹ä¸‹åˆ%ä½ èµ›å§ â€¦â€¦ 220ptsè¢«è™åˆ°rnk3ï¼Œæˆ‘æœç„¶è¿˜æ˜¯å¤ªèœäº†â€¦â€¦ 2020.3.1è·‘åˆ°åˆä¸€çš„æ¨¡æ‹Ÿèµ›å»ç©äº†ä¸€ä¸‹ï¼ˆæˆ‘ä¸ä¹Ÿæ˜¯åˆä¸€çš„å—ï¼‰ç„¶åAKåæ„Ÿå—åˆ°äº†å¿«ä¹ï¼ˆæˆ‘å†…å¿ƒæ‰­æ›²ï¼Ÿï¼‰ æ™šä¸Šæ´›è°·Ratedèµ›å¼€é¢˜T1ç§’åˆ‡ï¼Œç„¶åå°±å¼€å§‹è¯»ä¸æ‡‚é¢˜é¢äº†â€¦â€¦ï¼ˆæˆ‘å‘é‡ç™½å­¦äº†å˜¤å˜¤å˜¤ è‡ªé—­äº†è‡ªé—­äº† 2020.3.2æˆ‘å†³å®šäº†ï¼ æˆ‘è¦æŠŠæ´›è°·å†å¹´NOIpTGçš„dpèƒ½åšçš„å°½é‡åšäº†ï¼ ï¼ˆè°è®©æˆ‘dpèœæ­»äº†å‘¢ èƒ½åšå¤šå°‘çœ‹è¿æ°” ds100på¯èƒ½ä»æ­¤æ›´æ–°æ¯”è¾ƒæ…¢äº†â€¦â€¦ï¼ˆç»å¯¹ä¸å’•ï¼ 2020.3.3å»åˆä¸‰å­¦é•¿çš„æ¨¡æ‹Ÿèµ›æ··äº†ä¸€ä¸‹ï¼Œé™¤äº†T1å‚»é€¼çŸ©é˜µéšä¾¿åˆ‡ä»¥å¤–T2T3é¢˜ç›®çœ‹ç€å¾ˆé«˜çº§äºæ˜¯æˆ‘å†³å®šæ”¾å¼ƒâ€¦â€¦ ä»€ä¹ˆå¿ƒæ€â€¦â€¦ å‹‰å¼ºè¿‡äº†ä¸¤é“é¢˜è¿˜å‰©ä¸€é“ä¸çŸ¥é“æ˜¯ä¸ªä»€ä¹ˆã€‚ï¼ˆæˆ‘è¿˜æ˜¯å¤ªå¼±äº† åšä½œä¸šå‘ç°çª—å¤–å·æ‹çš„è€çˆ¹ä¸€åç„¶åçˆ¶å­ä¸Šæ¼”äº†ä¸€åœºæ‘”â™‚è·¤å¤§æˆ 2020.3.4è¡¥å®Œä¿ºå¦¹è¿‡åæ„Ÿè§‰æ•‘ä¸å›æ¥äº†ï¼šï¼‰ï¼šï¼ˆå…¥å‘äº†å°±æ•‘ä¸å›æ¥äº†ï¼šï¼ˆä½†æ˜¯æˆ‘æ€»ç®—å‡ºäº†è½»ç™¾åˆçš„å‘ è¡¥å®Œé’æ˜¥çŒªå¤´æ„Ÿè§‰ä¹Ÿæ•‘ä¸å›æ¥äº†ï¼šï¼‰ï¼šï¼ˆåŒæ—¶å…¥ä¸¤ä¸ªå‘æ„Ÿè§‰å¾ˆæ£’ï¼Ÿ 2020.3.5ä»Šå¤©è¢«é»„é‡‘æ‹¼å›¾æ•‘å›æ¥äº†ï¼Ÿç¥TMç«‹åœºåšå®š å¼ºæ¨é»„é‡‘æ‹¼å›¾å•Šå•Šå•Šï¼Œä¸ªäººè§‰å¾—ç”šè‡³æ¯”ç‚¹å…”æ›´æ¥è¿‘æˆ‘çš„å£å‘³ï¼ˆ LJSé‚£ä¸ªè½»ç™¾åˆæ§å±…ç„¶åœ¨ä¸€ä¸‹çœ‹å®Œä¸€å­£è¿‡åå‘Šè¯‰æˆ‘æ— æ„Ÿâ€¦â€¦ æ²¡é”™ï¼Œçœ‹å®Œæ•´æ•´ä¸€å­£æ‰å‘Šè¯‰æˆ‘æ— æ„Ÿâ€¦â€¦ï¼ˆ** å•Šå“ˆå“ˆï¼Œå»å¹´åšåˆ°ä»Šå¹´çš„é¢˜ç»ˆäºè§£å†³äº†ï¼Œæˆ‘å¥½é«˜å…´å•Šå•Šå“ˆå“ˆâ€¦â€¦ 2020.3.7é ï¼Œä»Šå¤©NOI Onlineç»“æœæ‰“ä¸ªå¡ç›´æ¥å¤§å‡¶â€¦â€¦ wdnmdåƒåœ¾CCFå°±èˆä¸å¾—ä¹°ä¸ªå¥½ç‚¹çš„æœåŠ¡å™¨ 2020.3.8æˆ‘ç°åœ¨åªæƒ³æŠŠæˆ‘çš„èº«ä»½è¯æ‘”åˆ°LJSè„¸ä¸Šè®©å¥¹å¥½å¥½çœ‹çœ‹æ€§åˆ«ç”·ä¸‰ä¸ªå¤§å­—â€¦â€¦ 2020.3.9äººç”Ÿç¬¬ä¸€æ¬¡åˆ Qå¥½å‹ æ€ä¹ˆè¯´å‘¢ã€‚å¤§æ¦‚å°±æ˜¯ä¸€ç§å¾ˆå¤±æœ›çš„æ„Ÿè§‰å§ã€‚ æ¯•ä¸šä¹‹å‰æ˜æ˜éƒ½è¿˜å¥½å¥½çš„ï¼Œæ¯•ä¸šåå°±æš´éœ²æœ¬æ€§äº†ï¼Ÿ å”‰ã€‚ 2020.3.14å’•äº†å¥½ä¹…å•Šï¼ˆï¼ˆ Hæ®µå­å­¦ç”Ÿä¼šä»¤äººå¿«ä¹ï¼ˆï¼ˆ çœ‹å®Œç¬¬ä¸€å­£å‘ç°æœ‰ç¬¬äºŒå­£ï¼› çœ‹å®Œç¬¬äºŒå­£å‘ç°æœ‰OVAï¼› çœ‹å®ŒOVAå‘ç°è¿˜æœ‰OADï¼› çœ‹å®ŒOADå‘ç°è¿˜TMæœ‰å‰§åœºç‰ˆã€‚ è¿™ç§å¿«ä¹ï¼ï¼ï¼ å¼ºæ¨uToolså¤ªæ–¹ä¾¿äº†å•Šï¼ 2020.3.17å½“æ•°å­¦ç«èµ›å’Œå¸¸è§„æé«˜åˆ†å¼€åï¼Œæˆ‘æ¯å¤©éƒ½é¢å¯¹ç€ä¸¤ä»½ä½œä¸šè‡ªæ¯™â€¦â€¦ 2020.3.19Westlifeã€One Republicã€The Scoreã€‚ 2020.3.21æˆ‘ä½“ä¼šåˆ°äº†æš´ç®—çš„å¿«ä¹ã€‚ æˆ‘TMæ•´ä¸ªäººéƒ½å‚»é€¼äº†å¥½å—ã€‚ 2020.3.26ç»è¿‡æˆ‘æ— æ•°æ¬¡è¯•éªŒæˆ‘å‘ç°æˆ‘èƒ½æ¥å—çš„æœ€å·®ç”»é£å°±æ˜¯æˆ‘æœ‹å‹å¾ˆå°‘â€¦â€¦ 2020.3.27ä½ ä»¬éƒ½è¦02å—ï¼Ÿé‚£æˆ‘æŠŠè“è¦èµ°å•¦ï¼ˆï¼ˆ è‰¹ä¸ºä»€ä¹ˆç»“å±€è“è·Ÿäº†äº”éƒå•Šå•Šå•Šåˆ¶ä½œç»„ä½ ç²—æ¥ï¼ï¼ï¼ ï¼ˆæ— èƒ½ç‹‚æ€’.webp æˆ‘ä¸ç®¡æˆ‘è¦çœ‹å¹¿å’Œè“å‘ç³–ï¼ï¼ï¼ 2020.3.28æˆ‘ç¥ˆç¥·é¾™ç‹å·¥æœ‰ç¬¬äºŒå­£ã€‚ã€‚ã€‚ã€‚ã€‚ã€‚ å°é¢é•‡æ¥¼ï¼ 2020.4.6å’•äº†å¥½ä¹…å•Šã€‚ åŒç³»ç»Ÿæ„Ÿè§‰å¾ˆèˆ’æœï¼ŒUbuntuå¾ˆå¥½åº·ï¼ˆï¼ˆï¼ˆ 2020.4.12å…‰ã‚‹ãªã‚‹ä¸€ç”Ÿæ¨ã€‚ 2020.4.13å•Šâ€¦â€¦ å¥½å›°å•Šâ€¦â€¦","categories":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}],"tags":[{"name":"æ—¥å¸¸","slug":"æ—¥å¸¸","permalink":"www.orchid-any.cf/tags/æ—¥å¸¸/"}],"keywords":[{"name":"Others","slug":"Others","permalink":"www.orchid-any.cf/categories/Others/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P2044éšæœºæ•°ç”Ÿæˆå™¨","slug":"SOL-P2044","date":"2020-02-20T07:51:05.000Z","updated":"2020-02-21T14:28:56.215Z","comments":true,"path":"2020/02/20/SOL-P2044/","link":"","permalink":"www.orchid-any.cf/2020/02/20/SOL-P2044/","excerpt":"","text":"é¢˜æ„ç®€è¿°ç»™ä½ ä¸€ä¸ªé€’æ¨å¼ï¼Œè®©ä½ æ±‚æŸä¸€é¡¹çš„å€¼æ¨¡ä¸Š $g$ã€‚ é¢˜è§£è¿™é“é¢˜æ­£è§£æ˜¯çŸ©é˜µã€‚æˆ‘è¿™é‡Œç»™å‡ºä¸€ç§åˆ†æ²»çš„åšæ³•ã€‚ é¢˜ç›®ä¸­è¯´ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $X_{i}=(a\\times X_{i-1}+c)\\ \\mathrm{mod}\\ m$ æˆ‘ä»¬å…ˆå¾€ä¸‹æ¨ä¸€æ­¥ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $X_{i-1}=(a\\times X_{i-2}+c)\\ \\mathrm{mod}\\ m$ æˆ‘ä»¬æŠŠè¿™ä¸ªå¼å­ä»£å…¥åˆ°åŸå¼ï¼Œå¾—åˆ° $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $X_{i}$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=(a\\times X_{i-1}+c)\\ \\mathrm{mod}\\ m$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=(a\\times(a\\times X_{i-2}+c)+c)\\ \\mathrm{mod}\\ m$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=a^{2}\\times X_{i-2}+c\\times(a+1)\\ \\mathrm{mod}\\ m$ æŒ‰ç…§è¿™ä¸ªå¥—è·¯æ¨ä¸‹å»ï¼Œæœ€åå¾—åˆ°ï¼š $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $X_{i}=a^{i}\\times X_{0}+c\\times(a^{i-1}+a^{i-2}+\\cdots+a+1)$ $a^{i}\\times X_{0}$ å¾ˆå¥½å¾—åˆ°ï¼Œç›´æ¥å¤§åŠ›å¿«é€Ÿå¹‚ï¼Œå†ä¹˜ä¸Š $X_{0}$ å³å¯ã€‚ æˆ‘ä»¬æ¥ç€æ¥çœ‹åé¢çš„ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $c\\times(a^{i-1}+a^{i-2}+\\cdots+a+1)$ å…ˆä¸è¦çœ‹ $c$ï¼Œå³ã€‚ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $a^{i-1}+a^{i-2}+\\cdots+a+1$ ç›¸ä¿¡å¤§å®¶éƒ½å­¦è¿‡å› å¼åˆ†è§£ï¼Œå¯¹äºè¿™æ ·çš„å¼å­è¿›è¡Œå› å¼åˆ†è§£ç®€ç›´å†å®¹æ˜“ä¸è¿‡äº†ã€‚å¦‚æœæœ€é«˜æ¬¡ä¸ºå¥‡æ•°æ¬¡ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ç›´æ¥ä¸¤ä¸¤åˆ†ç»„ï¼Œå°±å¯ä»¥æå‡ºæ¥ï¼Œå³ï¼š $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $a^{i-1}+a^{i-2}+\\cdots+a+1$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=(a^{i-1}+a^{i-2})+(a^{i-3}+a^{i-4})+\\cdots+(a+1)$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=a^{i-2}\\times(a+1)+a^{i-4}\\times(a+1)+\\cdots+(a+1)$ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $\\ \\ \\ \\ \\ \\ \\ $ $=(a+1)\\times(a^{i-2}+a^{i-4}+\\cdots+a^{2}+1)$ è¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ä¸€ç›´é€’å½’åˆ†æ²»ä¸‹å»è§£å†³é—®é¢˜äº†ï¼Œæœ€åå†ä¹˜ä¸Šä¸€ä¸ª $C$ å³å¯ã€‚ è‡³äºæœ€é«˜æ¬¡ä¸ºå¶æ¬¡å°±ç›´æ¥å•ç‹¬æå‡ºæ¥å¤§åŠ›å¿«é€Ÿå¹‚å³å¯ã€‚ è¿˜æœ‰ä¸€ä¸ªç»†èŠ‚ï¼Œè¿™é“é¢˜çš„ä¹˜æ³•å¸¸æ•°è¿‡å¤§ï¼Œéœ€è¦ç”¨â€œå¿«é€Ÿä¹˜â€ã€‚å…¶å®è·Ÿå¿«é€Ÿå¹‚å·®ä¸å¤šã€‚ #include &lt;cstdio&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } typedef long long LL; LL MOD, a, c, X0, n, g; LL fast_mul(LL x, LL y) { LL res = 0; for (; y; y &gt;&gt;= 1, x = (x + x) % MOD) if (y &amp; 1) res = (res + x) % MOD; return res % MOD; } LL fast_pow(LL x, LL y) { LL res = 1; for (; y; y &gt;&gt;= 1, x = fast_mul(x, x)) if (y &amp; 1) res = fast_mul(res, x); return res % MOD; } LL get_sum(LL x, LL y) { if (y == 0) return 1; else if (y == 1) return (x + 1) % MOD; else if (y &amp; 1) return fast_mul((fast_pow(x, (y &gt;&gt; 1) + 1) % MOD + 1) % MOD, get_sum(x, y &gt;&gt; 1) % MOD) % MOD; else return fast_mul((fast_pow(x, y &gt;&gt; 1) + 1) % MOD, get_sum(x, (y &gt;&gt; 1) - 1) % MOD) % MOD + fast_pow(x, y) % MOD; } signed main() { read(MOD, a, c, X0, n, g); X0 %= MOD; printf(&quot;%lld\\n&quot;, (fast_mul(fast_pow(a, n) % MOD, X0) % MOD + fast_mul(get_sum(a, n - 1) % MOD, c % MOD) % MOD) % MOD % g); return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"åˆ†æ²»","slug":"åˆ†æ²»","permalink":"www.orchid-any.cf/tags/åˆ†æ²»/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P3267ä¾¦å¯Ÿå®ˆå«","slug":"SOL-P3267","date":"2020-02-18T12:02:53.000Z","updated":"2020-02-20T03:02:50.267Z","comments":true,"path":"2020/02/18/SOL-P3267/","link":"","permalink":"www.orchid-any.cf/2020/02/18/SOL-P3267/","excerpt":"","text":"é¢˜æ„ç®€è¿°ç»™ä½ ä¸€æ£µæ ‘ï¼Œæ”¾ç½®å®ˆå«åœ¨æŸä¸ªç‚¹ä¸Šé¢éœ€è¦ä¸€å®šä»£ä»·å’Œä¸€å®šçš„æœ‰æ•ˆèŒƒå›´ã€‚è®©ä½ è¦†ç›–è‹¥å¹²æŒ‡å®šç‚¹ï¼Œæ±‚æœ€å°ä»£ä»· é¢˜è§£ç®—æ³•æ ‡ç­¾ï¼š$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ æ ‘DPDPçŠ¶æ€å®šä¹‰:$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ è¯´å®è¯è¿™é“é¢˜å®šçŠ¶æ€ä¸å¥½å®šã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ é‚£ä¹ˆæˆ‘ä»¬ä»å¤´æ¥çœ‹ï¼Œå½“ $d =0$ çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±æ˜¯åœ¨æ±‚æ ‘çš„æœ€å¤§ç‹¬ç«‹é›†ï¼Œå®šä¹‰æ˜¾è€Œæ˜“è§ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $d\\neq 0$ æˆ‘ä»¬å¯ä»¥ç…§æ¬åŸæ¥çš„å®šä¹‰ï¼ŒæŠŠå®ƒæ‰©å±•ä¸€ä¸‹ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $f_{i,j}$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘å·²ç»å®Œå…¨è¢«è¦†ç›–è®©ç„¶åè¿˜èƒ½å‘ä¸Šè¦†ç›– $j$ å±‚çš„æœ€å°ä»£ä»· $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $g_{i,j}=$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘è¿˜æœ‰ $j$ å±‚æ²¡æœ‰è¦†ç›–çš„æœ€å°ä»£ä»· $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ éœ€è¦æ³¨æ„çš„æ˜¯ $j$ æœ¬è´¨ä¸Šæ˜¯å¸¦æœ‰æ–¹å‘æ€§çš„ï¼Œå¯ä»¥ç±»æ¯”å‘é‡çš„æ¦‚å¿µã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ è¾¹ç•Œæ¡ä»¶å¾ˆæ˜¾ç„¶ï¼Œ$f_{i,0}=val_{i}$ æ­¤æ—¶å½“å‰ç»“ç‚¹éœ€è¦è¢«è¦†ç›–ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ å…¶ä»–æƒ…å†µï¼š \\begin{cases} f_{i,j}=val_{i},j\\in [1,d] \\\\ \\displaystyle f_{i,j}=\\infty,j=d+1 \\end{cases}$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ çŠ¶æ€è½¬ç§»æ–¹ç¨‹å€’æ˜¯æ¯”è¾ƒå¥½æƒ³ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } int val[500005], f[500005][25]; int g[500005][25], vis[500005]; int n, m, d, tot, head[500005]; int nxt[1000005], to[1000005]; std::vector &lt; std::vector &lt; int &gt; &gt; G(500005); void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; G[x].push_back(y); G[y].push_back(x); } void DP(int x, int fa) { if (vis[x]) g[x][0] = f[x][0] = val[x]; for (int i = 1; i &lt;= d; ++i) f[x][i] = val[x]; f[x][d + 1] = 0x3f3f3f3f; for (int i = head[x]; i; i = nxt[i]) { int y = to[i]; if (y ^ fa) { DP(y, x); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[y][j + 1] + g[x][j + 1], f[x][j] + g[y][j]); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[x][j + 1], f[x][j]); g[x][0] = f[x][0]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] += g[y][j - 1]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] = std::min(g[x][j - 1], g[x][j]); } } } signed main() { read(n, d); for (int i = 1; i &lt;= n; ++i) read(val[i]); read(m); for (int i = 0, x; i &lt; m; ++i) read(x), vis[x] = 1; for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); DP(1, 0); printf(&quot;%d\\n&quot;, g[1][0]); }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"www.orchid-any.cf/tags/åŠ¨æ€è§„åˆ’/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P2000æ‹¯æ•‘ä¸–ç•Œ","slug":"SOL-P2000","date":"2020-02-16T01:46:20.000Z","updated":"2020-02-20T02:48:47.143Z","comments":true,"path":"2020/02/16/SOL-P2000/","link":"","permalink":"www.orchid-any.cf/2020/02/16/SOL-P2000/","excerpt":"","text":"ç”Ÿæˆå‡½æ•°è£¸é¢˜ã€‚ æŠŠæ‰€æœ‰æƒ…å†µç½—åˆ—å‡ºæ¥: kkk: é‡‘: $1+x^6+x^{12}+\\dots=\\frac{1}{1-x^6}$ æœ¨: $1+x+x^2+\\dots+x^9=\\frac{1-x^{10}}{1-x}$ æ°´å—: $1+x+x^2+\\dots+x^5=\\frac{1-x^6}{1-x}$ ç«: $1+x^4+x^8+\\dots=\\frac{1}{1-x^4}$ åœŸ: $1+x+x^2+\\dots+x^7=\\frac{1-x^8}{1-x}$ lzn: é‡‘: $1+x^2+x^4+\\dots=\\frac{1}{1-x^2}$ æœ¨: $1+x=\\frac{1-x^2}{1-x}$ æ°´: $1+x^8+x^{16}+\\dots=\\frac{1}{1-x^8}$ ç«: $1+x^{10}+x^{20}+\\dots=\\frac{1}{1-x^{10}}$ åœŸ: $1+x+x^2+x^3=\\frac{1-x^4}{1-x}$ å‡‰å¿ƒå‡ºé¢˜äººå‹å¥½çš„å¡äº†ç²¾åº¦å¹¶ä¸”é¡ºä¾¿å¡äº†pypyã€‚æ‰€ä»¥ï¼Œäººç”Ÿè‹¦çŸ­ï¼ŒRubyç”¨æˆ‘ n = gets.to_i print (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"www.orchid-any.cf/tags/æ•°å­¦/"},{"name":"ç”Ÿæˆå‡½æ•°","slug":"ç”Ÿæˆå‡½æ•°","permalink":"www.orchid-any.cf/tags/ç”Ÿæˆå‡½æ•°/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 91~100é¢˜","slug":"DS100P-91-100-P","date":"2020-02-08T06:03:45.000Z","updated":"2020-02-18T10:15:02.883Z","comments":true,"path":"2020/02/08/DS100P-91-100-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-91-100-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 81~90é¢˜","slug":"DS100P-81-90-P","date":"2020-02-08T06:03:43.000Z","updated":"2020-02-18T10:14:39.850Z","comments":true,"path":"2020/02/08/DS100P-81-90-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-81-90-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 71~80é¢˜","slug":"DS100P-71-80-P","date":"2020-02-08T06:03:41.000Z","updated":"2020-02-18T10:14:17.538Z","comments":true,"path":"2020/02/08/DS100P-71-80-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-71-80-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 61~70é¢˜","slug":"DS100P-61-70-P","date":"2020-02-08T06:03:39.000Z","updated":"2020-02-18T10:13:41.177Z","comments":true,"path":"2020/02/08/DS100P-61-70-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-61-70-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 51~60é¢˜","slug":"DS100P-51-60-P","date":"2020-02-08T06:03:37.000Z","updated":"2020-02-18T10:13:09.552Z","comments":true,"path":"2020/02/08/DS100P-51-60-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-51-60-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 41~50é¢˜","slug":"DS100P-41-50-P","date":"2020-02-08T06:03:35.000Z","updated":"2020-02-18T10:12:17.446Z","comments":true,"path":"2020/02/08/DS100P-41-50-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-41-50-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 31~40é¢˜","slug":"DS100P-31-40-P","date":"2020-02-08T06:03:33.000Z","updated":"2020-05-02T00:01:55.287Z","comments":true,"path":"2020/02/08/DS100P-31-40-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-31-40-P/","excerpt":"","text":"31.P2163 [SHOI2007]å›­ä¸çš„çƒ¦æ¼]å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œåœ¨é¥è¿œçš„å¤§é™†ä¸Šæœ‰ä¸€ä¸ªç¾ä¸½çš„å›½å®¶ã€‚ç»Ÿæ²»ç€è¿™ä¸ªç¾ä¸½å›½å®¶çš„å›½ç‹æ˜¯ä¸€ä¸ªå›­è‰ºçˆ±å¥½è€…ï¼Œåœ¨ä»–çš„çš‡å®¶èŠ±å›­é‡Œç§æ¤ç€å„ç§å¥‡èŠ±å¼‚è‰ã€‚ æœ‰ä¸€å¤©å›½ç‹æ¼«æ­¥åœ¨èŠ±å›­é‡Œï¼Œè‹¥æœ‰æ‰€æ€ï¼Œä»–é—®ä¸€ä¸ªå›­ä¸é“ï¼š â€œæœ€è¿‘æˆ‘åœ¨æ€ç´¢ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬æŠŠèŠ±å›æ‘†æˆå…­ä¸ªå…­è§’å½¢ï¼Œé‚£ä¹ˆâ€¦â€¦â€ â€œé‚£ä¹ˆæœ¬è´¨ä¸Šå®ƒæ˜¯ä¸€ä¸ªæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé™›ä¸‹â€ï¼Œå›­ä¸æ·±æ·±åœ°å‘å›½ç‹é äº†ä¸€èº¬ã€‚ â€œå—¯â€¦â€¦æˆ‘å¬è¯´æœ‰ä¸€ç§æ€ªç‰©å«ä¹å¤´è›‡ï¼Œå®ƒéå¸¸è´ªåƒè‹¹æœæ ‘â€¦â€¦â€ â€œæ˜¯çš„ï¼Œæ˜¾ç„¶è¿™æ˜¯ä¸€é“ç»å…¸çš„åŠ¨æ€è§„åˆ’é¢˜ï¼Œæ—©åœ¨Nå…ƒ4002å¹´æˆ‘ä»¬å°±å·²ç»å‘ç°äº†å…¶ä¸­çš„å¥¥ç§˜äº†ï¼Œé™›ä¸‹â€ã€‚ â€œè¯¥æ­»çš„ï¼Œä½ ç©¶ç«Ÿæ˜¯ä»€ä¹ˆæ¥å¤´ï¼Ÿâ€ â€œé™›ä¸‹æ¯æ€’ï¼Œå¹²æˆ‘ä»¬çš„è¿™è¡Œç»å¸¸è«åå…¶å¦™åœ°è¢«é—®åˆ°å’ŒOIæœ‰å…³çš„é¢˜ç›®ï¼Œæˆ‘ä¹Ÿæ˜¯ä¸ºäº†é¢„é˜²ä¸‡ä¸€å•Šï¼â€ ç‹è€…çš„å°Šä¸¥å—åˆ°äº†ä¼¤å®³ï¼Œè¿™æ˜¯ä¸å¯å®¹å¿çš„ã€‚ çœ‹æ¥ä¸€èˆ¬çš„éš¾é¢˜æ˜¯éš¾ä¸å€’è¿™ä½å›­ä¸çš„ï¼Œå›½ç‹æœ€åæ‰“ç®—ç”¨è½¦è½®æˆ˜æ¥æ¶ˆè€—ä»–çš„å®åŠ›ï¼š â€œå¹´è½»äººï¼Œåœ¨æˆ‘çš„èŠ±å›­é‡Œçš„æ¯ä¸€æ£µæ ‘å¯ä»¥ç”¨ä¸€ä¸ªæ•´æ•°åæ ‡æ¥è¡¨ç¤ºï¼Œä¸€ä¼šå„¿ï¼Œæˆ‘çš„éª‘å£«ä»¬ä¼šæ¥è½®ç•ªè¯¢é—®ä½ æŸä¸€ä¸ªçŸ©é˜µå†…æœ‰å¤šå°‘æ ‘ï¼Œå¦‚æœä½ ä¸èƒ½ç«‹å³ç­”å¯¹ï¼Œä½ å°±å‡†å¤‡èµ°äººå§ï¼â€è¯´å®Œï¼Œå›½ç‹æ°”å‘¼å‘¼åœ°å…ˆèµ°äº†ã€‚ è¿™ä¸‹è½®åˆ°å›­ä¸å‚»çœ¼äº†ï¼Œä»–æ²¡æœ‰å‡†å¤‡è¿‡è¿™æ ·çš„é—®é¢˜ã€‚æ‰€å¹¸çš„æ˜¯ï¼Œä½œä¸ºâ€œå…¨å›½å›­ä¸ä¿æŠ¤è”ç›Ÿâ€çš„ä¼šé•¿â€”â€”ä½ ï¼Œå¯ä»¥æˆä¸ºä»–çš„æœ€åä¸€æ ¹æ•‘å‘½ç¨»è‰ã€‚ è¿™é“é¢˜æ‹¿åˆ°ä¸€çœ‹ï¼Œç¬¬ä¸€ä¸ªæƒ³æ³•æ˜¯äºŒç»´æ ‘çŠ¶æ•°ç»„ã€‚ å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢ã€‚ å¾ˆæ ‡å‡†çš„æ¨¡æ¿é¢˜å˜› è¿™ä¸ªæ•°æ®èŒƒå›´å¯ä¸æ¨¡æ¿â€¦â€¦ å°±ç®—ç¦»æ•£åŒ–ä¹‹åè¿˜å‰©$500000*500000$ è¿æ•°ç»„éƒ½å¼€ä¸ä¸‹ã€‚ æ‰€ä»¥æˆ‘ä»¬è¦å¯»æ‰¾æ–°çš„åšæ³•ã€‚ æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œæ‰€æœ‰çš„è¯¢é—®éƒ½ä¼šåœ¨ä¿®æ”¹çš„åé¢ã€‚ æ‰€ä»¥æ•´ä¸ªé—®é¢˜æ˜¯é™æ€çš„ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸»å¸­æ ‘æ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚ ä¸»å¸­æ ‘ç¬¬$i$ä¸ªç‰ˆæœ¬ç»Ÿè®¡æ¨ªåæ ‡ä¸º$1-i$çš„æ‰€æœ‰æ ‘æœ¨çš„çºµåæ ‡åœ¨æƒå€¼çº¿æ®µæ ‘ä¸Šçš„ä½“ç°ã€‚ è¿™ä¸ªæƒå€¼çº¿æ®µæ ‘ç»´æŠ¤æ¯ä¸ªå€¼åŸŸæœ‰å¤šå°‘ä¸ªå…ƒç´ ã€‚ é‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥åœ¨ç¦»æ•£åŒ–åæŒ‰ç…§æ¨ªåæ ‡é¡ºåºæ’å…¥ã€‚ æŸ¥è¯¢æ—¶åˆ©ç”¨æŸ¥åˆ†ã€‚åªéœ€è¦æŸ¥è¯¢ç¬¬$xr$ä¸ªç‰ˆæœ¬æ—¶å’Œç¬¬$xl-1$ä¸ªç‰ˆæœ¬æ—¶$yl$åˆ°$yr$è¿™ä¸ªåŒºé—´é‡Œæœ‰çš„å…ƒç´ ä¸ªæ•°ï¼Œå†ç›¸å‡å°±èƒ½å¾—åˆ°ç­”æ¡ˆäº†ã€‚ ä»£ç ï¼š #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int n,m,root[1500010],s,e,tot; struct tree { int x,y; }tre[500010]; struct query { int X1,X2,Y1,Y2; }q[500010]; struct node { int l,r,num; }nodes[50000010]; vector&lt;int&gt; pril,prih,inslist[1500010]; void ins(int l,int r,int pre,int &amp;now,int pos) { now=++tot; nodes[now]=nodes[pre]; ++nodes[now].num; if(l^r) { int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos); } } int find(int l,int r,int v1,int v2,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[v2].num-nodes[v1].num; int mid=(l+r)&gt;&gt;1; return find(l,mid,nodes[v1].l,nodes[v2].l,fr,ba)+find(mid+1,r,nodes[v1].r,nodes[v2].r,fr,ba); } void read(int &amp;hhh) { int x=0; char c=getchar(); while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)&amp;&amp;c^&#39;-&#39;) c=getchar(); if(c^&#39;-&#39;) x=c^&#39;0&#39;; char d=getchar(); while((d&lt;=&#39;9&#39;)&amp;(d&gt;=&#39;0&#39;)) { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(d^&#39;0&#39;); d=getchar(); } if(c^&#39;-&#39;) hhh=x; else hhh=-x; } void writing(int x) { if(!x) return; writing(x/10); putchar((x%10)+&#39;0&#39;); } void write(int x) { if(x&lt;0) { putchar(&#39;-&#39;); x=-x; } else if(!x) { putchar(&#39;0&#39;); putchar(&#39;\\n&#39;); return; } writing(x); putchar(&#39;\\n&#39;); } int main() { read(n); read(m); for(int i=1;i&lt;=n;++i) { read(tre[i].x); read(tre[i].y); pril.push_back(tre[i].x); prih.push_back(tre[i].y); } for(int i=1;i&lt;=m;++i) { read(q[i].X1); read(q[i].Y1); read(q[i].X2); read(q[i].Y2); --q[i].X1; pril.push_back(q[i].X1); prih.push_back(q[i].Y1); pril.push_back(q[i].X2); prih.push_back(q[i].Y2); } sort(pril.begin(),pril.end()); sort(prih.begin(),prih.end()); pril.erase(unique(pril.begin(),pril.end()),pril.end()); prih.erase(unique(prih.begin(),prih.end()),prih.end()); s=prih.size(); e=pril.size(); for(int i=1;i&lt;=n;++i) { tre[i].x=lower_bound(pril.begin(),pril.end(),tre[i].x)-pril.begin()+1; tre[i].y=lower_bound(prih.begin(),prih.end(),tre[i].y)-prih.begin()+1; inslist[tre[i].x].push_back(tre[i].y); } for(int i=1;i&lt;=m;++i) { q[i].X1=lower_bound(pril.begin(),pril.end(),q[i].X1)-pril.begin()+1; q[i].Y1=lower_bound(prih.begin(),prih.end(),q[i].Y1)-prih.begin()+1; q[i].X2=lower_bound(pril.begin(),pril.end(),q[i].X2)-pril.begin()+1; q[i].Y2=lower_bound(prih.begin(),prih.end(),q[i].Y2)-prih.begin()+1; } for(int i=1;i&lt;=e;++i) { root[i]=root[i-1]; int WHILEMAX=inslist[i].size(); for(int j=0;j^WHILEMAX;++j) ins(1,s,root[i],root[i],inslist[i][j]); } for(int i=1;i&lt;=m;++i) write(find(1,s,root[q[i].X1],root[q[i].X2],q[i].Y1,q[i].Y2)); return 0; } 32.P2471 [SCOI2007]é™é›¨é‡æˆ‘ä»¬å¸¸å¸¸ä¼šè¯´è¿™æ ·çš„è¯ï¼šâ€œXå¹´æ˜¯è‡ªYå¹´ä»¥æ¥é™é›¨é‡æœ€å¤šçš„â€ã€‚å®ƒçš„å«ä¹‰æ˜¯Xå¹´çš„é™é›¨é‡ä¸è¶…è¿‡Yå¹´ï¼Œä¸”å¯¹äºä»»æ„Y&lt;Z&lt;Xï¼ŒZå¹´çš„é™é›¨é‡ä¸¥æ ¼å°äºXå¹´ã€‚ä¾‹å¦‚2002ï¼Œ2003ï¼Œ2004å’Œ2005å¹´çš„é™é›¨é‡åˆ†åˆ«ä¸º4920ï¼Œ5901ï¼Œ2832å’Œ3890ï¼Œåˆ™å¯ä»¥è¯´â€œ2005å¹´æ˜¯è‡ª2003å¹´ä»¥æ¥æœ€å¤šçš„â€ï¼Œä½†ä¸èƒ½è¯´â€œ2005å¹´æ˜¯è‡ª2002å¹´ä»¥æ¥æœ€å¤šçš„â€ç”±äºæœ‰äº›å¹´ä»½çš„é™é›¨é‡æœªçŸ¥ï¼Œæœ‰çš„è¯´æ³•æ˜¯å¯èƒ½æ­£ç¡®ä¹Ÿå¯ä»¥ä¸æ­£ç¡®çš„ã€‚ è¿™é“é¢˜è¦æ±‚æŸ¥è¯¢ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯ç»§å¦ä¸€ä¸ªæ•°åçš„æœ€å¤§å€¼ã€‚ ç„¶è€Œä¸­é—´æœ‰å¾ˆå¤šæ•°æ˜¯æœªçŸ¥çš„ã€‚ è¦åˆ¤æ–­è¿™ä¸ªç»“è®ºä¸€å®šæˆç«‹ï¼Œæˆ‘ä»¬è¦çŸ¥é“ä¸­é—´çš„æ•°æ˜¯ä¸æ˜¯éƒ½çŸ¥é“ã€‚ é‚£æˆ‘ä»¬æ˜¯ä¸æ˜¯è¦æŠŠæ‰€æœ‰çš„æ•°éƒ½æ”¾è¿›çº¿æ®µæ ‘é‡Œå‘¢ï¼Ÿ è‚¯å®šä¸è¡Œï¼Œå› ä¸ºå¹´ä»½çš„èŒƒå›´æ˜¯$1e9$ã€‚ é‚£æˆ‘ä»¬æ€ä¹ˆç¦»æ•£åŒ–å‘¢ï¼Ÿ è¿™é‡Œæˆ‘ä»¬åªç”¨æŠŠä¸æ¯ä¸ªå¹´ä»½ç›¸é‚»çš„ä¸¤ä¸ªå¹´ä»½ä¹ŸåŠ è¿›æ¥å°±å¥½äº†ï¼Œå†é¡ºä¾¿æŠŠæŸ¥è¯¢çš„ç«¯ç‚¹å’Œå¾€å†…ä¸€ä¸ªæ•°ä¹ŸåŠ è¿›æ¥ï¼Œä¸ç„¶æ‰¾ç«¯ç‚¹çš„æ—¶å€™å®¹æ˜“é”…â€¦â€¦ å› ä¸ºå¦‚æœæŸ¥è¯¢æ—¶è¿™é‡Œæ²¡æœ‰æ•°ï¼Œé‚£ä¹ˆè‚¯å®šå°±è¢«æŸ¥åˆ°äº†ã€‚ å¦‚æœè¿™é‡Œæœ‰ï¼Œé‚£ä¹ˆè¿™é‡Œçš„è¿™ä¸ªæ•°å°±ä¼šåˆæŠŠå®ƒä¸¤è¾¹çš„æ•°åŠ è¿›æ¥ã€‚ä¸€ç›´åˆ°è¦æŸ¥è¯¢åˆ°çš„é‚£ä¸ªæ•°ä¸ºæ­¢ã€‚ é‚£ä¹ˆæˆ‘ä»¬åº”è¯¥æ€ä¹ˆåˆ¤æ–­å‘¢ï¼Ÿ è¿™é‡Œå°±è¦åˆ†ç±»è®¨è®ºäº†ï¼šæŸ¥è¯¢ä¸º$(p,q)$ $1.p &gt; q$ï¼šè‚¯å®šä¸æˆç«‹ï¼Œä»–ä»¬çš„ä½ç½®éƒ½ä¸å¯¹ï¼Œ$p$æ ¹æœ¬ä¸åœ¨$q$å‰é¢ã€‚ $2.p=q$ï¼šæ˜¾ç„¶æˆç«‹ã€‚ $3.$ç»§ç»­åˆ†ç±»ã€‚ $\\ \\ \\ \\ \\ $$1).$ä¸¤ä¸ªç«¯ç‚¹éƒ½å·²çŸ¥ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ 1>.p$çš„é™é›¨é‡å°äº$q$ï¼šè‚¯å®šä¸å¯¹ï¼Œä¸ç¬¦åˆå®šä¹‰ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$2&gt;.$å¦‚æœ$p,q$ä¸­é—´æœ‰æ•°æ¯”$q$çš„é™é›¨é‡å¤§æˆ–ç­‰äºï¼šä¹Ÿä¸ç¬¦åˆå®šä¹‰ï¼Œä¸å¯¹ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$3&gt;.$å¦‚æœ$p,q$ä¸­é—´æœ‰æ•°æœªçŸ¥:é‚£ä¹ˆæˆ‘ä»¬æ— æ³•ç¡®å®šè¿™äº›æœªçŸ¥çš„æ•°æ˜¯å¦å°äº$q$çš„é™é›¨é‡ï¼Œè¾“å‡ºä¹Ÿè®¸ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$4&gt;.$ä»¥ä¸Šæ¡ä»¶å‡ä¸æ»¡è¶³ï¼šè¯´æ˜æ»¡è¶³äº†æ‰€æœ‰æ¡ä»¶ï¼Œæ˜¯å¯¹çš„ã€‚ $\\ \\ \\ \\ \\ $$2).$çŸ¥é“$p$çš„é™é›¨é‡ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$1&gt;.$å¦‚æœ$p,q$ä¸­é—´æœ‰æ•°å¤§äº$p$çš„é™é›¨é‡æˆ–ç­‰äºï¼šä¸ç¬¦åˆå®šä¹‰ï¼Œä¸å¯¹ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$2&gt;.$å¦åˆ™æ— è®ºä¸­é—´æ˜¯å¦å…¨éƒ¨å·²çŸ¥ï¼Œç”±äº$q$æœªçŸ¥ï¼Œéƒ½ä¸èƒ½ç¡®å®šã€‚ $\\ \\ \\ \\ \\ $$3).$çŸ¥é“$q$çš„é™é›¨é‡ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$1&gt;.$å¦‚æœ$p,q$ä¸­é—´æœ‰æ•°å¤§äº$q$çš„é™é›¨é‡æˆ–ç­‰äºï¼šä¸ç¬¦åˆå®šä¹‰ï¼Œä¸å¯¹ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $$2&gt;.$å¦åˆ™æ— è®ºä¸­é—´æ˜¯å¦å…¨éƒ¨å·²çŸ¥ï¼Œç”±äº$p$æœªçŸ¥ï¼Œéƒ½ä¸èƒ½ç¡®å®šã€‚ $\\ \\ \\ \\ \\ $$4).$ä¸¤ä¸ªéƒ½æœªçŸ¥ï¼šæ— è®ºä¸­é—´æ˜¯å¦å…¨éƒ¨å·²çŸ¥ï¼Œç”±äºä¸èƒ½ç¡®å®šä¸­é—´çš„æ•°æ˜¯å¦å°äºä»–ä»¬ï¼Œæ‰€ä»¥è¾“å‡ºä¹Ÿè®¸ã€‚ å…³äºåˆ¤æ–­ä¸­é—´æ˜¯å¦æœ‰æ•°å¤§äºæŸæ•°ï¼Œæˆ‘ä»¬éœ€è¦æŸ¥è¯¢ä¸­é—´çš„æœ€å¤§å€¼ã€‚ å…³äºåˆ¤æ–­ä¸­é—´æ˜¯å¦æœ‰æ•°æœªçŸ¥ï¼Œæˆ‘ä»¬éœ€è¦æŸ¥è¯¢åŒºé—´é‡Œæœ‰å¤šå°‘æ•°ã€‚ æ‰€ä»¥æˆ‘ä»¬è¦å¼€ä¸¤æ£µçº¿æ®µæ ‘ï¼Œä¸€æ£µè®°å½•åŒºé—´æœ€å¤§å€¼ï¼Œä¸€æ£µè®°å½•åŒºé—´é‡Œçš„å…ƒç´ ä¸ªæ•°ã€‚ ä»£ç ï¼š #include&lt;map&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; vector&lt;int&gt; pri; map&lt;int,int&gt; mp; int n,m,s,y[50010],r[50010],p[10010],q[10010],siz[1000010],nodes[1000010]; int getID(int val) { return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1; } void ins(int l,int r,int x,int pos,int val) { ++siz[x]; if(l==r) nodes[x]=val; else { int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,x&lt;&lt;1,pos,val); else ins(mid+1,r,x&lt;&lt;1|1,pos,val); nodes[x]=max(nodes[x&lt;&lt;1],nodes[x&lt;&lt;1|1]); } } int findsiz(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr&amp;&amp;r&lt;=ba) return siz[x]; else { int mid=(l+r)&gt;&gt;1; return findsiz(l,mid,x&lt;&lt;1,fr,ba)+findsiz(mid+1,r,x&lt;&lt;1|1,fr,ba); } } int findmax(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[x]; else { int mid=(l+r)&gt;&gt;1; return max(findmax(l,mid,x&lt;&lt;1,fr,ba),findmax(mid+1,r,x&lt;&lt;1|1,fr,ba)); } } int main() { scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d %d&quot;,&amp;y[i],&amp;r[i]); pri.push_back(y[i]-1); pri.push_back(y[i]); pri.push_back(y[i]+1); mp[y[i]]=r[i]; } scanf(&quot;%d&quot;,&amp;m); for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d&quot;,&amp;p[i],&amp;q[i]); pri.push_back(p[i]); pri.push_back(p[i]+1); pri.push_back(q[i]); pri.push_back(q[i]-1); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); s=pri.size(); for(int i=1;i&lt;=n;++i) ins(1,s,1,getID(y[i]),r[i]); for(int i=1;i&lt;=m;++i) { int L=getID(p[i]); int R=getID(q[i]); if(p[i]&gt;q[i]) printf(&quot;false\\n&quot;); else if(p[i]==q[i]) printf(&quot;true\\n&quot;); else if(mp[p[i]]&amp;&amp;mp[q[i]]) { if(mp[p[i]]&lt;mp[q[i]]) printf(&quot;false\\n&quot;); else { if(findmax(1,s,1,L+1,R-1)&lt;mp[q[i]]) { if(findsiz(1,s,1,L,R)==R-L+1) printf(&quot;true\\n&quot;); else printf(&quot;maybe\\n&quot;); } else printf(&quot;false\\n&quot;); } } else if(mp[p[i]]) { if(findmax(1,s,1,L+1,R)&gt;=mp[p[i]]) printf(&quot;false\\n&quot;); else printf(&quot;maybe\\n&quot;); } else if(mp[q[i]]) { if(findmax(1,s,1,L,R-1)&gt;=mp[q[i]]) printf(&quot;false\\n&quot;); else printf(&quot;maybe\\n&quot;); } else printf(&quot;maybe\\n&quot;); } return 0; } 33.P2824 [HEOI2016/TJOI2016]æ’åºåœ¨ $2016$ å¹´ï¼Œä½³åª›å§å§å–œæ¬¢ä¸Šäº†æ•°å­—åºåˆ—ã€‚å› è€Œå¥¹ç»å¸¸ç ”ç©¶å…³äºåºåˆ—çš„ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„é—®é¢˜ï¼Œç°åœ¨å¥¹åœ¨ç ”ç©¶ä¸€ä¸ªéš¾é¢˜ï¼Œéœ€è¦ä½ æ¥å¸®åŠ©å¥¹ã€‚ è¿™ä¸ªéš¾é¢˜æ˜¯è¿™æ ·å­çš„ï¼šç»™å‡ºä¸€ä¸ª $1$ åˆ° $n$ çš„æ’åˆ—ï¼Œç°åœ¨å¯¹è¿™ä¸ªæ’åˆ—åºåˆ—è¿›è¡Œ $m$ æ¬¡å±€éƒ¨æ’åºï¼Œæ’åºåˆ†ä¸ºä¸¤ç§ï¼š 0 l r è¡¨ç¤ºå°†åŒºé—´ $[l,r]$ çš„æ•°å­—å‡åºæ’åº 1 l r è¡¨ç¤ºå°†åŒºé—´ $[l,r]$ çš„æ•°å­—é™åºæ’åº æ³¨æ„ï¼Œè¿™é‡Œæ˜¯å¯¹ä¸‹æ ‡åœ¨åŒºé—´ $[l,r]$ å†…çš„æ•°æ’åºã€‚æœ€åè¯¢é—®ç¬¬ $q$ ä½ç½®ä¸Šçš„æ•°å­—ã€‚ è¿™é“é¢˜å¾ˆæœ‰æ„æ€ï¼Œéœ€è¦ä¸€å®šçš„æŠ€å·§ã€‚ é¦–å…ˆæˆ‘ä»¬çŸ¥é“ï¼Œå¯¹äºä¸€ä¸ªé•¿åº¦ä¸º $n$ æ•´æ•°åºåˆ—æ’åºéœ€è¦ $\\Theta(n\\log n)$ çš„æ—¶é—´ã€‚ ä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬æŠŠåºåˆ—ä¸­çš„æ•°å­—ä»æ‰€æœ‰çš„æ•°è½¬ç§»åˆ°0å’Œ1ä¸¤ä¸ªæ•°ä¸Šï¼Œæ˜¯ä¸æ˜¯å°±å®¹æ˜“å¾ˆå¤šå‘¢ï¼Ÿ å¯¹äºä¸€ä¸ª01ä¸²å‡åºæ’åºæ˜¾ç„¶åªéœ€è¦ $\\Theta(n)$ çš„æ—¶é—´ã€‚æˆ‘ä»¬åªéœ€è¦ç»Ÿè®¡å‡ºåºåˆ—ä¸­æ‰€ä»¥1çš„ä¸ªæ•° $cnt$ã€‚ ç„¶åæŠŠ $A_{i},i\\in [1,n-cnt]$ æ”¹ä¸ºé›¶ï¼ŒæŠŠ $A_{i},i\\in [n-cnt+1,n]$ æ”¹ä¸º1å³å¯ã€‚ é™åºæ’åºåˆ™å®Œå…¨åŒç†ã€‚ ä¸ä»…å¦‚æ­¤ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥æŠŠæ—¶é—´ä» $\\Theta(n)$ é™åˆ° $\\Theta(\\log n)$ã€‚ æˆ‘ä»¬å¯ä»¥æŠŠç»Ÿè®¡åŒºé—´ä¸­1çš„ä¸ªæ•°çœ‹ä½œåŒºé—´æ±‚å’Œï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±å¯ä»¥ç”¨çº¿æ®µæ ‘æ¥ç»´æŠ¤åŒºé—´èµ‹å€¼å’ŒåŒºé—´æ±‚å’Œçš„æ“ä½œï¼Œå¤æ‚åº¦ $\\Theta(\\log n)$ã€‚ å¥½ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æ€è€ƒä¸€ä¸ªé—®é¢˜â€”â€”å¦‚ä½•æŠŠä¸€ä¸ªæ™®é€šçš„åºåˆ—è½¬åŒ–ä¸º01åºåˆ—å‘¢ï¼Ÿæˆ‘ä»¬å¯ä»¥æŒ‰å¤§å°æ¥åˆ’åˆ†ã€‚ å‡è®¾æˆ‘ä»¬ç°åœ¨æ­£åœ¨äºŒåˆ†ï¼Œé‚£ä¹ˆæˆ‘ä»¬ä¸å¦¨æŠŠæ‰€æœ‰å¤§äºç­‰äº $mid$ çš„æ•°ç½®ä¸º1ï¼Œå¦åˆ™ç½®ä¸º0ã€‚è¿™æ ·æ•´ä¸ªåºåˆ—å°±å˜æˆäº†ä¸€ä¸ª01åºåˆ—ã€‚ æ’åºååˆ¤æ–­ç¬¬ $q$ ä¸ªä½ç½®æ˜¯ä¸æ˜¯1å°±è¡Œäº†ã€‚ è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜â€”â€”ä¸ºä»€ä¹ˆè¿™ä¸ªäºŒåˆ†æ˜¯æ»¡è¶³å•è°ƒæ€§çš„å‘¢ï¼Ÿ å…¶å®è¿™ä¸ªé—®é¢˜å¾ˆç®€å•ï¼Œå°±ç•™ç»™å¤§å®¶å§ï¼‰ï¼‰ï¼‰ #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) // #define mid ((l + r) &gt;&gt; 1) const int MAXN = 1e5 + 5; int nodes[MAXN &lt;&lt; 2]; int marks[MAXN &lt;&lt; 2]; int ints[MAXN], bit[MAXN]; int n, m, q; struct QueryNode { int l, r; int type; QueryNode(){} QueryNode(int L, int R, int T) : l(L), r(R), type(T) {} } asks[MAXN]; void pushdown(int k, int l, int r) { if (~marks[k]) { int mid = (l + r) &gt;&gt; 1; nodes[ls] = (mid - l + 1) * marks[k]; marks[ls] = marks[k]; nodes[rs] = (r - mid) * marks[k]; marks[rs] = marks[k]; marks[k] = -1; } } void construct(int k, int l, int r) { int mid = ((l + r) &gt;&gt; 1); if (l ^ r) { construct(ls, l, mid); construct(rs, mid + 1, r); nodes[k] = nodes[ls] + nodes[rs]; } else nodes[k] = bit[l]; } void update(int k, int l, int r, int x, int y, int v) { int mid = ((l + r) &gt;&gt; 1); if (l &gt; y || r &lt; x) return ; if (l &gt;= x &amp;&amp; r &lt;= y) nodes[k] = (r - l + 1) * v, marks[k] = v; else { pushdown(k, l, r); if (mid &gt;= x) update(ls, l, mid, x, y, v); if (mid &lt; y) update(rs, mid + 1, r, x, y, v); nodes[k] = nodes[ls] + nodes[rs]; } } int queryf(int k, int l, int r, int x, int y) { int mid = ((l + r) &gt;&gt; 1); pushdown(k, l, r); if (l &gt; y || r &lt; x) return 0; else if (l &gt;= x &amp;&amp; r &lt;= y) return nodes[k]; else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y); } bool check(int x) { for (int i = 1; i &lt;= n; ++i) bit[i] = (ints[i] &gt;= x); memset(marks, -1, sizeof marks); memset(nodes, 0, sizeof nodes); construct(1, 1, n); for (int i = 1; i &lt;= m; ++i) { int sum = queryf(1, 1, n, asks[i].l, asks[i].r); if (asks[i].type == 1) update(1, 1, n, asks[i].l, asks[i].l + sum - 1, 1), update(1, 1, n, asks[i].l + sum, asks[i].r, 0); else update(1, 1, n, asks[i].l, asks[i].r - sum, 0), update(1, 1, n, asks[i].r - sum + 1, asks[i].r, 1); } return queryf(1, 1, n, q, q); } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i]); for (int i = 1; i &lt;= m; ++i) read(asks[i].type, asks[i].l, asks[i].r); read(q); int l = 1, r = n, ans = 0; while (l &lt;= r) { int mid = ((l + r) &gt;&gt; 1); if (check(mid)) l = mid + 1, ans = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, ans); return 0; } 34.P1712 [NOI2016]åŒºé—´åœ¨æ•°è½´ä¸Šæœ‰ $N$ ä¸ªé—­åŒºé—´ $[l_1,r_1],[l_2,r_2],â€¦,[l_n,r_n]$ ã€‚ç°åœ¨è¦ä»ä¸­é€‰å‡º $M$ ä¸ªåŒºé—´ï¼Œä½¿å¾—è¿™ $M$ ä¸ªåŒºé—´å…±åŒåŒ…å«è‡³å°‘ä¸€ä¸ªä½ç½®ã€‚æ¢å¥è¯è¯´ï¼Œå°±æ˜¯ä½¿å¾—å­˜åœ¨ä¸€ä¸ª $x$ ï¼Œä½¿å¾—å¯¹äºæ¯ä¸€ä¸ªè¢«é€‰ä¸­çš„åŒºé—´$[l_i,r_i]$ ï¼Œéƒ½æœ‰ $l_iâ‰¤xâ‰¤r_i$ ã€‚ å¯¹äºä¸€ä¸ªåˆæ³•çš„é€‰å–æ–¹æ¡ˆï¼Œå®ƒçš„èŠ±è´¹ä¸ºè¢«é€‰ä¸­çš„æœ€é•¿åŒºé—´é•¿åº¦å‡å»è¢«é€‰ä¸­çš„æœ€çŸ­åŒºé—´é•¿åº¦ã€‚åŒºé—´$[l_i,r_i]$ çš„é•¿åº¦å®šä¹‰ä¸º$r_i-l_i$ ï¼Œå³ç­‰äºå®ƒçš„å³ç«¯ç‚¹çš„å€¼å‡å»å·¦ç«¯ç‚¹çš„å€¼ã€‚ æ±‚æ‰€æœ‰åˆæ³•æ–¹æ¡ˆä¸­æœ€å°çš„èŠ±è´¹ã€‚å¦‚æœä¸å­˜åœ¨åˆæ³•çš„æ–¹æ¡ˆï¼Œè¾“å‡º $-1$ ã€‚ é¢˜æ„ç®€è¿°é¢˜æ„å·²ç»å¾ˆæ¸…æ¥šäº†ï¼Œå°±ä¸å†è¯´äº† é¢˜è§£æˆ‘ä»¬é¦–å…ˆè€ƒè™‘æ€ä¹ˆå»é€‰æ‹©è¿™ $M$ ä¸ªåŒºé—´æ‰èƒ½ä½¿å¾—æœ€ç»ˆçš„èŠ±è´¹æœ€å°ã€‚ ä¸éš¾æƒ³åˆ°æˆ‘ä»¬éœ€è¦å°½é‡é€‰æ‹© é•¿åº¦å°½é‡é è¿‘ çš„ $M$ ä¸ªåŒºé—´ï¼Œæ¢å¥è¯è¯´å°±æ˜¯æˆ‘ä»¬éœ€è¦æŒ‰ç…§åŒºé—´çš„é•¿åº¦è¿›è¡Œæ’åºã€‚ åŸå› å¾ˆæ˜¾ç„¶ï¼Œæˆ‘ä»¬å¦‚æœé€‰æ‹©çš„åŒºé—´çš„é•¿åº¦ä¸é è¿‘ï¼Œé‚£ä¹ˆå°±ä¼šé€ æˆæœ€å°çš„åŒºé—´é•¿åº¦å˜å°ï¼Œæœ€å¤§çš„åŒºé—´é•¿åº¦å˜å¤§ã€‚ç„¶è€Œç­”æ¡ˆå°±æ˜¯é•¿åº¦æœ€å¤§çš„åŒºé—´å’Œé•¿åº¦æœ€å°çš„åŒºé—´ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦è®©è¿™ä¸¤ä¸ªåŒºé—´çš„é•¿åº¦å°½é‡é è¿‘ã€‚ æ’å®Œåºåæˆ‘ä»¬å°±ä¾æ¬¡æŠŠæ¯ä¸ªåŒºé—´åŠ å…¥åˆ°ç­”æ¡ˆæ‰€åœ¨çš„é›†åˆé‡Œã€‚ å…·ä½“æ¥è¯´å°±æ˜¯ç»´æŠ¤ä¸€ä¸ªæ•°ç»„ $A$ï¼Œæ¯å½“æˆ‘ä»¬åŠ å…¥ä¸€ä¸ªåŒºé—´ $[l_{i},r_{i}]$ï¼Œå°±ä»¤ $A_{l_{i}},A_{l_{i}+1},\\cdots,A_{r_{i}}$ å…¨éƒ¨åŠ ä¸€ã€‚å¦‚æœå­˜åœ¨æŸä¸€ä¸ª $A_{p}$ ä½¿å¾— $M\\le A_{p}$ï¼Œæˆ‘ä»¬å°±æ›´æ–°ç­”æ¡ˆï¼Œå¹¶ä¸”åˆ é™¤æœ€å…ˆåŠ å…¥è¿›æ¥çš„åŒºé—´ï¼Œä¹Ÿå°±æ˜¯ä»¤ $A_{l_{i}},A_{l_{i}+1},\\cdots,A_{r_{i}}$ å…¨éƒ¨å‡ä¸€ã€‚ ä¸€äº›ç»†èŠ‚ï¼š è¦ç¦»æ•£åŒ–ï¼ˆåºŸè¯ çº¿æ®µæ ‘å¼€8å€ï¼ˆæ¯ä¸ªåŒºé—´æœ‰ä¸¤ä¸ªç«¯ç‚¹ æ²¡äº† #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = 500000 + 5; int MAX[SIZE &lt;&lt; 3]; int mark[SIZE &lt;&lt; 3]; vector &lt; int &gt; disc; int n, m, holyans = -1; struct interval { int l, r; int len; interval(){} interval(int L, int R, int S) : l(L), r(R), len(S){} bool operator &lt; (const interval&amp; rhs) const { return len &lt; rhs.len; } } seg[SIZE]; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) #define pushdown(k) \\ if (mark[k]) { \\ MAX[ls] += mark[k]; \\ MAX[rs] += mark[k]; \\ mark[ls] += mark[k]; \\ mark[rs] += mark[k]; \\ mark[k] = 0; \\ } #define pushup(k) MAX[k] = max(MAX[ls], MAX[rs]) #define GetID(x) (lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1) void modify(int k, int l, int r, int x, int y, int v) { if (l &gt;= x &amp;&amp; r &lt;= y) mark[k] += v, MAX[k] += v; else { pushdown(k); if (mid &gt;= x) modify(ls, l, mid, x, y, v); if (mid &lt; y) modify(rs, mid + 1, r, x, y, v); pushup(k); } } void discretization() { for (int i = 1; i &lt;= n; ++i) disc.push_back(seg[i].l), disc.push_back(seg[i].r); sort(disc.begin(), disc.end()); sort(seg + 1, seg + 1 + n); disc.erase(unique(disc.begin(), disc.end()), disc.end()); for (int i = 1; i &lt;= n; ++i) seg[i].l = GetID(seg[i].l), seg[i].r = GetID(seg[i].r); } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1, x, y; i &lt;= n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), seg[i] = interval(x, y, y - x + 1); discretization(); int size = disc.size(); int max_id = n; for (int i = n; i &gt;= 1; --i) { while (MAX[1] &gt;= m &amp;&amp; max_id &gt; i) { modify(1, 1, size, seg[max_id].l, seg[max_id].r, -1); --max_id; if (MAX[1] &gt;= m) { if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len); else holyans = seg[max_id].len - seg[i].len; } } modify(1, 1, size, seg[i].l, seg[i].r, 1); if (MAX[1] &gt;= m) { if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len); else holyans = seg[max_id].len - seg[i].len; } } printf(&quot;%d\\n&quot;, holyans); return 0; } 35.P5524 [Ynoi2012]NOIP2015æ´‹æº¢ç€å¸Œæœ›ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•´æ•°åºåˆ— $a_1,a_2,\\ldots,a_n$ï¼Œè¿›è¡Œ $m$ æ¬¡æ“ä½œï¼Œæ“ä½œåˆ†ä¸ºä¸¤ç±»ã€‚ æ“ä½œ $1$ï¼šç»™å‡º $l,r,v$ï¼Œå°† $a_l,a_{l+1},\\ldots,a_r$ åˆ†åˆ«åŠ ä¸Š $v$ã€‚ æ“ä½œ $2$ï¼šç»™å‡º $l,r$ï¼Œè¯¢é—® $\\sum\\limits_{i=l}^{r}\\sin(a_i)$ã€‚ å”¯ä¸€ä¸€é“æˆ‘èƒ½åšçš„Ynoiâ€¦â€¦ ä¿®æ”¹æ“ä½œå¾ˆæ¨¡æ¿ï¼Œç•¥ã€‚ å¯¹äºè¯¢é—®ï¼Œç›´æ¥ç»´æŠ¤æ˜¯ä¸ç†æ™ºçš„ã€‚ç›¸ä¿¡å¤§å®¶éƒ½å­¦è¿‡ä¸‰è§’å‡½æ•°ï¼Œå’Œå·®è§’å…¬å¼åº”è¯¥å¾ˆç†Ÿæ‚‰ã€‚ å¯¹äºè¿™é“é¢˜æˆ‘ä»¬å¯ä»¥ç”¨è¿™ä¸¤ä¸ªå…¬å¼æ¥ç»´æŠ¤è¯¢é—®ï¼š \\sin(\\alpha+\\beta)=\\sin\\ \\alpha\\times\\cos\\ \\beta+\\cos\\ \\alpha\\times\\sin\\ \\beta \\cos(\\alpha+\\beta)=\\cos\\ \\alpha\\times\\cos\\ \\beta-\\sin\\ \\alpha\\times\\sin\\ \\betaè¿™æ ·ï¼Œæˆ‘ä»¬å†ç»´æŠ¤ä¸€ä¸ªåŠ æ³•æ ‡è®°ï¼Œå°±èƒ½è§£å†³è¯¢é—®äº†ã€‚ æŒºæ°´çš„å¯¹å§ã€‚ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int MAXN = 2e5 + 5; int n, m, integer[MAXN]; long long nodes[MAXN &lt;&lt; 2]; double sum_sinx[MAXN &lt;&lt; 2]; double sum_cosx[MAXN &lt;&lt; 2]; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define mid ((l + r) &gt;&gt; 1) void update(int k, double sinx, double cosx) { double tsum_sinx = sum_sinx[k]; double tsum_cosx = sum_cosx[k]; sum_sinx[k] = tsum_sinx * cosx + tsum_cosx * sinx; sum_cosx[k] = tsum_cosx * cosx - tsum_sinx * sinx; } void pushup(int k) { sum_sinx[k] = sum_sinx[ls] + sum_sinx[rs]; sum_cosx[k] = sum_cosx[ls] + sum_cosx[rs]; } void pushdown(int k) { if (nodes[k]) { nodes[ls] += nodes[k]; nodes[rs] += nodes[k]; double t_sinx = sin(nodes[k]); double t_cosx = cos(nodes[k]); nodes[k] = 0; update(ls, t_sinx, t_cosx); update(rs, t_sinx, t_cosx); } } void build(int k, int l, int r) { if (l ^ r) build(ls, l, mid), build(rs, mid + 1, r), pushup(k); else sum_sinx[k] = sin(integer[l]), sum_cosx[k] = cos(integer[l]); } void modify(int k, int l, int r, int x, int y, int v, double sinx, double cosx) { if (l &gt;= x &amp;&amp; r &lt;= y) update(k, sinx, cosx), nodes[k] += v; else { pushdown(k); if (mid &gt;= x) modify(ls, l, mid, x, y, v, sinx, cosx); if (mid &lt; y) modify(rs, mid + 1, r, x, y, v, sinx, cosx); pushup(k); } } double queryf(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) return sum_sinx[k]; else { pushdown(k); double res = 0; if (mid &gt;= x) res += queryf(ls, l, mid, x, y); if (mid &lt; y) res += queryf(rs, mid + 1, r, x, y); return res; } } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;integer[i]); build(1, 1, n); scanf(&quot;%d&quot;, &amp;m); for (int i = 0, opt, x, y, v; i &lt; m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt == 1) scanf(&quot;%d&quot;, &amp;v), modify(1, 1, n, x, y, v, sin(v), cos(v)); else printf(&quot;%.1lf\\n&quot;, queryf(1, 1, n, x, y)); } return 0; } 36.P5335 [THUSC2016]è¡¥é€€é€‰ X æ˜¯ T å¤§çš„ä¸€åè€å¸ˆï¼Œæ¯å¹´ä»–éƒ½è¦æ•™æˆè®¸å¤šå­¦ç”ŸåŸºç¡€çš„ C++ çŸ¥è¯†ã€‚åœ¨ T å¤§ï¼Œæ¯ä¸ªå­¦ç”Ÿåœ¨æ¯å­¦æœŸçš„å¼€å­¦å‰éƒ½éœ€è¦é€‰è¯¾ï¼Œæ¯æ¬¡é€‰è¯¾ä¸€å…±åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼šé¢„é€‰ï¼Œæ­£é€‰ï¼Œè¡¥é€€é€‰ï¼›å…¶ä¸­ã€Œè¡¥é€€é€‰ã€é˜¶æ®µæœ€å¿™ç¢Œã€‚åœ¨è¡¥é€€é€‰é˜¶æ®µï¼Œå­¦ç”Ÿå³å¯ä»¥é€‰è¯¾ï¼Œä¹Ÿå¯ä»¥é€€è¯¾ã€‚å¯¹äºXè€å¸ˆæ¥è¯´ï¼Œåœ¨è¡¥é€€é€‰é˜¶æ®µå¯èƒ½å‘ç”Ÿä»¥ä¸‹ä¸¤ç§äº‹ä»¶ï¼š1.ä¸€ä¸ªå§“åä¸º $S$ çš„å­¦ç”Ÿé€‰äº†ä»–çš„è¯¾ï¼ˆå§“åå°†å‡ºç°åœ¨ X çš„å·²é€‰è¯¾å­¦ç”Ÿåå•ä¸­ï¼‰2.ä¸€ä¸ªå§“åä¸º $S$ çš„å­¦ç”Ÿé€€äº†ä»–çš„è¯¾ï¼ˆå§“åå°†ä» X çš„å·²é€‰è¯¾å­¦ç”Ÿåå•ä¸­ç§»é™¤ï¼‰åŒæ—¶ï¼ŒX è€å¸ˆå¯¹äºæœ‰å“ªäº›å­¦ç”Ÿé€‰äº†ä»–çš„è¯¾éå¸¸å…³å¿ƒï¼Œæ‰€ä»¥ä»–ä¼šä¸å®šæ—¶çš„æŸ¥è¯¢å·²é€‰è¯¾å­¦ç”Ÿåå•ï¼Œæ¯æ¬¡æŸ¥è¯¢çš„æ ¼å¼å¦‚ä¸‹ï¼š æœ€æ—©åœ¨å“ªä¸ªäº‹ä»¶ä¹‹åï¼Œå§“åä»¥ S ä¸ºå‰ç¼€çš„å­¦ç”Ÿæ•°é‡è¶…è¿‡äº† v Xè€å¸ˆçœ‹ä½ éª¨éª¼æƒŠå¥‡ï¼Œæ‰€ä»¥æƒ³ç”¨è¿™ä¸ªé—®é¢˜è€ƒè€ƒä½ ï¼Œä½ å½“ç„¶ä¸ä¼šç•æƒ§ï¼Œæ‰€ä»¥å‹‡æ•¢çš„æ¥ä¸‹äº†è¿™ä¸ªä»»åŠ¡ã€‚æ³¨æ„1ï¼šå­¦ç”Ÿçš„å§“åå¯èƒ½ç›¸åŒï¼Œå¦‚æœæœ‰$p$ä¸ªå§“åç›¸åŒçš„å­¦ç”Ÿéƒ½é€‰äº†Xè€å¸ˆçš„è¯¾ï¼Œåˆ™ä»–ä»¬çš„å§“åå°†å‡ºç°åœ¨Xè€å¸ˆçš„åå•ä¸Š$p$æ¬¡ã€‚ æ³¨æ„2ï¼šåªæœ‰å·²ç»é€‰äº†è¯¾çš„å­¦ç”Ÿæ‰ä¼šé€€è¯¾ï¼Œå¦‚æœå§“åä¸º$S$çš„å­¦ç”Ÿé€€è¯¾ï¼Œåˆ™åœ¨ä»–é€€è¯¾ä¹‹å‰Xè€å¸ˆçš„åå•ä¸Šä¸€å®šæœ‰å§“åã€‚ æ³¨æ„3ï¼šé€‰è¯¾ï¼Œé€€è¯¾å’ŒæŸ¥è¯¢éƒ½è¢«å®šä¹‰ä¸ºã€Œäº‹ä»¶ã€ï¼Œã€Œäº‹ä»¶ã€çš„ç¼–å·ä» 1 å¼€å§‹ é¢˜æ„ç®€è¿°ç»™å®šæ’å…¥ã€åˆ é™¤å­—ç¬¦ä¸²çš„æ“ä½œï¼ŒæŸ¥è¯¢åœ¨æœ€æ—©å“ªä¸€æ—¶åˆ»ä»¥ $S$ ä¸ºå‰ç¼€çš„å­—ç¬¦ä¸²æ•°é‡è¶…è¿‡äº†æŸä¸€ä¸ªå€¼ã€‚ é¢˜è§£å­—ç¬¦ä¸²+å‰ç¼€ä¸€çœ¼å°±trieæ ‘äº†å˜›ã€‚ æ’å…¥å’Œåˆ é™¤éƒ½æ˜¯å¸¸è§„çš„trieï¼Œå¯ä»¥ç»´æŠ¤ä¸€ä¸ªsumæ¥ç»Ÿè®¡ã€‚ å¦‚æœæŸä¸€æ—¶åˆ»çš„sumè¶…è¿‡äº†vectorç»Ÿè®¡çš„sizeï¼Œé‚£ä¹ˆå°±pushè¿›å»ã€‚ æŸ¥è¯¢çš„è¯å°±æš´åŠ›æŸ¥è¯¢ã€‚å¦‚æœåœ¨æŸä¸€ä¸ªå­—ç¬¦çš„ç»Ÿè®¡å°‘äºäº† $k$ é‚£ä¹ˆå°±ä¸å¯èƒ½äº†ã€‚ æ€»ç»“æ¥è¯´ï¼Œè¿™æ˜¯ä¸€é“æ¯”è¾ƒæ°´è€Œä¸”å…¸å‹çš„trieæ ‘ç»ƒä¹ é¢˜ã€‚ #include &lt;bits/stdc++.h&gt; using namespace std; const int N = 1e6 + 5; int n, tot, lastans = 0; struct TrieNode { int frie, ch[30]; vector &lt; int &gt; rec; } trie[N]; void Insert(char str[], int ts) { int root = 0; for (int i = 0; str[i]; ++i) { int now = str[i] - &#39;a&#39;; if (!trie[root].ch[now]) trie[root].ch[now] = ++tot; root = trie[root].ch[now]; trie[root].frie++; if (trie[root].frie &gt; (int)trie[root].rec.size()) trie[root].rec.push_back(ts); } } void Delete(char str[], int ts) { int root = 0; for (int i = 0; str[i]; ++i) { int now = str[i] - &#39;a&#39;; if (!trie[root].ch[now]) trie[root].ch[now] = ++tot; root = trie[root].ch[now]; trie[root].frie--; if (trie[root].frie &gt;= (int)trie[root].rec.size()) trie[root].rec.push_back(ts); } } int Queryf(char str[], long long k) { int root = 0; for (int i = 0; str[i]; ++i) { int now = str[i] - &#39;a&#39;; root = trie[root].ch[now]; if ((long long)trie[root].rec.size() &lt;= k) return -1; } return trie[root].rec[k]; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1, opr, a, b, c; i &lt;= n; ++i) { char str[N]; scanf(&quot;%d %s&quot;, &amp;opr, str); if (opr == 1) Insert(str, i); else if (opr == 2) Delete(str, i); else scanf(&quot;%d %d %d&quot;, &amp;a, &amp;b, &amp;c), printf(&quot;%d\\n&quot;, lastans = Queryf(str, (1LL * a * abs(lastans) + 1LL * b) % (1LL * c))); } return 0; } 37.P4309 ã€[TJOI2013]æœ€é•¿ä¸Šå‡å­åºåˆ—ã€‘ç»™å®šä¸€ä¸ªåºåˆ—ï¼Œåˆå§‹ä¸ºç©ºã€‚ç°åœ¨æˆ‘ä»¬å°†1åˆ°Nçš„æ•°å­—æ’å…¥åˆ°åºåˆ—ä¸­ï¼Œæ¯æ¬¡å°†ä¸€ä¸ªæ•°å­—æ’å…¥åˆ°ä¸€ä¸ªç‰¹å®šçš„ä½ç½®ã€‚æ¯æ’å…¥ä¸€ä¸ªæ•°å­—ï¼Œæˆ‘ä»¬éƒ½æƒ³çŸ¥é“æ­¤æ—¶æœ€é•¿ä¸Šå‡å­åºåˆ—é•¿åº¦æ˜¯å¤šå°‘ï¼Ÿ DescriptionåŠ¨æ€ç»´æŠ¤LIS Solutionè¿™é“é¢˜æ­£è§£åº”è¯¥æ˜¯åœ¨å¹³è¡¡æ ‘ä¸Šç»´æŠ¤dpã€‚ è®¾ $dp_{i}$ è¡¨ç¤ºå‰ $i$ ä¸ªæ•°çš„LISé•¿åº¦ï¼Œè½¬ç§»æ–¹ç¨‹æ˜¾ç„¶ä¸ºï¼š dp_{i}=max\\{dp_{j}+1\\}è¿™ä¸œè¥¿éƒ½ä¸çŸ¥é“å¯ä»¥è€ƒè™‘$\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ $äº† ç„¶åæˆ‘ä»¬æ”¾åˆ°ç»´æŠ¤çš„èŠ‚ç‚¹ä¸Šå³å¯ã€‚ å¼€å¤´è¯´è¿‡å¹³è¡¡æ ‘å¯¹å§ï¼Œä½†æ˜¯è¿™é“é¢˜çš„æ•°æ®è¿‡æ°´ï¼Œvector+bitç›´æ¥èƒ½è¿‡ï¼Œè€Œä¸”è·‘å¾—é£å¿«ï¼Œç®¡ç†å¦‚æœæœ‰å¿ƒæƒ…çš„è¯å°±åŠ å¼ºä¸€ä¸‹å§ã€‚ #include &lt;bits/stdc++.h&gt; const int N = 100000 + 5; int n, p[N], ans[N], bit[N]; std::vector &lt; int &gt; vec; void update(int x, int y) { for (; x &lt;= n; x += x &amp; -x) bit[x] = std::max(bit[x], y); } int queryf(int x) { int res = 0; for (; x; x -= x &amp; -x) res = std::max(res, bit[x]); return res; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;p[i]), vec.insert(p[i] + vec.begin(), i); for (int i = 1; i &lt;= n; ++i) ans[vec[i - 1]] = queryf(vec[i - 1]) + 1, update(vec[i - 1], ans[vec[i - 1]]); for (int i = 1; i &lt;= n; ++i) ans[i] = std::max(ans[i], ans[i - 1]); for (int i = 1; i &lt;= n; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 38.CF85D Sum of Mediansä¸€ä¸ªé›†åˆï¼Œåˆå§‹ä¸ºç©ºã€‚ç°æœ‰ä¸‰ä¸ªæ“ä½œï¼š 1.addï¼šå‘é›†åˆé‡ŒåŠ å…¥æ•°xï¼Œä¿è¯åŠ å…¥å‰é›†åˆä¸­æ²¡æœ‰æ•°xï¼› 2.delï¼šä»é›†åˆä¸­åˆ é™¤æ•°xï¼Œä¿è¯åˆ é™¤å‰é›†åˆä¸­æœ‰xï¼› 3.sumï¼šè¯¢é—®å°†é›†åˆé‡Œçš„æ•°ä»å°åˆ°å¤§æ’åºåï¼Œæ±‚ä¸‹æ ‡iæ¨¡5ä½™3çš„æ•°çš„å’Œã€‚ ç°æœ‰næ¬¡æ“ä½œï¼Œå¯¹äºæ¯ä¸ªæŸ¥è¯¢æ“ä½œï¼Œè¾“å‡ºç­”æ¡ˆ Descriptionè®©ä½ ç»´æŠ¤ä¸€ä¸ªç±»ä¼¼std::setçš„ä¸œè¥¿ï¼Œå®ç°ä¸€ä¸ªæ”¯æŒæ’å…¥ã€åˆ é™¤ã€æŸ¥è¯¢å‡åºæ’åºåçš„ $\\sum_{i=1}^{n}[i\\operatorname{mod}5=3]\\times A_{i}$ çš„ä¸å¯é‡é›†åˆã€‚ Solutionæ­£è§£çº¿æ®µæ ‘æ²¡è·‘ã€‚ä½†æ˜¯æˆ‘ä»¬çœ‹åˆ°3Sçš„æ—¶é™ $10^{5}$ çš„æ•°æ®ä»¥åŠä¸€è´¯çš„CFæ•°æ®ã€‚æˆ‘ä»¬æœ‰ç†ç”±è®¤ä¸ºè¿™é“é¢˜vectoræ¨¡æ‹Ÿèƒ½è¿‡ï¼ˆæ»‘ç¨½ ç„¶åå°±çœŸçš„èƒ½è¿‡ï¼Œstd::lower_boundæŸ¥æ‰¾æ’å…¥ä»¥åŠåˆ é™¤çš„ä½ç½®ã€‚æŸ¥è¯¢çš„è¯å°± $i$ ä»2å¼€å§‹ï¼ˆvectorä¸‹æ ‡ä»0å¼€å§‹ï¼Œæ‰€ä»¥è¦å‡ä¸€ï¼‰ï¼Œæ¯æ¬¡ $i=i+5$ ç„¶åç´¯åŠ  $A_{i}$ å³å¯ã€‚ #include &lt;bits/stdc++.h&gt; std::vector &lt; int &gt; vect; signed main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 0, x; i &lt; n; ++i) { char str[5]; scanf(&quot;%s&quot;, str); if (*str == &#39;a&#39;) { scanf(&quot;%d&quot;, &amp;x); vect.insert(std::lower_bound(vect.begin(), vect.end(), x), x); } else if (*str == &#39;d&#39;) { scanf(&quot;%d&quot;, &amp;x); vect.erase(std::lower_bound(vect.begin(), vect.end(), x)); } else { long long res = 0; for (unsigned i = 2; i &lt; vect.size(); i += 5) res += vect[i]; printf(&quot;%lld\\n&quot;, res); } } return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 21~30é¢˜","slug":"DS100P-21-30-P","date":"2020-02-08T06:03:31.000Z","updated":"2020-02-21T12:06:06.379Z","comments":true,"path":"2020/02/08/DS100P-21-30-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-21-30-P/","excerpt":"","text":"21.P4172 [WC2006]æ°´ç®¡å±€é•¿SC çœ MY å¸‚æœ‰ç€åºå¤§çš„åœ°ä¸‹æ°´ç®¡ç½‘ç»œï¼Œå˜Ÿå˜Ÿæ˜¯ MY å¸‚çš„æ°´ç®¡å±€é•¿ï¼ˆå°±æ˜¯ç®¡æ°´ç®¡çš„å•¦ï¼‰ï¼Œå˜Ÿå˜Ÿä½œä¸ºæ°´ç®¡å±€é•¿çš„å·¥ä½œå°±æ˜¯ï¼šæ¯å¤©ä¾›æ°´å…¬å¸å¯èƒ½è¦å°†ä¸€å®šé‡çš„æ°´ä» $x$ å¤„é€å¾€ $y$ å¤„ï¼Œå˜Ÿå˜Ÿéœ€è¦ä¸ºä¾›æ°´å…¬å¸æ‰¾åˆ°ä¸€æ¡ä» $A$ è‡³ $B$ çš„æ°´ç®¡çš„è·¯å¾„ï¼Œæ¥ç€é€šè¿‡ä¿¡æ¯åŒ–çš„æ§åˆ¶ä¸­å¿ƒé€šçŸ¥è·¯å¾„ä¸Šçš„æ°´ç®¡è¿›å…¥å‡†å¤‡é€æ°´çŠ¶æ€ï¼Œç­‰åˆ°è·¯å¾„ä¸Šæ¯ä¸€æ¡æ°´ç®¡éƒ½å‡†å¤‡å¥½äº†ï¼Œä¾›æ°´å…¬å¸å°±å¯ä»¥å¼€å§‹é€æ°´äº†ã€‚å˜Ÿå˜Ÿä¸€æ¬¡åªèƒ½å¤„ç†ä¸€é¡¹é€æ°´ä»»åŠ¡ï¼Œç­‰åˆ°å½“å‰çš„é€æ°´ä»»åŠ¡å®Œæˆäº†ï¼Œæ‰èƒ½å¤„ç†ä¸‹ä¸€é¡¹ã€‚ åœ¨å¤„ç†æ¯é¡¹é€æ°´ä»»åŠ¡ä¹‹å‰ï¼Œè·¯å¾„ä¸Šçš„æ°´ç®¡éƒ½è¦è¿›è¡Œä¸€ç³»åˆ—çš„å‡†å¤‡æ“ä½œï¼Œå¦‚æ¸…æ´—ã€æ¶ˆæ¯’ç­‰ç­‰ã€‚å˜Ÿå˜Ÿåœ¨æ§åˆ¶ä¸­å¿ƒä¸€å£°ä»¤ä¸‹ï¼Œè¿™äº›æ°´ç®¡çš„å‡†å¤‡æ“ä½œåŒæ—¶å¼€å§‹ï¼Œä½†ç”±äºå„æ¡ç®¡é“çš„é•¿åº¦ã€å†…å¾„ä¸åŒï¼Œè¿›è¡Œå‡†å¤‡æ“ä½œéœ€è¦çš„æ—¶é—´å¯èƒ½ä¸åŒã€‚ä¾›æ°´å…¬å¸æ€»æ˜¯å¸Œæœ›å˜Ÿå˜Ÿèƒ½æ‰¾åˆ°è¿™æ ·ä¸€æ¡é€æ°´è·¯å¾„ï¼Œè·¯å¾„ä¸Šçš„æ‰€æœ‰ç®¡é“å…¨éƒ½å‡†å¤‡å°±ç»ªæ‰€éœ€è¦çš„æ—¶é—´å°½é‡çŸ­ã€‚å˜Ÿå˜Ÿå¸Œæœ›ä½ èƒ½å¸®åŠ©ä»–å®Œæˆè¿™æ ·çš„ä¸€ä¸ªé€‰æ‹©è·¯å¾„çš„ç³»ç»Ÿï¼Œä»¥æ»¡è¶³ä¾›æ°´å…¬å¸çš„è¦æ±‚ã€‚å¦å¤–ï¼Œç”±äº MY å¸‚çš„æ°´ç®¡å¹´ä»£ä¹…è¿œï¼Œä¸€äº›æ°´ç®¡ä¼šä¸æ—¶å‡ºç°æ•…éšœå¯¼è‡´ä¸èƒ½ä½¿ç”¨ï¼Œä½ çš„ç¨‹åºå¿…é¡»è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ã€‚ ä¸å¦¨å°† MY å¸‚çš„æ°´ç®¡ç½‘ç»œçœ‹ä½œä¸€å¹…ç®€å•æ— å‘å›¾ï¼ˆå³æ²¡æœ‰è‡ªç¯æˆ–é‡è¾¹ï¼‰ï¼šæ°´ç®¡æ˜¯å›¾ä¸­çš„è¾¹ï¼Œæ°´ç®¡çš„è¿æ¥å¤„ä¸ºå›¾ä¸­çš„ç»“ç‚¹ã€‚ è¿™é“é¢˜åªæœ‰åˆ è¾¹æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥æŠŠè¿™ä¸ªè¿‡ç¨‹çœ‹åšæ˜¯åŠ è¾¹æ“ä½œï¼Œè¿™æ ·å¥½å¤„ç†ä¸€ç‚¹ã€‚ é¢˜ç›®ä¿è¯äº†å›¾æ— è®ºæ€ä¹ˆåˆ è¾¹éƒ½ä¿è¯è”é€šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæŠŠå›¾åˆ å®Œã€‚åˆ å®Œåæˆ‘ä»¬å‘¢æ±‚å‡ºå›¾çš„MST, é‚£ä¹ˆä»»æ„ä¸¤ç‚¹åœ¨è¿™é¢—MSTä¸Šèµ°éƒ½æ˜¯æœ€ä¼˜çš„åˆ«é—®æˆ‘æ€ä¹ˆè¯è´ªå¿ƒæ˜¯ç”¨æ¥è¯çš„å—ã€‚æˆ‘ä»¬å¯ä»¥ç”¨LCTæ¥ç»´æŠ¤è¿™é¢—MSTï¼ŒSplayç»´æŠ¤åŒºé—´æœ€å¤§å€¼(ä¹Ÿå°±æ˜¯é“¾ä¸Šçš„æœ€å¤§å€¼) è€ƒè™‘åŠ è¾¹æ“ä½œã€‚ä¸Šé¢æˆ‘æåˆ°äº†ä¸€ä¸ªè´ªå¿ƒï¼šä»»æ„ä¸¤ç‚¹åœ¨è¿™é¢—MSTä¸Šèµ°éƒ½æ˜¯æœ€ä¼˜çš„ã€‚å¦‚æœæ­¤æ—¶æˆ‘ä»¬åœ¨MSTä¸Šä»»æ„åŠ ä¸€æ¡è¾¹éƒ½ä¼šå½¢æˆä¸€ä¸ªç¯ã€‚æˆ‘ä»¬å¯ä»¥ä»ä»»æ„ä¸€ç‚¹å…¥ç¯ï¼Œä»»æ„ä¸€ç‚¹å‡ºç¯ï¼Œæ–¹å‘éšæ„ã€‚å¯ä»¥å‘ç°æˆ‘ä»¬çš„æœ€ä¼˜è§£å§‹ç»ˆèƒ½é¿å¼€æœ€é•¿çš„ä¸€æ¡è¾¹ï¼ è€ƒå¯Ÿè¿™ä¸ªç¯ï¼Œç”¨lctçš„splitæ“ä½œæå‡ºé“¾çš„ä¿¡æ¯ï¼ŒæŸ¥å‡ºæœ€å¤§çš„æƒå€¼ã€‚å‘ç°æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ é™¤æƒå€¼æœ€å¤§çš„è¾¹æ¥ä¿è¯ç¯ä¸Šçš„æœ€ä¼˜ã€‚ æ€ä¹ˆæ±‚å‡ºè¿™æ¡è¾¹å‘¢ï¼Ÿæ˜¾ç„¶æˆ‘ä»¬å¯ä»¥äºŒåˆ†æ¥æ‰¾ å†æ¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼šå¦‚ä½•ç»´æŠ¤è¾¹å‘¢ï¼Ÿ è€ƒè™‘ç”¨ä¸€ä¸ªç‚¹æ¥è¡¨ç¤ºä¸€æ¡è¾¹ã€‚ æœ€åé€†åºåŠ è¾¹ï¼ŒæŠŠç­”æ¡ˆé€†åºè¾“å‡ºå³å¯ (è‰¯å¿ƒé¢˜è§£) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace LinkCutTree { const int SIZE = 12e4 + 5; struct SPLAY { int ch[2]; int fa; int key; int maxValue; int lazyTag; } T[SIZE]; stack &lt; int &gt; MemoryWaste; #define ls T[x].ch[0] #define rs T[x].ch[1] #define WhichSon(x) (T[T[x].fa].ch[1] == x) #define IsRoot(x) (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x) void UpdateMessage(int x) { T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue); } void UpdateSons(int x) { if (T[x].lazyTag) { ls ^= rs ^= ls ^= rs; T[x].lazyTag = 0; T[ls].lazyTag ^= 1; T[rs].lazyTag ^= 1; } } void RotateNode(int x) { int y = T[x].fa; if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x; bool k = WhichSon(x); T[x].fa = T[y].fa; T[y].fa = x; T[y].ch[k] = T[x].ch[k ^ 1]; T[T[y].ch[k]].fa = y; T[x].ch[k ^ 1] = y; UpdateMessage(y); UpdateMessage(x); } void LinkSplay(int x) { int u = x; while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa; MemoryWaste.push(u); while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop(); for (; !IsRoot(x); RotateNode(x)) { int y = T[x].fa; if (!IsRoot(y)) RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y); } } void AccessEdge(int x) { for (int u = x, y = 0; u; y = u, u = T[u].fa) { LinkSplay(u); T[u].ch[1] = y; UpdateMessage(u); } } void MakeRoot(int x) { AccessEdge(x); LinkSplay(x); T[x].lazyTag ^= 1; } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); } void LinkTree(int x, int y) { MakeRoot(x); T[x].fa = y; } void CutTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); T[x].fa = T[y].ch[0] = 0; } int FindByKey(int x, int u) { if (T[x].key == u) return x; else if (T[ls].maxValue == u) return FindByKey(ls, u); else return FindByKey(rs, u); } } // namespace LinkCutTree using namespace LinkCutTree; int F[1005][1005], U[101000], V[101000]; int OP[101000], ans[101000], n, m, QueryNumber; struct EdgeNode { int x, y; int val, key; EdgeNode() { key = 1; } friend bool operator &lt; (EdgeNode X, EdgeNode Y) { return X.val &lt; Y.val; } } e[101000]; struct UnionFindSet { int fa[1010]; int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { int u = find(x), v = find(y); if (u ^ v) fa[u] = v; } void init(int n, int m) { for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) { if (e[i].key &amp;&amp; find(e[i].x) ^ find(e[i].y)) { merge(e[i].x, e[i].y); LinkTree(e[i].x, n + i); LinkTree(e[i].y, n + i); } } } } ufs; signed main() { read(n, m, QueryNumber); for (int i = 1; i &lt;= m; ++i) read(e[i].x, e[i].y, e[i].val); sort(e + 1, e + 1 + m); for (int i = 1; i &lt;= m; ++i) { F[e[i].x][e[i].y] = i; F[e[i].y][e[i].x] = i; T[n + i].key = e[i].val; } for (int i = 1; i &lt;= QueryNumber; ++i) { read(OP[i], U[i], V[i]); if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0; } ufs.init(n, m); int EdgeCount = 0; for (int i = QueryNumber; i &gt;= 1; --i) { SplitTree(U[i], V[i]); if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue; else { int Temporary = FindByKey(V[i], T[V[i]].maxValue); if (T[F[U[i]][V[i]] + n].key &lt; T[V[i]].maxValue) { CutTree(e[Temporary - n].x, Temporary); CutTree(e[Temporary - n].y, Temporary); LinkTree(U[i], F[U[i]][V[i]] + n); LinkTree(V[i], F[U[i]][V[i]] + n); } } } for (int i = EdgeCount; i &gt;= 1; --i) write(io_l, ans[i]); return 0; } 22.P3302 [SDOI2013]æ£®æ—å°Zæœ‰ä¸€ç‰‡æ£®æ—ï¼Œå«æœ‰Nä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½æœ‰ä¸€ä¸ªéè´Ÿæ•´æ•°ä½œä¸ºæƒå€¼ã€‚åˆå§‹çš„æ—¶å€™ï¼Œæ£®æ—ä¸­æœ‰Mæ¡è¾¹ã€‚ å°Zå¸Œæœ›æ‰§è¡ŒTä¸ªæ“ä½œï¼Œæ“ä½œæœ‰ä¸¤ç±»ï¼š Q x y kæŸ¥è¯¢ç‚¹xåˆ°ç‚¹yè·¯å¾„ä¸Šæ‰€æœ‰çš„æƒå€¼ä¸­ï¼Œç¬¬kå°çš„æƒå€¼æ˜¯å¤šå°‘ã€‚æ­¤æ“ä½œä¿è¯ç‚¹xå’Œç‚¹yè¿é€šï¼ŒåŒæ—¶è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„è·¯å¾„ä¸Šè‡³å°‘æœ‰kä¸ªç‚¹ã€‚ L x yåœ¨ç‚¹xå’Œç‚¹yä¹‹é—´è¿æ¥ä¸€æ¡è¾¹ã€‚ä¿è¯å®Œæˆæ­¤æ“ä½œåï¼Œä»ç„¶æ˜¯ä¸€ç‰‡æ£®æ—ã€‚ ä¸ºäº†ä½“ç°ç¨‹åºçš„åœ¨çº¿æ€§ï¼Œæˆ‘ä»¬æŠŠè¾“å…¥æ•°æ®è¿›è¡Œäº†åŠ å¯†ã€‚è®¾lastansä¸ºç¨‹åºä¸Šä¸€æ¬¡è¾“å‡ºçš„ç»“æœï¼Œåˆå§‹çš„æ—¶å€™lastansä¸º0ã€‚ å¯¹äºä¸€ä¸ªè¾“å…¥çš„æ“ä½œQ x y k,å…¶çœŸå®æ“ä½œä¸ºQ x^lastans y^lastans k^lastansã€‚ å¯¹äºä¸€ä¸ªè¾“å…¥çš„æ“ä½œL x yï¼Œå…¶çœŸå®æ“ä½œä¸ºL x^lastans y^lastansã€‚å…¶ä¸­^è¿ç®—ç¬¦è¡¨ç¤ºå¼‚æˆ–ï¼Œç­‰ä»·äºpascalä¸­çš„xorè¿ç®—ç¬¦ã€‚ è¯·å†™ä¸€ä¸ªç¨‹åºä¾†å¸®åŠ©å°Zå®Œæˆè¿™äº›æ“ä½œã€‚ æŸ¥è¯¢æ“ä½œæ˜¾ç„¶å¯ä»¥ç”¨ä¸»å¸­æ ‘æ¥å®Œæˆï¼Œç„¶è€Œè¿æ¥æ ‘çš„æ“ä½œåˆè®©æˆ‘ä»¬æƒ³åˆ°äº†lctã€‚æ€ä¹ˆåŠå‘¢ï¼Ÿä¸»å¸­æ ‘+LCTï¼Ÿ(æ®è¯´è¿˜çœŸæœ‰äººè¿™ä¹ˆå¹²) å¯å‘å¼åˆå¹¶ï¼ æ²¡é”™ï¼Œæˆ‘ä»¬ç”¨é€‰æ‹©ç”¨ä¸»å¸­æ ‘æ¥å®Œæˆè¿™é“é¢˜ï¼Œåˆå¹¶æ—¶é‡‡ç”¨å¯å‘å¼åˆå¹¶ã€‚ å…·ä½“æ¥è¯´å°±æ˜¯æ¯æ¬¡åˆå¹¶æ—¶éƒ½ç”¨å¤§å°è¾ƒå°çš„æ ‘å¾€å¤§çš„åˆå¹¶ï¼Œç„¶åæš´åŠ›éå†å¤§å°è¾ƒå°çš„æ ‘æ›´æ–°å€å¢æ•°ç»„å’Œä¸»å¸­æ ‘å³å¯ #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 9e4 + 5; const int LSIZE = SIZE &lt;&lt; 7; const int GSIZE = SIZE &lt;&lt; 1; int n, m, q, waste; int tot, rt[LSIZE], b[SIZE]; int pri_n, edge_tot, a[SIZE]; int Head[GSIZE], Next[GSIZE]; int Vertex[GSIZE], Weight[GSIZE]; int f[SIZE][LSIZE / SIZE &gt;&gt; 2]; int dp[SIZE], fa[SIZE], id[SIZE]; int size[SIZE], vis[SIZE]; struct TreeNode { int l, r; int size; } tr[LSIZE]; void add(int x, int y, int z = 1) { Vertex[++edge_tot] = y, Weight[edge_tot] = z; Next[edge_tot] = Head[x], Head[x] = edge_tot; } int find_set(int x) { return x == fa[x] ? x : fa[x] = find_set(fa[x]); } int make(int l, int r) { int u = ++tot; if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u; else return 0; } void modify(int &amp;u, int pre, int l, int r, int x) { u = ++tot; tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1}; if (l ^ r) if (mid &gt;= x) modify(tr[u].l, tr[pre].l, l, mid, x); else modify(tr[u].r, tr[pre].r, mid + 1, r, x); else return ; } int query(int x, int y, int lca, int fa_lca, int l, int r, int k) { if (l ^ r) if (_size_ &gt;= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k); else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_); else return l; } void dfs(int x, int _rt_) { for (int i = 1; i &lt; 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]); #define y Vertex[i] for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_); #undef y } int get_lca(int x, int y) { if (dp[x] &lt; dp[y]) x ^= y ^= x ^= y; for (int i = 16; i &gt;= 0; --i) if (f[x][i] &amp;&amp; dp[f[x][i]] &gt;= dp[y]) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } signed main() { read(waste, n, m, q); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); pri_n = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b; for (int i = 1, x, y; i &lt;= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1); *rt = make(1, pri_n); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i; int ans = 0, lastans = 0; for (int enum_q = 0; enum_q &lt; q; ++enum_q) { char opt[5]; int x, y, k, lca; read(opt), read(x, y); x ^= lastans, y ^= lastans; if (*opt == &#39;Q&#39;) read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]); else { add(x, y, 1); add(y, x, 1); int u = find_set(x); int v = find_set(y); if (size[u] &lt; size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v; f[y][0] = x; fa[y] = x; dp[y] = dp[x] + 1; vis[y] = true; size[u]++; dfs(y, v); } } return 0; } 23.P3250 [HNOI2016]ç½‘ç»œä¸€ä¸ªç®€å•çš„ç½‘ç»œç³»ç»Ÿå¯ä»¥è¢«æè¿°æˆä¸€æ£µæ— æ ¹æ ‘ã€‚æ¯ä¸ªèŠ‚ç‚¹ä¸ºä¸€ä¸ªæœåŠ¡å™¨ã€‚è¿æ¥æœåŠ¡å™¨ä¸æœåŠ¡å™¨çš„æ•°æ®çº¿åˆ™çœ‹åšä¸€æ¡æ ‘è¾¹ã€‚ä¸¤ä¸ªæœåŠ¡å™¨è¿›è¡Œæ•°æ®çš„äº¤äº’æ—¶ï¼Œæ•°æ®ä¼šç»è¿‡è¿æ¥è¿™ä¸¤ä¸ªæœåŠ¡å™¨çš„è·¯å¾„ä¸Šçš„æ‰€æœ‰æœåŠ¡å™¨ï¼ˆåŒ…æ‹¬è¿™ä¸¤ä¸ªæœåŠ¡å™¨è‡ªèº«ï¼‰ã€‚ ç”±äºè¿™æ¡è·¯å¾„æ˜¯å”¯ä¸€çš„ï¼Œå½“è·¯å¾„ä¸Šçš„æŸä¸ªæœåŠ¡å™¨å‡ºç°æ•…éšœï¼Œæ— æ³•æ­£å¸¸è¿è¡Œæ—¶ï¼Œæ•°æ®ä¾¿æ— æ³•äº¤äº’ã€‚æ­¤å¤–ï¼Œæ¯ä¸ªæ•°æ®äº¤äº’è¯·æ±‚éƒ½æœ‰ä¸€ä¸ªé‡è¦åº¦ï¼Œè¶Šé‡è¦çš„è¯·æ±‚æ˜¾ç„¶éœ€è¦å¾—åˆ°è¶Šé«˜çš„ä¼˜å…ˆå¤„ç†æƒã€‚ç°åœ¨ï¼Œä½ ä½œä¸ºä¸€ä¸ªç½‘ç»œç³»ç»Ÿçš„ç®¡ç†å‘˜ï¼Œè¦ç›‘æ§æ•´ä¸ªç³»ç»Ÿçš„è¿è¡ŒçŠ¶æ€ã€‚ç³»ç»Ÿçš„è¿è¡Œä¹Ÿæ˜¯å¾ˆç®€å•çš„ï¼Œåœ¨æ¯ä¸€ä¸ªæ—¶åˆ»ï¼Œåªæœ‰å¯èƒ½å‡ºç°ä¸‹åˆ—ä¸‰ç§äº‹ä»¶ä¸­çš„ä¸€ç§ï¼š åœ¨æŸä¸¤ä¸ªæœåŠ¡å™¨ä¹‹é—´å‡ºç°ä¸€æ¡æ–°çš„æ•°æ®äº¤äº’è¯·æ±‚ï¼› æŸä¸ªæ•°æ®äº¤äº’ç»“æŸè¯·æ±‚ï¼› æŸä¸ªæœåŠ¡å™¨å‡ºç°æ•…éšœã€‚ç³»ç»Ÿä¼šåœ¨ä»»ä½•æ•…éšœå‘ç”Ÿåç«‹å³ä¿®å¤ã€‚ä¹Ÿå°±æ˜¯åœ¨å‡ºç°æ•…éšœçš„æ—¶åˆ»ä¹‹åï¼Œè¿™ä¸ªæœåŠ¡å™¨ä¾ç„¶æ˜¯æ­£å¸¸çš„ã€‚ä½†åœ¨æœåŠ¡å™¨äº§ç”Ÿæ•…éšœæ—¶ä¾ç„¶ä¼šå¯¹éœ€è¦ç»è¿‡è¯¥æœåŠ¡å™¨çš„æ•°æ®äº¤äº’è¯·æ±‚é€ æˆå½±å“ã€‚ ä½ çš„ä»»åŠ¡æ˜¯åœ¨æ¯æ¬¡å‡ºç°æ•…éšœæ—¶ï¼Œç»´æŠ¤æœªè¢«å½±å“çš„è¯·æ±‚ä¸­é‡è¦åº¦çš„æœ€å¤§å€¼ã€‚æ³¨æ„ï¼Œå¦‚æœä¸€ä¸ªæ•°æ®äº¤äº’è¯·æ±‚å·²ç»ç»“æŸï¼Œåˆ™ä¸å°†å…¶çº³å…¥æœªè¢«å½±å“çš„è¯·æ±‚èŒƒå›´ã€‚ æä¾› $\\Theta(n\\log^3n)$ çš„æš´åŠ›æ ‘å‰–æ‰“æ³•ã€‚ æœ¬æ¥æˆ‘æƒ³ææ ‘å¥—æ ‘+æ ‘å‰–çš„ï¼Œä½†å‘ç°Splayå¸¸æ•°è¿‡å¤§å®¹æ˜“Tçˆ†ï¼Œfhq-treapä¹Ÿç‚¸äº†ã€‚ åæ¥æˆ‘å¹¡ç„¶é†’æ‚Ÿæˆ‘ä»¬åªéœ€è¦å¼€ä¸¤ä¸ªä¼˜å…ˆé˜Ÿåˆ—ä¸€ä¸ªæ”¾æ·»åŠ çš„å€¼ï¼Œä¸€ä¸ªæ”¾åˆ é™¤çš„å€¼ã€‚ ç¢°åˆ°æŸ¥è¯¢æ“ä½œæ—¶å…ˆæ¯”è¾ƒä¸¤ä¸ªå †çš„å †é¡¶ï¼Œå¦‚æœç›¸åŒæ˜¾ç„¶å®ƒè¢«åˆ æ‰äº†ï¼Œä¸¤ä¸ªæ ˆåŒæ—¶å¼¹å‡ºï¼›ä¸ç›¸åŒæ—¶æ·»åŠ å…ƒç´ é˜Ÿåˆ—çš„é˜Ÿé¦–å°±æ˜¯ç­”æ¡ˆã€‚ è€Œä¸”è¿™é“é¢˜å¼€O2æ•ˆæœç‰¹åˆ«æ˜æ˜¾ï¼Œ2.x s èƒ½å˜æˆ xxx ms! #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define CheckSize ((d[top[x]] &lt; d[top[y]]) &amp;&amp; (x ^= y ^= x ^= y)) #define ForGraph int i = Head[x], y = Vertex[i]; i; i = Next[i], y = Vertex[i] #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace HNOI2016_Network { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { const int SIZE = 2e5 + 5; const int GSIZE = SIZE &lt;&lt; 1; namespace SegmentTree { priority_queue &lt; int &gt; I[SIZE&lt;&lt;1], D[SIZE&lt;&lt;1]; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) void DoModify(int k, int l, int r, int x, int y, int val, int opt) { if (!(l &gt; y || r &lt; x)) if (l &gt;= x &amp;&amp; r &lt;= y) if (opt) I[k].push(val); else D[k].push(val); else DoModify(ls, l, mid, x, y, val, opt), DoModify(rs, mid + 1, r, x, y, val, opt); } int GetAnswer(int k, int l, int r, int x) { while (I[k].size() &amp;&amp; D[k].size() &amp;&amp; I[k].top() == D[k].top()) I[k].pop(), D[k].pop(); int res = I[k].size() ? I[k].top() : -1; if (l ^ r) if (mid &gt;= x) res = max(res, GetAnswer(ls, l, mid, x)); else res = max(res, GetAnswer(rs, mid + 1, r, x)); return res; } } // namespace SegmentTree namespace TreeChainSplitting { int tx[SIZE], ty[SIZE], tk[SIZE]; int Head[SIZE], Vertex[GSIZE]; int Next[GSIZE], EdgeCount; int fa[SIZE], size[SIZE]; int d[SIZE], son[SIZE]; int dfn[SIZE], rnk[SIZE]; int top[SIZE], tot; int edge_tot = 0, n, m; struct Vector2 { int x; int y; friend bool operator &lt; (Vector2 rhs1, Vector2 rhs2) { return rhs1.x &lt; rhs2.x; } } Vec2[SIZE]; void add(int x, int y) { Vertex[++edge_tot] = y; Next[edge_tot] = Head[x]; Head[x] = edge_tot; } void dfs1(int x, int fa) { size[x] = 1, TreeChainSplitting::fa[x] = fa, d[x] = d[fa] + 1; for (ForGraph) if (y ^ fa) dfs1(y, x), size[x] += size[y], ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)); } void dfs2(int x, int tp) { top[x] = tp, dfn[x] = ++tot, rnk[tot] = x; if (son[x]) dfs2(son[x], tp); for (ForGraph) if (y ^ fa[x] &amp;&amp; y ^ son[x]) dfs2(y, y); } void ModifySubTree(int x, int y, int val, int opt, int tp = 0) { while (top[x] ^ top[y]) CheckSize, Vec2[++tp] = {dfn[top[x]], dfn[x]}, x = fa[top[x]]; if (dfn[x] &gt; dfn[y]) x ^= y ^= x ^= y; Vec2[++tp] = {dfn[x], dfn[y]}; sort(Vec2 + 1, Vec2 + 1 + tp); int Sys = 1; for (int i = 1; i &lt;= tp; ++i) ((Sys &lt; Vec2[i].x) &amp;&amp; (SegmentTree::DoModify(1, 1, n, Sys, Vec2[i].x - 1, val, opt), 1)), Sys = Vec2[i].y + 1; if (Sys &lt;= n) SegmentTree::DoModify(1, 1, n, Sys, n, val, opt); } void main() { read(n, m); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); dfs1(1, 0), dfs2(1, 1); for (int i = 1, x, y, k, t, opt; i &lt;= m; ++i) { read(opt); if (opt == 0) read(x, y, k), ModifySubTree(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k; else if (opt == 1) read(t), ModifySubTree(tx[t], ty[t], tk[t], 0); else if (opt == 2) read(x), write(io_l, SegmentTree::GetAnswer(1, 1, n, dfn[x])); } } } // namespace TreeChainSplittin } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace HNOI2016_Network signed main() { HNOI2016_Network::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::TreeChainSplitting::main(); } 24.P4211 [LNOI2014]LCAç»™å‡ºä¸€ä¸ªnä¸ªèŠ‚ç‚¹çš„æœ‰æ ¹æ ‘ï¼ˆç¼–å·ä¸º0åˆ°n-1ï¼Œæ ¹èŠ‚ç‚¹ä¸º0ï¼‰ã€‚ä¸€ä¸ªç‚¹çš„æ·±åº¦å®šä¹‰ä¸ºè¿™ä¸ªèŠ‚ç‚¹åˆ°æ ¹çš„è·ç¦»+1ã€‚è®¾dep[i]è¡¨ç¤ºç‚¹içš„æ·±åº¦ï¼ŒLCA(i,j)è¡¨ç¤ºiä¸jçš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚æœ‰qæ¬¡è¯¢é—®ï¼Œæ¯æ¬¡è¯¢é—®ç»™å‡ºl r zï¼Œæ±‚$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$ é—®é¢˜å¯ä»¥è½¬åŒ–ä¸ºæ±‚ç‚¹åˆ°æ ¹çš„è·ç¦»+1ï¼Œè¯¢é—®låˆ°rçš„ç»“ç‚¹åˆ°æ ¹çš„è·ç¦»å’Œã€‚ è¿™ç›¸å½“äºæ˜¯åœ¨æ±‚ç»“ç‚¹åˆ°æ ¹çš„ç‚¹æƒ+1çš„å’Œã€‚ é‚£ä¹ˆè¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿ æ˜¾ç„¶æˆ‘ä»¬å¯ä»¥ç¦»çº¿å¾—åˆ°æ‰€æœ‰çš„è¯¢é—®ï¼Œç„¶åå°†å·®åˆ†è¯¢é—®ï¼Œä¹Ÿå°±æ˜¯æŸ¥è¯¢ $[1,r]-[1,l-1]$ æˆ‘ä»¬å¯ä»¥åœ¨l-1å’Œrå¤„æ‰“æ ‡è®°ï¼Œç„¶åéå†æ ‘çš„ç»“ç‚¹æœ‰æ ‡è®°å°±æ‰§è¡ŒæŸ¥è¯¢æ“ä½œã€‚ æ–¹ä¾¿èµ·è§æˆ‘ä»¬å¯ä»¥ç”¨æ ‘é“¾å‰–åˆ†æ¥ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦nä¹˜ä¸Šä¸€ä¸ªLogæ–¹nã€‚ (å¯¹äº†æˆ‘çš„ä»£ç ç‰¹åˆ«ç„å­¦ï¼ŒæŸ¥è¯¢éƒ¨åˆ†å¾ªç¯ç‰ˆæœ¬åœ¨luoguä¸ŠTäº†ï¼Œåœ¨lojAäº†ï¼Œé€’å½’ç‰ˆæœ¬åœ¨luoguAäº†ï¼Œåœ¨lojTäº†ï¼) (æˆ‘å¯¹è¿™ä»½ä»£ç é™¤äº†ç¼“ç¼“åœ°æ‰“å‡ºä¸€ä¸ªé—®å·ä¹Ÿä¸èƒ½è¯´ä»€ä¹ˆäº†) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define IT vector &lt; int &gt;::iterator #define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i] #define CheckSize ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define TCS TreeChainSplitting #define CFS ChainForwardStar #define PS ProblemSolver #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e4 + 5; namespace ChainForwardStar { const int SIZE = ::SIZE; int tot_, Vert[SIZE]; int Head[SIZE], Next[SIZE]; void AddLine(int x, int y) { Vert[++tot_] = y; Next[tot_] = Head[x]; Head[x] = tot_; } } // namespace ChainForwardStar using CFS::Head; using CFS::Vert; using CFS::Next; using CFS::AddLine; namespace TreeChainSplitting { const int SIZE = ::SIZE; const int MOD = 201314; int n, m, tot, d[SIZE]; int fa[SIZE], size[SIZE]; int son[SIZE], top[SIZE]; int dfn[SIZE], rnk[SIZE]; int ask[SIZE], ans[SIZE]; vector &lt; int &gt; GFY[SIZE]; vector &lt; int &gt; FI[SIZE]; int sum[SIZE &lt;&lt; 2], lf[SIZE &lt;&lt; 2]; void Prepare(int x) { size[x] = 1, d[x] = d[fa[x]] + 1; for (ForGraph) Prepare(y), size[x] += size[y], CheckSize; } void Prepare(int x, int tp) { rnk[dfn[x] = ++tot] = x, top[x] = tp; if (son[x]) Prepare(son[x], tp); for (ForGraph) if (y ^ son[x]) Prepare(y, y); } #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define L_RECUR ls, l, mid, x, y #define R_RECUR rs, mid + 1, r, x, y #define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD, \\ sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k], \\ lf[rs] += lf[k], lf[k] = 0 #define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD void ModifyChain(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k]; else { UpdateSons(k, l, r); if (mid &gt;= x) ModifyChain(L_RECUR); if (mid &lt; y) ModifyChain(R_RECUR); UpdateMessages(k); } } void ModifySubTree(int x) { if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]); } int QueryChain(int k, int l, int r, int x, int y, int res = 0) { if (l &gt;= x &amp;&amp; r &lt;= y) return sum[k]; UpdateSons(k, l, r); if (mid &gt;= x) res += QueryChain(L_RECUR, 0); if (mid &lt; y) res += QueryChain(R_RECUR, 0); return res; } int QuerySubTree(int x, int res = 0) { // luogu-only if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res; } // int QuerySubTree(int x, int res = 0) { // loj-only // while (x) { // res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]); // x = fa[top[x]]; // } // return res; // } } // namespace TreeChainSplitting namespace ProblemSolver { void main() { read(TCS::n), read(TCS::m); for (int i = 2; i &lt;= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i); TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1); int L, R; for (int i = 1; i &lt;= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i]; for (int i = 1; i &lt;= TCS::n; ++i) { TCS::ModifySubTree(i); for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]); for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]); } for (int i = 1; i &lt;= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD); } } // namespace ProblemSover signed main() { PS::main(); } 25.ã€Œ2018 é›†è®­é˜Ÿäº’æµ‹ Day 3ã€åŒ—æ ¡é—¨å¤–çš„æœªæ¥å‰è¨€è¿™é“é¢˜ç»å¯¹æ˜¯æˆ‘ç›®å‰æ¥è¯´åšé¢˜ç”¨æ—¶æœ€é•¿çš„ä¸€é“é¢˜ï¼ˆæ€»å…±èŠ±äº†æˆ‘äº”å¤©æ—¶é—´å·¦å³ï¼‰ è¯´ä¸€ä¸‹æˆ‘è¿™å‡ å¤©çš„å¿ƒè·¯å†ç¨‹å§ï¼š Day1:å—¯ï¼Ÿæˆ‘å¥½åƒå‘ç°äº†ä¸€é“æœ‰è¶£çš„é¢˜ç›®ï¼Ÿæ´›è°·ä¸Šå¥½åƒæ²¡æœ‰ã€‚ã€‚ç®—äº†ï¼Œåšä¸€ä¸‹è¯•è¯•ã€‚ã€‚ã€‚ Day2:cowï¼Œè¿™é“é¢˜æ˜¯é“ä»€ä¹ˆé¢˜ï¼Ÿå£èƒ¡ä¸€ä¸‹LCTï¼Ÿç®—äº†ç®—äº†çœ‹çœ‹é¢˜è§£ã€‚ã€‚ã€‚ç¬›å¡å°”æ ‘æ˜¯ä»€ä¹ˆï¼Ÿï¼Ÿå­¦å§å­¦å§ã€‚ã€‚ã€‚ Day3ï¼šä¸ŠåŠå¤©ï¼šcowå­¦ä¸åŠ¨äº†ã€‚ã€‚ã€‚æ›´ä¸€ä¸‹åšå®¢å§(å¹¿å‘Šä½)ï¼›ä¸‹åŠå¤©ï¼šç»§ç»­å§ã€‚ã€‚ã€‚ Day4:ä¸ŠåŠå¤©ï¼šå¥½åƒæœ‰ç‚¹æƒ³æ³•äº†ã€‚ã€‚ã€‚å®Œå–„ä¸€ä¸‹ã€‚ã€‚æ‰¾æ‰¾é”…ã€‚ã€‚ï¼›ä¸‹åŠå¤©(ç¡®åˆ‡çš„è¯´æ˜¯æ™šä¸Šã€‚ã€‚)ï¼šå¼€å§‹ç å’¯ï¼ Day5ï¼šä¸ŠåŠå¤©ï¼šè°ƒäº†5ä¸ªå°æ—¶åè¿‡äº†ï¼›ä¸‹åŠå¤©ï¼šå†™å†™é¢˜è§£å’¯ æ­£æ–‡Description å¦‚æœä½ ä¸æƒ³é˜…è¯»æ•…äº‹ï¼Œè¯·ç›´æ¥è·³åˆ°é¢˜æ„éƒ¨åˆ†ã€‚ è½¬çœ¼é—´ï¼Œå·²æ˜¯ä¸‰å¹´æµè½¬ã€‚ å¤æ—¥æ³•æ¡çš„ç»¿è«ï¼Œä»£æ›¿äº†ç§‹å­£çš„è§ç´¢ï¼Œè¡¬æ‰˜ç€ LCR å’Œç¥çŠ‡æˆé•¿çš„èƒŒå½±ã€‚ èº«åçš„åŒ—æ ¡é—¨ï¼Œä¹Ÿä¸å†æ˜¯å½“å¹´å­¦ç”Ÿè¯•å›¾æ‘§æ¯çš„ï¼ŒæŸç¼šè‡ªç”±çš„æ·é”ï¼Œè€Œæˆäº†é’æ˜¥è®°å¿†çš„ç¬¦å·ã€‚ åˆåˆ°äº†ç¥çŠ‡å’Œ LCR ç›¸é‡çš„åœ°æ–¹ â€”â€” åŒ—æ ¡é—¨å¤–çš„æ ‘ä¸‹ã€‚è¿™æ£µç¥å¥‡çš„æ ‘æ—©å·²ä¸æ˜¯ K é¡¹æ ‘çš„å½¢æ€ã€‚æ¯æ—¶æ¯åˆ»ï¼Œå®ƒéƒ½ä»¥æ–°çš„ç‹¬ç‰¹æ–¹å¼æ¼”ç»ç€ç”Ÿå‘½ã€‚ è°ä¹Ÿæ²¡æœ‰å¼€å£ï¼Œä»–å’Œå¥¹é™é™åœ°æ³¨è§†ç€é­”æ³•èˆ¬ç”Ÿé•¿çš„è‡ªç„¶ç§å­ã€‚åˆå§‹æ—¶ï¼Œè¿™æ£µæ ‘åªæœ‰ä¸€ä¸ªç‚¹ï¼ŒLCR å°†å…¶æ ‡å·ä¸º $1$ã€‚æ­¤åï¼Œæ¯è¿‡ä¸€æ®µæ—¶é—´ï¼Œå°±ä¼šæœ‰ä¸€ä¸ªæ–°èŠ‚ç‚¹ä»åŸæœ‰çš„æŸä¸ªç‚¹å‡ºç”Ÿé•¿å‡ºæ¥ï¼ŒLCR ä¼šç»™å®ƒåˆ†é…ä¸€ä¸ªå°šæœªä½¿ç”¨è¿‡çš„ä¸è¶…è¿‡ $n$ çš„æ­£æ•´æ•°ç¼–å·ã€‚ æ ‘ä¸­ç”Ÿæ´»ç€ä¸€äº›å°ç²¾çµã€‚å®ƒä»¬æ€»åœç•™åœ¨èŠ‚ç‚¹ä¸Šï¼Œå¦‚æœä¸€ä¸ªç²¾çµåœ¨ç¼–å· $u$ çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒå¯ä»¥ä¸€æ­¥è·³åˆ°ä»»ä½•ç¼–å· $v$ çš„æ»¡è¶³ $u,v$ ä¹‹é—´çš„ç®€å•è·¯å¾„ä¸Šä¸å­˜åœ¨å¼‚äº $u,v$ çš„ç¼–å·å¤§äº $\\min(u,v)$ çš„ç‚¹å¤„ã€‚ åœ¨è§‚å¯Ÿè¿™æ£µæ ‘çš„è¿‡ç¨‹ä¸­ï¼ŒLCR äº§ç”Ÿäº†ä¸€äº›ç–‘é—®ã€‚å¥¹æƒ³çŸ¥é“ï¼Œå¯¹äºä¸€å¯¹èŠ‚ç‚¹ç¼–å· $u,v$ï¼Œä»èŠ‚ç‚¹ $u$ è·³åˆ°èŠ‚ç‚¹ $v$ æœ€å°‘éœ€è¦å‡ æ­¥ã€‚ ç¥çŠ‡è½»æ¾åœ°è§£å†³äº†è¿™äº›é—®é¢˜ã€‚æœ€ç»ˆï¼Œæ ‘æ¸æ¸åœæ­¢äº†ç”Ÿé•¿ï¼Œä½†ç¥çŠ‡ä»ç„¶é™¶é†‰å…¶ä¸­ã€‚ ä¸€åªé£˜æ¸ºçš„æ‰‹æ­ä¸Šäº†ç¥çŠ‡çš„è‚©è†€ã€‚ä»–å›è¿‡å¤´ï¼Œçœ‹åˆ° LCR æ­£åœ¨å¾®ç¬‘ã€‚ â€œäº²çˆ±çš„å°‘å¹´ï¼Œç¥çŠ‡å›ã€‚â€ â€œä½ æ˜¯å¦æƒ³è¿‡ï¼Œä¸ºä»€ä¹ˆç²¾çµä¼šä¾ç…§æˆ‘ç¼–å·çš„æ³•åˆ™è€Œè¿åŠ¨å‘¢ï¼Ÿâ€ ç¥çŠ‡ä¸€æ—¶è¯­å¡ã€‚ç¬é—´ï¼ŒLCR çš„æ‰‹å˜å¾—è™šå¹»äº†èµ·æ¥ï¼Œå¦‚åŒæ˜ç­çš„ç«ç‚¬ã€‚ â€œä½ çš„æˆé•¿ï¼Œæ˜¯è¿™å˜åŒ–ä¸–ç•Œçš„ä¸€ä¸ªåˆ‡é¢ã€‚æ„Ÿè°¢ä½ ä¸æˆ‘åº¦è¿‡çš„æ—¶å…‰ã€‚ä¸è¦ç•™æ‹ â€¦â€¦ æˆ‘çš„éšé£é£˜æ•£ï¼Œæ­£æ˜¯ä¸ä½ ä»¬åŒåœ¨ã€‚â€ â€œå†è§äº†ï¼Œç¥çŠ‡å›ã€‚â€ LCR æ¶ˆå¤±äº†ï¼Œç¥çŠ‡æœºæ¢°åœ°è½¬è¿‡èº«ï¼Œå´å‘ç°èƒŒåçš„æ ‘ä¹Ÿå·²æ¶ˆå¤±æ— è¸ªã€‚ â€œç¥çŠ‡ï¼Œç¥çŠ‡ â€¦â€¦â€ èŒ«ç„¶è‹¥å¤±çš„ç¥çŠ‡èƒŒåä¼ æ¥äº†æ¸è¡Œæ¸è¿‘çš„å‘¼å«ã€‚ç¥çŠ‡è½¬è¿‡èº«ï¼Œå‘ç°æœºæˆ¿é‡Œçš„è’Ÿè’» LCA æ­£å‘ä»–è·‘æ¥ã€‚ â€œåˆæ˜¯ä¸€å¹´æ¯•ä¸šå­£äº†å‘¢ã€‚å­¦é•¿ä½ è¿˜å¥½å—ï¼Ÿâ€ â€œä¹Ÿè®¸å§ã€‚â€ ç¥çŠ‡æœ›å‘æ ¡é—¨å¤–çš„æ ‘åŸå…ˆçš„ä½ç½®ï¼Œâ€œLCR èµ°äº†ï¼Œä½†å¥¹çš„èƒŒå½±ä¼šå¸å¼•ç€æˆ‘ä»¬çš„äººç”Ÿã€‚â€ LCA æ²‰é»˜äº†ã€‚ä»–å’Œç¥çŠ‡ä¸€åŒæœ›å‘æ ‘æ¶ˆå¤±çš„åœ°æ–¹ï¼ŒæŒç»­ç‰‡åˆ»ã€‚ â€œæ‰€è°“ä¸­äºŒçš„å¹»æƒ³ï¼Œæ‰æ˜¯æˆ‘ä»¬ç›¸å¯¹çš„æœ‰é™çš„ä¸»è§‚èƒ½åŠ¨æ€§å”¯ä¸€çš„ç«‹åœºå§ï¼Œä¸è¦ç»™è‡ªå·±è®¾é™å•Šï¼ŒLCAã€‚æˆ‘ä»¬å»è¿½å¯»å¥¹ â€¦â€¦ è¿½å¯»è‡ªç„¶çš„ç²¾çµã€‚ä¹Ÿè®¸è¿™å°±æ˜¯æˆ‘ä»¬çš„åˆå¿ƒä¹Ÿè¯´ä¸å®šã€‚â€ è¿™æ¬¡æ˜¯ LCA ç›®é€ç¥çŠ‡çš„èƒŒå½±æ¸è¡Œæ¸è¿œäº†ã€‚ â€œå†è§äº†ï¼Œå­¦é•¿ã€‚â€ æŸå°‘å¥³é™„ä¸­ï¼Œåˆè¿æ¥äº†æ–°çš„ä¸€å¹´ã€‚ é‚£ä¹ˆï¼Œä½ èƒ½å¤Ÿå›ç­” LCR æå‡ºçš„é—®é¢˜å—ï¼Ÿ é¢˜æ„å¯¹äºä¸€æ£µæ ‘ $T=(V,E)$ï¼Œ$V$ ä¸­æ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªäº’ä¸ç›¸åŒçš„æ­£æ•´æ•°æ ‡å·ã€‚æˆ‘ä»¬ç”¨ç‚¹ $i$ è¡¨ç¤ºç¼–å·ä¸º $i$ çš„ç‚¹ã€‚ å®šä¹‰è¿™æ£µæ ‘çš„è°·å›¾ä¸º $G(T)=(V,Eâ€™)$ã€‚$G(T)$ æ˜¯æ— å‘ç®€å•å›¾ã€‚å­˜åœ¨è¾¹ $(u,v)\\in Eâ€™$ å½“ä¸”ä»…å½“åœ¨ $T$ ä¸­ï¼Œä¸å­˜åœ¨ä¸€ä¸ªå¼‚äº $u,v$ çš„ç‚¹ $x$ æ»¡è¶³ $x$ åœ¨ä» $u$ åˆ° $v$ çš„ç®€å•è·¯å¾„ä¸Šä¸”å…¶ç¼–å·å¤§äº $\\min(u,v)$ã€‚ æœ‰ä¸€æ£µæ ‘ $T$ï¼Œåˆå§‹æ—¶åªæœ‰ä¸€ä¸ªç‚¹ï¼Œç¼–å·ä¸º $1$ï¼Œæ¥ä¸‹æ¥æœ‰ $q$ æ¬¡æ“ä½œï¼Œæ“ä½œæœ‰ä»¥ä¸‹ä¸¤ç§ï¼š $\\texttt{1 u v}$ è¡¨ç¤ºåŠ å…¥ä¸€ä¸ªç¼–å·ä¸º $v$ çš„èŠ‚ç‚¹å¹¶ä¸å½“å‰ç¼–å·ä¸º $u$ çš„èŠ‚ç‚¹ç›¸è¿ï¼ˆä¿è¯ä»»ä½•æ—¶åˆ»ä¸ä¼šæœ‰ä¸¤ä¸ªç¼–å·ç›¸åŒçš„èŠ‚ç‚¹ï¼‰ï¼› $\\texttt{2 u v}$ è¡¨ç¤ºæŸ¥è¯¢ $G(T)$ ä¸­ç‚¹ $u$ åˆ° $v$ çš„æœ€çŸ­è·¯ï¼ˆæ¯æ¡è¾¹é•¿åº¦å‡ä¸º $1$ï¼‰ã€‚ è¯·ä½ å›ç­”æ‰€æœ‰æŸ¥è¯¢ã€‚ é¢˜ç›®å¥½é•¿å’³å’³å’³ã€‚ã€‚ã€‚ï¼ˆæœ€å…³é”®çš„æ˜¯æˆ‘è¯»å®Œè¿‡åé‡è¯»ä¸€éå‘ç°èƒŒæ™¯ä¸é¢˜ç›®æ— å…³ã€‚ã€‚ã€‚é ! ä¸æ‰¯äº†è¯´æ­£äº‹å„¿ã€‚ã€‚ã€‚ åŠ¨æ€é—®é¢˜å…¶å®å¾ˆçƒ¦äººå¯¹å§ï¼Ÿè¿™é‡Œæˆ‘ä»¬å¯ä»¥å‡è®¾åŸé—®é¢˜ä¸ºé™æ€é—®é¢˜ã€‚ é™æ€é—®é¢˜å°±å¾ˆå¥½å¤„ç†å¯¹å§ï¼Ÿéƒ½æ˜¯æ˜¾ç„¶åšæ³•ã€‚é‚£ä¹ˆé—®é¢˜åˆå›åˆ°åŠ¨æ€é—®é¢˜ï¼Œå¯¹äºåŠ ç‚¹æ“ä½œï¼Œäº‹å®ä¸Šæˆ‘çš„åšæ³•ååˆ†**ï¼Œåˆ©ç”¨Splayçš„æ€§è´¨ä¹±æã€‚æ‰“å‡ºäº†ä¸€ä¸ªåƒæ¨¡æ‹Ÿä¸€æ ·çš„ä¸œè¥¿ å…¶å®æˆ‘ä¹Ÿä¸å¤ªæ¸…æ¥šæˆ‘æ˜¯æ€ä¹ˆè¿‡çš„ã€‚ã€‚ã€‚å› ä¸ºæˆ‘çš„åšæ³•å¾ˆç„å­¦+æš´åŠ›ï¼Œæ‰€ä»¥ã€‚ã€‚ã€‚å¤§å®¶æ„ä¼šä¸€ä¸‹ã€‚ å¦‚æœå®åœ¨è¦çœ‹é¢˜è§£çš„è¯ï¼Œæˆ‘è¿™é‡Œæœ‰ä¸€ç¯‡ï¼Œä¸è¿‡ä¼°è®¡ä¹Ÿæ²¡äººèƒ½çœ‹æ‡‚ï¼Œåæ­£ä½ çœ‹äº†å°±çŸ¥é“äº†ã€‚è‡³äºå…¶ä»–çš„é¢˜è§£æƒ³éƒ½åˆ«æƒ³äº†æˆ‘ç¿»å¢™å»éš”å£Googleéƒ½æ²¡æ‰¾åˆ°ï¼ŒåŸºæœ¬ä¸Šæ˜¯æ‰¾ä¸é“çš„ã€‚ã€‚ã€‚Link æ”¾ä¸ªä»£ç ï¼Œå¤§å®¶æ„ä¼šä¸€ä¸‹ã€‚ã€‚ã€‚(404è¡Œå¥½è¯„) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define SIZE_CHECKER ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; vector &lt; vector &lt; int &gt; &gt; G(SIZE); int n, m, st[SIZE], tp, F[SIZE]; int _time[SIZE], _down[SIZE]; int OP[SIZE], U[SIZE], V[SIZE]; void init(int n) { for (int i = 1; i &lt;= n; ++i) F[i] = i; } int find(int x) { if (x ^ F[x]) F[x] = find(F[x]); return F[x]; } namespace CartesianTree { vector &lt; vector &lt; int &gt; &gt; GCT(SIZE); int son[SIZE], fa[SIZE]; int top[SIZE], size[SIZE]; int low[SIZE], d[SIZE]; int tot, ls[SIZE], rs[SIZE]; void Prepare1(int x) { while (_time[st[tp]] &gt; _time[x] &amp;&amp; tp) _down[st[tp--]] = x; st[++tp] = x; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto y : GCT[x]) Prepare1((fa[y] = x, y)), size[x] += size[y], SIZE_CHECKER; } void Prepare2(int x) { ls[x] = ++tot; if (!top[x]) top[x] = x; if (!son[x]) return (void)(rs[x] = tot); top[son[x]] = top[x]; for (auto y : GCT[x]) Prepare2(y); rs[x] = tot; } int GetLCA(int x, int y) { while (top[x] ^ top[y]) d[top[x]] &gt; d[top[y]] ? x = fa[top[x]] : y = fa[top[y]]; return d[x] &lt; d[y] ? x : y; } int Behavior(int x, int y) { while (top[x] ^ top[y]) if (fa[x = top[x]] ^ y) x = fa[x]; else return x; return son[y]; } bool FindRule(int x, int y) { return ls[x] &lt; ls[y]; } bool CheckForFun(int x, int y) { int std = *(upper_bound(GCT[y].begin(), GCT[y].end(), x, FindRule) - 1); return !(ls[low[std]] &gt; rs[x] || ls[x] &gt; ls[low[std]]); } void Main() { init(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; find(j)) GCT[i].pub(find(j)), F[find(j)] = i; Prepare1(n), Prepare2(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; j) low[Behavior(j, i)] = j; } } // namespace CartesianTree #define CT CartesianTree namespace LinkCutTree { struct SPLAY { int ch[2]; int fa; int sum; int key; } data[SIZE]; int next[SIZE], root[SIZE]; #define WhichSon(x) (data[data[x].fa].ch[1] == x) void UpdateMessages(int x) { data[x].sum = data[data[x].ch[0]].sum + data[data[x].ch[1]].sum + data[x].key; } void RotateNode(int x) { int y = data[x].fa, z = data[y].fa; int k = WhichSon(x); if (root[y]) root[y] = 0, root[x] = root[y] ^ 1; else data[z].ch[data[z].ch[1] == y] = x; data[x].fa = data[y].fa; data[y].ch[k] = data[x].ch[k ^ 1]; if (data[y].ch[k]) data[data[x].ch[k ^ 1]].fa = y; data[x].ch[k ^ 1] = y; data[y].fa = x; UpdateMessages(y), UpdateMessages(x); } void SplayToRoot(int x) { for (int y; !root[x]; RotateNode(x)) if (!root[y = data[x].fa]) RotateNode(data[data[y].fa].ch[0] ^ y ^ data[y].ch[0] ^ x ? x : y); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); if (data[x].ch[1]) root[data[x].ch[1]] = 1; if (data[x].ch[1] = y) root[y] = 0; UpdateMessages(x); } } void Behavior(int u, int v) { if (u &gt; v) { F[v] = u; data[v].fa = u; data[v].key = 1; data[v].sum = 1; return ; } int x = _down[v], rhs = u; SplayToRoot(x); int rsp = 0, cpy = 0, now = data[x].ch[0]; if (now) { while (data[now].ch[1]) now = data[now].ch[1]; SplayToRoot(now); while (data[x].fa ^ now) RotateNode(x); root[x] = 1; data[now].ch[1] = 0; UpdateMessages(now); } now = data[x].fa; if (next[now] == x) next[now] = v; data[v].key = data[v].sum = data[x].key; if (now) next[v] = x; SplayToRoot(x); data[x].fa = v; data[v].fa = now; data[x].key = 0; UpdateMessages(x); while (u) { SplayToRoot(u); if (data[u].ch[1]) root[data[u].ch[1]] = 1; data[u].ch[1] = rsp; if (data[u].ch[1]) root[rsp] = 0; UpdateMessages(u); if (data[u].sum) { x = u; while (233) if (data[x].ch[1] &amp;&amp; data[data[x].ch[1]].sum) x = data[x].ch[1]; else if (!data[x].key) x = data[x].ch[0]; else break; SplayToRoot(x); if (x &gt;= v) break; u = data[x].ch[0]; if (u) { while (data[u].ch[1]) u = data[u].ch[1]; SplayToRoot(u); data[u].ch[1] = 0; root[x] = 1; UpdateMessages(u); } else u = data[x].fa; if (u &gt;= v) break; SplayToRoot(rhs); if (now = data[rhs].ch[1]) root[now] = 1, data[rhs].ch[1] = 0; if (now = next[rhs]) { SplayToRoot(now); data[now].fa = u; data[now].key = 1; UpdateMessages(now); next[rhs] = 0; } u = F[x]; rhs = F[x]; data[x].key = 0; UpdateMessages(x); SplayToRoot(x); while (data[x].ch[1]) x = data[x].ch[1]; SplayToRoot(x); data[x].ch[1] = cpy; if (data[x].ch[1]) { data[cpy].fa = x, root[cpy] = 0, data[x].ch[1] = cpy; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(x); cpy = x; rsp = 0; } else rsp = u, u = data[u].fa; } F[v] = F[_down[v]]; F[_down[v]] = v; if (!F[v]) { SplayToRoot(v); x = v; while (data[x].ch[1]) x = data[x].ch[1]; if (cpy) { data[x].ch[1] = cpy; root[cpy] = 0; data[cpy].fa = x; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(v); x = data[v].ch[1]; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); } else if (cpy) { x = cpy; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); data[x].fa = v; } } pii GetDis(int x, int t) { if (x ^ t) { AccessEdge(x); SplayToRoot(x); int st = x; int fir = 0, sec = 0; while (x) if (x &lt; t) sec = x, x = data[x].ch[0]; else x = data[x].ch[1]; SplayToRoot(sec); x = data[sec].ch[1]; fir = data[x].sum; if (!fir) return mp(0, st); while (233) { if (data[data[x].ch[0]].sum) x = data[x].ch[0]; else if (!data[x].key) sec = x, x = data[x].ch[1]; else { if (data[x].ch[0]) { x = data[x].ch[0]; while (data[x].ch[1]) x = data[x].ch[1]; sec = x; } break; } } return mp(fir, sec); } else return mp(0, x); } int GetAnswers(int x, int y) { if (x ^ y) { if (x &gt; y) x ^= y ^= x ^= y; int sys = CT::GetLCA(x, y); if (sys ^ y) { pii t1 = GetDis(x, sys); pii t2 = GetDis(y, sys); return t1.fir + t2.fir + ((CT::CheckForFun(t1.sec, sys) &amp;&amp; CT::CheckForFun(t2.sec, sys)) ^ 1) + 2; } else { pii t = GetDis(x, sys); return t.fir + (CT::CheckForFun(t.sec, sys) ^ 1) + 1; } } else return 0; } } // namespace LinkCutTree #define LCT LinkCutTree namespace SOLVER { void Main() { read(m), read(m); n = 1; for (int i = 1; i &lt;= m; ++i) { read(OP[i], U[i], V[i]); if (OP[i] ^ 1) continue; G[U[i]].pub(V[i]); G[V[i]].pub(U[i]); _time[V[i]] = i; n = max(n, V[i]); } for (int i = 1; i &lt;= n; ++i) LCT::root[i] = true; CT::Main(); F[1] = 0; for (int i = 1; i &lt;= m; ++i) { if (OP[i] ^ 2) LCT::Behavior(U[i], V[i]); else write(io_l, LCT::GetAnswers(U[i], V[i])); } } } signed main() { SOLVER::Main(); } 26.P1121 ç¯çŠ¶æœ€å¤§ä¸¤æ®µå­æ®µå’Œç»™å‡ºä¸€æ®µç¯çŠ¶åºåˆ—ï¼Œå³è®¤ä¸º$A_1$å’Œ$A_N$æ˜¯ç›¸é‚»çš„ï¼Œé€‰å‡ºå…¶ä¸­è¿ç»­ä¸é‡å ä¸”éç©ºçš„ä¸¤æ®µä½¿å¾—è¿™ä¸¤æ®µå’Œæœ€å¤§ã€‚ ä¸€å…±ä¸‰ä¸ªå…³é”®è¯: ç¯çŠ¶ æœ€å¤§ ä¸¤æ®µå­æ®µå’Œ æ˜¾ç„¶è¿™æ˜¯ä¸€é“DPé¢˜ã€‚ã€‚ã€‚ç„¶è€Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒææˆçº¿æ®µæ ‘! æ™®é€šçš„æœ€å¤§å­æ®µå’Œç›¸ä¿¡å¤§å®¶éƒ½èƒ½å¤Ÿç”¨çº¿æ®µæ ‘æ¥å®Œæˆã€‚ æ— éå°±æ˜¯è®°å½•åŒºé—´å’Œã€åŒºé—´æœ€å¤§å­æ®µå’Œã€åŒºé—´æœ€å¤§å‰ç¼€å’Œã€åŒºé—´æœ€å¤§åç¼€å’Œ ç„¶ååˆå¹¶æ—¶æ›´æ–°ä¿¡æ¯å³å¯ é‚£ä¹ˆä¸¤æ®µå­æ®µå’Œè¯¥æ€ä¹ˆæå‘¢? å…¶å®ä¹Ÿä¸è´¹è„‘å­åºŸç¬” é¦–å…ˆå¥—è·¯çš„è®¨è®ºè¿™ä¸¤æ®µçš„ä½ç½®ï¼Œæˆ‘ä»¬å¯ä»¥å‘ç°æœ‰5ç§æƒ…å†µï¼ˆç”»ç”»å›¾ç¤ºæ„ä¸€ä¸‹å¯èƒ½å¾ˆä¸‘åæ­£æ„æ€ä½ ä»¬èƒ½æ‡‚å°±è¡Œ æ€»ç»“å‡ºæ¥æˆ‘ä»¬éœ€è¦åœ¨çº¿æ®µæ ‘é‡Œç»´æŠ¤çš„ä¸œè¥¿æœ‰ï¼š åŒºé—´å’Œ åŒºé—´æœ€å¤§å‰ç¼€ åŒºé—´æœ€å¤§åç¼€ åŒºé—´æœ€å¤§å­æ®µå’Œ åŒºé—´æœ€å¤§å‰ç¼€+åç¼€ åŒºé—´æœ€å¤§ä¸­é—´+åç¼€ åŒºé—´æœ€å¤§å‰ç¼€+ä¸­é—´ åŒºé—´ä¸¤æ®µæœ€å¤§å­æ®µå’Œ æ¯è¡Œé•¿åº¦ä¸ä¸‹é™çœ‹ç€è¿˜æ˜¯å¾ˆçˆ½çš„ã€‚ã€‚ã€‚ å…·ä½“å®ç°çœ‹ä»£ç ä¸­çš„æ³¨é‡Š // çœç•¥å¿«è¯»å’Œä¸€å †é¢„å¤„ç†å‘½ä»¤ const int SIZE = 4e5 + 5; const int INF = ~0U &gt;&gt; 1; struct TreeNode { // è¿™é‡Œçš„æ„æ€åº”è¯¥å¾ˆæ˜ç¡® int sum; int maxSum; int maxSumDouble; int maxPrefixSum; int maxSuffixSum; int maxPrePlusSuf; int maxPrePlusMid; int maxSufPlusMid; } data[SIZE&lt;&lt;2]; int ints[SIZE&lt;&lt;1], ans = -INF, n; TreeNode UpdateMessages(TreeNode x, TreeNode y) { // è¿™æ˜¯é‡ç‚¹ TreeNode res; res.sum = x.sum + y.sum; // åŒºé—´å’Œæ ‡è®°ä¸Šä¼  res.maxSum = max(x.maxSum, y.maxSum); // // åŒºé—´æœ€å¤§å­æ®µå’Œæ ‡è®°ä¸Šä¼  res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // å†æŠŠè‡ªå·±å’Œä¸¤ä¸ªå„¿å­çš„æœ€å¤§å‰/åç¼€å’Œçš„å’Œæ¯”è¾ƒ res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // å…¶å®ä¸‹é¢éƒ½å·®ä¸å¤š res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // å®åœ¨ä¸æ‡‚çœ‹ä¸Šé¢çš„å›¾ res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // çœ‹äº†å°±æ˜ç™½äº†ã€‚ã€‚ã€‚ res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf); res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum); res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid); res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum); res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum); res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble); res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid); return res; } void Initialization(int k, int l) { // ç»™çº¿æ®µæ ‘ç»“ç‚¹èµ‹åˆå€¼ data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l]; data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF; } void BuildTree(int k, int l, int r) { if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]); else Initialization(k, l); } TreeNode GetAnswers(int k, int l, int r, int x, int y) { if (l ^ x || r ^ y) { if (mid &gt;= y) return GetAnswers(ls, l, mid, x, y); if (mid &lt; x) return GetAnswers(rs, mid + 1, r, x, y); return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y)); } else return data[k]; } signed main() { read(n); for (int i = 1; i &lt;= n; ++i) read(ints[i]), ints[i + n] = ints[i]; BuildTree(1, 1, n &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) ans = max(ans, GetAnswers(1, 1, n &lt;&lt; 1, i, i + n - 1).maxSumDouble); write(io_l, ans); } 27.ã€ä¸­åˆçš„é¢˜ç›®ã€‘åˆ†ç³–æœå° Z å¸¦ç€æ–°ä¹°çš„ç³–æœæ¥æ‹œè®¿èˆ…èˆ…å®¶ï¼Œèˆ…èˆ…å®¶çš„ $K$ ä¸ªå­©å­çœ‹è§å° Z å¸¦ç€ç³–æœæ¥æ‹œè®¿å˜å¾—æ¬£å–œè‹¥ç‹‚ï¼Œä»–ä»¬éƒ½å¸Œæœ›åƒåˆ°å¥½åƒçš„ç³–æœã€‚æ­£å½“å° Z å‡†å¤‡ç»™ $K$ ä¸ªå­©å­åˆ†ç³–æœæ—¶ï¼Œèˆ…èˆ…å´è®©å° Z å°½é‡å°‘åˆ†ç‚¹ï¼Œå…å¾—å­©å­ä»¬è›€ç‰™ã€‚ å° Z å¸¦æ¥çš„ç³–æœæ¯”è¾ƒç‰¹åˆ«ï¼Œä¸€å…±æœ‰ $N$ ä¸ªç³–æœè¿æˆä¸€ä¸²ï¼Œç¼–å·ä¸º $1\\ldots N$ï¼Œç¬¬ $i$ ä¸ªç³–æœæœ‰ä¸€ä¸ªæ•°å€¼ $a[i]$ è¡¨ç¤ºè›€ç‰™çš„å¯èƒ½æ€§ï¼Œæ•°å€¼è¶Šå¤§çš„ç³–æœè¶Šå®¹æ˜“å¯¼è‡´è›€ç‰™ï¼Œå¤šä¸ªç³–æœçš„è›€ç‰™å€¼è®¤ä¸ºæ˜¯å„ä¸ªç³–æœçš„è›€ç‰™å€¼ä¹‹å’Œã€‚ ç°åœ¨å° Z æ‰“ç®—å– $N$ ä¸ªç³–æœçš„å‰è‹¥å¹²ä¸ªï¼Œåˆ†æˆ $K$ æ®µåˆ†ç»™ $K$ ä¸ªå­©å­ã€‚å° Z å¥½å¥‡ï¼Œä»–è¯¥æ€ä¹ˆåˆ†ç³–æœï¼Œæ‰èƒ½ä½¿å¾—åˆ†åˆ°ç³–æœè›€ç‰™å€¼æœ€å¤§çš„å­©å­å°½å¯èƒ½ä¸è›€ç‰™ é¦–å…ˆæš´åŠ›åšæ³•æ˜¾ç„¶ã€‚ é¦–å…ˆå‰ç¼€å’Œç„¶åå¯¹å‰ç¼€å’Œç¦»æ•£åŒ– äºŒåˆ†ç­”æ¡ˆç„¶åchecké‡Œé¢dpï¼Œ$dp_i$ ä¸ºåŒºé—´ $[1,i]$ æœ€å¤šèƒ½åˆ†æˆçš„å—æ•°ã€‚ dpæ–¹ç¨‹æ˜¾ç„¶ä¸º $dp_i=max{dp_j}+1$ã€‚ è¿™æ ·è½¬ç§»æ˜¯ $\\Theta(n^2)$ çš„ï¼Œæ˜¾ç„¶Té£ã€‚ è€ƒè™‘æ ‘çŠ¶æ•°ç»„ä¼˜åŒ–ï¼Œéœ€è¦åŒºé—´æœ€å¤§å€¼å’Œå•ç‚¹ä¿®æ”¹æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦ $\\Theta(n\\log^2n)$ #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; __int64 , __int64 &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const __int64 SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; __int64 fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register __int64 i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const __int64 SIZE = 1e6 + 5; const __int64 INF = 0x7fffffff; __int64 a[SIZE], bit[SIZE]; __int64 dp[SIZE], n, k, T; vector &lt; __int64 &gt; disc; void add(__int64 x, __int64 y) { for (; x &gt; 0; x -= x &amp; -x) bit[x] = max(bit[x], y); } __int64 ask(__int64 x, __int64 lim, __int64 res = -INF) { for (; x &lt; lim; x += x &amp; -x) res = max(res, bit[x]); return res; } void Discretization(__int64 x) { disc.clear(); disc.pb(0); for (__int64 i = 1; i &lt;= n; ++i) disc.pb(a[i]); sort(disc.begin(), disc.end()); disc.erase(unique(disc.begin(), disc.end()), disc.end()); } bool Check(__int64 x) { Discretization(x); for (__int64 i = 1; i &lt;= (__int64)disc.size(); ++i) { for (__int64 j = i; j &lt; (__int64)disc.size(); j += j &amp; -j) bit[i] = -INF; for (__int64 j = i; j &gt; 0; j -= j &amp; -j) bit[i] = -INF; } *dp = 0; add(lower_bound(disc.begin(), disc.end(), 0) - disc.begin() + 1, *dp); for (__int64 i = 1; i &lt;= n; ++i) { dp[i] = ask(lower_bound(disc.begin(), disc.end(), a[i] - x) - disc.begin() + 1, disc.size() + 1) + 1; add(lower_bound(disc.begin(), disc.end(), a[i]) - disc.begin() + 1, dp[i]); if (k &lt;= dp[i]) return 1; } return 0; } signed main() { for (read(T); T; --T) { read(n, k); for (__int64 i = 1; i &lt;= n; ++i) read(a[i]), a[i] += a[i - 1]; __int64 l = -INF * SIZE, r = SIZE * INF; while (l &lt; r - 1) if (Check(mid)) r = mid; else l = mid; write(io_l, r); } return 0; } 28.P2163 [SHOI2007]å›­ä¸çš„çƒ¦æ¼å¾ˆä¹…å¾ˆä¹…ä»¥å‰ï¼Œåœ¨é¥è¿œçš„å¤§é™†ä¸Šæœ‰ä¸€ä¸ªç¾ä¸½çš„å›½å®¶ã€‚ç»Ÿæ²»ç€è¿™ä¸ªç¾ä¸½å›½å®¶çš„å›½ç‹æ˜¯ä¸€ä¸ªå›­è‰ºçˆ±å¥½è€…ï¼Œåœ¨ä»–çš„çš‡å®¶èŠ±å›­é‡Œç§æ¤ç€å„ç§å¥‡èŠ±å¼‚è‰ã€‚ æœ‰ä¸€å¤©å›½ç‹æ¼«æ­¥åœ¨èŠ±å›­é‡Œï¼Œè‹¥æœ‰æ‰€æ€ï¼Œä»–é—®ä¸€ä¸ªå›­ä¸é“ï¼š â€œæœ€è¿‘æˆ‘åœ¨æ€ç´¢ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æœæˆ‘ä»¬æŠŠèŠ±å›æ‘†æˆå…­ä¸ªå…­è§’å½¢ï¼Œé‚£ä¹ˆâ€¦â€¦â€ â€œé‚£ä¹ˆæœ¬è´¨ä¸Šå®ƒæ˜¯ä¸€ä¸ªæ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé™›ä¸‹â€ï¼Œå›­ä¸æ·±æ·±åœ°å‘å›½ç‹é äº†ä¸€èº¬ã€‚ â€œå—¯â€¦â€¦æˆ‘å¬è¯´æœ‰ä¸€ç§æ€ªç‰©å«ä¹å¤´è›‡ï¼Œå®ƒéå¸¸è´ªåƒè‹¹æœæ ‘â€¦â€¦â€ â€œæ˜¯çš„ï¼Œæ˜¾ç„¶è¿™æ˜¯ä¸€é“ç»å…¸çš„åŠ¨æ€è§„åˆ’é¢˜ï¼Œæ—©åœ¨Nå…ƒ4002å¹´æˆ‘ä»¬å°±å·²ç»å‘ç°äº†å…¶ä¸­çš„å¥¥ç§˜äº†ï¼Œé™›ä¸‹â€ã€‚ â€œè¯¥æ­»çš„ï¼Œä½ ç©¶ç«Ÿæ˜¯ä»€ä¹ˆæ¥å¤´ï¼Ÿâ€ â€œé™›ä¸‹æ¯æ€’ï¼Œå¹²æˆ‘ä»¬çš„è¿™è¡Œç»å¸¸è«åå…¶å¦™åœ°è¢«é—®åˆ°å’ŒOIæœ‰å…³çš„é¢˜ç›®ï¼Œæˆ‘ä¹Ÿæ˜¯ä¸ºäº†é¢„é˜²ä¸‡ä¸€å•Šï¼â€ ç‹è€…çš„å°Šä¸¥å—åˆ°äº†ä¼¤å®³ï¼Œè¿™æ˜¯ä¸å¯å®¹å¿çš„ã€‚ çœ‹æ¥ä¸€èˆ¬çš„éš¾é¢˜æ˜¯éš¾ä¸å€’è¿™ä½å›­ä¸çš„ï¼Œå›½ç‹æœ€åæ‰“ç®—ç”¨è½¦è½®æˆ˜æ¥æ¶ˆè€—ä»–çš„å®åŠ›ï¼š â€œå¹´è½»äººï¼Œåœ¨æˆ‘çš„èŠ±å›­é‡Œçš„æ¯ä¸€æ£µæ ‘å¯ä»¥ç”¨ä¸€ä¸ªæ•´æ•°åæ ‡æ¥è¡¨ç¤ºï¼Œä¸€ä¼šå„¿ï¼Œæˆ‘çš„éª‘å£«ä»¬ä¼šæ¥è½®ç•ªè¯¢é—®ä½ æŸä¸€ä¸ªçŸ©é˜µå†…æœ‰å¤šå°‘æ ‘ï¼Œå¦‚æœä½ ä¸èƒ½ç«‹å³ç­”å¯¹ï¼Œä½ å°±å‡†å¤‡èµ°äººå§ï¼â€è¯´å®Œï¼Œå›½ç‹æ°”å‘¼å‘¼åœ°å…ˆèµ°äº†ã€‚ è¿™ä¸‹è½®åˆ°å›­ä¸å‚»çœ¼äº†ï¼Œä»–æ²¡æœ‰å‡†å¤‡è¿‡è¿™æ ·çš„é—®é¢˜ã€‚æ‰€å¹¸çš„æ˜¯ï¼Œä½œä¸ºâ€œå…¨å›½å›­ä¸ä¿æŠ¤è”ç›Ÿâ€çš„ä¼šé•¿â€”â€”ä½ ï¼Œå¯ä»¥æˆä¸ºä»–çš„æœ€åä¸€æ ¹æ•‘å‘½ç¨»è‰ã€‚ ã€‚ã€‚ã€‚å±…ç„¶æ²¡æœ‰çœ‹åˆ°ä¸»å¸­æ ‘é¢˜è§£ã€‚ è¿™å·®ä¸å¤šå°±æ˜¯ä¸€é“ä¸»å¸­æ ‘çš„æ¿é¢˜äº†ã€‚ é¦–å…ˆå¯¹xæ’åºï¼Œç„¶ååŠ¨æ€å¼€ç‚¹ä¸€ä¸ªä¸€ä¸ªçš„insertè¿›å»ã€‚ å¯¹äºè¯¢é—®ç›´æ¥å°±äºŒåˆ†å–å‡ºæ¨ªè½´çš„èŒƒå›´lå’Œr ç„¶åè¯¢é—®root[r]-root[l-1]å°±å¥½äº† #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (data[rt].l) #define rs (data[rt].r) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; int , int &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; const int INF = 1e7; int n, m, tot, rt[SIZE]; struct TreeNode { int l, r; int sum; } data[SIZE &lt;&lt; 5]; struct TwoNode { int x, y; } ints[SIZE]; struct BinarySeach { int upper_bound(int x) { int l = 1, r = n + 1; while (l &lt; r - 1) if (ints[mid].x &gt; x) r = mid; else l = mid; return l; } int lower_bound(int x) { int l = 0, r = n; while (l &lt; r - 1) if (ints[mid].x &gt;= x) r = mid; else l = mid; return r; } } BS; bool cmp(const TwoNode&amp; x, const TwoNode&amp; y) { return x.x &lt; y.x; } void update(int &amp;rt, int l, int r, int x) { data[++tot] = data[rt]; ++data[rt = tot].sum; if (l ^ r) if (mid &gt;= x) update(ls, l, mid, x); else update(rs, mid + 1, r, x); else return ; } int queryf(int rt, int l, int r, int x, int y) { if (l &gt; y || r &lt; x || !rt) return 0; else if (l &gt;= x &amp;&amp; r &lt;= y) return data[rt].sum; else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y); } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i].x, ints[i].y); sort(ints + 1, ints + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) update(rt[i] = rt[i - 1], 0, INF, ints[i].y); for (int i = 1, a, b, c, d; i &lt;= m; ++i) { read(a, b, c, d); write(io_l, queryf(rt[BS.upper_bound(c)], 0, INF, b, d) - queryf(rt[BS.lower_bound(a) - 1], 0, INF, b, d)); } return 0; } 29.P5220 ç‰¹å·¥çš„ä¿¡æ¯æµ$\\text{TYM}$ æ‰€åœ¨çš„å›½å®¶æœ‰ $n$ ä¸ªåŸå¸‚ï¼Œç¼–å·ä¸º $1,\\dots,n$ï¼Œç”± $n - 1$ æ¡åŒå‘é“è·¯è¿æ¥ã€‚ä¿è¯ä»»æ„ä¸¤ä¸ªåŸå¸‚é—´éƒ½æœ‰å”¯ä¸€çš„ç®€å•è·¯å¾„ã€‚ä»¥åŠï¼Œæ¯ä¸ªåŸå¸‚éƒ½æœ‰ä¸€ä¸ªä¿¡æ¯æµçš„æµé‡ $a_i$ã€‚ $\\text{TYM}$ ä¸€å…±è¦æ‰§è¡Œ $m_0$ ä¸ªä»»åŠ¡ï¼Œæ¯ä¸ªä»»åŠ¡ç»™å®šä¸¤ä¸ªåŸå¸‚ $s,t$ï¼Œå…¶æ‰§è¡Œè¿‡ç¨‹å¦‚ä¸‹ï¼šç¬¬ä¸€ä¸ªæ—¶åˆ»ï¼Œä»–ä»åŸå¸‚ $s$ å‡ºå‘ï¼Œä»¥æ¯ä¸ªæ—¶åˆ»ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªåŸå¸‚çš„é€Ÿåº¦ï¼Œèµ° $s,t$ ä¹‹é—´çš„ç®€å•è·¯å¾„åˆ° $t$ã€‚æ¯åˆ°è¾¾ä¸€ä¸ªåŸå¸‚ï¼Œä»–éƒ½ä¼šæŠŠè¿™ä¸ªåŸå¸‚çš„ä¿¡æ¯æµ $a_i$ å‘é€åˆ°ç»è¿‡çš„æ¯ä¸ªåŸå¸‚ã€‚æˆ‘ä»¬çº¦å®šï¼Œä»–åˆ°è¾¾ä¸€ä¸ªåŸå¸‚çš„åŒä¸€æ—¶åˆ»ä¹Ÿä¼šæŠŠè¿™ä¸ªåŸå¸‚çš„ä¿¡æ¯æµå‘é€ç»™è¿™ä¸ªåŸå¸‚ã€‚æˆ‘ä»¬å®šä¹‰ä¸€ä¸ªåŸå¸‚çš„ä»·å€¼ä¸ºè¿™ä¸ªåŸå¸‚æ‰€æ¥å—åˆ°çš„ä¿¡æ¯æµçš„ä¹˜ç§¯ã€‚ è¯·ä½ æ±‚å‡ºæ¯ä¸ªä»»åŠ¡ä¸­ï¼Œ$s$ åˆ° $t$ çš„ç®€å•è·¯å¾„ä¸Šç»è¿‡çš„åŸå¸‚çš„ä»·å€¼çš„æ€»å’Œå¯¹ $20924$ å–æ¨¡çš„ç»“æœã€‚ æ­¤å¤–ï¼Œä¸å¹¸åœ°ï¼Œç”±äºä¾µç•¥è€…åŒæ—¶ä¹Ÿåœ¨è¡ŒåŠ¨ï¼Œæ‰€ä»¥åœ¨ä»–æ‰§è¡Œå¤šä¸ªä»»åŠ¡ä¹‹é—´ï¼Œå¯èƒ½ä¼šæœ‰æŸä¸ª $a_i$ å‘ç”Ÿæ”¹å˜ã€‚ ä»–çš„ä»»åŠ¡æ€»æ•°ä¸æ”¹å˜æŸä¸ª $a_i$ çš„æ¬¡æ•°ä¹‹å’Œä¸º $m$ã€‚ WGYï¼šLCTè¿™é“é¢˜çš„é¢˜æ„æ˜¯çœŸçš„ç»•ï¼Œæˆ‘å‰å‰ååè¯»äº†ä¸ä¸‹äº”éæ‰å¤§æ¦‚æ„ä¼šã€‚ã€‚ã€‚ åšæ•°æ®ç»“æ„çš„é¢˜ä¸€èˆ¬éƒ½è¦å…ˆæµ“ç¼©é¢˜æ„ã€‚è¿™é“é¢˜æ˜¯è®©æˆ‘ä»¬æ±‚åç¼€ç§¯ä¹‹å’Œï¼Œå†åŠ ä¸Šä¿®æ”¹æ“ä½œå°±åŸºæœ¬ä¸Šç¡®å®šç”¨LCTäº† éœ€è¦ç»´æŠ¤çš„ä¿¡æ¯æœ‰å‰ç¼€ç§¯ä¹‹å’Œ,åç¼€ç§¯ä¹‹å’Œï¼ŒåŒºé—´ä¹˜æ³•ä¸‰ä¸ªä¿¡æ¯ã€‚ å¯¹äºä¿®æ”¹æ“ä½œï¼Œç›´æ¥ä¸ŠLCTçš„å¥—è·¯makerootå’Œaccessã€‚ å¯¹äºè¯¢é—®æ“ä½œï¼Œæˆ‘ä»¬ç›´æ¥æŒ‰ç…§LCTçš„å¥—è·¯ç”¨makerootå’ŒaccessæŠŠé“¾ç»™æå‡ºæ¥ã€‚ å…¶å®è¿™å°±ç›¸å½“äºä¸€é“LCTçš„æ¿é¢˜å§ã€‚ã€‚ã€‚å…¨éƒ¨éƒ½æ˜¯åŸºç¡€æ“ä½œã€‚ã€‚ã€‚ å®Œæ•´ä»£ç åœ¨è¿™é‡ŒLink å¦‚æœé“¾æ¥å¤±æ•ˆäº†å°±è¿™ä¸ªLink const int SIZE = 1e5 + 5; const int M_SIZE = 2e5 + 5; const int MOD = 20924; int head[M_SIZE], nxt[M_SIZE]; int to[M_SIZE], ints[SIZE]; int waste[SIZE], n, m, top, tot; struct SPLAY { int fa; int ch[2]; int prod; int preprod; int sufprod; int lztg; } data[SIZE]; void AddEdge(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } bool IsRoot(int x) { return ((data[data[x].fa].ch[1] ^ x) &amp;&amp; (data[data[x].fa].ch[0] ^ x)); } bool WhichSon(int x) { return (data[data[x].fa].ch[1] == x); } void UpdateMessages(int x) { data[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD; data[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD; data[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD; } void UpdateSons(int x) { if (data[x].lztg) { swap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]); swap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]); swap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod); swap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod); data[data[x].ch[0]].lztg ^= 1; data[data[x].ch[1]].lztg ^= 1; data[x].lztg = 0; } } void RotateNode(int x) { int y = data[x].fa; int z = data[y].fa; int k = WhichSon(x); if (!IsRoot(y)) data[z].ch[WhichSon(y)] = x; data[y].fa = x; data[data[y].fa].fa = z; if (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y; data[y].ch[k] = data[x].ch[k ^ 1]; data[x].ch[k ^ 1] = y; UpdateMessages(y); } void SplayToRoot(int x) { int y = waste[top = 1] = x; while (!IsRoot(y)) waste[++top] = y = data[y].fa; while (top) UpdateSons(waste[top--]); for (; !IsRoot(x); RotateNode(x)) if (!IsRoot((y = data[x].fa))) RotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y); UpdateMessages(x); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); data[x].ch[1] = y; UpdateMessages(x); } } void MakeRoot(int x) { AccessEdge(x); SplayToRoot(x); swap(data[x].ch[0], data[x].ch[1]); swap(data[x].preprod, data[x].sufprod); data[x].lztg ^= 1; UpdateMessages(x); } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); SplayToRoot(y); } void Prepare(int x) { data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; for (int i = head[x]; i; i = nxt[i]) if (to[i] ^ data[x].fa) data[to[i]].fa = x, Prepare(to[i]); } int GetAnswers(int x, int y) { SplitTree(x, y); UpdateSons(y); return data[y].sufprod; } void Behavior(int x, int y) { SplitTree(x, x); ints[x] += y; ints[x] %= MOD; data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i]); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x); (*data).prod = 1; Prepare(1); for (int i = 0, x, y; i &lt; m; ++i) { char opt[5]; read(opt); read(x, y); if (*opt ^ &#39;C&#39;) write(io_l, GetAnswers(x, y)); else Behavior(x, y); } return 0; } LYC:TCS// æ— æƒ…çš„LYCå’•æ‰äº†è¿™ç¯‡é¢˜è§£ï¼Œå¿«å»æ‰“ä»–ï¼ï¼ï¼ 30.P5350 åºåˆ—æœ‰ä¸€ä¸ªåºåˆ—$a_n$å’Œè‹¥å¹²æ“ä½œã€‚ $\\mathrm{1\\ l \\ r \\ }$ æ±‚$a_l$åˆ°$a_r$çš„å’Œ $\\mathrm{2\\ l \\ r \\ val \\ }$ å°†$a_l$åˆ°$a_r$èµ‹å€¼ä¸º$\\mathrm{val}$ $\\mathrm{3\\ l \\ r \\ val\\ }$å°†$a_l$åˆ°$a_r$åŠ ä¸Š$\\mathrm{val}$ $\\mathrm{4\\ l_1 \\ r_1 \\ l_2 \\ r_2 }$å°†$a_{l_1}$åˆ°$a_{r_1}$å¤åˆ¶åˆ°$a_{l_2}$åˆ°$a_{r_2}$å¤„ $\\mathrm{5\\ l_1 \\ r_1 \\ l_2 \\ r_2 }$å°†$a_{l_1}$åˆ°$a_{r_1}$ä¸$a_{l_2}$åˆ°$a_{r_2}$äº¤æ¢ $\\mathrm{6\\ l \\ r \\ }$å°†$a_l$åˆ°$a_r$ç¿»è½¬ è¿™é“é¢˜æœ‰äº†åŒºé—´æ¨å¹³åŸºæœ¬å°±æ²¡ä»€ä¹ˆæ‚¬å¿µäº†ã€‚ODTï¼Œä¸Šï¼ï¼ˆé›¾ å…·ä½“è®²ä¸€ä¸‹å§ æ±‚å’Œæ“ä½œã€åŒºé—´èµ‹å€¼æ“ä½œã€åŒºé—´åŠ æ³•æ²¡ä»€ä¹ˆæŠ€æœ¯å«é‡ï¼Œæ•°æ®ç»“æ„100é¢˜é‡Œæœ‰ODTï¼Œè¯·è‡ªè¡Œç¿»é˜…ã€‚ åŒºé—´åè½¬ä¹Ÿå¾ˆæ˜¾ç„¶ï¼Œä¸å†èµ˜è¿°ã€‚ å¤åˆ¶åŒºé—´æ“ä½œï¼Œæˆ‘ä»¬ç›´æ¥splitå‡ºl1,r1,l2,l2ï¼Œç„¶åæŠŠå¤åˆ¶çœ‹ä½œåˆ é™¤l2,r2ï¼ŒæŠŠl1,r1æ”¾åœ¨ä¸Šé¢ã€‚å³l1,r1,val â€”&gt; l2-l1+l,l2-l1+r,valã€‚ äº¤æ¢åŒºé—´æ“ä½œï¼Œæœ¬è´¨å°±æ˜¯å¤åˆ¶åŒºé—´æ“ä½œåšä¸¤æ¬¡ã€‚ Code: #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;set&gt; using namespace std; typedef long long LL; const int SIZE = 5e5 + 5; const int MOD = 1e9 + 7; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } struct CHTHOLLY { int l, r; mutable LL val; friend bool operator &lt; (const CHTHOLLY&amp; x, const CHTHOLLY&amp; y) { return x.l &lt; y.l; } } a[SIZE], b[SIZE]; int n, q; set &lt; CHTHOLLY &gt; st; #define IT set &lt; CHTHOLLY &gt;::iterator void split(int l, int r) { IT it = --st.upper_bound({l, l, 0}); CHTHOLLY t = *it; if ((*it).l != l) st.erase(it), st.insert({t.l, l - 1, t.val}), st.insert({l, t.r, t.val}); it = --st.upper_bound({r, r, 0}); t = *it; if ((*it).r != r) st.erase(it), st.insert({t.l, r, t.val}), st.insert({r + 1, t.r, t.val}); } void assign(int l, int r, int key) { split(l, r); st.erase(st.lower_bound({l, l, 0}), st.upper_bound({r, r, 0})); st.insert({l, r, key}); } int queryf(int l, int r) { LL res = 0; split(l, r); IT it = st.lower_bound({l, l, 0}); for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) res = (res + (*it).val * ((*it).r - (*it).l + 1)) % MOD; return res; } void update(int l, int r, int key) { split(l, r); IT it = st.lower_bound({l, l, 0}); for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) (*it).val = ((*it).val + key) % MOD; } void copy(int l1, int r1, int l2, int r2) { split(l1, r1); split(l2, r2); st.erase(st.lower_bound({l2, l2, 0}), st.upper_bound({r2, r2, 0})); IT it = st.lower_bound({l1, l1, 0}); for (; it != st.end() &amp;&amp; (*it).r &lt;= r1; ++it) st.insert({l2 + (*it).l - l1, l2 + (*it).r - l1, (*it).val}); } void exchange(int l1, int r1, int l2, int r2) { split(l1, r1); split(l2, r2); IT it = st.lower_bound({l1, l1, 0}); int lenx = 0, leny = 0; for (; it != st.end() &amp;&amp; (*it).r &lt;= r1; ++it) a[++lenx] = *it; it = st.lower_bound({l2, l2, 0}); for (; it != st.end() &amp;&amp; (*it).r &lt;= r2; ++it) b[++leny] = *it; st.erase(st.lower_bound({l1, l1, 0}), st.upper_bound({r1, r1, 0})); st.erase(st.lower_bound({l2, l2, 0}), st.upper_bound({r2, r2, 0})); for (int i = 1; i &lt;= lenx; ++i) st.insert({l2 - l1 + a[i].l, l2 - l1 + a[i].r, a[i].val}); for (int i = 1; i &lt;= leny; ++i) st.insert({l1 - l2 + b[i].l, l1 - l2 + b[i].r, b[i].val}); } void reverse(int l, int r) { split(l, r); IT it = st.lower_bound({l, l, 0}); int lim = 0; for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) a[++lim] = *it; st.erase(st.lower_bound({l, l, 0}), st.upper_bound({r, r, 0})); for (int i = lim; i; --i) st.insert({l + r - a[i].r, l + r - a[i].l, a[i].val}); } void Imomonalse() { int opt, l, r, l0, r0, key; read(opt, l, r); if (opt == 1) printf(&quot;%d\\n&quot;, queryf(l, r)); else if (opt == 2) read(key), assign(l, r, key); else if (opt == 3) read(key), update(l, r, key); else if (opt == 4) read(l0, r0), copy(l, r, l0, r0); else if (opt == 5) read(l0, r0), exchange(l, r, l0, r0); else if (opt == 6) reverse(l, r); } void init() { read(n, q); for (int i = 1, x; i &lt;= n; ++i) read(x), st.insert({i, i, x}); for (int i = 0; i &lt; q; ++i) Imomonalse(); } void write() { IT it = st.begin(); for (; it != st.end(); ++it) for (int i = (*it).l; i &lt;= (*it).r; ++i) printf(&quot;%lld &quot;, (*it).val); } signed main() { init(); write(); }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 11~20é¢˜","slug":"DS100P-11-20-P","date":"2020-02-08T06:03:29.000Z","updated":"2020-02-18T10:10:34.914Z","comments":true,"path":"2020/02/08/DS100P-11-20-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-11-20-P/","excerpt":"","text":"11.P3203 [HNOI2010]å¼¹é£ç»µç¾ŠæŸå¤©ï¼Œ$Lostmonkey$ å‘æ˜äº†ä¸€ç§è¶…çº§å¼¹åŠ›è£…ç½®ï¼Œä¸ºäº†åœ¨ä»–çš„ç»µç¾Šæœ‹å‹é¢å‰æ˜¾æ‘†ï¼Œä»–é‚€è¯·å°ç»µç¾Šä¸€èµ·ç©ä¸ªæ¸¸æˆã€‚ æ¸¸æˆä¸€å¼€å§‹ï¼Œ$Lostmonkey$ åœ¨åœ°ä¸Šæ²¿ç€ä¸€æ¡ç›´çº¿æ‘†ä¸Š $n$ ä¸ªè£…ç½®ï¼Œæ¯ä¸ªè£…ç½®è®¾å®šåˆå§‹å¼¹åŠ›ç³»æ•° $k_i$ï¼Œå½“ç»µç¾Šè¾¾åˆ°ç¬¬ $i$ ä¸ªè£…ç½®æ—¶ï¼Œå®ƒä¼šå¾€åå¼¹ $k_i$ æ­¥ï¼Œè¾¾åˆ°ç¬¬ $i+k_i$ ä¸ªè£…ç½®ï¼Œè‹¥ä¸å­˜åœ¨ç¬¬ $i+k_i$ ä¸ªè£…ç½®ï¼Œåˆ™ç»µç¾Šè¢«å¼¹é£ã€‚ ç»µç¾Šæƒ³çŸ¥é“å½“å®ƒä»ç¬¬ $i$ ä¸ªè£…ç½®èµ·æ­¥æ—¶ï¼Œè¢«å¼¹å‡ æ¬¡åä¼šè¢«å¼¹é£ã€‚ä¸ºäº†ä½¿å¾—æ¸¸æˆæ›´æœ‰è¶£ï¼Œ$Lostmonkey$ å¯ä»¥ä¿®æ”¹æŸä¸ªå¼¹åŠ›è£…ç½®çš„å¼¹åŠ›ç³»æ•°ï¼Œä»»ä½•æ—¶å€™å¼¹åŠ›ç³»æ•°å‡ä¸ºæ­£æ•´æ•°ã€‚ æ¯ä¸ªå¼¹åŠ›è£…ç½®åªä¼šå¯¹åº”ä¸€ä¸ªä½ç½®å¯ä»¥å¼¹åˆ°ï¼Œä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥æŠŠå®ƒçœ‹ä½œä¸€æ¡è¾¹ï¼Œè€Œä¸”ä¸ä¼šæœ‰ç¯è¿™ç§**ç©æ„ã€‚ å¯¹äºä¿®æ”¹å¼¹åŠ›ç³»æ•°ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æ–­è¾¹è¿è¾¹æ¥ç»´æŠ¤ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = 2e5 + 5; class LinkCutTree { public: struct SPLAY { int val; int fa; int ch[2]; } T[SIZE]; inline bool isroot(int x) { return !(T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline void push(int x) { T[x].val = T[T[x].ch[0]].val + T[T[x].ch[1]].val + 1; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, k = T[y].ch[1] == x, w = T[x].ch[!k]; (isroot(y)) &amp;&amp; (T[z].ch[T[z].ch[1] == y] = x); T[x].ch[!k] = y, T[y].ch[k] = w; (w) &amp;&amp; (T[w].fa = y); T[y].fa = x; T[x].fa = z; push(y); } inline void splay(int x) { for(; isroot(x); rotate(x)) { int y = T[x].fa, z = T[y].fa; (isroot(y)) &amp;&amp; (rotate(T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? x : y), 1); } push(x); } inline void access(int x) { for(int y = 0; x; x = T[y = x].fa) splay(x), T[x].ch[1] = y, push(x); } } lct_mast; int n, m; signed main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1, s; i &lt;= n; ++i) { lct_mast.T[i].val = 1; scanf(&quot;%d&quot;, &amp;s); (i + s &lt;= n) &amp;&amp; (lct_mast.T[i].fa = i + s); } for(scanf(&quot;%d&quot;, &amp;m); m; --m) { int opt, x, y; scanf(&quot;%d&quot;, &amp;opt), scanf(&quot;%d&quot;, &amp;x); if (opt ^ 2) { lct_mast.access(x + 1); lct_mast.splay(x + 1); printf(&quot;%d\\n&quot;, lct_mast.T[x + 1].val); } else { scanf(&quot;%d&quot;, &amp;y); lct_mast.access(x + 1); lct_mast.splay(x + 1); lct_mast.T[x + 1].ch[0] = lct_mast.T[lct_mast.T[x + 1].ch[0]].fa = 0; (x + y + 1 &lt;= n) &amp;&amp; (lct_mast.T[x + 1].fa = x + y + 1); lct_mast.push(x + 1); } } return 0; } 12.SP4487 GSS6 - Can you answer these queries VIThe first line of the input contains an integer N.The following line contains N integers, representing the startingsequence A1..AN, _(|Ai| &lt;= 10000)_. The third line contains an integer Q. The next Q lines contains the operations in following form: I x y: insert element y at position x _(between x - 1 and x)_.D x : delete the element at position x.R x y: replace element at position x with y.Q x y: print max{Ai + Ai+1 + .. + Aj | x &lt;= i &lt;= j &lt;= y}. All given positions are valid, and given values are between -10000 and +10000. The sequence will never be empty. è¿™é“é¢˜æ˜¾ç„¶æ˜¯ä¸€é“å¹³è¡¡æ ‘çš„è£¸é¢˜ï¼Œå”¯ä¸€çš„éš¾åº¦å°±æ˜¯æ±‚æœ€å¤§å­æ®µå’Œã€‚ å¯ä»¥ç±»æ¯”çº¿æ®µæ ‘ç»´æŠ¤æœ€å¤§å­æ®µå’Œï¼Œç»´æŠ¤$lmax$ä»¥xä¸ºæ ¹çš„å‰ç¼€æœ€å¤§å’Œã€$rmax$ä»¥xä¸ºæ ¹çš„åç¼€æœ€å¤§å’Œã€$maxsum$æœ€å¤§å­æ®µå’Œä»¥åŠ$sum$æ€»å’Œ å¯¹äº$Update$æˆ‘ä»¬å¯ä»¥å¯¹æ˜¯å¦æœ‰å·¦å³å­©å­åšè®¨è®ºã€‚ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; using namespace std; const int SIZE = 2e5 + 5; int n, m, tot, root, a[SIZE]; struct SPLAY { int fa; int ch[2]; int siz; int val; int sum; int lmax; int rmax; int maxsum; } T[SIZE]; vector &lt; int &gt; st; inline int newnode(int v = 0) { int x; if (st.empty()) x = ++tot; else x = st.back(), st.pop_back(); T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].siz = 1; T[x].val = T[x].sum = T[x].maxsum = v; T[x].lmax = T[x].rmax = max(v, 0); return x; } inline void delnode(int x) { T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].sum = T[x].lmax = T[x].rmax = T[x].maxsum = 0; T[x].siz = 1; st.push_back(x); } inline bool which(int x) { if (T[T[x].fa].ch[0] == x) return 0; if (T[T[x].fa].ch[1] == x) return 1; return -1; } inline void update(int x) { T[x].sum = T[x].val; T[x].siz = 1; if (T[x].ch[0]) T[x].sum += T[T[x].ch[0]].sum, T[x].siz += T[T[x].ch[0]].siz; if (T[x].ch[1]) T[x].sum += T[T[x].ch[1]].sum, T[x].siz += T[T[x].ch[1]].siz; if (T[x].ch[0] &amp;&amp; T[x].ch[1]) { T[x].lmax = max(T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val + T[T[x].ch[1]].lmax); T[x].rmax = max(T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val + T[T[x].ch[0]].rmax); T[x].maxsum = max({T[T[x].ch[0]].maxsum, T[T[x].ch[1]].maxsum, T[T[x].ch[0]].rmax + T[x].val + T[T[x].ch[1]].lmax}); } else if (T[x].ch[0]) { T[x].lmax = max({T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val, 0}); T[x].rmax = max(T[x].val + T[T[x].ch[0]].rmax, 0); T[x].maxsum = max(T[T[x].ch[0]].maxsum, T[T[x].ch[0]].rmax + T[x].val); } else if (T[x].ch[1]) { T[x].lmax = max(T[x].val + T[T[x].ch[1]].lmax, 0); T[x].rmax = max({T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val, 0}); T[x].maxsum = max(T[T[x].ch[1]].maxsum, T[T[x].ch[1]].lmax + T[x].val); } else { T[x].maxsum = T[x].val; T[x].lmax = T[x].rmax = max(T[x].val, 0); } } inline void rotate(int x) { if (!x) return; int w = which(x), y = T[x].fa; if (~which(y)) T[T[y].fa].ch[which(y)] = x; T[x].fa = T[y].fa; T[y].ch[w] = T[x].ch[w ^ 1]; if (T[x].ch[w ^ 1]) T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int &amp;goal) { if (x == goal) return; int p = T[goal].fa; for (int y; T[x].fa ^ p; rotate(x)) y = T[x].fa, (T[y].fa ^ p) &amp;&amp; (rotate(which(y) ^ which(x) ? x : y), 1); goal = x; } inline int kth_element(int x, int k) { while (233) { if (T[x].ch[0] &amp;&amp; k &lt;= T[T[x].ch[0]].siz) x = T[x].ch[0]; else { if (T[x].ch[0]) k -= T[T[x].ch[0]].siz; if (!--k) return x; x = T[x].ch[1]; } } } inline void insert(int &amp;rt, int p, int val) { int x = kth_element(rt, p); splay(x, rt); int y = kth_element(rt, p + 1); splay(y, T[rt].ch[1]); T[y].ch[0] = newnode(val); T[T[y].ch[0]].fa = y; update(T[y].ch[0]); update(y), update(x); } inline void erase(int &amp;rt, int p) { int y = kth_element(rt, p); splay(y, rt); int x = kth_element(rt, p + 1); splay(x, T[rt].ch[1]); int z = T[x].ch[1]; T[z].fa = y; T[y].ch[1] = z; delnode(x); update(y); } inline void modify(int &amp;rt, int p, int val) { int x = kth_element(rt, p + 1); splay(x, rt); T[x].val = val; update(x); } inline int find(int &amp;rt, int l, int r) { int x = kth_element(rt, l); splay(x, rt); int y = kth_element(rt, r + 2); splay(y, T[rt].ch[1]); return T[T[y].ch[0]].maxsum; } inline void make(int p, int l, int r) { int mid = (l + r) &gt;&gt; 1; T[p].val = a[mid]; if (mid - 1 &gt;= l) T[p].ch[0] = newnode(), T[T[p].ch[0]].fa = p, make(T[p].ch[0], l, mid - 1); if (mid + 1 &lt;= r) T[p].ch[1] = newnode(), T[T[p].ch[1]].fa = p, make(T[p].ch[1], mid + 1, r); update(p); } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int root = newnode(); make(root, 0, n + 1); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { char opt[2]; int x, y; scanf(&quot;%s %d&quot;, opt, &amp;x); if (*opt ^ &#39;D&#39;) scanf(&quot;%d&quot;, &amp;y); if (*opt == &#39;I&#39;) insert(root, x, y); if (*opt == &#39;D&#39;) erase(root, x); if (*opt == &#39;R&#39;) modify(root, x, y); if (*opt == &#39;Q&#39;) printf(&quot;%d\\n&quot;, find(root, x, y)); } return 0; } 13.Count on a treeç»™å®šä¸€æ£µ $n$ ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œæ¯ä¸ªç‚¹æœ‰ä¸€ä¸ªæƒå€¼ã€‚æœ‰ $m$ ä¸ªè¯¢é—®ï¼Œæ¯æ¬¡ç»™ä½  $u$,$v$,$k$ ä½ éœ€è¦å›ç­” $u \\text{ xor last}$ å’Œ $v$ è¿™ä¸¤ä¸ªèŠ‚ç‚¹é—´ç¬¬ $k$ å°çš„ç‚¹æƒã€‚ LYCæ ‘ä¸Šçš„è·¯å¾„é—®é¢˜ï¼Œæˆ‘ä»¬ä¸€èˆ¬éƒ½è¦ç”¨æ ‘é“¾å‰–åˆ†ã€‚ é™æ€ç¬¬$k$å°çš„é—®é¢˜ï¼Œæˆ‘ä»¬ä¸€èˆ¬ç”¨ä¸»å¸­æ ‘ã€‚ ç»è¿‡ä¸¥è°¨åˆ†æï¼Œæˆ‘ä»¬å¾—å‡ºï¼Œè¿™é“é¢˜æ˜¯æ ‘å‰–åŠ ä¸»å¸­æ ‘ã€‚ æŠŠæ ‘å‰–æˆé‡é“¾ä¹‹ååƒä¸»å¸­æ ‘æ¨¡æ¿é‚£æ ·æŒ‰$dfs$åºæ’å…¥æ¯ä¸ªæ•°(è®©åŒä¸€æ¡é‡é“¾åœ¨ä¸»å¸­æ ‘çš„$root$æ•°ç»„ä¸­æˆä¸ºä¸€ä¸ªè¿ç»­çš„åŒºé—´ï¼Œæ–¹ä¾¿ç»Ÿè®¡)ï¼Œç„¶åæˆ‘ä»¬è¦æŸ¥è¯¢$u$,$v$ä¸¤ä¸ªèŠ‚ç‚¹é—´çš„ç¬¬$k$å°ã€‚ å’Œæ¨¡æ¿ä¸ä¸€æ ·çš„åœ°æ–¹æ¥äº†ï¼šè¿™é‡Œçš„åŒºé—´ç¬¬$k$å°çš„åŒºé—´ä¸è¿ç»­ã€‚ æˆ‘ä»¬å›æƒ³æ¨¡æ¿çš„æ€æƒ³è¿‡ç¨‹ï¼š é€šè¿‡å·®åˆ†å¾—å‡ºåŒºé—´å†…æ¯ä¸ªæ•°å€¼å‡ºç°çš„ä¸ªæ•°ã€‚ æ—¢ç„¶è¿™æ¬¡åŒºé—´æ˜¯ä¸è¿ç»­çš„ï¼Œæˆ‘ä»¬å°±æ¯æ¬¡éƒ½æŠŠè¿™äº›ä¸è¿ç»­çš„å­åŒºé—´ç»Ÿè®¡ä¸€éï¼Œå†åŠ èµ·æ¥å°±å¥½äº†ï¼Œå°±ç›¸å½“äºæ˜¯æŠŠè¿™äº›å­åŒºé—´åˆèµ·æ¥ã€‚ å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯æ ‘å‰–$LCA$æ—¶è®°å½•æ¯ä¸ªåŒºé—´çš„å·¦å³ç«¯ç‚¹ã€‚ä½¿ç”¨ä¸»å¸­æ ‘æŸ¥è¯¢æ—¶å†æŠŠåŸæ¥çš„å¯¹äºä¸€ä¸ªåŒºé—´çš„ç»Ÿè®¡æ”¹ä¸ºå¯¹å¾ˆå¤šåŒºé—´çš„ç»Ÿè®¡å°±å¥½äº†ã€‚ å‰©ä¸‹çš„å°±å’Œæ¨¡æ¿ä¸€æ ·äº†ã€‚ ä»£ç ï¼š #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int n,m,p,a[100010],last,u,v,w,fa[100010],dep[100010],son[100010],siz[100010],dfn[100010],ton[100010],hb[100010],tot,be[100010],en[100010],cnt,root[100010],cntot; struct node { int l,r,sum; }nodes[4000010]; vector&lt;int&gt; e[100010],pri; int getID(int val) { return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1; }//ç¦»æ•£åŒ– void dfs1(int x,int las) { dep[x]=dep[las]+1; fa[x]=las; siz[x]=1; int b=-1e9,s=0; for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las) { dfs1(y,x); siz[x]+=siz[y]; if(siz[y]&gt;b) { b=siz[y]; s=y; } } } son[x]=s; } void dfs2(int x,int las,int heavy) { if(heavy) hb[x]=hb[las]; else hb[x]=x; dfn[x]=++tot; ton[tot]=a[x]; if(son[x]) dfs2(son[x],x,1); for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las&amp;&amp;y^son[x]) dfs2(y,x,0); } } void LCA(int x,int y) { int fx=hb[x],fy=hb[y]; while(fx^fy) { if(dep[fx]&lt;dep[fy]) { swap(fx,fy); swap(x,y); } be[++cnt]=root[dfn[fx]-1]; en[cnt]=root[dfn[x]];//è®°å½•æ¯ä¸€ä¸ªåŒºé—´çš„å·¦ç«¯ç‚¹-1å’Œå³ç«¯ç‚¹ï¼Œç›¸å½“äºåŸæ¥find(int l,int r,int p1,int p2,int k)ä¸­çš„p1,p2ã€‚ x=fa[fx]; fx=hb[x]; } be[++cnt]=root[min(dfn[x],dfn[y])-1]; en[cnt]=root[max(dfn[x],dfn[y])]; //æ‰€æœ‰çš„å­åŒºé—´ä¸­çš„æ•°åŒ…å«ä¸”ä»…åŒ…å«äº†uåˆ°vçš„æœ€çŸ­è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹ã€‚å› ä¸ºæ ‘å‰–LCAä¼šç”¨ä¸€ä¸ªä¸€ä¸ªåŒºé—´è¦†ç›–æ‰€æœ‰ç‚¹ï¼Œè€Œæˆ‘ä»¬è®°å½•äº†æ¯ä¸€ä¸ªåŒºé—´ã€‚ }//æ ‘å‰– void ins(int l,int r,int pre,int &amp;now,int pos) { nodes[++cntot]=nodes[pre]; now=cntot; ++nodes[now].sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos); } int find(int l,int r,int k) { if(l==r) return pri[l-1];//ä¸€ç›´åˆ°ç¡®å®šç¬¬kå°çš„ä½ç½®ï¼›è¿”å›åŸå€¼ã€‚ int X=0; for(int i=1;i&lt;=cnt;++i) X+=(nodes[nodes[en[i]].l].sum-nodes[nodes[be[i]].l].sum); //ä¸´æ—¶ç»Ÿè®¡uåˆ°vçš„æœ€çŸ­è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹æƒä¸­åœ¨[l,mid]ä¸­çš„æ•°çš„ä¸ªæ•°ã€‚ int mid=(l+r)&gt;&gt;1; if(k&lt;=X)//k&lt;=X,è¯´æ˜ç¬¬kå°åœ¨å·¦è¾¹ { for(int i=1;i&lt;=cnt;++i)//æŠŠæ¯ä¸ªç«¯ç‚¹éƒ½å¾€å·¦ä¸‹è·³ã€‚ä½¿å®ƒä»£è¡¨çš„å€¼ä¸ºè¿™ä¸ªåŒºé—´çš„å…ƒç´ å€¼åœ¨[l,mid]çš„ä¸ªæ•°ã€‚ { en[i]=nodes[en[i]].l; be[i]=nodes[be[i]].l; } //ç„¶åæˆ‘ä»¬å°±å¯ä»¥å»ç¼©å°èŒƒå›´ï¼Œå»æŸ¥è¯¢[l,mid]è¿™ä¸ªåŒºé—´äº†ã€‚ return find(l,mid,k); } else//å¦åˆ™ï¼Œç¬¬kå°æ˜¯å³è¾¹çš„ç¬¬k-Xå° { for(int i=1;i&lt;=cnt;++i)//æŠŠæ¯ä¸ªç«¯ç‚¹éƒ½å¾€å³ä¸‹è·³ã€‚é“ç†åŒä¸Šã€‚ { en[i]=nodes[en[i]].r; be[i]=nodes[be[i]].r; } return find(mid+1,r,k-X);//ç»§ç»­æŸ¥æ‰¾ } }//ä¸»å¸­æ ‘ int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } for(int i=1;i&lt;n;++i) { scanf(&quot;%d %d&quot;,&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); dfs1(1,1); dfs2(1,1,0); p=pri.size(); for(int i=1;i&lt;=n;++i) ins(1,p,root[i-1],root[i],getID(ton[i]));//æŒ‰dfsåºæ’å…¥ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); u^=last; cnt=0; LCA(u,v); last=find(1,p,w); printf(&quot;%d\\n&quot;,last); } return 0; } WGYå¯¹äºæ¯ä¸€ä¸ªèŠ‚ç‚¹$x$ï¼Œå…ˆä»¤$rt_x=rt_{x-1}$ï¼Œç„¶ååœ¨$rt_x$ä¸­æ’å…¥$a_i$ï¼Œè¿™æ ·å…¶å®æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤çš„éƒ½æ˜¯èŠ‚ç‚¹åˆ°æ ¹çš„ä¿¡æ¯ å¯¹äºæŸ¥è¯¢æ“ä½œä¸­çš„æ¯ä¸€ä¸ª$(x,y)$ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨$rt_x+rt_y-rt_{lca_{x,y}}-rt_{fa_{lca_{x,y}}}$æ¥å¾—åˆ°ç­”æ¡ˆ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) const int SIZE = 1e5 + 5; struct TreeNode { int l, r; int size; } fhq[SIZE &lt;&lt; 5]; int n, m, tot, fa[SIZE], rt[SIZE]; int a[SIZE], rnk[SIZE], dp[SIZE], inq[30][SIZE], lastans, Q[SIZE]; std::vector &lt; std::vector &lt; int &gt; &gt; G(SIZE); inline bool cmp(int x, int y) { return a[x] &lt; a[y]; } inline void newnode(int t, int p) { fhq[++tot] = fhq[rt[t]]; rt[t] = tot; int u = rt[t], l = 1, r = n; while (l ^ r) { fhq[u].size++; if (p &lt;= mid) fhq[++tot] = fhq[fhq[u].l], fhq[u].l = tot, u = fhq[u].l, r = mid; else fhq[++tot] = fhq[fhq[u].r], fhq[u].r = tot, u = fhq[u].r, l = mid + 1; } fhq[u].size++; } inline int find(int a, int b, int c, int d, int l, int r, int u) { if (l ^ r) if (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size &gt;= u) return find(fhq[a].l, fhq[b].l, fhq[c].l, fhq[d].l, l, mid, u); else return find(fhq[a].r, fhq[b].r, fhq[c].r, fhq[d].r, mid + 1, r, u - (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size)); else return l; } inline void dfs(int x, int fa) { dp[x] = dp[fa] + 1; rt[x] = rt[fa]; ::fa[x] = fa; newnode(x, a[x]); for (int i = 0; i &lt; (int)G[x].size(); ++i) if (G[x][i] ^ fa) dfs(G[x][i], x); } inline int lca_mast(int x, int y) { if (dp[x] &lt; dp[y]) std::swap(x, y); for (int i = 0; dp[x] - dp[y]; ++i) if ((1 &lt;&lt; i) &amp; (dp[x] - dp[y])) x = inq[i][x]; if (x ^ y) { for (int i = 25; i &gt;= 0; --i) if (inq[i][x] ^ inq[i][y]) x = inq[i][x], y = inq[i][y]; return fa[x]; } else return x; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), Q[i] = i; std::sort(Q + 1, Q + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) rnk[i] = a[Q[i]], a[Q[i]] = i; for (int i = 1, x, y; i &lt; n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); dfs(1, 0); for (int i = 1; i &lt;= n; ++i) inq[0][i] = fa[i]; for (int i = 1; i &lt; 26; ++i) for (int j = 1; j &lt;= n; ++j) inq[i][j] = inq[i - 1][inq[i - 1][j]]; for (int i = 1; i &lt;= m; ++i) { int x, y, z; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); x ^= lastans; int lca = lca_mast(x, y); printf(&quot;%d\\n&quot;, lastans = rnk[find(rt[x], rt[y], rt[lca], rt[fa[lca]], 1, n, z)]); } return 0; } 14.P2486 [SDOI2011]æŸ“è‰² WGYå¯ä»¥æŠŠé¦–å…ˆæŠŠè¿æ¥ä¸åŒè‰²ç‚¹çš„è¾¹æƒè®¾ç½®ä¸º1ï¼ŒåŒè‰²çš„è®¾ä¸º9ï¼Œè¿™æ ·æ•´ä¸ªé—®é¢˜å°±å˜æˆäº†æŸ¥è¯¢è·¯å¾„ä¸Šçš„æƒå€¼å’Œã€‚ æ˜¾ç„¶ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨æš´åŠ›$LinkCutTree$æˆ–$TreeChainSplitting$æ¥æï¼Œè¿™é‡Œç»™å‡º$LCT$çš„åšæ³•ã€‚ ç»´æŠ¤æ¯ä¸€ä¸ª$Splay$èŠ‚ç‚¹çš„æœ€å·¦ç«¯ç‚¹çš„å€¼å’Œæœ€å³ç«¯ç‚¹çš„é¢œè‰²ï¼Œå¯¹äºå®ƒçš„è€æ±‰èŠ‚ç‚¹ï¼Œæˆ‘ä»¬å¯ä»¥æ‰¾å‡ºå®ƒçš„å‰é©±å’Œåç»§çš„é¢œè‰²ã€‚è¿™æ ·å°±å¯ä»¥ç´¯è®¡å®ƒå’Œå‰é©±å’Œåç»§è¿è¾¹çš„æƒå€¼å’Œè¾£ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define lson (fhq[x].ch[0]) #define rson (fhq[x].ch[1]) using namespace std; #define DEBUG 1 // debug toggle struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m; class LinkCutTree { public: struct SPLAY { int w, c; int l, r; int tag, rev; int fa, ch[2]; } fhq[SIZE]; // The fhq-treap replaces the splay // Struct SPLAY int stack[SIZE], tp; inline bool isroot(int x) { return fhq[fhq[x].fa].ch[0] ^ x &amp;&amp; fhq[fhq[x].fa].ch[1] ^ x; } inline void tr_dn1(int x) { if (fhq[x].rev) swap(lson, rson), swap(fhq[lson].l, fhq[lson].r), swap(fhq[rson].l, fhq[rson].r), fhq[lson].rev ^= 1, fhq[rson].rev ^= 1, fhq[x].rev = 0; } inline void tr_dn2(int x) { if (fhq[x].tag) fhq[x].l = fhq[x].r = fhq[x].c = fhq[x].tag, fhq[lson].tag = fhq[rson].tag = fhq[x].tag, fhq[x].w = fhq[x].tag = 0; } inline void tr_dn(int x) { tr_dn1(x), tr_dn2(x); } inline void tr_up_(int x) { tr_dn(lson), tr_dn(rson); fhq[x].w = fhq[lson].w + fhq[rson].w; } inline void tr_up1(int x) { if (lson) fhq[x].l = fhq[lson].l, ((fhq[x].c ^ fhq[lson].r) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].l = fhq[x].c; } inline void tr_up2(int x) { if (rson) fhq[x].r = fhq[rson].r, ((fhq[x].c ^ fhq[rson].l) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].r = fhq[x].c; } inline void tr_up(int x) { tr_up_(x); tr_up1(x); tr_up2(x); } inline void rotate(int x) { int y = fhq[x].fa, z = fhq[y].fa, k = fhq[y].ch[1] == x; if (!isroot(y)) fhq[z].ch[fhq[z].ch[1] == y] = x; fhq[x].fa = z; fhq[y].ch[k] = fhq[x].ch[k ^ 1], fhq[fhq[x].ch[k ^ 1]].fa = y; fhq[x].ch[k ^ 1] = y; fhq[y].fa = x; tr_up(y); } inline void splay1(int x) { stack[tp = 1] = x; for (int i = x; !isroot(i); i = fhq[i].fa) stack[++tp] = fhq[i].fa; while (tp) tr_dn(stack[tp--]); } inline void splay2(int x) { for (; !isroot(x); rotate(x)) { int y = fhq[x].fa, z = fhq[y].fa; if (!isroot(y)) (fhq[y].ch[1] ^ x ^ fhq[z].ch[1] ^ y) ? rotate(x) : rotate(y); } } inline void splay(int x) { splay1(x), splay2(x); tr_up(x); } inline void access(int x) { for (int y = 0; x; y = x, x = fhq[x].fa) splay(x), rson = y, tr_up(x); } inline void makeroot(int x) { access(x), splay(x), fhq[x].rev ^= 1; } inline int findroot(int x) { access(x), splay(x); while (lson) x = lson; return x; } inline void split(int x, int y) { makeroot(x), access(y), splay(y); } inline void connect(int x, int y) { makeroot(x), fhq[x].fa = y; } } lct_mast; // Class LinkCutTree signed main() { io.read(n), io.read(m); for (int i = 1, x; i &lt;= n; ++i) io.read(x), lct_mast.fhq[i].c = lct_mast.fhq[i].l = lct_mast.fhq[i].r = x; for (int i = 1, x, y; i &lt; n; ++i) io.read(x), io.read(y), lct_mast.connect(x, y); for (int i = 1, a, b, c; i &lt;= m; ++i) { char ch = getchar(); while (ch ^ &#39;C&#39; &amp;&amp; ch ^ &#39;Q&#39;) ch = getchar(); if (ch ^ &#39;Q&#39;) io.read(a), io.read(b), io.read(c), lct_mast.split(a, b), lct_mast.fhq[b].tag = c; else io.read(a), io.read(b), lct_mast.split(a, b), io.write(lct_mast.fhq[b].w + 1, &#39;\\n&#39;); } return 0; } LYC15.ã€ŒZJOI2017ã€æ ‘çŠ¶æ•°ç»„æ¼†é»‘çš„æ™šä¸Šï¼Œä¹æ¡å¯æ€œèººåœ¨åºŠä¸Šè¾—è½¬åä¾§ã€‚éš¾ä»¥å…¥çœ çš„å¥¹æƒ³èµ·äº†è‹¥å¹²å¹´å‰å¥¹çš„ä¸€æ¬¡æ‚²æƒ¨çš„OIæ¯”èµ›ç»å†ã€‚é‚£æ˜¯ä¸€é“åŸºç¡€çš„æ ‘çŠ¶æ•°ç»„é¢˜ã€‚ ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º$n$çš„æ•°ç»„$A$ï¼Œåˆå§‹å€¼éƒ½ä¸º0ï¼Œæ¥ä¸‹æ¥è¿›è¡Œ$m$æ¬¡æ“ä½œï¼Œæ“ä½œæœ‰ä¸¤ç§ï¼š * 1 xï¼Œè¡¨ç¤ºå°† $A_{x}$ å˜æˆ $\\left ( A_{x}+ 1 \\right )$ mod 2ã€‚ * 2 l rï¼Œè¡¨ç¤ºè¯¢é—® $ \\left ( \\sum_{i=l}^{r} A_{i} \\right )$ mod 2ã€‚ å°½ç®¡é‚£ä¸ªæ—¶å€™çš„å¯æ€œéå¸¸çš„ simpleï¼Œä½†æ˜¯å¥¹è¿˜æ˜¯å‘ç°è¿™é¢˜å¯ä»¥ç”¨æ ‘çŠ¶æ•°ç»„åšã€‚å½“æ—¶éå¸¸young çš„å¥¹å†™äº†å¦‚ä¸‹çš„ç®—æ³•ï¼š å…¶ä¸­ lowbit($x$) è¡¨ç¤ºæ•°å­— $x$ æœ€ä½çš„é 0 äºŒè¿›åˆ¶ä½ï¼Œä¾‹å¦‚ lowbit(5) = 1, lowbit(12) = 4ã€‚è¿›è¡Œç¬¬ä¸€ç±»æ“ä½œçš„æ—¶å€™å°±è°ƒç”¨ Add($x$)ï¼Œç¬¬äºŒç±»æ“ä½œçš„æ—¶å€™ç­”æ¡ˆå°±æ˜¯ Query($l$,$r$)ã€‚ å¦‚æœä½ å¯¹æ ‘çŠ¶æ•°ç»„æ¯”è¾ƒç†Ÿæ‚‰ï¼Œä¸éš¾å‘ç°å¯æ€œæŠŠæ ‘çŠ¶æ•°ç»„å†™é”™äº†ï¼š Add å’Œ Find ä¸­ $x$ å˜åŒ–çš„æ–¹å‘åäº†ã€‚å› æ­¤è¿™ä¸ªç¨‹åºåœ¨æœ€ç»ˆæµ‹è¯•æ—¶åä¸½çš„çˆ† 0 äº†ã€‚ ç„¶è€Œå¥‡æ€ªçš„æ˜¯ï¼Œåœ¨å½“æ—¶ï¼Œè¿™ä¸ªç¨‹åºé€šè¿‡äº†å‡ºé¢˜äººç»™å‡ºçš„å¤§æ ·ä¾‹â€”â€”è¿™ä¹Ÿæ˜¯å¯æ€œæ²¡æœ‰è¿›è¡Œå¯¹ æ‹çš„åŸå› ã€‚ ç°åœ¨ï¼Œå¯æ€œæƒ³è¦ç®—ä¸€ä¸‹ï¼Œè¿™ä¸ªç¨‹åºå›ç­”å¯¹æ¯ä¸€ä¸ªè¯¢é—®çš„æ¦‚ç‡æ˜¯å¤šå°‘ï¼Œè¿™æ ·å¥¹å°±å¯ä»¥å†æ¬¡çš„ æ„Ÿå—åˆ°è‡ªå·±æ˜¯ä¸€ä¸ªå¤šä¹ˆéçš„äººäº†ã€‚ç„¶è€Œæ—¶é—´å·²ç»è¿‡å»äº†å¾ˆå¤šå¹´ï¼Œå³ä½¿æ˜¯å¯æ€œä¹Ÿæ²¡æœ‰åŠæ³•å®Œå…¨å›å¿†èµ·å½“æ—¶çš„å¤§æ ·ä¾‹ã€‚å¹¸è¿çš„æ˜¯ï¼Œå¥¹å›å¿†èµ·äº†å¤§éƒ¨åˆ†å†…å®¹ï¼Œå”¯ä¸€é—å¿˜çš„æ˜¯æ¯ä¸€æ¬¡ç¬¬ä¸€ç±»æ“ä½œçš„ $x$ çš„å€¼ï¼Œå› æ­¤å¥¹å‡å®šè¿™æ¬¡æ“ä½œçš„ $x$ æ˜¯åœ¨ $\\left [ l_{i},r_{i} \\right ]$ èŒƒå›´å†… ç­‰æ¦‚ç‡éšæœº çš„ã€‚ å…·ä½“æ¥è¯´ï¼Œå¯æ€œç»™å‡ºäº†ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„ $A$ï¼Œåˆå§‹ä¸º 0ï¼Œæ¥ä¸‹æ¥è¿›è¡Œäº† $m$ æ¬¡æ“ä½œï¼š * 1 $l$ $r$ï¼Œè¡¨ç¤ºåœ¨åŒºé—´ $\\left [ l, r \\right ]$ ä¸­ç­‰æ¦‚ç‡é€‰å–ä¸€ä¸ª $x$ å¹¶æ‰§è¡Œ Add($x$)ã€‚ * 2 $l$ $r$ï¼Œè¡¨ç¤ºè¯¢é—®æ‰§è¡Œ Query$\\left ( l, r \\right )$å¾—åˆ°çš„ç»“æœæ˜¯æ­£ç¡®çš„æ¦‚ç‡æ˜¯å¤šå°‘ã€‚ è¿™é“é¢˜$\\cdots$ï¼Œæ²¡ä»€ä¹ˆå¯è®²çš„å§ï¼ŸäºŒç»´çº¿æ®µæ ‘è›®å¹²å°±å¥½äº† #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; typedef long long int ull; const int SIZE = 1e5 + 5; const int MOD = 998244353; struct TreeNode { int l, r; int val; } tr[SIZE * 400]; int rt[SIZE * 20], n, q, tot; inline ull result(ull p, ull q) { ull res = p * q; res %= MOD; return res = (res + (1 - p + MOD) * (1 - q + MOD) % MOD) % MOD; } inline ull fast_pow(ull x, ull y) { ull res = 1; for (; y; y &gt;&gt;= 1, (x *= x) %= MOD) if (y &amp; 1) (res *= x) %= MOD; return res % MOD; } inline void modifies(int l, int r, int &amp;rt, int x, int y, ull p) { if (!rt) rt = ++tot, tr[rt].val = 1; if (l &gt;= x &amp;&amp; r &lt;= y) return (void)(tr[rt].val = result(p, tr[rt].val)); if (mid &gt;= x) modifies(l, mid, tr[rt].l, x, y, p); if (mid &lt; y) modifies(mid + 1, r, tr[rt].r, x, y, p); } inline void modify(int l, int r, int rt, int lx, int rx, int ly, int ry, ull p) { if (l &gt;= lx &amp;&amp; r &lt;= rx) return (void)(modifies(1, n, ::rt[rt], ly, ry, p)); if (mid &gt;= lx) modify(l, mid, rt &lt;&lt; 1, lx, rx, ly, ry, p); if (mid &lt; rx) modify(mid + 1, r, rt &lt;&lt; 1 | 1, lx, rx, ly, ry, p); } inline ull finds(int l, int r, int rt, int x) { if (!rt) return 1; if (l ^ r) if (mid &gt;= x) return result(tr[rt].val, finds(l, mid, tr[rt].l, x)); else return result(tr[rt].val, finds(mid + 1, r, tr[rt].r, x)); else return tr[rt].val; } inline ull find(int l, int r, int rt, int x, int y) { if (l ^ r) if (mid &gt;= x) return result(finds(1, n, ::rt[rt], y), find(l, mid, rt &lt;&lt; 1, x, y)); else return result(finds(1, n, ::rt[rt], y), find(mid + 1, r, rt &lt;&lt; 1 | 1, x, y)); else return finds(1, n, ::rt[rt], y); } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 0; i &lt; q; ++i) { int opt, l, r; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;l, &amp;r); if (opt ^ 1) printf(&quot;%lld\\n&quot;, find(0, n, 1, l - 1, r)); else { ull p = fast_pow(r - l + 1, MOD - 2); if (l &gt; 1) modify(0, n, 1, 1, l - 1, l, r, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, 1, l - 1, 0); if (r &lt; n) modify(0, n, 1, l, r, r + 1, n, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, r + 1, n, 0); modify(0, n, 1, l, r, l, r, (1 - p * 2 % MOD + MOD) % MOD), modify(0, n, 1, 0, 0, l, r, p); } } return 0; } 16.P2161 [SHOI2009]ä¼šåœºé¢„çº¦// æœªå…LJSåæ§½ä¸è´´é¢˜é¢äº† è¿™é“é¢˜æ­£è§£åº”è¯¥æ˜¯å¹³è¡¡æ ‘æˆ–è€…BITï¼Œè¿™é‡Œæä¾›ä¸€ç§ç®€ä¾¿çš„STLåšæ³•ã€‚ å¯¹äºç¬¬ä¸€ä¸ªæ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥ä»¤æœ‰å†²çªçš„é¢„çº¦ç›¸ç­‰ï¼Œé¿å…setç‰¹æ€§å‘æ­»ä¸€ç¥¨äºº å¯¹äºç¬¬äºŒä¸ªæ“ä½œç›´æ¥è¾“å‡ºsetçš„å¤§å°å³å¯ // çœç•¥å¤´æ–‡ä»¶å’Œå¿«è¯» struct LaLaLand { int l, r; bool operator &lt; (const LaLaLand&amp; rhs) const { return r &lt; rhs.l; } }; set &lt; LaLaLand &gt; st; int T; signed main() { for (read(T); T; --T) { char opt[5]; read(opt); int l, r, cnt = 0; if (*opt == &#39;A&#39;) { read(l, r); LaLaLand tmp = {l, r}; IT it = st.find(tmp); while (it != st.end()) ++cnt, st.erase(it), it = st.find(tmp); st.insert(tmp); write(io_l, cnt); } else write(io_l, st.size()); } return 0; } 17.SP11470 TTM - To the moonä¸€ä¸ªé•¿åº¦ä¸ºnçš„æ•°ç»„ï¼Œ4ç§æ“ä½œ ï¼š C l r dï¼šåŒºé—´ $[l,r]$ ä¸­çš„æ•°éƒ½åŠ  $d$ ï¼ŒåŒæ—¶å½“å‰çš„æ—¶é—´æˆ³åŠ  $1$ã€‚ Q l rï¼šæŸ¥è¯¢å½“å‰æ—¶é—´æˆ³åŒºé—´ $[l,r]$ ä¸­æ‰€æœ‰æ•°çš„å’Œ ã€‚ H l r tï¼šæŸ¥è¯¢æ—¶é—´æˆ³ $t$ åŒºé—´ $[l,r]$ çš„å’Œ ã€‚ B tï¼šå°†å½“å‰æ—¶é—´æˆ³ç½®ä¸º $t$ ã€‚ è¿™é“é¢˜æ­£è§£åº”è¯¥æ˜¯ä¸»å¸­æ ‘+æ ‡è®°æ°¸ä¹…åŒ–ï¼Œæˆ‘æ¥æä¾›ä¸€ç§ä»£ç æçŸ­(å‹è¡Œåä¸åˆ°1K)çš„åšæ³•(æ€ä¹ˆæ„Ÿè§‰æˆ‘å°±æ²¡ä»€ä¹ˆæ­£ç»è§£æ³•) ç»´æŠ¤ä¸€ä¸ªå·®åˆ†æ•°ç»„ï¼Œå°†æ¯æ¬¡è¯¢é—®çœ‹ä½œæ˜¯ä¸¤æ¬¡å‰ç¼€å’Œç›¸å‡ ç„¶åâ€¦å°±æ²¡æœ‰ç„¶åäº†ï¼Œå…¶å®ƒéƒ½æ˜¯æ¨¡æ¿çš„ä¸»å¸­æ ‘ï¼Œåªæ˜¯ä¿®æ”¹ç”¨å·®åˆ†å°±å¥½äº† 18.P4168 [Violet]è’²å…¬è‹±åœ¨ä¹¡ä¸‹çš„å°è·¯æ—ç§ç€è®¸å¤šè’²å…¬è‹±ï¼Œè€Œæˆ‘ä»¬çš„é—®é¢˜æ­£æ˜¯ä¸è¿™äº›è’²å…¬è‹±æœ‰å…³ã€‚ ä¸ºäº†ç®€åŒ–èµ·è§ï¼Œæˆ‘ä»¬æŠŠæ‰€æœ‰çš„è’²å…¬è‹±çœ‹æˆä¸€ä¸ªé•¿åº¦ä¸ºnçš„åºåˆ— $(a_1,a_2..a_n)$ï¼Œå…¶ä¸­ $a_i$ ä¸ºä¸€ä¸ªæ­£æ•´æ•°ï¼Œè¡¨ç¤ºç¬¬iæ£µè’²å…¬è‹±çš„ç§ç±»ç¼–å·ã€‚ è€Œæ¯æ¬¡è¯¢é—®ä¸€ä¸ªåŒºé—´ [l,r]ï¼Œä½ éœ€è¦å›ç­”åŒºé—´é‡Œå‡ºç°æ¬¡æ•°æœ€å¤šçš„æ˜¯å“ªç§è’²å…¬è‹±ï¼Œå¦‚æœæœ‰è‹¥å¹²ç§è’²å…¬è‹±å‡ºç°æ¬¡æ•°ç›¸åŒï¼Œåˆ™è¾“å‡ºç§ç±»ç¼–å·æœ€å°çš„é‚£ä¸ªã€‚ æ³¨æ„ï¼Œä½ çš„ç®—æ³•å¿…é¡»æ˜¯åœ¨çº¿çš„ LYC:è¿™å°±æ˜¯ä¼ è¯´ä¸­çš„åˆ†å—æ‰“è¡¨äº† ç”±äºå¼ºåˆ¶åœ¨çº¿ï¼Œè«é˜Ÿæ˜¯ä¸å¯èƒ½çš„äº† æ±‚åŒºé—´ä¼—æ•°ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ä¹‹å‰è®²çš„åˆ†å—æ‰“è¡¨æŠ€æœ¯ï¼Œå¤„ç†å‡ºæ¯ä¸¤ä¸ªç‰¹å¾ç‚¹çš„æ¯ä¸ªå…ƒç´ çš„å‡ºç°ä¸ªæ•°å’Œå½“å‰ä¼—æ•°ã€‚ å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œç”±äºä¼—æ•°é—®é¢˜ä¸å®¹æ˜“å¾€å›æ”¶ï¼ˆè¦é‡æ–°æ‰¾ä¼—æ•°ï¼‰ï¼Œæˆ‘ä»¬é€‰å–å·¦å³ç«¯ç‚¹å¾€å†…çš„æœ€è¿‘çš„ç‰¹å¾ç‚¹ ç»§æ‰¿ï¼ˆæ³¨æ„ä¸æ˜¯ç›´æ¥æŠŠè¿™ä¸ªåŒºé—´çš„ç­”æ¡ˆæ‹¿æ¥æ¥ç€ç”¨ï¼Œå› ä¸ºä¸èƒ½å›é€€ï¼Œå¦‚æœç›´æ¥ç”¨åˆä¸å›é€€ï¼Œä¸‹æ¬¡è°ƒç”¨æ—¶ä¼šè°ƒåˆ°é”™è¯¯çš„ç»“æœï¼‰è¿™ä¸ªåŒºé—´çš„ç­”æ¡ˆï¼Œåˆ©ç”¨è¿™ä¸ªåŒºé—´ä¹‹å‰ç»Ÿè®¡çš„å…ƒç´ å‡ºç°ä¸ªæ•° å‘å¤–æ‰©å¼ ï¼Œç»Ÿè®¡å‡ºè¦è¯¢é—®çš„ç­”æ¡ˆ æœ€åè¦æŠŠåˆšåˆšç»Ÿè®¡ä¼—æ•°åŠ ä¸Šçš„å…ƒç´ ä¸ªæ•°æ¸…æ‰ï¼ˆå›æº¯æœ€åˆå¤„ç†å¥½çš„çŠ¶æ€ï¼‰ ä»£ç ï¼šï¼ˆè¿™é‡Œå—å¤§å°æˆ‘å¼€çš„$n^{2/3}$ï¼Œå¼€$\\sqrt n$å¥½åƒå¼€ä¸ä¸‹ï¼‰ #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; vector&lt;int&gt; pri; int n,m,a[40010],each,cnt[40][40][40010],MAX[40][40],lans,l,r,ans,tmp[40010]; int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); each=pow(n,2.0/3); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); for(int i=1;i&lt;=n;++i) a[i]=lower_bound(pri.begin(),pri.end(),a[i])-pri.begin()+1;//ç¦»æ•£åŒ– for(int i=1,p=1;i&lt;=n;i+=each,++p) { for(int j=i+each-1,q=p;j&lt;=n;j+=each,++q) { for(int k=i;k&lt;=j;++k) { ++cnt[p][q][a[k]]; if(cnt[p][q][a[k]]&gt;cnt[p][q][MAX[p][q]]||(cnt[p][q][a[k]]==cnt[p][q][MAX[p][q]]&amp;&amp;a[k]&lt;MAX[p][q])) MAX[p][q]=a[k]; } } }//åˆå§‹åŒ–ï¼ˆæ‰“è¡¨ï¼‰ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d&quot;,&amp;l,&amp;r); l=(l+lans-1)%n+1; r=(r+lans-1)%n+1; if(l&gt;r) swap(l,r);//å¼ºåˆ¶åœ¨çº¿ if(r-l&gt;2*each) { int p=ceil(1.0*(l-1)/each)+1; int q=ceil(1.0*(r+1)/each)-1;//å¾—åˆ°å‘å†…æ”¶ç¼©çš„ç«¯ç‚¹ ans=MAX[p][q];//ç»§æ‰¿ç­”æ¡ˆ for(int i=(p-1)*each;i&gt;=l;--i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } for(int i=q*each+1;i&lt;=r;++i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1];//è·å¾—åŸå€¼ printf(&quot;%d\\n&quot;,lans); for(int i=(p-1)*each;i&gt;=l;--i) --cnt[p][q][a[i]]; for(int i=q*each+1;i&lt;=r;++i) --cnt[p][q][a[i]];//å›æº¯ } else//åŒºé—´å¤ªå°ï¼Œå¦‚æœä¸¤ä¸ªç«¯ç‚¹åœ¨ä¸€ä¸ªå—å†…ï¼Œå‘å†…æ”¶ç¼©å°±ä¼šé‡å¤ç»Ÿè®¡æ•´ä¸ªå—ï¼Œæ‰€ä»¥æš´åŠ›ç»Ÿè®¡ { ans=0; for(int i=l;i&lt;=r;++i) { ++tmp[a[i]]; if(tmp[a[i]]&gt;tmp[ans]||(tmp[a[i]]==tmp[ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1]; printf(&quot;%d\\n&quot;,lans); for(int i=l;i&lt;=r;++i) --tmp[a[i]];//å›æº¯æ¸…é›¶ } } return 0; } WGY:è¿™é“é¢˜luoguçš„æ•°æ®å¾ˆæ°´ï¼Œäºæ˜¯â€¦äºæ˜¯â€¦æˆ‘ä»¬ç›´æ¥ç¦»æ•£åŒ–+æš´åŠ›å°±èƒ½è¿‡ï¼ ç„¶åâ€¦.ç„¶åå°±æ²¡äº†(è¿™æ¬¡çœŸçš„ä¸æ˜¯æˆ‘ä¸æƒ³å†™ï¼Œæ˜¯çœŸçš„æ²¡ä»€ä¹ˆå†™çš„â€¦) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 50000 + 5; int a[SIZE], b[SIZE]; int cnt[SIZE], x; int l, r, n, m, l0, r0; signed main() { io.read(n), io.read(m); for (int i = 1; i &lt;= n; ++i) io.read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b; while (m--) { io.read(l0), io.read(r0); l = (l0 + x - 1) % n + 1; r = (r0 + x - 1) % n + 1; if (l &gt; r) swap(l, r); for (int i = l; i &lt;= r; ++i) cnt[a[i]]++; int MAX = 0, pos = 0; for (int i = 1; i &lt;= len; ++i) if (MAX &lt; cnt[i]) MAX = cnt[i], pos = i; printf(&quot;%d\\n&quot;, b[pos]); x = b[pos]; memset(cnt, 0, sizeof cnt); } } 19.[CQOI2014]æ’åºæœºæ¢°è‡‚ä¸ºäº†æŠŠå·¥å‚ä¸­é«˜ä½ä¸ç­‰çš„ç‰©å“æŒ‰ä»ä½åˆ°é«˜æ’å¥½åºï¼Œå·¥ç¨‹å¸ˆå‘æ˜äº†ä¸€ç§æ’åºæœºæ¢°è‡‚ã€‚å®ƒéµå¾ªä¸€ä¸ªç®€å•çš„æ’åºè§„åˆ™ï¼Œç¬¬ä¸€æ¬¡æ“ä½œæ‰¾åˆ°é«˜åº¦æœ€ä½çš„ç‰©å“çš„ä½ç½® $P_1$ ï¼Œå¹¶æŠŠå·¦èµ·ç¬¬ä¸€ä¸ªç‰©å“è‡³ $P_1$ é—´çš„ç‰©å“ (å³åŒºé—´ $[1,P_1]$ é—´çš„ç‰©å“) ååºï¼›ç¬¬äºŒæ¬¡æ‰¾åˆ°ç¬¬äºŒä½çš„ç‰©å“çš„ä½ç½® $P_2$ ï¼Œå¹¶æŠŠå·¦èµ·ç¬¬äºŒä¸ªè‡³ $P_2$ é—´çš„ç‰©å“ (å³åŒºé—´ $[2,P_2]$ é—´çš„ç‰©å“) ååºâ€¦â€¦æœ€ç»ˆæ‰€æœ‰çš„ç‰©å“éƒ½ä¼šè¢«æ’å¥½åºã€‚ ä¸Šå›¾ç»™å‡ºæœ‰å…­ä¸ªç‰©å“çš„ç¤ºä¾‹ï¼Œç¬¬ä¸€æ¬¡æ“ä½œå‰ï¼Œé«˜åº¦æœ€ä½çš„ç‰©å“åœ¨ä½ç½® $4$ ï¼Œäºæ˜¯æŠŠç¬¬ä¸€è‡³ç¬¬å››çš„ç‰©å“ååºï¼›ç¬¬äºŒæ¬¡æ“ä½œå‰ï¼Œç¬¬äºŒä½çš„ç‰©å“åœ¨ä½ç½å…­ï¼Œäºæ˜¯æŠŠç¬¬äºŒè‡³å…­çš„ç‰©å“ååºâ€¦â€¦ ä½ çš„ä»»åŠ¡ä¾¿æ˜¯ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œç¡®å®šä¸€ä¸ªæ“ä½œåºåˆ—ï¼Œå³æ¯æ¬¡æ“ä½œå‰ç¬¬ $i$ ä½çš„ç‰©å“æ‰€åœ¨ä½ç½® $P_i$ ï¼Œä»¥ä¾¿æœºæ¢°è‡‚å·¥ä½œã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœæœ‰é«˜åº¦ç›¸åŒçš„ç‰©å“ï¼Œå¿…é¡»ä¿è¯æ’åºåå®ƒä»¬çš„ç›¸å¯¹ä½ç½®å…³ç³»ä¸åˆå§‹æ—¶ç›¸åŒã€‚ LYCï¼šæˆ‘ä»¬ä¹ä¸€çœ‹è¿™é“é¢˜ â€œå“Ÿï¼åŒºé—´ç¿»è½¬å¹³è¡¡æ ‘è£¸é¢˜ï¼Œè¿˜6å€ç»éªŒï¼Ÿï¼â€ å†ä¸€çœ‹ï¼Œæ¯æ¬¡ç¿»è½¬åŒºé—´ç¬¬ä¸€ä¸ªåˆ°å…ƒç´ å€¼æœ€å°çš„ä¸€ä¸ªï¼Œå†åˆ é™¤æœ€å°çš„ä¸€ä¸ª ï¼Ÿï¼Ÿï¼Ÿ å…ƒç´ å€¼æœ€å°çš„ä¸€ä¸ª åº”è¯¥æ€ä¹ˆç»´æŠ¤å‘¢ æˆ‘ä»¬å¯ä»¥åœ¨updateé‡Œé¡ºä¾¿ç»´æŠ¤è¿™ä¸ªå­æ ‘ä¸­æœ€å°çš„å€¼æ˜¯ç¬¬å‡ ä¸ªå’Œå®ƒçš„å¤§å°ï¼ˆæˆ‘è„‘æ®‹ç»´æŠ¤äº†å‰é¢æœ‰å‡ ä¸ªæ•°ï¼‰ã€‚ é’ˆå¯¹è¿™ä¸ªè¿›è¡Œåˆ†ç±»è®¨è®ºï¼š 1).å½“å‰ç»“ç‚¹çš„å€¼æ¯”å·¦å³å­æ ‘çš„æœ€å°å€¼éƒ½å° é‚£ä¹ˆæœ€å°å€¼æ˜¯å½“å‰ç»“ç‚¹çš„å€¼ã€‚ å®ƒå‰é¢çš„å…ƒç´ ä¸ªæ•°æ˜¯å·¦å­æ ‘çš„å¤§å°ï¼ˆä¸­åºéå†ä¸ºåŸåºåˆ—ï¼‰ 2).å·¦å­æ ‘çš„æœ€å°å€¼æœ€å° å®Œç¾ç»§æ‰¿å·¦å­æ ‘çš„ä¸¤ä¸ªå€¼ã€‚ 3).å³å­æ ‘çš„æœ€å°å€¼æœ€å° æœ€å°å€¼ä¸ç”¨è¯´äº†å§ã€‚ å®ƒå‰é¢çš„ä¸ªæ•°å°±æ˜¯å·¦å­æ ‘çš„å¤§å°åŠ ä¸€ï¼ˆå½“å‰ç»“ç‚¹ï¼‰å†åŠ ä¸Šå³å­æ ‘ä¸­åœ¨å®ƒå‰é¢çš„å…ƒç´ ä¸ªæ•° å› ä¸ºå­æ ‘ä¸å˜æ—¶ï¼Œé‚£æˆ‘ä»¬ç»´æŠ¤çš„è¿™ä¸ªå€¼ä¹Ÿä¸å˜ã€‚å­æ ‘å˜äº†ï¼Œé‚£å°±è‚¯å®šè¦æ›´æ–°ã€‚ ç„¶åå†æ¯æ¬¡éƒ½æŸ¥è¯¢æœ€å°çš„å…ƒç´ åœ¨å“ªä¸€ä¸ªä½ç½®ï¼Œåˆ æ‰å®ƒå†ç¿»è½¬å‰é¢çš„åŒºé—´å°±å¥½äº† ä»£ç ï¼š #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,tot,root,root1,root2,root3,c[100010]; struct node { int l,r,num,key,sum; int s,smum;//æœ€å°å€¼å¤§å°ï¼Œå‰é¢çš„å…ƒç´ ä¸ªæ•° bool rev;//ç¿»è½¬æ ‡è®° }nodes[100010]; struct laji { int v,ID; }a[100010]; bool cmp(laji one,laji two) { if(one.v^two.v) return one.v&lt;two.v; return one.ID&lt;two.ID; }//ç¦»æ•£åŒ–ï¼Œé¡ºä¾¿è§£å†³å¦‚æœå€¼ç›¸åŒï¼Œä¿æŒåŸæœ‰ç›¸å¯¹ä½ç½®çš„é—®é¢˜ int newnode(int val) { nodes[++tot].s=val;//æœ€å°å€¼è®¾ä¸ºè‡ªå·±ï¼Œå‰é¢æ²¡æœ‰æ•° nodes[tot].num=val; nodes[tot].key=rand(); nodes[tot].sum=1; return tot; } void pushdown(int x) { swap(nodes[x].l,nodes[x].r);//é¦–å…ˆäº¤æ¢å·¦å³å„¿å­ nodes[x].smum=nodes[x].sum-(nodes[x].smum+1);//æ•´ä¸ªå­æ ‘ç¿»è½¬è¿‡æ¥ï¼Œåˆ™æœ€å°å€¼çš„ä½ç½®å°±è¦ç¿»è¿‡æ¥ //åŸæ¥å‰é¢çš„å…ƒç´ ä¸ªæ•°ï¼šnodes[x].smum //åŸä½ç½®: nodes[x].smum+1 //ç¿»è½¬ä½ç½®ï¼šnodes[x].sum-(nodes[x].smum+1)+1 //ç¿»è½¬åå‰é¢çš„å…ƒç´ ä¸ªæ•°ï¼šnodes[x].sum-(nodes[x].smum+1) nodes[nodes[x].l].rev^=1; nodes[nodes[x].r].rev^=1;//ä¸‹ä¼ æ ‡è®° nodes[x].rev=0;//è®°å¾—æ¸…ç©º } void update(int x) { nodes[x].sum=nodes[nodes[x].l].sum+nodes[nodes[x].r].sum+1; if(nodes[nodes[x].l].rev) pushdown(nodes[x].l); if(nodes[nodes[x].r].rev) pushdown(nodes[x].r);//å¦‚æœå·¦å³å­æ ‘æœ‰æ ‡è®°ï¼Œä¹Ÿè¦ä¸‹ä¼ ï¼Œå¦åˆ™æ›´æ–°å‡ºçš„å€¼ä¸å¯¹ if(nodes[x].num&lt;nodes[nodes[x].l].s&amp;&amp;nodes[x].num&lt;nodes[nodes[x].r].s)//åˆ†ç±»è®¨è®ºæƒ…å†µ1 { nodes[x].s=nodes[x].num; nodes[x].smum=nodes[nodes[x].l].sum; } else if(nodes[nodes[x].l].s&lt;nodes[nodes[x].r].s)//æƒ…å†µ2 { nodes[x].s=nodes[nodes[x].l].s; nodes[x].smum=nodes[nodes[x].l].smum; } else//æƒ…å†µ3 { nodes[x].s=nodes[nodes[x].r].s; nodes[x].smum=nodes[nodes[x].r].smum+nodes[nodes[x].l].sum+1; } } void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[now].rev) pushdown(now);//ä¸‹é¢è¦ç”¨åˆ°å®ƒçš„å„¿å­ï¼Œæ‰€ä»¥æˆ‘ä»¬è¦ä¸‹ä¼ æ ‡è®° if(nodes[nodes[now].l].sum&lt;siz) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { if(nodes[x].rev) pushdown(x); nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { if(nodes[y].rev) pushdown(y); nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } int main() { srand(20060515); nodes[0].num=nodes[0].s=1e9;//å¤„ç†èŠ‚ç‚¹ä¸ºç©ºçš„ç‰¹æ®Šæƒ…å†µä¸ºæå¤§å€¼ï¼Œä½¿æ›´æ–°å¶å­èŠ‚ç‚¹æ—¶ä¸ä¼šæŠŠ0æ›´æ–°è¿›å» scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i].v); a[i].ID=i; } sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;++i) c[a[i].ID]=i;//ç¦»æ•£åŒ– for(int i=1;i&lt;=n;++i) root=merge(root,newnode(c[i]));//å¤„ç†åŸåºåˆ—ï¼Œç›´æ¥æŠŠå½“å‰å…ƒç´ æ’å…¥åˆ°å®ƒå‰é¢å…ƒç´ çš„å³è¾¹ for(int i=1;i&lt;=n;++i) { if(nodes[root].rev) pushdown(root);//å¦‚æœæ ¹èŠ‚ç‚¹æœ‰ç¿»è½¬æ ‡è®°è¦ç¿»è½¬ï¼Œå¦åˆ™æœ€å°å€¼çš„ä½ç½®æ˜¯åçš„ã€‚ printf(&quot;%d &quot;,nodes[root].smum+i);//è¿˜æœ‰ä¹‹å‰çš„i-1ä¸ªå·²ç»è¢«åˆ é™¤çš„æ•° split(root,nodes[root].smum,root1,root2); split(root2,1,root2,root3);//åˆ é™¤è¿™ä¸ªæ•° nodes[root1].rev^=1;//ç¿»è½¬å‰é¢çš„åŒºé—´ root=merge(root1,root3); } return 0; } WGY:SplayNBï¼ï¼ï¼åŒºé—´æ“ä½œç›´æ¥ç§’è¿‡ï¼ï¼(å…·ä½“é¢˜è§£å‚è€ƒLYCï¼Œæˆ‘å°±æ”¾ä¸ªä»£ç ) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 100000 + 5; struct SPLAY { int fa; int size; int val; int rev; int ch[2]; } t[SIZE]; int n, root, tot, pos[SIZE]; struct InputNode { int id; int val; } a[SIZE]; bool cmp1(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.val ^ rsp.val ? rhs.val &lt; rsp.val : rhs.id &lt; rsp.id; } bool cmp2(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.id &lt; rsp.id; } void update(int x) { t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; } void transf(int x) { if (t[x].rev) { swap(t[x].ch[0], t[x].ch[1]); t[t[x].ch[0]].rev ^= 1; t[t[x].ch[1]].rev ^= 1; t[x].rev = 0; } } int make(int fa, int l, int r) { if (l &gt; r) return 0; int p = ++tot; return(t[p].val = a[mid].val, t[p].fa = fa, pos[a[mid].val] = p, t[p].ch[0] = make(p, l, mid - 1), t[p].ch[1] = make(p, mid + 1, r), update(p), p); } void rotate(int x) { int y = t[x].fa, z = t[y].fa; transf(y), transf(x); int k = t[t[x].fa].ch[1] == x; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[y].ch[k]].fa = y; t[y].fa = x; t[x].ch[k ^ 1] = y; t[x].fa = z; if (z) t[z].ch[y == t[z].ch[1]] = x; update(y), update(x); } void splay(int x, int goal) { for (int y; (y = t[x].fa) ^ goal; rotate(x)) if (t[y].fa ^ goal) rotate(t[t[x].fa].ch[1] ^ x ^ y ^ t[t[y].fa].ch[1] ? x : y); if (!goal) root = x; } int behavior() { transf(root); int x = t[root].ch[1]; while (transf(x), t[x].ch[0]) x = t[x].ch[0]; return x; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i + 1].val), a[i + 1].id = i + 1; a[1].val = 0, a[n + 2].val = n + 1; sort(a + 2, a + 2 + n, cmp1); for (int i = 2; i &lt;= n + 1; ++i) a[i].val = i - 1; sort(a + 2, a + 2 + n, cmp2); root = make(0, 1, n + 2); for (int i = 1; i &lt;= n; ++i) { int x = pos[i]; splay(x, 0); printf(&quot;%d &quot;, t[t[x].ch[0]].size); x = behavior(); int y = pos[i - 1]; splay(y, 0); splay(x, y); t[t[x].ch[0]].rev ^= 1; } return 0; } 20.[SHOI2013]æ‰‡å½¢é¢ç§¯å¹¶(æƒå€¼çº¿æ®µæ ‘&amp;æ‰«æçº¿) ç»™å®š n ä¸ªåŒå¿ƒçš„æ‰‡å½¢ï¼Œæ±‚æœ‰å¤šå°‘é¢ç§¯ï¼Œè¢«è‡³å°‘ $k$ ä¸ªæ‰‡å½¢æ‰€è¦†ç›–ã€‚ LYC:è¿™é“é¢˜è¦ç”¨åˆ°æ‰«æçº¿çš„æ€æƒ³,é‚£æ‰«æçº¿æ˜¯ä»€ä¹ˆå‘¢? æ‰«æçº¿ï¼š ç»å…¸åº”ç”¨ï¼šç»™å‡ºä¸€å †çŸ©é˜µï¼Œæ±‚å®ƒä»¬è¦†ç›–çš„æ€»é¢ç§¯ æ•°æ®èŒƒå›´æ¶å¿ƒæ­»äº†ï¼Œ$10^5$ä¸ªçŸ©é˜µï¼ŒçŸ©é˜µçš„åæ ‡çš„ç»å¯¹å€¼å°äº$10^9$ã€‚ çœ‹åˆ°è¿™ä¸ªæ•°æ®èŒƒå›´æˆ‘ä»¬å°±çŸ¥é“ï¼šè¦ç¦»æ•£åŒ–ã€‚ ä¹‹åå‘¢ï¼Œæˆ‘ä»¬æŠŠæ¯ä¸ªçŸ©é˜µçš„å·¦å³è¾¹ç•Œéƒ½è½¬æ¢æˆæ·»åŠ å’Œåˆ é™¤ã€‚ æˆ‘ä»¬ç”¨ä¸€æ¡æ‰«æçº¿ä»å·¦åˆ°å³æ‰«è¿‡å»ï¼Œçº¿æ®µæ ‘æ¥ç»´æŠ¤ç°åœ¨æ•´æ¡æ‰«æçº¿çš„è¢«è¦†ç›–æƒ…å†µã€‚ çŸ©é˜µçš„å·¦è¾¹å°±æ˜¯æ·»åŠ ä»¥è¿™ä¸ªçŸ©é˜µçš„ä¸Šä¸‹è¾¹ç•Œç‚¹ä¸ºç«¯ç‚¹çš„çº¿æ®µã€‚ å³è¾¹å†å³è¾¹ä¸€ä¸ªå°±è½¬æ¢æˆåˆ é™¤ã€‚ æ¯èµ°è¿‡ä¸€ä¸ªç‚¹ï¼Œæˆ‘ä»¬å°±ç”¨çº¿æ®µæ ‘ç»Ÿè®¡å½“å‰æ‰«æçº¿è¢«è¿™äº›çŸ©é˜µè¦†ç›–äº†å¤šå°‘ï¼Œå†æŠŠç­”æ¡ˆåŠ ä¸Šå»å°±å¥½äº†ã€‚ æ¨¡æ¿æˆ‘å°±ä¸å†™å•¦å…¶å®æ˜¯æˆ‘ä¸ä¼š $\\ $ å¥½äº†é‚£æˆ‘ä»¬æ¥çœ‹è¿™é“é¢˜å§ã€‚ ä¸€å †åœ†å¿ƒç›¸åŒçš„æ‰‡å½¢ï¼Œæ±‚è¢«è‡³å°‘$k$ä¸ªæ‰‡å½¢è¦†ç›–çš„é¢ç§¯ã€‚ æˆ‘ä»¬å…ˆå•çœ‹ä¸€æ¡ä»åœ†å¿ƒå°„å‡ºçš„å°„çº¿ã€‚ ç”±äºæ¯ä¸ªæ‰‡å½¢çš„åœ†å¿ƒæ˜¯ç›¸åŒçš„ã€‚ æ‰€ä»¥è¦†ç›–æ¯ä¸ªåœ°æ–¹çš„æ‰‡å½¢æ•°é‡æ˜¯å‘å¤–é€’å‡çš„ã€‚ é‚£ä¹ˆè¢«è‡³å°‘$k$ä¸ªæ‰‡å½¢è¦†ç›–çš„åœ°æ–¹å°±åœ¨ä»å¤–åˆ°å†…ç¬¬$k$ä¸ªæ‰‡å½¢ï¼Œå®ƒè¢«åˆšå¥½æˆ–è€…å¤šäº$k$ä¸ªæ‰‡å½¢æ‰€è¦†ç›–ï¼Œæ›´å‘å†…çš„åœ°æ–¹çš„æ•°é‡åˆ™æ›´å¤šï¼Œä¹Ÿæ˜¯å¤§äºç­‰äº$k$ã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨æƒå€¼çº¿æ®µæ ‘æ¥ç»´æŠ¤æ¯ä¸ªåœ°æ–¹æœ‰å¤šå°‘ä¸ªæ‰‡å½¢è¾¹ç•Œã€‚ä»è€ŒæŸ¥æ‰¾ä»å¤–åˆ°å†…ç¬¬$k$ä¸ªæ‰‡å½¢è¾¹ç•Œã€‚ è¿ç”¨æ‰«æçº¿æ€æƒ³ï¼ŒæŠŠç»™å‡ºçš„æ‰‡å½¢çš„ä¸¤ä¸ªè§’åº¦å€¼è½¬æ¢æˆæ·»åŠ å’Œåˆ é™¤ä¸€ä¸ªæ‰‡å½¢è¾¹ç•Œã€‚ å®ç°æœ‰å¾ˆå¤šå‘ï¼Œè‡ªå·±çœ‹æ³¨é‡Šå§ã€‚ ä»£ç ï¼š #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; long long n,m,k,nodes[400010],a1,a2,ans,s,now; struct cir { long long r; bool insorex;//1ä¸ºæ·»åŠ ï¼Œ2ä¸ºåˆ é™¤ }cur; vector&lt;cir&gt; op[2000010];//ç”¨æ¥å‚¨å­˜åœ¨æ¯ä¸ªè§’åº¦çš„ä¿®æ”¹ void ins(long long l,long long r,long long x,long long pos) { ++nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,x&lt;&lt;1,pos); else ins(mid+1,r,x&lt;&lt;1|1,pos); } } void exins(long long l,long long r,long long x,long long pos)//æƒå€¼çº¿æ®µæ ‘åˆ é™¤ { --nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) exins(l,mid,x&lt;&lt;1,pos); else exins(mid+1,r,x&lt;&lt;1|1,pos); } } long long find(long long l,long long r,long long x,long long val)//æƒå€¼çº¿æ®µæ ‘æŸ¥æ‰¾ä»å¤–åˆ°å†…ç¬¬kä¸ª { if(l==r) return l; long long mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1|1]) return find(mid+1,r,x&lt;&lt;1|1,val); else return find(l,mid,x&lt;&lt;1,val-nodes[x&lt;&lt;1|1]); } int main() { scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;k); for(long long i=1;i&lt;=n;++i) { scanf(&quot;%lld %lld %lld&quot;,&amp;cur.r,&amp;a1,&amp;a2); s=max(s,cur.r); a1+=m; a2+=m;//a1,a2å¯èƒ½æ˜¯è´Ÿæ•° //è½¬æ¢æˆæ·»åŠ å’Œä¿®æ”¹ if(a1&gt;a2)//è¿™ä¸ªæ‰‡å½¢è·¨è¶Šäº†åˆ†ç•Œçº¿ï¼Œéœ€è¦æ‹†æˆä¸¤åŠ { cur.insorex=1; op[a1+1].push_back(cur); op[1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } else { cur.insorex=1; op[a1+1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } } for(long long i=1;i&lt;=m*2;++i)//æ³¨æ„æ˜¯åŠå¼€åŒºé—´(-Pi,Pi] { for(long long j=0;j&lt;op[i].size();++j)//è¿›è¡Œä¿®æ”¹æ“ä½œ { cur=op[i][j]; if(cur.insorex) { ins(1,s,1,cur.r); ++now; } else { exins(1,s,1,cur.r); --now;//ç»Ÿè®¡ç°åœ¨æ€»å…±æœ‰å¤šå°‘ä¸ª } } if(now&gt;=k)//æœ‰kä¸ªæ‰ç»Ÿè®¡ï¼Œä¸ç„¶å®¹æ˜“å‡ºé”… { long long tmp=find(1,s,1,k); ans+=tmp*tmp;//åœ†é¢ç§¯å…¬å¼ï¼šPi*r*r } } printf(&quot;%lld\\n&quot;,ans); return 0; } WGYæä¾›æ ‘çŠ¶æ•°ç»„+äºŒåˆ†åšæ³•ï¼Œå¤æ‚åº¦$O(n\\log^2n)$ æ ‘çŠ¶æ•°ç»„å†™èµ·æ¥çŸ­ï¼Œå¸¸æ•°å°ï¼ŒåŠ¨åŠ¨è„‘å­å¯ä»¥å¥—åœ¨å¾ˆå¤šé¢˜ç›®ä¸Šï¼Œå®ƒä¸é¦™å˜› é¢˜ç›®è®©æˆ‘ä»¬æ±‚ç›®å‰è¦†ç›–çš„ç¬¬ $k$ å¤§ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåŸæ¥çš„è¦†ç›–ä½ç½®å·®åˆ†ä¸€ä¸‹ï¼Œç„¶åäºŒåˆ†å³å¯ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m, k, a[SIZE]; LL tree[SIZE], ans; vector &lt; int &gt; In[SIZE&lt;&lt;1], Out[SIZE&lt;&lt;1]; void Add(int x, int y) { for (; x &lt; SIZE; x += x &amp; -x) tree[x] += y; } int Ask(int x, int res = 0) { for (; x; x -= x &amp; -x) res += tree[x]; return res; } int KthElement(int k) { int l = 1, r = SIZE - 5; while (l &lt; r) if (Ask(mid) &lt; k) l = mid + 1; else r = mid; return l; } signed main() { io.read(m), io.read(n), io.read(k); int L, R; for (int i = 1; i &lt;= m; ++i) { io.read(a[i]); io.read(L); io.read(R); if (L &lt; R) L += n + 1, R += n, In[L].pub(i), Out[R + 1].pub(i); else L ^= R ^= L ^= R, L += n, R += n + 1, In[1].pub(i), Out[L + 1].pub(i), In[R].pub(i); } int now = 0, x; for (int i = 1; i &lt;= (n&lt;&lt;1); ++i) { for (int j = 0; j &lt; In[i].size(); ++j) Add(a[In[i][j]], 1); for (int j = 0; j &lt; Out[i].size(); ++j) Add(a[Out[i][j]], -1); now += In[i].size() - Out[i].size(); if (now &gt;= k) x = KthElement(now - k + 1), ans += (LL)x * x; } printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 1~10é¢˜","slug":"DS100P-1-10-P","date":"2020-02-08T06:03:27.000Z","updated":"2020-02-18T10:10:03.954Z","comments":true,"path":"2020/02/08/DS100P-1-10-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-1-10-P/","excerpt":"","text":"1.ã€Œä¸€æœ¬é€š 4.6 ä¾‹ 1ã€è¥ä¸šé¢ç»Ÿè®¡åŸé¢˜æ¥è‡ªï¼šHNOI 2002 Tiger æœ€è¿‘è¢«å…¬å¸å‡ä»»ä¸ºè¥ä¸šéƒ¨ç»ç†ï¼Œä»–ä¸Šä»»åæ¥å—å…¬å¸äº¤ç»™çš„ç¬¬ä¸€é¡¹ä»»åŠ¡ä¾¿æ˜¯ç»Ÿè®¡å¹¶åˆ†æå…¬å¸æˆç«‹ä»¥æ¥çš„è¥ä¸šæƒ…å†µã€‚ Tiger æ‹¿å‡ºäº†å…¬å¸çš„è´¦æœ¬ï¼Œè´¦æœ¬ä¸Šè®°å½•äº†å…¬å¸æˆç«‹ä»¥æ¥æ¯å¤©çš„è¥ä¸šé¢ã€‚åˆ†æè¥ä¸šæƒ…å†µæ˜¯ä¸€é¡¹ç›¸å½“å¤æ‚çš„å·¥ä½œã€‚ç”±äºèŠ‚å‡æ—¥ï¼Œå¤§å‡ä»·æˆ–è€…æ˜¯å…¶ä»–æƒ…å†µçš„æ—¶å€™ï¼Œè¥ä¸šé¢ä¼šå‡ºç°ä¸€å®šçš„æ³¢åŠ¨ï¼Œå½“ç„¶ä¸€å®šçš„æ³¢åŠ¨æ˜¯èƒ½å¤Ÿæ¥å—çš„ï¼Œä½†æ˜¯åœ¨æŸäº›æ—¶å€™è¥ä¸šé¢çªå˜å¾—å¾ˆé«˜æˆ–æ˜¯å¾ˆä½ï¼Œè¿™å°±è¯æ˜å…¬å¸æ­¤æ—¶çš„ç»è¥çŠ¶å†µå‡ºç°äº†é—®é¢˜ã€‚ ç»æµç®¡ç†å­¦ä¸Šå®šä¹‰äº†ä¸€ç§æœ€å°æ³¢åŠ¨å€¼æ¥è¡¡é‡è¿™ç§æƒ…å†µï¼šè®°è¯¥å¤©ä»¥å‰æŸä¸€å¤©çš„è¥ä¸šé¢ä¸º $a_i$ï¼Œè¯¥å¤©è¥ä¸šé¢ä¸º $b$ï¼Œåˆ™è¯¥å¤©çš„æœ€å°æ³¢åŠ¨å€¼ $\\delta=\\min |a_i-b|$ï¼Œå½“æœ€å°æ³¢åŠ¨å€¼è¶Šå¤§æ—¶ï¼Œå°±è¯´æ˜è¥ä¸šæƒ…å†µè¶Šä¸ç¨³å®šã€‚è€Œåˆ†ææ•´ä¸ªå…¬å¸çš„ä»æˆç«‹åˆ°ç°åœ¨è¥ä¸šæƒ…å†µæ˜¯å¦ç¨³å®šï¼Œåªéœ€è¦æŠŠæ¯ä¸€å¤©çš„æœ€å°æ³¢åŠ¨å€¼åŠ èµ·æ¥å°±å¯ä»¥äº†ã€‚ ä½ çš„ä»»åŠ¡å°±æ˜¯ç¼–å†™ä¸€ä¸ªç¨‹åºå¸®åŠ© Tiger æ¥è®¡ç®—è¿™ä¸€ä¸ªå€¼ï¼Œç¬¬ä¸€å¤©çš„æœ€å°æ³¢åŠ¨å€¼ä¸ºç¬¬ä¸€å¤©çš„è¥ä¸šé¢ã€‚ ä¸€å¥è¯é¢˜æ„ç»™å‡ºä¸€ä¸ª $n$ ä¸ªæ•°çš„æ•°åˆ— $\\{a_n\\}$ï¼Œå¯¹äºç¬¬ $i$ ä¸ªå…ƒç´  $a_i$ï¼Œå®šä¹‰ $f_i=\\min |a_i-a_j|$ï¼Œå…¶ä¸­ $1\\le j\\lt i,f_1=a_1$ã€‚æ±‚ $\\sum f_i$ã€‚ æ²¡ä»€ä¹ˆå¯è¯´çš„ï¼Œå°±æ˜¯æ¿å­ï¼Œå¯ä»¥ç”¨æ¥è°ƒä¸€ä¸‹æŒ‡é’ˆç‰ˆsplayã€‚ä¸è¿‡æˆ‘å‘ç°æŒ‡é’ˆç‰ˆè·‘çš„é£æ…¢æ˜¯åœ¨æå˜› è¿˜æ˜¯æ­£ç»è¯´ä¸€ä¸‹å§ è¿™é“é¢˜è¦æŸ¥è¯¢æœ€å°æ³¢åŠ¨å€¼ã€‚æˆ‘ä»¬åªéœ€è¦æŠŠxçš„å‰é©±å’Œåç»§æ±‚å‡ºæ¥ï¼Œçœ‹ä¸€ä¸‹è°è·Ÿxçš„å…³ç³»æ›´å¥½ç¦»çš„æ›´è¿‘ï¼Œå†ç®—å‡ºç­”æ¡ˆï¼Œå†æŠŠè¿™ä¸ªæ•°insertè¿›å»å°±å¥½äº† #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define mid (l + r &gt;&gt; 1) #define int long long using namespace std; const int SIZE = (1 &lt;&lt; 15) + 5; const int INF = 0x7fffffff; struct SplayNode { SplayNode *son[2], *fa; int val, siz; SplayNode(SplayNode *fa = NULL, int val = 0) : fa(fa), val(val) { *son = *(son + 1) = NULL; siz = 1; } inline bool islyczbing() { return this == fa-&gt;son[1]; } inline int rnk() { return 1 + (*son ? (*son)-&gt;siz : 0); } inline void up() { siz = 1 + (*son ? (*son)-&gt;siz : 0) + ((*(son + 1)) ? (*(son + 1))-&gt;siz : 0); } } * root; inline void rotate(SplayNode *x) { bool k = x-&gt;islyczbing(); SplayNode *y = x-&gt;fa, *z = y-&gt;fa, *w = x-&gt;son[!k]; if (root == y) root = x; else z-&gt;son[y-&gt;islyczbing()] = x; x-&gt;fa = z; y-&gt;fa = x; x-&gt;son[!k] = y; y-&gt;son[k] = w; if (w) w-&gt;fa = y; y-&gt;up(); x-&gt;up(); } inline void cosplay(SplayNode *x) { while (x != root) { if (x-&gt;fa != root) rotate(x-&gt;islyczbing() ^ x-&gt;fa-&gt;islyczbing() ? x : x-&gt;fa); rotate(x); } } inline void insert(int val) { if (!root) return (void)(root = new SplayNode(NULL, val)); SplayNode *p = root, *fa = NULL; while (p) { fa = p; p = p-&gt;son[val &gt; p-&gt;val]; } p = new SplayNode(fa, val); fa-&gt;son[val &gt; fa-&gt;val] = p; cosplay(p); } inline int getpre(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &gt; p-&gt;val) lst = p, p = p-&gt;son[1]; else p = p-&gt;son[0]; } if (lst) return cosplay(lst), lst-&gt;val; return -INF; } inline int getnext(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &lt; p-&gt;val) lst = p, p = p-&gt;son[0]; else p = p-&gt;son[1]; } if (lst) return cosplay(lst), lst-&gt;val; return INF; } signed main() { root = NULL; int n; scanf(&quot;%lld&quot;, &amp;n); int ans = 0; for (int i = 1, x; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;x); if (i == 1) ans += x; else ans += min(x - getpre(x + 1), getnext(x - 1) - x); insert(x); } printf(&quot;%lld\\n&quot;, ans); return 0; } 2.[SHOI2013]å‘ç‰Œåœ¨ä¸€äº›æ‰‘å…‹æ¸¸æˆé‡Œï¼Œå¦‚å¾·å·æ‰‘å…‹ï¼Œå‘ç‰Œæ˜¯æœ‰è®²ç©¶çš„ã€‚ä¸€èˆ¬ç§°å‘¼ä¸“ä¸šçš„å‘ç‰Œæ‰‹ä¸ºè·å®˜ã€‚è·å®˜åœ¨å‘ç‰Œå‰ï¼Œå…ˆè¦é”€ç‰Œï¼ˆburn cardï¼‰ã€‚æ‰€è°“é”€ç‰Œï¼Œå°±æ˜¯æŠŠå½“å‰åœ¨ç‰Œåº“é¡¶çš„é‚£ä¸€å¼ ç‰Œç§»åŠ¨åˆ°ç‰Œåº“åº•ï¼Œå®ƒç”¨æ¥é˜²æ­¢ç©å®¶çŒœç‰Œè€Œå½±å“æ¸¸æˆã€‚ å‡è®¾ä¸€å¼€å§‹ï¼Œè·å®˜æ‹¿å‡ºäº†ä¸€å‰¯æ–°ç‰Œï¼Œè¿™å‰¯ç‰Œæœ‰N å¼ ä¸åŒçš„ç‰Œï¼Œç¼–å·ä¾æ¬¡ä¸º1åˆ°Nã€‚ç”±äºæ˜¯æ–°ç‰Œï¼Œæ‰€ä»¥ç‰Œæ˜¯æŒ‰ç…§é¡ºåºæ’å¥½çš„ï¼Œä»ç‰Œåº“é¡¶å¼€å§‹ï¼Œä¾æ¬¡ä¸º1, 2,â€¦â€¦ç›´åˆ°Nï¼ŒN å·ç‰Œåœ¨ç‰Œåº“åº•ã€‚ä¸ºäº†å‘å®Œæ‰€æœ‰çš„ç‰Œï¼Œè·å®˜ä¼šè¿›è¡ŒN æ¬¡å‘ç‰Œæ“ä½œï¼Œåœ¨ç¬¬i æ¬¡å‘ç‰Œä¹‹å‰ï¼Œä»–ä¼šè¿ç»­è¿›è¡ŒRiæ¬¡é”€ç‰Œæ“ä½œï¼Œ Riç”±è¾“å…¥ç»™å®šã€‚è¯·é—®æœ€åç©å®¶æ‹¿åˆ°è¿™å‰¯ç‰Œçš„é¡ºåºæ˜¯ä»€ä¹ˆæ ·çš„ï¼Ÿ ä¸¾ä¸ªä¾‹å­ï¼Œå‡è®¾N = 4ï¼Œåˆ™ä¸€å¼€å§‹çš„æ—¶å€™ï¼Œç‰Œåº“ä¸­ç‰Œçš„æ„æˆé¡ºåºä¸º{1, 2, 3, 4}ã€‚ å‡è®¾R1=2ï¼Œåˆ™è·å®˜åº”è¯¥è¿é”€ä¸¤æ¬¡ç‰Œï¼Œå°†1 å’Œ2 æ”¾å…¥ç‰Œåº“åº•ï¼Œå†å°†3 å‘ç»™ç©å®¶ã€‚ç›®å‰ç‰Œåº“ä¸­çš„ç‰Œé¡ºåºä¸º{4, 1, 2}ã€‚ å‡è®¾R2=0ï¼Œè·å®˜ä¸éœ€è¦é”€ç‰Œï¼Œç›´æ¥å°†4 å‘ç»™ç©å®¶ï¼Œç›®å‰ç‰Œåº“ä¸­çš„ç‰Œé¡ºåºä¸º{1,2}ã€‚ å‡è®¾R3=3ï¼Œåˆ™è·å®˜ä¾æ¬¡é”€å»äº†1, 2, 1ï¼Œå†å°†2 å‘ç»™äº†ç©å®¶ã€‚ç›®å‰ç‰Œåº“ä»…å‰©ä¸‹ä¸€å¼ ç‰Œ1ã€‚ å‡è®¾R4=2ï¼Œè·å®˜åœ¨é‡å¤é”€å»ä¸¤æ¬¡1 ä¹‹åï¼Œè¿˜æ˜¯å°†1 å‘ç»™äº†ç©å®¶ï¼Œè¿™æ˜¯å› ä¸º1 æ˜¯ç‰Œåº“ä¸­å”¯ä¸€çš„ä¸€å¼ ç‰Œã€‚ splayé¢˜è§£ by wgyè¿™é“é¢˜è¿˜è›®ç®€å•çš„ï¼Œç”¨splayæ‰¾å‡º1-xçš„åŒºé—´ï¼Œç„¶åæŠŠå®ƒè½¬åˆ°åé¢å»ï¼Œå†åˆ é™¤ç¬¬ä¸€ä¸ªæ•°å°±å¥½äº† éœ€å¸æ°§ #pragma GCC optimize(2) #pragma GCC optimize(3) #pragma GCC optimize(&quot;Ofast&quot;) #pragma GCC optimize(&quot;inline&quot;) #pragma GCC optimize(&quot;-fgcse&quot;) #pragma GCC optimize(&quot;-fgcse-lm&quot;) #pragma GCC optimize(&quot;-fipa-sra&quot;) #pragma GCC optimize(&quot;-ftree-pre&quot;) #pragma GCC optimize(&quot;-ftree-vrp&quot;) #pragma GCC optimize(&quot;-fpeephole2&quot;) #pragma GCC optimize(&quot;-ffast-math&quot;) #pragma GCC optimize(&quot;-fsched-spec&quot;) #pragma GCC optimize(&quot;unroll-loops&quot;) #pragma GCC optimize(&quot;-falign-jumps&quot;) #pragma GCC optimize(&quot;-falign-loops&quot;) #pragma GCC optimize(&quot;-falign-labels&quot;) #pragma GCC optimize(&quot;-fdevirtualize&quot;) #pragma GCC optimize(&quot;-fcaller-saves&quot;) #pragma GCC optimize(&quot;-fcrossjumping&quot;) #pragma GCC optimize(&quot;-fthread-jumps&quot;) #pragma GCC optimize(&quot;-funroll-loops&quot;) #pragma GCC optimize(&quot;-fwhole-program&quot;) #pragma GCC optimize(&quot;-freorder-blocks&quot;) #pragma GCC optimize(&quot;-fschedule-insns&quot;) #pragma GCC optimize(&quot;inline-functions&quot;) #pragma GCC optimize(&quot;-ftree-tail-merge&quot;) #pragma GCC optimize(&quot;-fschedule-insns2&quot;) #pragma GCC optimize(&quot;-fstrict-aliasing&quot;) #pragma GCC optimize(&quot;-fstrict-overflow&quot;) #pragma GCC optimize(&quot;-falign-functions&quot;) #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;) #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;) #pragma GCC optimize(&quot;-fsched-interblock&quot;) #pragma GCC optimize(&quot;-fpartial-inlining&quot;) #pragma GCC optimize(&quot;no-stack-protector&quot;) #pragma GCC optimize(&quot;-freorder-functions&quot;) #pragma GCC optimize(&quot;-findirect-inlining&quot;) #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;) #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;) #pragma GCC optimize(&quot;inline-small-functions&quot;) #pragma GCC optimize(&quot;-finline-small-functions&quot;) #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;) #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;) #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;) #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;) #pragma GCC optimize(&quot;inline-functions-called-once&quot;) #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;) #pragma GCC optimize(2) #pragma GCC optimize(3) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;cctype&gt; #define mid (l + r &gt;&gt; 1) using namespace std; const int SIZE = 7e5 + 5; struct SPLAY { int siz; int val; int ch[2]; int fa; } T[SIZE]; int root, n, R[SIZE], tot; template &lt; typename T &gt; inline void read ( T &amp;a ) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T &gt; inline T read ( T _checkType, bool _Typeflag ) { T f = 1, a = 0; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } template &lt; typename T &gt; inline void write ( T x, char end_, int st = 0 ) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10, end_, st + 1); putchar(x % 10 + &#39;0&#39;); if (!st) putchar(end_); } inline void update(int u) { T[u].siz = T[T[u].ch[0]].siz + T[T[u].ch[1]].siz + 1; } inline int make(int l, int r, int fa) { int u = ++tot; T[u].siz = 1; T[u].val = mid; T[u].ch[0] = T[u].ch[1] = 0; T[u].fa = fa; if (mid &gt; l) T[u].ch[0] = make(l, mid - 1, u); if (mid &lt; r) T[u].ch[1] = make(mid + 1, r, u); update(u); return u; } inline void rotate(int x) { int y = T[x].fa; int z = T[y].fa; int w = T[y].ch[1] == x; T[z].ch[T[z].ch[1] == y] = x; T[x].fa = z; T[y].ch[w] = T[x].ch[w ^ 1]; T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int goal) { for (; T[x].fa ^ goal; rotate(x)) { int y = T[x].fa; int z = T[y].fa; if (z ^ goal) T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y); } if (!goal) root = x; } inline int getRank(int x) { int u = root; while (233) { if (x &lt;= T[T[u].ch[0]].siz) u = T[u].ch[0]; else { x -= T[T[u].ch[0]].siz + 1; if (!x) return u; u = T[u].ch[1]; } } } inline int getcard(int x) { if (x) { splay(getRank(x), 0); int u = root; root = T[u].ch[1]; T[root].fa = 0; T[u].ch[1] = 0; update(u); splay(getRank(T[root].siz), 0); if (u) T[u].fa = root; if (root) T[root].ch[1] = u, update(root); } int ranker = getRank(1); int res = T[ranker].val; splay(ranker, 0); if (T[ranker].ch[1]) T[root = T[ranker].ch[1]].fa = 0; return res; } signed main() { read(n); root = make(1, n, 0); for (int i = 1; i &lt;= n; ++i) { read(R[i]); write(getcard(R[i] % T[root].siz), &#39;\\n&#39;); } return 0; } æƒå€¼çº¿æ®µæ ‘é¢˜è§£ by lyc:å¯¹äºè¿™é“é¢˜ï¼Œå¹³è¡¡æ ‘ å¸¸æ•°å¤ªå¤§ ä¸å¼€O2åŸºæœ¬éƒ½ä¼šè¶…æ—¶ã€‚ æ‰€ä»¥æˆ‘ä»¬ç”¨å¸¸æ•°æ›´å°ä¸€äº›çš„çº¿æ®µæ ‘æ¥è§£å†³è¿™é“é¢˜ã€‚ é¦–å…ˆï¼Œè¿™é“é¢˜æœ‰7e5å¼ ç‰Œï¼Œæˆ‘ä»¬é‡‡ç”¨æƒå€¼çº¿æ®µæ ‘çš„åšæ³•ï¼Œæ¯ä¸ªèŠ‚ç‚¹è®°å½•å®ƒå¯¹åº”çš„åŒºé—´è¿˜å‰©å¤šå°‘å¼ ç‰Œã€‚é‚£ä¹ˆå»ºæ ‘æ“ä½œå°±å¾ˆæ˜¾ç„¶äº†å¯¹å§ ç„¶åæˆ‘ä»¬è€ƒè™‘é”€ç‰Œæ“ä½œï¼Œç”±äºé”€ç‰Œåæ•´ä¸ªåºåˆ—ä¾æ—§æŒ‰ä»å°åˆ°å¤§æœ‰åºï¼ˆ1ï¼Œ2ï¼Œ3ï¼Œ4 -&gt;1ï¼Œ3ï¼Œ4ï¼‰ï¼Œæˆ‘ä»¬è®¾å®šä¸€ä¸ªæŒ‡é’ˆnowï¼ŒæŒ‡å‘å½“å‰ç‰Œå †é‡Œçš„æœ€åä¸€å¼ ç‰Œåœ¨ç›®å‰ç‰Œå †ä¸­å¤§å°çš„æ’åï¼Œåˆå§‹ä¸º0ï¼ˆn%nï¼‰ï¼Œæ¯æ¬¡é”€æ‰aå¼ ç‰Œï¼Œæˆ‘ä»¬å°±å°†nowå‘å³ç§»aä½ï¼Œä½¿å®ƒæŒ‡å‘é”€å®Œç‰Œåç‰Œå †é‡Œçš„æœ€åä¸€å¼ ï¼Œå†å°†nowåŠ ä¸€ï¼Œå¾—åˆ°å½“å‰æ’é˜Ÿé¡¶çš„ç‰Œåœ¨ç‰Œå †ä¸­çš„æ’åï¼Œæ ¹æ®å®šä¹‰ï¼Œåœ¨æƒå€¼çº¿æ®µæ ‘ä¸­æŸ¥æ‰¾ç¬¬nowä¸ªè¿˜å­˜åœ¨çš„æ•°å°±å¾—åˆ°äº†è¿™æ¬¡åˆ å»çš„ç‰Œçš„ç¼–å·ã€‚è¾“å‡ºåè¿˜è¦è®°å¾—æŠŠè¿™å¼ ç‰Œåœ¨æƒå€¼çº¿æ®µæ ‘ä¸­åˆ æ‰ï¼Œå†æŠŠnowå‡ä¸€ï¼Œä½¿å®ƒé‡æ–°æŒ‡å‘ç‰Œå †é‡Œçš„æœ€åä¸€å¼ ç‰Œã€‚ ä»£ç ï¼š #include&lt;cstdio&gt; int n,nodes[80000010],now,a; void writing(int x) { if(!x) return; writing(x/10); putchar((x%10)+&#39;0&#39;); } void read(int &amp;hhh) { int x=0; char c=getchar(); while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)) c=getchar(); x=c^&#39;0&#39;; c=getchar(); while((c&lt;=&#39;9&#39;)&amp;(c&gt;=&#39;0&#39;)) { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^&#39;0&#39;); c=getchar(); } hhh=x; } void build(int l,int r,int x) { if(l==r) nodes[x]=1; else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=r-l+1; } } int kth(int l,int r,int x,int val) { if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1]) return kth(l,mid,x&lt;&lt;1,val); else return kth(mid+1,r,(x&lt;&lt;1)+1,val-nodes[x&lt;&lt;1]); } else return l; } void del(int l,int r,int x,int val) { --nodes[x]; if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=mid) del(l,mid,x&lt;&lt;1,val); else del(mid+1,r,(x&lt;&lt;1)+1,val); } } int main() { read(n); build(1,n,1); for(int i=n;i;--i) { read(a); now=(now+a)%i+1; int cur=kth(1,n,1,now); writing(cur); putchar(&#39;\\n&#39;); del(1,n,1,cur); --now; } return 0; } 3.æ•°åˆ—åˆ†å—å…¥é—¨ 8ç»™å‡ºä¸€ä¸ªé•¿ä¸º $n$ çš„æ•°åˆ—ï¼Œä»¥åŠ $n$ ä¸ªæ“ä½œï¼Œæ“ä½œæ¶‰åŠåŒºé—´è¯¢é—®ç­‰äºä¸€ä¸ªæ•° $c$ çš„å…ƒç´ ï¼Œå¹¶å°†è¿™ä¸ªåŒºé—´çš„æ‰€æœ‰å…ƒç´ æ”¹ä¸º $c$ã€‚ æœ¬é¢˜çš„é‡ç‚¹åœ¨äºå¹¶å°†è¿™ä¸ªåŒºé—´çš„æ‰€æœ‰å…ƒç´ æ”¹ä¸ºc åŒºé—´æ¨å¹³æ“ä½œï¼ æœ‰äº†åŒºé—´æ¨å¹³ï¼Œæˆ‘ä»¬ç¬¬ä¸€æ—¶é—´ä¼šæƒ³åˆ°ä»€ä¹ˆï¼Ÿçº¿æ®µæ ‘|åˆ†å—ï¼Ÿ ODTï¼ï¼ï¼ï¼ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;cctype&gt; #include &lt;utility&gt; #include &lt;set&gt; #define IT set&lt;TreeNode&gt;::iterator using namespace std; inline int getInt() { int a = 0, f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } inline void outInt(int x) { char buffer[20]; int length = 0; bool minus = x &lt; 0; if (minus) x = -x; do { buffer[length++] = x % 10 + &#39;0&#39;; x /= 10; } while (x); if (minus) buffer[length++] = &#39;-&#39;; do { putchar(buffer[--length]); } while (length); } struct TreeNode { int lef; int rig; mutable int val; TreeNode(int l, int r = -1, int v = 0) : lef(l), rig(r), val(v) {} friend bool operator &lt; (const TreeNode &amp;rhs) const { return lef &lt; rhs.lef; } } ; set&lt;TreeNode&gt; st; int n = getInt(); inline IT split(int pos) { IT it = st.lower_bound(TreeNode(pos)); if (it != st.end() &amp;&amp; it-&gt;lef == pos) return it; it--; int l = it-&gt;lef, r = it-&gt;rig; int v = it-&gt;val; st.erase(it); st.insert(TreeNode(l, pos - 1, v)); return st.insert(TreeNode(pos, r, v)).first; } inline void assign(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); st.erase(itl, itr); st.insert(TreeNode(l, r, v)); } inline int query(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); int res = 0; for (; itl != itr; ++itl) res += (itl-&gt;rig - itl-&gt;lef + 1) * (itl-&gt;val == v); return res; } signed main() { for (int i = 1; i &lt;= n; ++i) { int x = getInt(); st.insert(TreeNode(i, i, x)); } for (int i = 1; i &lt;= n; ++i) { int l = getInt(); int r = getInt(); int v = getInt(); printf(&quot;%d\\n&quot;, query(l, r, v)); assign(l, r, v); } return 0; } 4.SP3267 DQUERY - D-query$Given$ $a$ $sequence$ $of$ $n$ $numbers$ $and$ $a$ $number$ $of$ $d-queries.$ $A$ $d-query$ $is$ $a$ $pair$ $(i,$ $j)$ $(1$ $â‰¤$ $i$ $â‰¤$ $j$ $â‰¤$ $n).$ $For$ $each$ $d-query$ $(i,$ $j),$ $you$ $have$ $to$ $return$ $the$ $number$ $of$ $distinct$ $elements$ $in$ $the$ $subsequence$ $a_i$,$a_{i+1},\\cdots,a_j$ è¿™é“é¢˜çš„æ ‘çŠ¶æ•°ç»„çš„åšæ³•æ˜¯ç¦»çº¿çš„ã€‚ é¦–å…ˆæŒ‰è¯¢é—®çš„å³ç«¯ç‚¹æ’åºï¼Œç„¶åç”¨æ ‘çŠ¶æ•°ç»„æŠŠæ²¡æœ‰å‡ºç°è¿‡çš„å€¼åŠ ä¸Šå»ï¼ŒæŠŠå‡ºç°è¿‡çš„å‡å»ï¼Œæœ€åç»Ÿè®¡ç­”æ¡ˆå³å¯ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; const int SIZE = 1e6 + 5; int n, m, tree[SIZE], ans[SIZE]; int list[SIZE], tag[SIZE]; pair &lt; pair &lt; int , int &gt; , int &gt; st[SIZE]; inline bool _rule(pair &lt; pair &lt; int , int &gt; , int &gt; x, pair &lt; pair &lt; int , int &gt; , int &gt; y) { return x.first.second &lt; y.first.second; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;list[i]); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;st[i].first.first, &amp;st[i].first.second), st[i].second = i; sort(st + 1, st + 1 + m, _rule); int zblyc = 1; for (int i = 1; i &lt;= m; ++i) { for (int j = zblyc; j &lt;= st[i].first.second; ++j) { if (tag[list[j]]) for (int x = tag[list[j]]; x &lt;= n; x += x &amp; -x) tree[x]--; tag[list[j]] = j; for (int x = j; x &lt;= n; x += x &amp; -x) tree[x]++; } zblyc = st[i].first.second + 1; int lef = 0, rig = 0; for (int x = st[i].first.second; x; x -= x &amp; -x) rig += tree[x]; for (int x = st[i].first.first - 1; x; x -= x &amp; -x) lef += tree[x]; ans[st[i].second] = rig - lef; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 5.P1231 æ•™è¾…çš„ç»„æˆæ³¨ï¼šæœ¬é¢˜æˆ‘å·²æ¬è¿åˆ°OJï¼Œæ•°æ®å·²ç»é½å…¨ï¼Œç•¥å¡æ—¶é—´å’Œç©ºé—´ï¼Œä½†å‡åœ¨åˆç†èŒƒå›´ï¼Œæˆ‘çš„ä»£ç å·²é€šè¿‡ï¼Œè¯·æ±‚å…¬å¼€ Link è’Ÿè’»HansBugåœ¨ä¸€æœ¬è¯­æ–‡ä¹¦é‡Œé¢å‘ç°äº†ä¸€æœ¬ç­”æ¡ˆï¼Œç„¶è€Œä»–å´æ˜æ˜è®°å¾—è¿™ä¹¦åº”è¯¥è¿˜åŒ…å«ä¸€ä»½ç»ƒä¹ é¢˜ã€‚ ç„¶è€Œå‡ºç°åœ¨ä»–çœ¼å‰çš„ä¹¦å¤šå¾—æ•°ä¸èƒœæ•°ï¼Œå…¶ä¸­æœ‰ä¹¦ï¼Œæœ‰ç­”æ¡ˆï¼Œæœ‰ç»ƒä¹ å†Œã€‚å·²çŸ¥ä¸€ä¸ªå®Œæ•´çš„ä¹¦å†Œå‡åº”è¯¥åŒ…å«ä¸”ä»…åŒ…å«ä¸€æœ¬ä¹¦ã€ä¸€æœ¬ç»ƒä¹ å†Œå’Œä¸€ä»½ç­”æ¡ˆï¼Œç„¶è€Œç°åœ¨å…¨éƒ½ä¹±åšäº†ä¸€å›¢ã€‚ è®¸å¤šä¹¦ä¸Šé¢çš„å­—è¿¹éƒ½å·²ç»æ¨¡ç³Šäº†ï¼Œç„¶è€ŒHansBugè¿˜æ˜¯å¯ä»¥å¤§è‡´åˆ¤æ–­è¿™æ˜¯ä¸€æœ¬ä¹¦è¿˜æ˜¯ç»ƒä¹ å†Œæˆ–ç­”æ¡ˆï¼Œå¹¶ä¸”èƒ½å¤Ÿå¤§è‡´çŸ¥é“ä¸€æœ¬ä¹¦å’Œç­”æ¡ˆä»¥åŠä¸€æœ¬ä¹¦å’Œç»ƒä¹ å†Œçš„å¯¹åº”å…³ç³»ï¼ˆå³ä»…ä»…çŸ¥é“æŸä¹¦å’ŒæŸç­”æ¡ˆã€æŸä¹¦å’ŒæŸç»ƒä¹ å†Œæœ‰å¯èƒ½ç›¸å¯¹åº”ï¼Œé™¤æ­¤ä»¥å¤–çš„å‡ä¸å¯èƒ½å¯¹åº”ï¼‰ã€‚ æ—¢ç„¶å¦‚æ­¤ï¼ŒHansBugæƒ³çŸ¥é“åœ¨è¿™æ ·çš„æƒ…å†µä¸‹ï¼Œæœ€å¤šå¯èƒ½åŒæ—¶ç»„åˆæˆå¤šå°‘ä¸ªå®Œæ•´çš„ä¹¦å†Œã€‚ è™½ç„¶è¿™å¹¶ä¸æ˜¯æ•°æ®ç»“æ„çš„é¢˜ï¼Œä½†æˆ‘è§‰å¾—æ¬ä¸Šæ¥ä¹Ÿä¸é”™ï¼Œæ¯•ç«Ÿç½‘ç»œæµæ˜¯ä¸ªå¥½ä¸œè¥¿ã€‚ è¿™é“é¢˜æˆ‘è‡ªå·±ç äº†åŠå¤©REç»“æœçœ‹äº†Siyuançš„é¢˜è§£åæ‰å‘ç°æˆ‘add_edgeä¼ å‚ä¼ é”™äº†ã€‚è¯è¯´ä¸ºä»€ä¹ˆä¼ å‚é”™ä¼šRE å¤§æ¦‚è®²ä¸€ä¸‹è¿™é“é¢˜çš„æ€è·¯å§ çœ‹åˆ°é¢˜ç›®å¾ˆå®¹æ˜“æƒ³åˆ°è·‘è´¹ç”¨æµäºŒåˆ†å›¾åŒ¹é…ï¼Œä½†è¿™é“é¢˜ä¸è¡Œã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ å› ä¸ºä»–æœ‰ä¸‰ä¸ªéƒ¨åˆ† é‚£ä¹ˆç›´æ¥è·‘æœ€å¤§æµå§ï¼ ä½†è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯ä¸€æœ¬ä¹¦ä½œä¸ºä¸­é—´çš„éƒ¨åˆ†æœ‰å¯èƒ½ä¼šè¢«é‡å¤åˆ©ç”¨ç»¿è‰²äº§å“ Siyuanæ›¾ç»è¿™æ ·è¯´é“ï¼š å› æ­¤æˆ‘ä»¬å°±è¦å¼•å…¥æ‹†ç‚¹çš„æ€æƒ³ã€‚æˆ‘ä»¬çš„ç›®çš„æ˜¯ï¼šå³ä½¿ä¸€æœ¬ä¹¦ä¸å¤šä¸ªè”ç³»å†Œæœ‰å…³ç³»ï¼Œå®ƒæµå‡ºçš„æµé‡ä¹Ÿåªèƒ½æ˜¯ 1ã€‚æ‰€ä»¥æˆ‘ä»¬æŠŠæ¯ä¸ªä»£è¡¨ä¹¦çš„ç‚¹æ‹†æˆå·¦å³ä¸¤ä¸ªç‚¹ï¼Œå·¦è¾¹çš„ç‚¹å’Œç»ƒä¹ å†Œè¿è¾¹ï¼Œå³è¾¹çš„ç‚¹å’Œç­”æ¡ˆè¿è¾¹ï¼›å½“ç„¶å·¦å³å¯¹åº”ç‚¹ä¹Ÿè¦è¿ä¸€æ¡å®¹é‡ä¸º 1 çš„è¾¹ æœ‰äº†æ‹†ç‚¹çš„æ€æƒ³æˆ‘ä»¬å°±å¯ä»¥ç›´æ¥è·‘æœ€å¤§æµå•¦! #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE_N = 4e6 + 5; const int SIZE_M = 1e6 + 5; const int INF = 1 &lt;&lt; 30; int n1, n2, n3, m, tot = 1, s, t; int path[SIZE_N], ter[SIZE_M]; int head[SIZE_N], edge[SIZE_M]; int _next[SIZE_N], ver[SIZE_M]; int depth[SIZE_N], cur[SIZE_N]; inline int getid(int p, int x) { switch (p) { case 1: return x; case 2: return n2 + x; case 3: return n2 + n1 + x; case 4: return n2 + (n1 &lt;&lt; 1) + x; } } inline void add_edge(int from, int to, int dis) { ver[++tot] = to, edge[tot] = dis, _next[tot] = head[from], head[from] = tot; } inline int bfs() { memset(depth, 0, sizeof depth); memcpy(cur, head, sizeof head); queue &lt; int &gt; Q; Q.push(s), depth[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = head[x]; i; i = _next[i]) { if (!depth[ver[i]] &amp;&amp; edge[i]) depth[ver[i]] = depth[x] + 1, Q.push(ver[i]); } } return depth[t]; } inline int dfs(int x, int flow) { if (x == t) return flow; int res = 0; for (int i = cur[x]; i &amp;&amp; res &lt; flow; i = _next[i]) { cur[x] = i; if (depth[ver[i]] == depth[x] + 1 &amp;&amp; edge[i]) { int tmp = dfs(ver[i], min(edge[i], flow - res)); if (tmp) edge[i] -= tmp, edge[i ^ 1] += tmp, res += tmp; } } if (res &lt; flow) depth[x] = -1; return res; } inline int dinic() { int res = 0; for (int x; bfs(); ) while (x = dfs(s, INF)) res += x; return res; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n1, &amp;n2, &amp;n3); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(1, to), getid(2, from), 1); add_edge(getid(2, from), getid(1, to), 0); } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(3, from), getid(4, to), 1); add_edge(getid(4, to), getid(3, from), 0); } for (int i = 1; i &lt;= n1; ++i) add_edge(getid(2, i), getid(3, i), 1), add_edge(getid(3, i), getid(2, i), 0); s = 0, t = (n1 &lt;&lt; 1) + n2 + n3 + 1; for (int i = 1; i &lt;= n2; ++i) add_edge(s, getid(1, i), 1), add_edge(getid(1, i), s, 0); for (int i = 1; i &lt;= n3; ++i) add_edge(getid(4, i), t, 1), add_edge(t, getid(4, i), 0); printf(&quot;%d\\n&quot;, dinic()); return 0; } 6.[USACO12OPEN]ä¹¦æ¶Bookshelfå½“å†œå¤«çº¦ç¿°é—²çš„æ²¡äº‹å¹²çš„æ—¶å€™ï¼Œä»–å–œæ¬¢åä¸‹æ¥çœ‹ä¹¦ã€‚å¤šå¹´è¿‡å»ï¼Œä»–å·²ç»æ”¶é›†äº† N æœ¬ä¹¦ (1 &lt;= N &lt;= 100,000)ï¼Œ ä»–æƒ³é€ ä¸€ä¸ªæ–°çš„ä¹¦æ¶æ¥è£…æ‰€æœ‰ä¹¦ã€‚ æ¯æœ¬ä¹¦ i éƒ½æœ‰å®½åº¦ W(i) å’Œé«˜åº¦ H(i)ã€‚ä¹¦éœ€è¦æŒ‰é¡ºåºæ·»åŠ åˆ°ä¸€ç»„ä¹¦æ¶ä¸Šï¼›æ¯”å¦‚è¯´ï¼Œç¬¬ä¸€å±‚æ¶å­åº”è¯¥åŒ…å«ä¹¦ç±1 â€¦ kï¼Œç¬¬äºŒå±‚æ¶å­åº”è¯¥ä»¥ç¬¬k + 1æœ¬ä¹¦å¼€å§‹ï¼Œä»¥ä¸‹å¦‚æ­¤ã€‚æ¯å±‚æ¶å­çš„æ€»å®½åº¦æœ€å¤§ä¸ºLï¼ˆ1â‰¤Lâ‰¤1,000,000,000ï¼‰ã€‚æ¯å±‚çš„é«˜åº¦ç­‰äºè¯¥å±‚ä¸Šæœ€é«˜çš„ä¹¦çš„é«˜åº¦ï¼Œå¹¶ä¸”æ•´ä¸ªä¹¦æ¶çš„é«˜åº¦æ˜¯æ‰€æœ‰å±‚çš„é«˜åº¦çš„æ€»å’Œï¼Œå› ä¸ºå®ƒä»¬éƒ½å‚ç›´å †å ã€‚ è¯·å¸®åŠ©å†œå¤«çº¦ç¿°è®¡ç®—æ•´ä¸ªä¹¦æ¶çš„æœ€å°å¯èƒ½é«˜åº¦ã€‚ æœ‰N(1 &lt;= N &lt;= 100000)æœ¬ä¹¦ï¼Œæ¯æœ¬ä¹¦æœ‰ä¸€ä¸ªå®½åº¦W(i)ï¼Œé«˜åº¦H(i)ï¼Œ(1 &lt;= H(i) &lt;= 1,000,000; 1 &lt;= W(i) &lt;= L)ã€‚ ç°åœ¨æœ‰è¶³å¤Ÿå¤šçš„ä¹¦æ¶ï¼Œä¹¦æ¶å®½åº¦æœ€å¤šæ˜¯L (1 &lt;= L &lt;= 1,000,000,000)ï¼ŒæŠŠä¹¦æŒ‰é¡ºåºï¼ˆå…ˆæ”¾1ï¼Œå†æ”¾2â€¦..ï¼‰æ”¾å…¥ä¹¦æ¶ã€‚æŸä¸ªä¹¦æ¶çš„é«˜åº¦æ˜¯è¯¥ä¹¦æ¶ä¸­æ‰€æ”¾çš„æœ€é«˜çš„ä¹¦çš„é«˜åº¦ã€‚ å°†æ‰€æœ‰ä¹¦æ”¾å…¥ä¹¦æ¶åï¼Œæ±‚æ‰€æœ‰ä¹¦æ¶çš„é«˜åº¦å’Œçš„æœ€å°å€¼ï¼Ÿ é¦–å…ˆè€ƒè™‘$O(N^2)$çš„æš´åŠ›DPï¼Œå¾ˆå¥½å†™å‡ºä»¥ä¸‹çš„è½¬ç§»æ–¹ç¨‹ï¼š F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))å…¶ä¸­æ»¡è¶³ W_{j+1},W_{j+2},\\cdots,W_i\\le Lä¸éš¾å‘ç°$W$çš„é™åˆ¶æ»¡è¶³å•è°ƒæ€§ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡äºŒåˆ†å¾—åˆ° ä¹Ÿå°±æ˜¯è¯´ F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))æ»¡è¶³ left_i\\le jæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”¨çº¿æ®µæ ‘ä¼˜åŒ–ï¼Œç»´æŠ¤åŒºé—´èµ‹å€¼ï¼ŒåŒºé—´æœ€å°å€¼ï¼Œå•ç‚¹ä¿®æ”¹ä¸‰ä¸ªæ“ä½œã€‚ ä½†è¿™æ ·è¿˜ä¸å¤Ÿï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¼€ä¸€ä¸ªå•è°ƒæ ˆï¼Œå½“ç„¶å•è°ƒé˜Ÿåˆ—ä¹Ÿå¯ä»¥(ä¸è¿‡æˆ‘æ‡’) æšä¸¾æ¯ä¸€ä¸ªä½ç½®ç„¶åæ‰¾å‡ºç¬¬ä¸€ä¸ªå¤§äº$H_i$çš„ä½ç½®$lef$ï¼Œå°†$[lef+1,i]$è¿™æ®µåŒºé—´çš„å€¼èµ‹ä¸º$H_i$ è¿›è€Œå¯ä»¥å‘ç°æˆ‘ä»¬åªéœ€è¦æ¯æ¬¡åŒºé—´ä¿®æ”¹$H$çš„å€¼ï¼ŒæŸ¥è¯¢ç›´æ¥åœ¨è¿™ä¸€æ®µåŒºé—´æŸ¥è¯¢å°±å¥½äº† #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) using namespace std; typedef long long ull; const int SIZE = 100000 + 5; const ull INF = 1e18; stack &lt; ull &gt; S; ull n, limit, W[SIZE], H[SIZE], pre[SIZE]; ull list[SIZE], dp[SIZE], val[SIZE &lt;&lt; 2]; ull minval[SIZE &lt;&lt; 2], flag[SIZE &lt;&lt; 2]; inline void make(int k, int l, int r) { minval[k] = val[k] = flag[k] = INF; if (l ^ r) make(lson, l, mid), make(rson, mid + 1, r); } inline void push(int k) { if (flag[k] ^ INF) { minval[lson] = val[lson] + flag[k]; minval[rson] = val[rson] + flag[k]; flag[lson] = flag[rson] = flag[k]; flag[k] = INF; } } inline int update(int k, int l, int r, int x, int y, int v) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k] = val[k] + v, flag[k] = v, 0; push(k); if (mid &gt;= x) update(lson, l, mid, x, y, v); if (mid &lt; y) update(rson, mid + 1, r, x, y, v); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); return 0; } inline void modify(int k, int l, int r, int x) { if (l ^ r) { push(k); if (mid &gt;= x) modify(lson, l, mid, x); else modify(rson, mid + 1, r, x); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); } else minval[k] = INF, val[k] = dp[l - 1]; } inline ull query(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k]; push(k); ull res = INF; if (mid &gt;= x) res = min(res, query(lson, l, mid, x, y)); if (mid &lt; y) res = min(res, query(rson, mid + 1, r, x, y)); return res; } signed main() { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;limit); make(1, 1, n); S.push(1); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld %lld&quot;, &amp;H[i], &amp;W[i]), list[i] = list[i - 1] + W[i]; for (int i = 2; i &lt;= n; ++i) { while (S.size() &amp;&amp; H[i] &gt; H[S.top()]) S.pop(); if (S.size()) pre[i] = S.top(); S.push(i); } for (int i = 1; i &lt;= n; ++i) { modify(1, 1, n, i); if (pre[i] + 1 &lt;= i) update(1, 1, n, pre[i] + 1, i, H[i]); int lef = lower_bound(list, list + 1 + i, list[i] - limit) - list; if (lef &lt; i) dp[i] = query(1, 1, n, lef + 1, i); } printf(&quot;%lld\\n&quot;, dp[n]); return 0; } 7.P1110 [ZJOI2007]æŠ¥è¡¨ç»Ÿè®¡Qçš„å¦ˆå¦ˆæ˜¯ä¸€ä¸ªå‡ºçº³ï¼Œç»å¸¸éœ€è¦åšä¸€äº›ç»Ÿè®¡æŠ¥è¡¨çš„å·¥ä½œã€‚ä»Šå¤©æ˜¯å¦ˆå¦ˆçš„ç”Ÿæ—¥ï¼Œå°Qå¸Œæœ›å¯ä»¥å¸®å¦ˆå¦ˆåˆ†æ‹…ä¸€äº›å·¥ä½œï¼Œä½œä¸ºå¥¹çš„ç”Ÿæ—¥ç¤¼ç‰©ä¹‹ä¸€ã€‚ ç»è¿‡ä»”ç»†è§‚å¯Ÿï¼Œå°Qå‘ç°ç»Ÿè®¡ä¸€å¼ æŠ¥è¡¨å®é™…ä¸Šæ˜¯ç»´æŠ¤ä¸€ä¸ªéè´Ÿæ•´æ•°æ•°åˆ—ï¼Œå¹¶ä¸”è¿›è¡Œä¸€äº›æŸ¥è¯¢æ“ä½œã€‚ åœ¨æœ€å¼€å§‹çš„æ—¶å€™ï¼Œæœ‰ä¸€ä¸ªé•¿åº¦ä¸ºNçš„æ•´æ•°åºåˆ—ï¼Œå¹¶ä¸”æœ‰ä»¥ä¸‹ä¸‰ç§æ“ä½œï¼š INSERT i kï¼šåœ¨åŸæ•°åˆ—çš„ç¬¬iä¸ªå…ƒç´ åé¢æ·»åŠ ä¸€ä¸ªæ–°å…ƒç´ kkï¼›å¦‚æœåŸæ•°åˆ—çš„ç¬¬iiä¸ªå…ƒç´ å·²ç»æ·»åŠ äº†è‹¥å¹²å…ƒç´ ï¼Œåˆ™æ·»åŠ åœ¨è¿™äº›å…ƒç´ çš„æœ€åï¼ˆè§ä¸‹é¢çš„ä¾‹å­ï¼‰MIN_GAPï¼šæŸ¥è¯¢ç›¸é‚»ä¸¤ä¸ªå…ƒç´ çš„ä¹‹é—´å·®å€¼ï¼ˆç»å¯¹å€¼ï¼‰çš„æœ€å°å€¼MIN_SORT_GAPï¼šæŸ¥è¯¢æ‰€æœ‰å…ƒç´ ä¸­æœ€æ¥è¿‘çš„ä¸¤ä¸ªå…ƒç´ çš„å·®å€¼ï¼ˆç»å¯¹å€¼ï¼‰ä¾‹å¦‚ä¸€å¼€å§‹çš„åºåˆ—ä¸º5, 3, 15,3,1ã€‚ æ‰§è¡Œæ“ä½œINSERT 2 9å°†å¾—åˆ°ï¼š5, 3, 9, 15,3,9,1ï¼Œæ­¤æ—¶MIN_GAPä¸º22ï¼ŒMIN_SORT_GAPä¸º22ã€‚ å†æ‰§è¡Œæ“ä½œINSERT 2 6å°†å¾—åˆ°ï¼š5, 3, 9, 6, 15,3,9,6,1 æ³¨æ„è¿™ä¸ªæ—¶å€™åŸåºåˆ—çš„ç¬¬22ä¸ªå…ƒç´ åé¢å·²ç»æ·»åŠ äº†ä¸€ä¸ª99ï¼Œæ­¤æ—¶æ·»åŠ çš„66åº”åŠ åœ¨99çš„åé¢ã€‚è¿™ä¸ªæ—¶å€™MIN_GAPä¸º22ï¼ŒMIN_SORT_GAPä¸º11ã€‚ äºæ˜¯å°Qå†™äº†ä¸€ä¸ªç¨‹åºï¼Œä½¿å¾—ç¨‹åºå¯ä»¥è‡ªåŠ¨å®Œæˆè¿™äº›æ“ä½œï¼Œä½†æ˜¯ä»–å‘ç°å¯¹äºä¸€äº›å¤§çš„æŠ¥è¡¨ä»–çš„ç¨‹åºè¿è¡Œå¾—å¾ˆæ…¢ï¼Œä½ èƒ½å¸®åŠ©ä»–æ”¹è¿›ç¨‹åºä¹ˆï¼Ÿ å¾…å‘ï¼Œå…ˆç•™ç€ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define sgt_mid ((SGT[k].l + SGT[k].r) &gt;&gt; 1) #define mid ((l + r) &gt;&gt; 1) #define U int k, int l, int r #define H int k, int x, int val #define transfer SGT[k].val = min(SGT[lson].val, SGT[rson].val) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) #define LRE lson, l, mid #define RRE rson, mid + 1, r #define LWA lson, x, val #define RWA rson, x, val #define int long long using namespace std; const int SIZE = 500000 + 5; const int INF = 0x7fffffff; int a[SIZE], b[SIZE], root; int n, m, tot, MIN_GAP, MIN_SORT_GAP; struct SPLAY { int ch[2]; int val; int fa; } SBT[SIZE]; struct TREE { int l; int r; int val; } SGT[SIZE]; template &lt; typename T &gt; inline T ads(T x) { return x &gt; 0 ? x : -x; } /*****************SplayArea*****************/ inline void rotate(int x) { int y = SBT[x].fa; int z = SBT[y].fa; int w = SBT[y].ch[1] == x; SBT[z].ch[SBT[z].ch[1] == y] = x; SBT[x].fa = z; SBT[y].ch[w] = SBT[x].ch[w ^ 1]; SBT[SBT[x].ch[w ^ 1]].fa = y; SBT[x].ch[w ^ 1] = y; SBT[y].fa = x; } inline void splay(int x, int goal) { for (; SBT[x].fa ^ goal; rotate(x)) { int y = SBT[x].fa; int z = SBT[y].fa; if (z ^ goal) SBT[z].ch[1] ^ y ^ SBT[y].ch[1] ^ x ? rotate(x) : rotate(y); } if (!goal) root = x; } inline void insert(int x) { int u = root, fa = 0; while (u &amp;&amp; SBT[u].val ^ x) fa = u, u = SBT[u].ch[x &gt; SBT[u].val]; if (u) return ; u = ++tot; SBT[u].fa = fa; if (fa) SBT[fa].ch[x &gt; SBT[fa].val] = u; SBT[u].val = x; splay(u, 0); } inline void find(int x) { int u = root; if (!u) return ; while (SBT[u].ch[x &gt; SBT[u].val] &amp;&amp; SBT[u].val ^ x) u = SBT[u].ch[x &gt; SBT[u].val]; splay(u, 0); } inline int next_(int x, int f) { find(x); int u = root; if (SBT[u].val == x) return SBT[u].val; if (SBT[u].val &lt; x &amp;&amp; !f) return SBT[u].val; if (SBT[u].val &gt; x &amp;&amp; f) return SBT[u].val; u = SBT[u].ch[f]; while (SBT[u].ch[f ^ 1]) u = SBT[u].ch[f ^ 1]; return SBT[u].val; } /*****************EndSplay*****************/ /*****************SegmentTreeArea*****************/ inline void make(U) { SGT[k].l = l, SGT[k].r = r; if (l ^ r) make(LRE), make(RRE), transfer; else SGT[k].val = ads(a[l] - a[l - 1]); } inline void modify(H) { if (SGT[k].l ^ SGT[k].r) if (sgt_mid &gt;= x) modify(LWA), transfer; else modify(RWA), transfer; else SGT[k].val = val; } /*****************EndSegmentTree*****************/ inline void Initialize() { MIN_GAP = INF, MIN_SORT_GAP = INF; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); insert(INF), insert(-INF); a[0] = INF, a[n + 1] = INF; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); if (i ^ 1) { int l_limit = next_(a[i], false), r_limit = next_(a[i], true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(l_limit - a[i]), ads(r_limit - a[i]))); } insert(a[i]); b[i] = a[i]; } make(1, 1, n); for (int i = 1; i &lt;= m; ++i) { char S[SIZE]; scanf(&quot;%s&quot;, S); if (*S == &#39;I&#39;) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); int l_limit = next_(y, false); int r_limit = next_(y, true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(y - l_limit), ads(y - r_limit))); insert(y); MIN_GAP = min(MIN_GAP, ads(b[x] - y)); modify(1, x + 1, ads(a[x + 1] - y)); b[x] = y; } else if (S[4] == &#39;G&#39;) printf(&quot;%d\\n&quot;, min(MIN_GAP, SGT[1].val)); else printf(&quot;%d\\n&quot;, MIN_SORT_GAP); } } signed main() { Initialize(); return 0; } 8.Link Cut Tree ï¼ˆåŠ¨æ€æ ‘ï¼‰ç»™å®š n ä¸ªç‚¹ä»¥åŠæ¯ä¸ªç‚¹çš„æƒå€¼ï¼Œè¦ä½ å¤„ç†æ¥ä¸‹æ¥çš„ m ä¸ªæ“ä½œã€‚æ“ä½œæœ‰å››ç§ï¼Œæ“ä½œä» 0 åˆ° 3 ç¼–å·ã€‚ç‚¹ä» 1 åˆ° n ç¼–å·ã€‚ 0 x y ä»£è¡¨è¯¢é—®ä» x åˆ° y çš„è·¯å¾„ä¸Šçš„ç‚¹çš„æƒå€¼çš„ xor å’Œã€‚ä¿è¯ x åˆ° y æ˜¯è”é€šçš„ã€‚ 1 x y ä»£è¡¨è¿æ¥ x åˆ° yï¼Œè‹¥ x åˆ° y å·²ç»è”é€šåˆ™æ— éœ€è¿æ¥ã€‚ 2 x y ä»£è¡¨åˆ é™¤è¾¹ (x,y)ï¼Œä¸ä¿è¯è¾¹ (x,y) å­˜åœ¨ã€‚ 3 x y ä»£è¡¨å°†ç‚¹ x ä¸Šçš„æƒå€¼å˜æˆ yã€‚ æ¨¡æ¿é¢˜æ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œæ”¾ä¸€ä¸‹ä»£ç å°±å¥½äº†ï¼Œå¦‚æœè¦å­¦LCTå¯ä»¥è‡ªå·±çœ‹åšå®¢(é¦–å…ˆè¦å­¦splay(not fhq-treap)) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; } // éœ€è¦233.cpp 9.P5227 [AHOI2013]è¿é€šå›¾ç»™å®šä¸€ä¸ªæ— å‘è¿é€šå›¾å’Œè‹¥å¹²ä¸ªå°é›†åˆï¼Œæ¯ä¸ªå°é›†åˆåŒ…å«ä¸€äº›è¾¹ï¼Œå¯¹äºæ¯ä¸ªé›†åˆï¼Œä½ éœ€è¦ç¡®å®šå°†é›†åˆä¸­çš„è¾¹åˆ æ‰åæ”¹å›¾æ˜¯å¦ä¿æŒè”é€šã€‚é›†åˆé—´çš„è¯¢é—®ç›¸äº’ç‹¬ç«‹ å®šä¹‰ä¸€ä¸ªå›¾ä¸ºè”é€šçš„å½“ä¸”ä»…å½“å¯¹äºä»»æ„çš„ä¸¤ä¸ªé¡¶ç‚¹ï¼Œéƒ½å­˜åœ¨ä¸€æ¡è·¯å¾„è¿æ¥å®ƒä»¬ æš´åŠ›LCTï¼Œç»´æŠ¤æŠŠæ—¶é—´å½“æˆæƒå€¼çš„æœ€å¤§ç”Ÿæˆæ ‘ å› ä¸ºæˆ‘ä»¬æ˜¯ç¦»çº¿ç®—æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—åˆ°æ¯ä¸€æ¡è¾¹çš„åˆ é™¤æ—¶é—´ é¡ºä¾¿ç»´æŠ¤ä¸€ä¸ªæƒå€¼æœ€å°çš„è¾¹çš„ç¼–å· %:include &lt;cstdio&gt; %:include &lt;iostream&gt; %:include &lt;algorithm&gt; %:include &lt;cstring&gt; %:include &lt;queue&gt; using namespace std; const int SIZE = 1e7 + 5; const int INF = 0x7fffffff; struct ReadNode &lt;% template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) &lt;% a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; %&gt; template &lt; typename T&gt; void write(T x) &lt;% if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); %&gt; template &lt; typename T&gt; void operator &lt;&lt; (T x) &lt;% write(x); %&gt; %&gt; win; int n, m; /******************LinkCutTree******************/ class LinkCutTree &lt;% public: struct TreeNode &lt;% int ch&lt;:2:&gt;; int fa; int val; int siz; int cnt; int miv; bool rev; %&gt; T&lt;:SIZE:&gt;; inline void exch(int &amp;x, int &amp;y) &lt;% x ^= y ^= x ^= y; %&gt; inline void push1(int x) &lt;% T&lt;:x:&gt;.siz = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.siz + T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz +T&lt;:x:&gt;.cnt + (x &lt;= n); x &gt; n &amp;&amp; (T&lt;:x:&gt;.miv = x); %&gt; inline void push2(int x) &lt;% (T&lt;:x:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv); (T&lt;:T&lt;:x:&gt;.miv:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv); %&gt; inline void transfer(int x) &lt;% push1(x); push2(x); %&gt; inline bool which(int x) &lt;% return T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; == x; %&gt; inline bool isroot(int x) &lt;% return (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:0:&gt; ^ x) &amp;&amp; (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; ^ x); %&gt; inline void rotate(int x) &lt;% int y = T&lt;:x:&gt;.fa, z = T&lt;:y:&gt;.fa, w = which(x), test = which(y), s = T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt;; (!isroot(y)) &amp;&amp; (T&lt;:z:&gt;.ch&lt;:test:&gt; = x); T&lt;:y:&gt;.ch&lt;:w:&gt; = s, T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt; = y; (s) &amp;&amp; (T&lt;:s:&gt;.fa = y); T&lt;:x:&gt;.fa = z, T&lt;:y:&gt;.fa = x; transfer(y); %&gt; inline void reverse(int x) &lt;% exch(T&lt;:x:&gt;.ch&lt;:0:&gt;, T&lt;:x:&gt;.ch&lt;:1:&gt;), T&lt;:x:&gt;.rev ^= 1; %&gt; inline void push_down(int x) &lt;% if (T&lt;:x:&gt;.rev) &lt;% if (T&lt;:x:&gt;.ch&lt;:0:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:0:&gt;); if (T&lt;:x:&gt;.ch&lt;:1:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:1:&gt;); T&lt;:x:&gt;.rev = 0; %&gt; %&gt; inline void push_up(int x) &lt;% (!isroot(x)) &amp;&amp; (push_up(T&lt;:x:&gt;.fa), 1); push_down(x); %&gt; inline void splay(int x) &lt;% push_up(x); for (; !isroot(x); rotate(x)) (!isroot(T&lt;:x:&gt;.fa)) &amp;&amp; ((which(x) == which(T&lt;:x:&gt;.fa) ? rotate(T&lt;:x:&gt;.fa) : rotate(x)), 1); transfer(x); %&gt; inline void access(int x) &lt;% for (int i = 0; x; x = T&lt;:i = x:&gt;.fa) splay(x), T&lt;:x:&gt;.cnt += T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz, T&lt;:x:&gt;.cnt -= T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt; = i:&gt;.siz, transfer(x); %&gt; inline void makeroot(int x) &lt;% access(x), splay(x), reverse(x); %&gt; inline void split(int x, int y) &lt;% makeroot(y), access(x), splay(x); %&gt; inline int getroot(int x) &lt;% access(x), splay(x), push_down(x); for (; T&lt;:x:&gt;.ch&lt;:0:&gt;; push_down(x = T&lt;:x:&gt;.ch&lt;:0:&gt;)); return splay(x), x; %&gt; inline void init(int length, int data) &lt;% for (int i = 0; i &lt;= length; ++i) T&lt;:i:&gt;.val = data; %&gt; inline void connect(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = x, T&lt;:x:&gt;.cnt += T&lt;:y:&gt;.siz, transfer(x); %&gt; inline void erase(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = T&lt;:x:&gt;.ch&lt;:0:&gt; = 0, transfer(x); %&gt; inline bool find() &lt;% return access(1), splay(1), (T&lt;:1:&gt;.siz == n); %&gt; %&gt; lct_mast; /*****************EndLinkCutTree*****************/ int now&lt;:SIZE:&gt;, num, ans&lt;:SIZE:&gt;, st&lt;:SIZE:&gt;, top; struct EdgeNode &lt;% int from; int to; int dis; %&gt; edge&lt;:SIZE:&gt;; struct LycNode &lt;% bool opt, tag; int idx; %&gt; H&lt;:SIZE:&gt;; signed main() &lt;% win &gt;&gt; n; win &gt;&gt; m; lct_mast.init(n, INF); for (int i = 1; i &lt;= m; ++i) &lt;% int x, y; win &gt;&gt; x; win &gt;&gt; y; edge&lt;:i:&gt; = &lt;%x, y%&gt;; now&lt;:i:&gt; = i; H&lt;:++num:&gt; = &lt;%1, 0, i%&gt;; %&gt; int k, tot = m; win &gt;&gt; k; for (int i = 1; i &lt;= k; ++i) &lt;% int x; win &gt;&gt; x; for (int j = 1; j &lt;= x; ++j) &lt;% int y; win &gt;&gt; y; edge&lt;:now&lt;:y:&gt;:&gt;.dis = i - 1; lct_mast.T&lt;:now&lt;:y:&gt; + n:&gt;.val = i - 1; H&lt;:++num:&gt; = &lt;%0, 0, now&lt;:y:&gt;%&gt;; edge&lt;:++tot:&gt;.from = edge&lt;:now&lt;:y:&gt;:&gt;.from; edge&lt;:tot:&gt;.to = edge&lt;:now&lt;:y:&gt;:&gt;.to; now&lt;:y:&gt; = tot; st&lt;:++top:&gt; = now&lt;:y:&gt;; %&gt; H&lt;:++num:&gt;.tag = true; if (i ^ k) while (top) H&lt;:++num:&gt; = &lt;%1, 0, st&lt;:top--:&gt;%&gt;; %&gt; for (int i = 1; i &lt;= m; ++i) if (!edge&lt;:now&lt;:i:&gt;:&gt;.dis) edge&lt;:now&lt;:i:&gt;:&gt;.dis = k, lct_mast.T&lt;:now&lt;:i:&gt; + n:&gt;.val = k; tot += n; for (int i = 1; i &lt;= tot; ++i) lct_mast.T&lt;:i:&gt;.siz = 1; for (int i = 1; i &lt;= num; ++i) &lt;% if (H&lt;:i:&gt;.tag) puts(lct_mast.find() ? &quot;Connected&quot; : &quot;Disconnected&quot;); else &lt;% int j = H&lt;:i:&gt;.idx, from = edge&lt;:j:&gt;.from; int to = edge&lt;:j:&gt;.to, dis = edge&lt;:j:&gt;.dis; lct_mast.makeroot(from); if (H&lt;:i:&gt;.opt) &lt;% if (lct_mast.getroot(to) == from) &lt;% int mix = lct_mast.T&lt;:from:&gt;.miv; if (lct_mast.T&lt;:mix:&gt;.val &gt;= dis) continue; lct_mast.erase(edge&lt;:mix - n:&gt;.from, mix); lct_mast.erase(edge&lt;:mix - n:&gt;.to, mix); %&gt; lct_mast.connect(from, j + n); lct_mast.connect(to, j + n); %&gt; else &lt;% if (lct_mast.getroot(to) == from) &lt;% lct_mast.transfer(j + n); if (!lct_mast.T&lt;:j + n:&gt;.fa &amp;&amp; !lct_mast.T&lt;:j + n:&gt;.siz) continue; lct_mast.erase(edge&lt;:j:&gt;.from, j + n); lct_mast.erase(edge&lt;:j:&gt;.to, j + n); %&gt; %&gt; %&gt; %&gt; return 0; %&gt; 10.[TJOI2018]å¼‚æˆ–ç°åœ¨æœ‰ä¸€é¢—ä»¥$1$ä¸ºæ ¹èŠ‚ç‚¹çš„ç”±$n$ä¸ªèŠ‚ç‚¹ç»„æˆçš„æ ‘ï¼Œæ ‘ä¸Šæ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½æœ‰ä¸€ä¸ªæƒå€¼$v_i$ã€‚ç°åœ¨æœ‰$Q$æ¬¡æ“ä½œï¼Œæ“ä½œå¦‚ä¸‹ï¼š $1\\;x\\;y$ï¼šæŸ¥è¯¢èŠ‚ç‚¹$x$çš„å­æ ‘ä¸­ä¸$y$å¼‚æˆ–ç»“æœçš„æœ€å¤§å€¼ $2\\;x\\;y\\;z$ï¼šæŸ¥è¯¢è·¯å¾„$x$åˆ°$y$ä¸Šç‚¹ä¸$z$å¼‚æˆ–ç»“æœæœ€å¤§å€¼ è¿™æ˜¯ä¸€é“å¯æŒä¹…åŒ–$01Trie$æ ‘+æ ‘é“¾å‰–åˆ†çš„å¥½é¢˜ã€‚ ä½†æ˜¯æ ‘å‰–æ˜¯å‡ºäº†åçš„éš¾æ‰“ï¼Œä»”ç»†çœ‹é¢˜ï¼Œå¯ä»¥å‘ç°åªéœ€è¦$DFS$åºä¾¿å¯ä»¥è§£å†³é—®é¢˜ å¯¹äºç¬¬ä¸€ä¸ªæ“ä½œï¼Œç›´æ¥ç”¨$DFS$åºç»´æŠ¤$sub_tree$çš„ä¿¡æ¯å³å¯ å¯¹äºç¬¬äºŒä¸ªæ“ä½œï¼Œå¯ä»¥è€ƒè™‘åœ¨$DFS$éå†æ•´æ£µæ ‘çš„åŒæ—¶æ’å…¥æƒå€¼ æŸ¥è¯¢çš„è¯ç›´æ¥ä¸Š$LCA$ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = (100000 + 5) &lt;&lt; 1; int head[SIZE], ver[SIZE]; int nxt[SIZE], edge[SIZE]; int n, q, fuck, a[SIZE]; inline void pushEdge(int x, int y, int z) { ver[++fuck] = y, edge[fuck] = z; nxt[fuck] = head[x], head[x] = fuck; } struct ZeroOneTrie { int root[SIZE], cnt; int trie[SIZE &lt;&lt; 6][2]; int frie[SIZE &lt;&lt; 6]; ZeroOneTrie() { root[0] = cnt = 1; } inline void insert(int last, int &amp;lyc, int x) { int rt = lyc = ++cnt; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; trie[rt][!now] = trie[last][!now]; trie[rt][now] = ++cnt; rt = trie[rt][now]; last = trie[last][now]; frie[rt] = frie[last] + 1; } } inline int find(int l, int r, int x) { int res = 0; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; if (frie[trie[r][!now]] - frie[trie[l][!now]]) { r = trie[r][!now]; l = trie[l][!now]; res |= 1 &lt;&lt; i; } else { r = trie[r][now]; l = trie[l][now]; } } return res; } } t0, t1; int dfn[SIZE], L[SIZE], R[SIZE]; int num, fa[SIZE][30], depth[SIZE]; inline void dfs(int x, int pre) { t1.insert(t1.root[pre], t1.root[x], a[x]); fa[x][0] = pre; depth[x] = depth[pre] + 1; L[x] = ++num; dfn[num] = a[x]; for (int i = head[x]; ~i; i = nxt[i]) if (ver[i] ^ pre) dfs(ver[i], x); R[x] = num; } inline int lca_mast(int x, int y) { if (depth[x] &lt; depth[y]) swap(x, y); for (int i = 25; ~i; --i) if (depth[fa[x][i]] &gt;= depth[y]) x = fa[x][i]; if (x ^ y) { for (int i = 25; ~i; --i) if (fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0]; } else return x; } signed main() { memset(head, -1, sizeof head); scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt; n; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); pushEdge(from, to, 1); pushEdge(to, from, 1); } dfs(1, 0); for (int j = 1; j &lt;= 25; ++j) for (int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (int i = 1; i &lt;= n; ++i) t0.insert(t0.root[i - 1], t0.root[i], dfn[i]); for (int i = 1; i &lt;= q; ++i) { int opt, x, y, z; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt ^ 1) { scanf(&quot;%d&quot;, &amp;z); int ans = lca_mast(x, y); printf(&quot;%d\\n&quot;, max(t1.find(t1.root[fa[ans][0]], t1.root[x], z), t1.find(t1.root[fa[ans][0]], t1.root[y], z))); } else { printf(&quot;%d\\n&quot;, t0.find(t0.root[L[x] - 1], t0.root[R[x]], y)); } } return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åŸºäºå¾ªç¯çš„çº¿æ®µæ ‘","slug":"DS100P-SEGMENT-TREE-WITH-LOOP","date":"2020-02-08T05:50:19.000Z","updated":"2020-04-12T06:05:02.424Z","comments":true,"path":"2020/02/08/DS100P-SEGMENT-TREE-WITH-LOOP/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-SEGMENT-TREE-WITH-LOOP/","excerpt":"","text":"0x00 å‰è¨€çº¿æ®µæ ‘çš„ç é‡å¯¹äºåˆå­¦è€…æ¥è¯´ååˆ†ä¸å‹å¥½ï¼Œè€Œä¸”å°±ç®—ç†è§£äº†æ¿å­åˆ°äº†å®é™…åº”ç”¨æ—¶ä¹Ÿå¾ˆå®¹æ˜“åœ¨ç ä»£ç çš„æ—¶å€™æ¼æ‰ä¸€äº›ç»†èŠ‚ã€‚è€Œä¸”çº¿æ®µæ ‘çš„å››å€ç©ºé—´ä¹Ÿå¯èƒ½è¢«å¡ï¼ˆè™½ç„¶æˆ‘æ²¡è§è¿‡ï¼‰ï¼ˆä½†æ€»å½’æ˜¯å¤šäº†ä¸€äº›å¼€é”€ï¼‰ï¼Œå¯¼è‡´æœ‰æ—¶å€™æˆ‘ä»¬ä¸å¾—ä¸ä½¿ç”¨å…¶ä»–çš„æ•°æ®ç»“æ„ã€‚æœ€é‡è¦çš„æ˜¯ï¼Œç”±äºé€’å½’ç­‰åŸå› ï¼Œä¼ ç»Ÿå½¢å¼çš„çº¿æ®µæ ‘çš„å¸¸æ•°å¾ˆå¤§ã€‚ é‚£ä¹ˆåœ¨è¿™é‡Œæˆ‘å°†ä»‹ç»ä¸€ç§åŸºäºå¾ªç¯çš„ã€ç©ºé—´åªéœ€å¼€ä¸¤å€çš„è¾ƒäºä¼ ç»Ÿå½¢å¼çš„çº¿æ®µæ ‘æ›´åŠ ç®€æ´é«˜æ•ˆçš„çº¿æ®µæ ‘çš„å½¢å¼ã€‚ï¼ˆç”šè‡³å¯ä»¥é”¤BITï¼‰ è¿™ä¸ªä¸œè¥¿æ˜¯æˆ‘åœ¨AI.Cashç¥ä»™é‚£é‡Œå­¦çš„ï¼Œè¿™é‡Œç»™å‡ºä»–çš„æ–‡ç« é“¾æ¥ï¼šhttps://codeforc.es/blog/entry/18051 0x01 ç¬¬ä¸€éƒ¨åˆ†æˆ‘ä»¬é¦–å…ˆè€ƒè™‘ä¸¤ç§æ“ä½œï¼šå•ç‚¹æ›´æ–°å’ŒåŒºé—´ã€‚è¿™é‡Œæˆ‘ä»¬å‡è®¾ $n=2^{p},p\\in\\mathbb{N}$ã€‚ ä¸¾ä¸ªä¾‹å­ï¼Œå½“ $n=2^{4}$ï¼Œæˆ‘ä»¬ç”»å‡ºçº¿æ®µæ ‘çš„å›¾ç¤ºã€‚ ï¼ˆæˆ‘ç”»å›¾èŠ±äº†ä¸€å¹´â€¦â€¦ï¼‰ é¦–å…ˆæˆ‘ä»¬è€ƒè™‘å»ºæ ‘ï¼Œå…ˆç»™å‡ºå»ºæ ‘çš„ä»£ç å®ç°ï¼š void build() { for (int i = n - 1; i &gt;= 1; --i) t[i] = t[i &lt;&lt; 1] + t[i &lt;&lt; 1 | 1]; } ç»“åˆå›¾ä¾‹å°±å¾ˆå¥½ç†è§£ã€‚å»ºæ ‘æ¯”è¾ƒæ˜¾ç„¶ï¼Œå°±ä¸å¤šèµ˜è¿°äº†ã€‚æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶ $\\Theta(n)$ ç„¶åæ˜¯å•ç‚¹ä¿®æ”¹ï¼Œå…ˆç»™ä»£ç ï¼š void modify(int pos, int val) { for (t[pos += n] = val; pos &gt; 1; pos &gt;&gt;= 1) t[pos &gt;&gt; 1] = t[pos] + t[pos ^ 1]; } ä¸¾ä¸ªä¾‹å­ï¼Œæˆ‘ä»¬ç°åœ¨è¦ä¿®æ”¹ç¬¬1ä¸ªå…ƒç´ ï¼Œä¹Ÿå°±æ˜¯17å·èŠ‚ç‚¹ã€‚é¦–å…ˆæˆ‘ä»¬æŠŠpos += nï¼Œè¿™æ ·æˆ‘ä»¬å°±å®šä½åˆ°äº†åºåˆ—çš„ç¬¬1ä¸ªå…ƒç´ åœ¨çº¿æ®µæ ‘å¯¹åº”çš„å¶å­èŠ‚ç‚¹ä¹Ÿå°±æ˜¯17å·èŠ‚ç‚¹ã€‚æ­¤æ—¶æˆ‘ä»¬ä¿®æ”¹å¶å­èŠ‚ç‚¹ã€‚ç„¶åæˆ‘ä»¬å¾€ä¸Šæ‰¾çˆ¶äº²èŠ‚ç‚¹ï¼Œpos &gt;&gt; 1å¯ä»¥å¸®æˆ‘ä»¬æ‰¾åˆ°ä¸€ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹ã€‚poså’Œpos ^ 1ç¨å¾®äº†è§£ä½è¿ç®—å°±èƒ½çŸ¥é“ï¼Œä¸å¤šèµ˜è¿°ã€‚æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶ $\\Theta(\\log_{2}n)$ã€‚ å†æ¥è€ƒè™‘åŒºé—´æŸ¥è¯¢ï¼ŒåŒæ ·å…ˆç»™ä»£ç å†è®²è§£ã€‚ int queryf(int l, int r) { int res = 0; for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) res += t[l++]; if (r &amp; 1) res += t[--r]; } return res; } åŒæ ·ä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚æˆ‘ä»¬è¦æ±‚ $[3,11)$ çš„å’Œï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºèŠ‚ç‚¹ç¼–å·ä¸º19ã€5ã€12ã€26çš„å’Œå³å¯ã€‚çœ‹å›¾ç†è§£ã€‚ çœ‹å‘ä»£ç ï¼Œé¦–å…ˆæˆ‘ä»¬æŠŠ $l$ å’Œ $r$ åˆ†åˆ«åŠ  $n$ï¼Œè·å–åˆ°3å’Œ10åœ¨çº¿æ®µæ ‘çš„èŠ‚ç‚¹ç¼–å·ã€‚ç„¶åæ ¹æ® $l$ å’Œ $r$ çš„å¥‡å¶æ€§åˆ¤æ–­æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å„¿å­è¿˜æ˜¯å³å„¿å­ï¼Œç„¶ååŠ èµ·æ¥å³å¯ã€‚æ³¨æ„åŒºé—´æ˜¯å·¦é—­å³å¼€çš„ã€‚æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¾ç„¶ $\\Theta(\\log_{2}n)$ å½“ç„¶ï¼Œå½“ $n\\neq 2^{p},p\\in\\mathbb{N}$ æ—¶ï¼Œä»¥ä¸Šçš„ç»“è®ºå’Œä»£ç ä¾ç„¶æˆç«‹ã€‚ è®©æˆ‘ä»¬æ¥çœ‹ä¸€é“æ¿é¢˜ï¼ŒP3374 ã€Œæ¨¡æ¿ã€æ ‘çŠ¶æ•°ç»„1 ä»£ç å’Œä¸Šé¢å·®ä¸å¤šï¼Œæˆ‘ç›´æ¥ç»™äº†ï¼š #include &lt;cstdio&gt; const int N = 5e5 + 5; int n, m, t[N &lt;&lt; 1]; void build() { for (int i = n - 1; i &gt; 0; --i) t[i] = t[i &lt;&lt; 1] + t[i &lt;&lt; 1 | 1]; } void modify(int p, int val) { for (t[p += n] += val; p &gt; 1; p &gt;&gt;= 1) t[p &gt;&gt; 1] = t[p] + t[p ^ 1]; } int queryf(int l, int r) { int res = 0; for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) res += t[l++]; if (r &amp; 1) res += t[--r]; } return res; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;t[i + n]); build(); for (int i = 0, opt, x, y; i &lt; m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt == 1) modify(x - 1, y); else printf(&quot;%d\\n&quot;, queryf(x - 1, y)); } return 0; } å¥½ï¼Œè®©æˆ‘ä»¬æ¥å…³æ³¨ä¸€ä¸‹ç”¨æ—¶ï¼š æ ‘çŠ¶æ•°ç»„ï¼š829~1.07ms Accepted çº¿æ®µæ ‘ï¼ˆæˆ‘çš„å¤§å¸¸æ•°ç‰ˆï¼‰ï¼š4.98S Time Limit Exceeded çº¿æ®µæ ‘ï¼ˆLYCçš„å°å¸¸æ•°ç‰ˆï¼‰ï¼š1.53S Accepted çº¿æ®µæ ‘ï¼ˆä»Šå¤©ä»‹ç»çš„ç‰ˆæœ¬ï¼‰ï¼š925ms Accepted å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬ä»Šå¤©çš„å¾ªç¯çº¿æ®µæ ‘çš„å¸¸æ•°å‡ ä¹å’Œç´ æ¥ä»¥å°å¸¸æ•°è‘—ç§°çš„BITå·®ä¸å¤šç”šè‡³æ›´ä¼˜äº†ã€‚ ç©ºé—´å¼€é”€ï¼š æ ‘çŠ¶æ•°ç»„ï¼š8.04MB çº¿æ®µæ ‘ï¼ˆæˆ‘çš„å¤§å¸¸æ•°ç‰ˆï¼‰ï¼š16.57MB çº¿æ®µæ ‘ï¼ˆLYCçš„å°å¸¸æ•°ç‰ˆï¼‰ï¼š23.93MB çº¿æ®µæ ‘ï¼ˆä»Šå¤©ä»‹ç»çš„ç‰ˆæœ¬ï¼‰ï¼š4.42MB è™½ç„¶ç†è®ºç©ºé—´å¤æ‚åº¦æ˜¯BITæ›´ä¼˜ï¼Œä½†æ˜¯å®é™…ä¸Šæ˜¯ä»Šå¤©ä»‹ç»å¾ªç¯çº¿æ®µæ ‘ç¢¾å‹å…¨åœºã€‚ ç¬¬äºŒé“é¢˜P3368 ã€Œæ¨¡æ¿ã€æ ‘çŠ¶æ•°ç»„2ï¼š ä»£ç å¤§åŒå°å¼‚ï¼š #include &lt;cstdio&gt; const int N = 5e5 + 5; int n, m, t[N &lt;&lt; 1]; void modify(int l, int r, int v) { for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) t[l++] += v; if (r &amp; 1) t[--r] += v; } } int queryf(int p) { int res = 0; for (p += n; p &gt; 0; p &gt;&gt;= 1) res += t[p]; return res; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;t[i + n]); for (int i = 0, opt, x, y, v; i &lt; m; ++i) { scanf(&quot;%d %d&quot;, &amp;opt, &amp;x); if (opt == 1) scanf(&quot;%d %d&quot;, &amp;y, &amp;v), modify(x - 1, y, v); else printf(&quot;%d\\n&quot;, queryf(x - 1)); } return 0; } ç»“æœæ¯”å¯¹ï¼š æ ‘çŠ¶æ•°ç»„ï¼š1.76s, 25.91MB, 1.66KB Accepted çº¿æ®µæ ‘ï¼ˆä»Šå¤©ä»‹ç»çš„ç‰ˆæœ¬ï¼‰ï¼š863ms, 3.91MB, 607B Accepted éœ‡æƒŠï¼Œçº¿æ®µæ ‘ç«Ÿåœ¨ç é‡æ—¶é—´ç©ºé—´ä¸Šéƒ½ç¢¾å‹äº†æ ‘çŠ¶æ•°ç»„233 0x02 ç¬¬äºŒéƒ¨åˆ†ç›´åˆ°ç›®å‰ä¸ºæ­¢ï¼Œæˆ‘ä»¬åªæ˜¯ç”¨çº¿æ®µæ ‘æ·¦äº†æ ‘çŠ¶æ•°ç»„æ·¦çš„äº‹æƒ…è€Œå·²ã€‚çº¿æ®µæ ‘çš„çµé­‚LazyTagæˆ‘ä»¬è¿˜æ²¡æœ‰æ¶‰åŠã€‚é‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬å°±æ¥ä»‹ç»å¾ªç¯ç‰ˆæœ¬çš„çº¿æ®µæ ‘å¦‚ä½•ä½¿ç”¨LazyTagã€‚ æ¯”å¦‚è®©æˆ‘ä»¬ç»´æŠ¤åŒºé—´åŠ å’ŒåŒºé—´æå€¼ã€‚ å…ˆç»™ä»£ç ï¼š const int N = 5e5 + 5; int n, m, h, t[N &lt;&lt; 1], d[N]; å˜é‡è§£é‡Šï¼Œ$n,m$ ä¸è§£é‡Šã€‚$h$ è¡¨ç¤ºæ ‘çš„é«˜åº¦ï¼Œå³ $\\log_{2}n$ã€‚$t$ æ•°ç»„çš„æ„ä¹‰æ˜¯æˆ‘ä»¬ç»´æŠ¤çš„ä¸œè¥¿ã€‚$d$ å¯ä»¥ç†è§£ä¸ºæˆ‘ä»¬çš„LazyTagã€‚ä¹‹æ‰€ä»¥åªç”¨ $\\Theta(n)$ çš„ç©ºé—´æ˜¯å› ä¸ºå¶å­èŠ‚ç‚¹ä¸éœ€è¦LazyTagï¼Œå› ä¸ºä»–ä»¬æ²¡æœ‰éœ€è¦ç»´æŠ¤çš„å­èŠ‚ç‚¹ã€‚ void apply(int p, int val) { t[p] += val; if (p &lt; n) d[p] += val; } è¿™æ®µæ˜¯åœ¨ä¿®æ”¹çš„èŠ‚ç‚¹å€¼ï¼Œæ„å‘³æ˜“å¾—ï¼Œä¸èµ˜è¿°ã€‚ void update(int p) { while (p &gt; 1) p &gt;&gt;= 1, t[p] = max(t[p &lt;&lt; 1], t[p &lt;&lt; 1 | 1]) + d[p]; } è¿™æ®µå°±æ˜¯åœ¨æ›´æ–°èŠ‚ç‚¹çš„æœ€å¤§å€¼ã€‚ ä»¥ä¸Šå›¾ä¸ºä¾‹ï¼Œæ‰‹ç©ä¸€ä¸‹æ„å‘³æ˜“å¾—ï¼Œä¸‹ä¸€ä¸ªã€‚ void push(int p) { for (int bit = h; bit &gt; 0; --bit) { int i = (p &gt;&gt; bit); if (d[i]) { apply(i &lt;&lt; 1, d[i]); apply(i &lt;&lt; 1 | 1, d[i]); d[i] = 0; } } } ç›¸å½“äºæ™®é€šçº¿æ®µæ ‘çš„pushdownã€‚ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œå¦‚æœå½“å‰çš„èŠ‚ç‚¹çš„LazyTagè¿˜æ²¡æ›´æ–°ï¼Œé‚£ä¹ˆå°±applyåˆ°å­èŠ‚ç‚¹å»ï¼Œå¹¶ä¸”æ¸…æ‰LazyTagã€‚ void modify(int l, int r, int val) { int L = (l += n), R = (r += n); for (; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) apply(l++, val); if (r &amp; 1) apply(--r, val); } return update(L), update(R - 1); } ä¿®æ”¹æ“ä½œï¼Œå­˜ä¸‹å¶èŠ‚ç‚¹çš„ç¼–å·ï¼Œæ›´æ–°å®Œåupdateã€‚ int queryf(int l, int r) { int res = -1926081701; for (push((l += n)), push((r += n) - 1); l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) res = max(res, t[l++]); if (r &amp; 1) res = max(res, t[--r]); } return res; } æŸ¥è¯¢ï¼Œæ„å‘³æ˜“å¾—ï¼Œä¸èµ˜ã€‚ ä»¥ä¸‹æ˜¯å®Œæ•´çš„ä»£ç ï¼š #include &lt;cstdio&gt; #include &lt;iostream&gt; using std::max; const int N = 5e5 + 5; int n, m, h, t[N &lt;&lt; 1], d[N]; void apply(int p, int val) { t[p] += val; if (p &lt; n) d[p] += val; } void update(int p) { while (p &gt; 1) p &gt;&gt;= 1, t[p] = max(t[p &lt;&lt; 1], t[p &lt;&lt; 1 | 1]) + d[p]; } void push(int p) { for (int bit = h; bit &gt; 0; --bit) { int i = (p &gt;&gt; bit); if (d[i]) { apply(i &lt;&lt; 1, d[i]); apply(i &lt;&lt; 1 | 1, d[i]); d[i] = 0; } } } void modify(int l, int r, int val) { int L = (l += n), R = (r += n); for (; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) apply(l++, val); if (r &amp; 1) apply(--r, val); } return update(L), update(R - 1); } int queryf(int l, int r) { int res = -1926081701; for (push((l += n)), push((r += n) - 1); l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) { if (l &amp; 1) res = max(res, t[l++]); if (r &amp; 1) res = max(res, t[--r]); } return res; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); h = sizeof(int) * 8 - __builtin_clz(n); for (int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;t[i + n]); for (int i = 0, opt, x, y, v; i &lt; m; ++i) { scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt == 1) scanf(&quot;%d&quot;, &amp;v), modify(x - 1, y, v); else printf(&quot;%d\\n&quot;, queryf(x - 1, y)); } return 0; } 0x03 ç»“å°¾åŸºäºå¾ªç¯çš„çº¿æ®µæ ‘è¾ƒäºåŸºäºé€’å½’çš„çº¿æ®µæ ‘å¸¸æ•°æ›´å°ï¼Œå®ç°æ›´ç®€å•ï¼Œå¯¹åˆå­¦è€…æ›´å‹å¥½ã€‚è€Œä¸”ä¹Ÿæ”¯æŒLazyTagã€‚ è¾ƒäºæ ‘çŠ¶æ•°ç»„èƒ½æ·¦çš„äº‹æƒ…æ›´å¤šè€Œä¸”ç»å¸¸åœ¨ç©ºé—´æ—¶é—´ç é‡æš´æ¶BITâ€¦â€¦å½“ç„¶ä¹Ÿå¯èƒ½æ˜¯æˆ‘æ‰“çš„BITå¤ªä¸‘äº†ã€‚ æœ€ä¸»è¦çš„å°±æ˜¯ï¼Œä¸å®¹æ˜“æ‰“é”™ã€‚åƒæˆ‘è¿™ç§çœ‹å®¶æœ¬é¢†Splayç»“æœæ¯æ¬¡æ‰“éƒ½è¦é”™ä¸€æ¬¡splayå’Œrotateçš„æ‰‹æ®‹æ¥è¯´ï¼Œç®€ç›´ä¸è¦å¤ªå‹å¥½ã€‚è€Œä¸”å¾ˆå¥½ç†è§£ã€‚ å¯ä»¥å‘ç°æˆ‘çš„ä»£ç å’ŒåŸä½œè€…çš„ä»£ç å¾ˆåƒã€‚å…¶å®è¿™æ˜¯å› ä¸ºæˆ‘å¾ˆå–œæ¬¢åŸä½œè€…çš„ç é£ï¼Œæ‰€ä»¥å†™ç€å†™ç€å°±å·®ä¸å¤šå•¦~/xyx","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"},{"name":"çº¿æ®µæ ‘","slug":"çº¿æ®µæ ‘","permalink":"www.orchid-any.cf/tags/çº¿æ®µæ ‘/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å·¦åæ ‘","slug":"DS100P-LEFT-SIDE-TREE","date":"2020-02-08T05:39:04.000Z","updated":"2020-02-20T02:48:47.126Z","comments":true,"path":"2020/02/08/DS100P-LEFT-SIDE-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-LEFT-SIDE-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ”¯é…æ ‘","slug":"DS100P-DOMINATION-TREE","date":"2020-02-08T05:38:18.000Z","updated":"2020-02-20T02:48:47.111Z","comments":true,"path":"2020/02/08/DS100P-DOMINATION-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-DOMINATION-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---çŒ«æ ‘","slug":"DS100P-CAT-TREE","date":"2020-02-08T05:37:14.000Z","updated":"2020-02-20T02:48:47.108Z","comments":true,"path":"2020/02/08/DS100P-CAT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-CAT-TREE/","excerpt":"","text":"0x01 å¼•å­é¦–å…ˆå¼•å…¥è¿™æ ·ä¸€ç§é—®é¢˜ï¼šç»™å®š $n$ çš„èŒƒå›´ï¼Œå†ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„åºåˆ—ï¼Œç„¶åç»™å‡ºå„ç§è¯¢é—®ï¼Œè¯¢é—®çš„æ•°é‡å¤§äº $n$ã€‚æ¯”å¦‚è¯´ $n=10^{6},q=10^{7}$ã€‚ è€ƒè™‘çº¿æ®µæ ‘ï¼Œ$\\log n$ çš„æŸ¥è¯¢å½“åœºæ­»äº¡ã€‚ é‚£ä¹ˆæ€ä¹ˆåŠå‘¢ï¼ŸçŒ«é”Ÿå¤§å¤§å°±ç»™å‡ºäº†ä¸€ç§ ä¸æ”¯æŒä¿®æ”¹ä½†æ˜¯å¯ä»¥åšåˆ° $\\Theta(n\\log n)$ é¢„å¤„ç† $\\Theta(1)$ æŸ¥è¯¢çš„æ•°æ®ç»“æ„â€”â€”çŒ«æ ‘ ï¼Œç»™å¤§å®¶åˆ†äº«ä¸€ä¸‹åŸæ–‡ç« Linkã€‚ 0x02 é¢„å¤„ç†éƒ¨åˆ†å…·ä½“è¿‡ç¨‹æŒ‰æˆ‘çš„ç†è§£ï¼ŒçŒ«æ ‘å…¶å®å¯ä»¥çœ‹åšåƒ $DP$ ä¸€æ · æŠŠåˆ†æ²»çš„è¿‡ç¨‹è®°å½•ä¸‹æ¥ çš„ä¸œè¥¿ã€‚ ä¸¾ä¾‹æ¥è¯´ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦ä½ æŸ¥è¯¢åºåˆ—çš„åŒºé—´æœ€å¤§å€¼å’ŒåŒºé—´å’Œä¹‹ç±»çš„ å…·æœ‰åŒºé—´å¯åŠ æ€§ çš„ä¿¡æ¯ï¼ŒæŸ¥è¯¢åŒºé—´ä¸º $[l,r]$ã€‚ é€’å½’çš„æ¥æƒ³ï¼ŒåŒºé—´ $[l,r]$ æ˜¯ç”±åŒºé—´ $[l,mid]$ å’Œ $[mid+1,r]$ ä¸¤ä¸ªåŒºé—´åˆå¹¶è€Œæ¥çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦èƒ½å¤Ÿä½¿ç”¨é¢„å¤„ç†çš„æ‰‹æ®µä½¿å¾—æ‰€æœ‰å¯èƒ½çš„è¯¢é—®åŒºé—´éƒ½å¯ä»¥é€šè¿‡åˆå¹¶æ¥ $\\Theta(1)$ å¾—å‡ºç­”æ¡ˆå‘¢ï¼Ÿç­”æ¡ˆæ˜¯æ²¡é—®é¢˜ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹å…·ä½“çš„æ­¥éª¤ï¼š step1:æˆ‘ä»¬å°†æ•´ä¸ªåºåˆ—åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå³ $[1,mid]$ å’Œ $[mid+1,n]$step2:åˆ†åˆ«ä» $mid$ å‘å·¦ä» $mid+1$ å‘å³ï¼Œéå†æ•´ä¸ªåŒºé—´step3:ç»´æŠ¤ä¿¡æ¯ã€‚æ¯”å¦‚è¯´åŒºé—´æœ€å¤§å€¼ï¼Œé‚£ä¹ˆå¯¹äºä» $mid$ å¼€å§‹å‘å·¦çš„åŒºé—´ï¼Œ$maxvalue_{i}=max\\{max_{i+1},a_{i}\\}$ï¼Œå¯¹äºä» $mid+1$ å¼€å§‹å‘å³çš„åŒºé—´åŒç†step4:å¤è¯»æœº æ—¶é—´å¤æ‚åº¦å°±åƒçº¿æ®µæ ‘ä¸€æ ·ï¼ŒçŒ«æ ‘æ˜¯ä¸€é¢—äºŒå‰æ ‘ï¼Œæ·±åº¦æœ€å¤šä¸º $\\log_{2}n$ å±‚ï¼Œæ¯ä¸€å±‚æˆ‘ä»¬éœ€è¦ $\\Theta(n)$ çš„æ—¶é—´è¿›è¡Œç»´æŠ¤ä¿¡æ¯çš„å·¥ä½œï¼Œæ‰€ä»¥é¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(n\\log n)$ã€‚ å•Šå¯¹äº†ï¼Œç©ºé—´å¤æ‚åº¦ä¹Ÿæ˜¯ $\\Theta(n\\log n)$ï¼Œæƒ³æƒ³å°±æ˜ç™½äº†ï¼Œè¿™é‡Œä¸ºäº†èŠ‚çœç¯‡å¹…å°±ç•¥æ‰äº†ã€‚ 0x03 å¤„ç†è¯¢é—®éƒ¨åˆ†å…·ä½“è¿‡ç¨‹å¯¹äºä¸€ä¸ª è¯¢é—® åŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒæ”¾åœ¨æŸä¸ª å·²ç»ç»è¿‡é¢„å¤„ç†çš„ å¹¶ä¸” è¯¢é—® åŒºé—´ç»è¿‡ å·²ç»ç»è¿‡é¢„å¤„ç†çš„ çš„åŒºé—´çš„ ä¸­ç‚¹ çš„åŒºé—´é‡Œã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬è®¾è¯¢é—®åŒºé—´ä¸º $q$ï¼Œæˆ‘ä»¬æŠŠ $q$ æ”¾åœ¨ä¸€ä¸ªåŒºé—´ $t$ é‡Œé¢ï¼Œ$t$ çš„å®šä¹‰æ˜¯å·²ç»ç»è¿‡é¢„å¤„ç†ï¼Œå¹¶ä¸”è¯¢é—®åŒºé—´ $q$ è·¨è¿‡åŒºé—´ $t$ çš„ä¸­ç‚¹ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œæ—¢ç„¶ $t$ å·²ç»ç»è¿‡äº†é¢„å¤„ç†ï¼Œé‚£ä¹ˆ $t$ çš„ä¸­ç‚¹æŠŠ $q$ åˆ†æˆçš„ä¸¤éƒ¨åˆ†ä¹Ÿä¸€å®šç»è¿‡äº†é¢„å¤„ç†ï¼Œæˆ‘ä»¬å°±å¯ä»¥ $\\Theta(1)$ çš„åˆå¹¶äº†ã€‚ æ²¡æœ‰å›¾å§‹ç»ˆæ²¡æœ‰æ„Ÿè§‰å¯¹å§ï¼Ÿé‚£ä¹ˆä¸Šå›¾æ¥ç†è§£å§ã€‚ è¿™æ˜¯ä¸€æ£µç‰›é€¼çš„æ ‘ï¼Œæˆ‘ä»¬ç»™ä»–å–åå«ç‰›é€¼æ ‘ å“¦ï¼ç°åœ¨ç‰›é€¼æ ‘ä¸Šæœ‰äº†ä¸€ä¸ªè¯¢é—®ï¼ å“ˆï¼ç‰›é€¼æ ‘ä¸Šçš„è¯¢é—®æˆåŠŸçš„è¢«ç¬¬ä¸‰å±‚çš„æŸä¸ªåŒºé—´åˆ†å‰²å•¦ï¼è€¶ï¼ å¹³ç”Ÿæ²¡æœ‰è¿™ä¹ˆå‚»è¿‡ æ—¶é—´å¤æ‚åº¦æŸ¥è¯¢çš„å¤æ‚åº¦è²Œä¼¼æ˜¯ $\\Theta(\\log n)$ï¼Ÿä¸ä¸ä¸ï¼Œæ—¢ç„¶å‰é¢è¯´äº†æŸ¥è¯¢æ˜¯ $\\Theta(1)$ çš„ï¼Œé‚£å°±ä¸€å®šæ˜¯ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬è°ˆä¸€è°ˆä¼˜åŒ–çš„å†…å®¹ã€‚ æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–ä»”ç»†æƒ³æƒ³å¦‚æœæˆ‘ä»¬ä¸ä»æ ¹ç»“ç‚¹å‡ºå‘ï¼Œè€Œæ˜¯ä»å¶å­ç»“ç‚¹æ¥çš„è¯ï¼Œè¿™å°±æ˜¯åœ¨æ±‚ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ å˜›ï¼ä½†æ˜¯æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿä»”ç»†æƒ³æƒ³ï¼Œæˆ‘ä»¬çš„ç‰›é€¼çŒ«æ ‘æ˜¯ä¸€é¢—äºŒå‰æ ‘ï¼Œè€ŒäºŒå‰æ ‘çš„ $LCA$ æ˜¯ä»€ä¹ˆï¼Ÿ è¿™é‡Œæœ‰ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼ŒäºŒå‰æ ‘ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ å°±æ˜¯äºŒè¿›åˆ¶ä¸‹çš„å®ƒä»¬çš„ç¼–å·çš„ æœ€é•¿å…¬å…±å‰ç¼€ ã€‚ æ¯”å¦‚è¯´ $7$ å·ç»“ç‚¹å’Œ $5$ å·ç»“ç‚¹çš„ $LCA$ å°±æ˜¯ï¼š $(0111)_{2}\\ \\ \\ (0101)_{2}$ ä¹Ÿå°±æ˜¯ $(01)_{2}$ ä¹Ÿå°±æ˜¯ $1$ å·ç»“ç‚¹ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ‰¾å‡ºä¸¤ä¸ªæ•°çš„äºŒè¿›åˆ¶æœ€é•¿å…¬å…±å‰ç¼€å‘¢ï¼Ÿ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬å°†ä¸¤ä¸ªèŠ‚ç‚¹ $xor$ èµ·æ¥ï¼Œå°±èƒ½å¤Ÿå»æ‰å®ƒä»¬çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨x&gt;&gt;log2[x^y]æ¥è·å¾—ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ã€‚ 0x03 ä¾‹é¢˜ä¸ä»£ç # SP1043 GSS1 - Can you answer these queries Iç»™å‡ºäº†åºåˆ— $A[1],A[2],â€¦,A[N]$ ã€‚ ($a[i]â‰¤15007,1â‰¤Nâ‰¤50000$ )ã€‚æŸ¥è¯¢å®šä¹‰å¦‚ä¸‹ï¼š æŸ¥è¯¢ $(x,y)=\\max\\{a[i]+a[i+1]+â€¦+a[j];xâ‰¤iâ‰¤jâ‰¤y\\}$ã€‚ ç»™å®š$M$ä¸ªæŸ¥è¯¢ï¼Œç¨‹åºå¿…é¡»è¾“å‡ºè¿™äº›æŸ¥è¯¢çš„ç»“æœã€‚ é¢˜ç›®è®©æˆ‘ä»¬æŸ¥è¯¢æœ€å¤§å­æ®µå’Œï¼Œå¹¶ä¸”æ²¡æœ‰ä¿®æ”¹æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡çŒ«æ ‘æ¥ç©è¿™é“é¢˜ã€‚ å…·ä½“æ­¥éª¤ä¸Šæ–‡å·²ç»å†™äº†ï¼Œå¯¹äºè¿™é“ æ¿ é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®°å½•æœ€å¤§å­æ®µå’Œä»¥åŠæœ€å¤§å‰ç¼€å’Œå³å¯ã€‚ ä»£ç ï¼š // çœç•¥äº†ä¸€äº›å¤´æ–‡ä»¶ã€å¿«è¯»ã€é¢„å¤„ç†å‘½ä»¤ç­‰ä¸œè¥¿ï¼Œå®Œæ•´ä»£ç è¯·ç§»æ­¥è‡³https://vjudge.net/solution/24123955 const int SIZE = 2e5 + 5; const int LOG_SIZE = 20; int n, m, real = 2, ints[SIZE]; // real:æŠŠnæ˜ å°„ä¸º2çš„å¹‚å½¢å¼ // ints:åŸåºåˆ— namespace CatsTree { int log2[SIZE]; // é¢„å¤„ç†log2 int nodes[SIZE]; // ç»“ç‚¹ int ans[LOG_SIZE][SIZE]; // æœ€å¤§å­æ®µå’Œ int preans[LOG_SIZE][SIZE]; // æœ€å¤§å‰ç¼€å’Œ void MakeLog() { for (int i = 2, lim = real &lt;&lt; 1; i &lt;= lim; ++i) log2[i] = log2[i &gt;&gt; 1] + 1; } void BuildTree(int k, int l, int r, int s) { if (l ^ r) { ans[s][mid] = preans[s][mid] = ints[mid]; int pre, sum; pre = sum = ints[mid]; sum = sum &gt; 0 ? sum : 0; for (int i = mid - 1; i &gt;= l; --i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i + 1]); preans[s][i] = max(sum, preans[s][i + 1]); sum = sum &gt; 0 ? sum : 0; } ans[s][mid + 1] = preans[s][mid + 1] = ints[mid + 1]; pre = sum = ints[mid + 1]; sum = sum &gt; 0 ? sum : 0; for (int i = mid + 2; i &lt;= r; ++i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i - 1]); preans[s][i] = max(sum, preans[s][i - 1]); sum = sum &gt; 0 ? sum : 0; } BuildTree(ls, l, mid, s + 1); BuildTree(rs, mid + 1, r, s + 1); } else nodes[l] = k; } int GetAnswers(int l, int r) { if (l ^ r) { int s = log2[nodes[l]] - log2[nodes[l] ^ nodes[r]]; return max(ans[s][l] + ans[s][r], max(preans[s][l], preans[s][r])); } else return ints[l]; } } #define CT CatsTree void init() { read(n); while (real &lt; n) real &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) read(ints[i]); CT::BuildTree(1, 1, real, 1); CT::MakeLog(); } void solving() { read(m); for (int i = 0, l, r; i &lt; m; ++i) read(l, r), write(io_l, CT::GetAnswers(l, r)); } signed main() { init(); solving(); }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---ç¬›å¡å°”æ ‘ï¼ˆå¨±ä¹å‘","slug":"DS100P-CARTESIAN-TREE","date":"2020-02-07T17:55:22.000Z","updated":"2020-04-16T18:01:45.770Z","comments":true,"path":"2020/02/08/DS100P-CARTESIAN-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-CARTESIAN-TREE/","excerpt":"","text":"0x00 å‰è¨€è¿™ä¸ªä¸œè¥¿æ¿å­è¿˜æ˜¯æ¯”è¾ƒç®€å•ï¼Œå½“å¨±ä¹å‘çš„DS100Pçœ‹å§ã€‚ 0x01 æ¦‚å¿µç¬›å¡å°”æ ‘çš„æ¯ä¸ªç»“ç‚¹éƒ½å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªäºŒå…ƒç»„ $(k,w)$ã€‚ä¸¤ä¸ªå…ƒç´ åˆ†åˆ«æ»¡è¶³ä¸åŒçš„æ€§è´¨ï¼š$k$ æ»¡è¶³BSTçš„æ€§è´¨ï¼Œ$w$ æ»¡è¶³å †æ€§è´¨ã€‚ç›—ä¸€å¼ ç»´åŸºç™¾ç§‘çš„å›¾ï¼š å¦‚ä¸Šå›¾ï¼Œæˆ‘ä»¬æŠŠæ•°ç»„çš„ä¸‹æ ‡å½“ä½œäº† $k$ï¼ŒæŠŠåºåˆ—å€¼å½“ä½œäº† $w$ï¼Œæ‰‹æ¨ä¸€ä¸‹å‘ç°éƒ½æ»¡è¶³å¯¹åº”çš„æ€§è´¨ã€‚å·®ä¸å¤štreapå¯ä»¥è¯´æ˜¯ç¬›å¡å°”æ ‘çš„ä¸€ç§ï¼š$w$ å…¨éšæœºã€‚ 0x02 æ„å»ºç¬›å¡å°”æ ‘çš„æ„å»ºæ¯”è¾ƒå¥½ç†è§£ï¼šæ¯åŠ å…¥ä¸€ä¸ªå…ƒç´ ï¼Œå°±å…ˆæ”¾åˆ°ç¬›å¡å°”æ ‘æœ€å³è¾¹çš„é“¾çš„å¶å­èŠ‚ç‚¹ä¸Šå»ï¼Œç„¶åæ ¹æ®æ€§è´¨è°ƒæ•´ã€‚ç”¨å•è°ƒé˜Ÿåˆ—å¯ä»¥è¾¾åˆ° $\\Theta(n)$ã€‚ void build() { stack[++top] = 0; for (int i = 1; i &lt;= n; ++i) { int now = top; while (now &gt; 0 &amp;&amp; a[stack[now]] &gt; a[i]) --now; if (now) t[stack[now]].r = i; if (now &lt; top) t[i].l = stack[now + 1]; stack[top = ++now] = i; } } 0x03 ç»“å°¾ï¼ˆé›¾å•Šï¼ŒçœŸå°±è¿™ä¹ˆç‚¹ã€‚é¢˜ä»€ä¹ˆçš„åšåšå°±å¥½ï¼Œåæ­£ç®€å•ä½ éšä¾¿åˆ‡ï¼Œéš¾çš„ä½ ä¹Ÿåšä¸æ¥ã€‚ è¿˜æ˜¯ä¸¢é“æ¿é¢˜å§ï¼šhttps://www.luogu.com.cn/problem/P5854 å‚è€ƒä»£ç ï¼š #include &lt;cstdio&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is() (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; class Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is())) if (ch == &#39;-&#39;) f = 1; while (is()) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; class Type, class... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } const int N = 1e7 + 5; int n, top, a[N], stack[N]; struct { int l, r; } t[N]; void build() { stack[++top] = 0; for (int i = 1; i &lt;= n; ++i) { int now = top; while (now &gt; 0 &amp;&amp; a[stack[now]] &gt; a[i]) --now; if (now) t[stack[now]].r = i; if (now &lt; top) t[i].l = stack[now + 1]; stack[top = ++now] = i; } } signed main() { read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); build(); long long ans1 = 0, ans2 = 0; for (int i = 1; i &lt;= n; ++i) ans1 ^= (i * (1ll * t[i].l + 1)), ans2 ^= (i * (1ll * t[i].r + 1)); return printf(&quot;%lld %lld\\n&quot;, ans1, ans2), 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"ç¬›å¡å°”æ ‘","slug":"ç¬›å¡å°”æ ‘","permalink":"www.orchid-any.cf/tags/ç¬›å¡å°”æ ‘/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---K-D Tree","slug":"DS100P-K-D-TREE","date":"2020-02-07T12:03:42.000Z","updated":"2020-02-20T02:48:47.124Z","comments":true,"path":"2020/02/07/DS100P-K-D-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-K-D-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Sqrt-Tree","slug":"DS100P-SQRT-TREE","date":"2020-02-07T10:49:19.000Z","updated":"2020-02-20T02:48:47.133Z","comments":true,"path":"2020/02/07/DS100P-SQRT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SQRT-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å—çŠ¶æ•°ç»„","slug":"DS100P-BLOCK-ARRAY","date":"2020-02-07T10:48:41.000Z","updated":"2020-02-20T02:48:47.106Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-ARRAY/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å—çŠ¶é“¾è¡¨","slug":"DS100P-BLOCK-LIST","date":"2020-02-07T10:48:26.000Z","updated":"2020-02-20T02:48:47.107Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-LIST/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-LIST/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘ä¸Šåˆ†å—","slug":"DS100P-TREE-FENKUAI","date":"2020-02-07T10:43:01.000Z","updated":"2020-02-20T02:48:47.138Z","comments":true,"path":"2020/02/07/DS100P-TREE-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-FENKUAI/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€è‡ªåŠ¨æœº","slug":"DS100P-SUFFIX-AUTOMATON","date":"2020-02-07T10:14:33.000Z","updated":"2020-02-20T02:48:47.134Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-AUTOMATON/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-AUTOMATON/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ ‘","slug":"DS100P-SUFFIX-TREE","date":"2020-02-07T10:14:14.000Z","updated":"2020-02-20T02:48:47.135Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---ä¸»å¸­æ ‘","slug":"DS100P-CHAIRMAN-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.109Z","comments":true,"path":"2020/02/07/DS100P-CHAIRMAN-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHAIRMAN-TREE/","excerpt":"","text":"ä¸»å¸­æ ‘($nlogn$) â€œä½ æ˜¯ä¸»å¸­æ ‘å—ï¼Ÿæœ‰é‚£ä¹ˆå¤šçˆ·çˆ·ï¼â€â€”â€”$LJS$ã€‚ è¿™å¥è¯è¿ç”¨æ‰“æ¯”æ–¹çš„è¯´æ˜æ–¹æ³•ï¼Œç”ŸåŠ¨å½¢è±¡åœ°è¯´æ˜äº†ä¸»å¸­æ ‘æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¾ˆå¤šçˆ¶äº²çš„ç‰¹ç‚¹ï¼Œä½“ç°è¯´æ˜è¯­è¨€çš„ç”ŸåŠ¨æ€§ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸»å¸­æ ‘çš„å‡ ä¸ªèŠ‚ç‚¹å¯èƒ½å…±ç”¨ä¸€ä¸ªå­èŠ‚ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š ä¸»å¸­æ ‘å¯ä»¥ç”¨æ¥æŸ¥è¯¢é™æ€åŒºé—´ç¬¬kå°ï¼Œé™æ€åŒºé—´å‰kå¤§çš„å’Œç­‰ç­‰ã€‚ï¼ˆç”¨æ³•ååˆ†çµæ´»ï¼‰ æˆ‘ä»¬ä¼šåˆ›å»ºå¾ˆå¤šç‰ˆæœ¬çš„æ ‘ï¼Œä¸€äº›ç‰ˆæœ¬ä¼šå…±ç”¨ä¸€äº›èŠ‚ç‚¹ï¼Œä»¥èŠ‚çœç©ºé—´å’Œæ—¶é—´ã€‚ ä¸»å¸­æ ‘ä¹Ÿå«å¯æŒä¹…åŒ–çº¿æ®µæ ‘ã€‚ä½†å¯æŒä¹…åŒ–è¿˜æœ‰å¾ˆå¤šä¸œè¥¿ã€‚æˆ‘å°±è®²å¯æŒä¹…åŒ–çº¿æ®µæ ‘å§ã€‚ 1.å¦‚ä½•å…±ç”¨èŠ‚ç‚¹æˆ‘ä»¬è€ƒè™‘å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ã€‚ å¦‚æœè¦å¾—åˆ°è¿™ä¸ªåºåˆ—æŸä¸ªå…ƒç´ $x$åŠ ä¸Šä¸€ä¸ªå€¼$val$ä¹‹åçš„æ–°ç‰ˆæœ¬ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæ”¹å˜çš„åªæœ‰å¯¹åº”å…ƒç´ $x$çš„èŠ‚ç‚¹å’Œä»–çš„ç¥–å…ˆä¼šåŠ ä¸Š$val$ã€‚é‚£ä¹ˆå…¶ä»–èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥ä¸ä¸Šä¸€ä¸ªç‰ˆæœ¬å…±ç”¨ã€‚ æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§æ‰¿ä¹‹å‰è¯¥ä½ç½®çš„å€¼å’Œå·¦å³å„¿å­ï¼Œç„¶åæ›´æ–°å€¼ï¼Œå†ç»§ç»­å‘ä¸‹å¯»æ‰¾å…ƒç´ $x$çš„ä½ç½®ï¼Œæœ€åé€’å½’å›æ¥æ›´æ–°è¿™ä¸ªå„¿å­ã€‚ æˆ‘ä»¬ä½¿ç”¨$root$æ•°ç»„æ¥è®°å½•æ¯ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ç¼–å·ã€‚ ä»£ç ï¼š void ins(int l,int r,int pre,int &amp;now,int pos,int val)//åŒºé—´å·¦å³ç«¯ç‚¹ï¼Œä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œå½“å‰ç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œä¿®æ”¹ä½ç½®ï¼Œå¢åŠ çš„å€¼ã€‚ { nodes[++tot]=nodes[pre];//å…ˆæ•´ä¸ªå¤åˆ¶ now=tot;//æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å„¿å­ã€‚ nodes[now].sum+=val;//æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å€¼ if(l==r) return; //å‘ä¸‹ç»§ç»­å¯»æ‰¾ int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //è°ƒç”¨ï¼šins(1,n,root[i-1],root[i],p,v); æœ€å$root[i]$çš„å¼•ç”¨å°±ç›¸å½“äºè®°å½•äº†è¿™ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ã€‚ æŸ¥è¯¢å…¶å®å°±å’Œæ™®é€šçš„çº¿æ®µæ ‘ä¸€æ ·ï¼Œä½†ä¸»å¸­æ ‘çš„ç”¨é€”ä¸æ­¢è¿™ä¸ªã€‚ 2.ä¾‹é¢˜ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ 1ï¼ˆä¸»å¸­æ ‘ï¼‰ å¦‚é¢˜ï¼Œç»™å®š $n$ ä¸ªæ•´æ•°æ„æˆçš„åºåˆ—ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬ $k$ å°å€¼ã€‚ æƒå€¼çº¿æ®µæ ‘ï¼š (çº¿æ®µæ ‘çš„å¦ä¸€ç§åº”ç”¨ï¼Œåªæ˜¯æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æ•´ä¸ªåºåˆ—å€¼åœ¨$[l,r]$åŒºé—´å†…çš„æ•°çš„ä¸ªæ•°) è¿™é“é¢˜è¦æ±‚æŸ¥è¯¢é™æ€åŒºé—´ç¬¬$k$å°ã€‚é‚£ä¹ˆå¯¹äºç¬¬$k$å°è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ ç¦»æ•£åŒ–ï¼š$-1e9\\leq a_i \\leq1e9$ çš„æ•°æ®çº¿æ®µæ ‘è‚¯å®šå¼€ä¸ä¸‹ï¼Œä½†è¿™é“é¢˜åªéœ€è¦æ±‚ç¬¬kå°ï¼Œæ²¡æœ‰å¿…è¦å¼€é‚£ä¹ˆå¤§ï¼Œå¯ä»¥å¯¹æ•°æ®è¿›è¡Œç¦»æ•£åŒ–ã€‚ æˆ‘ä»¬æŒ‰ç…§åºåˆ—çš„é¡ºåºæ’å…¥$a_i$ã€‚å¾—åˆ°æ¯ä¸ª$root[i]$ä»£è¡¨çš„æƒå€¼çº¿æ®µæ ‘ä»£è¡¨ä»$a_1$åˆ°$a_i$çš„æ¯ä¸ªæ•°å€¼çš„å‡ºç°æ¬¡æ•°ã€‚ é‚£ä¹ˆæ ¹æ®å‰ç¼€å’Œçš„æ€æƒ³ï¼ŒåŒºé—´$[l,r]$ä¸­æ¯ä¸ªæ•°å€¼çš„å‡ºç°ä¸ªæ•°å°±æ˜¯$[1,r]$çš„å‡å»$[1,l-1]$çš„ã€‚é‚£ä¹ˆæ•°å€¼çš„åŒºé—´ä¹Ÿå…·æœ‰è¿™ä¸ªæ€§è´¨ã€‚ æ‰€æœ‰å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæˆ‘ä»¬åªéœ€è¦æŸ¥è¯¢ä¸€æ¬¡ï¼Œç”¨$root[r]$å’Œ$root[l-1]$çš„æƒå€¼çº¿æ®µæ ‘å¤„ç†å‡ºåŒºé—´$[l,r]$åº”æœ‰çš„æƒå€¼çº¿æ®µæ ‘ï¼Œå°±å¯ä»¥åƒæ­£å¸¸çš„æƒå€¼çº¿æ®µæ ‘ä¸€æ ·æŸ¥è¯¢ç¬¬kå°äº†ã€‚ ä»£ç ï¼š #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//æ’å…¥ï¼Œåˆ›å»ºæ–°ç‰ˆæœ¬ { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//ç°åœºå¤„ç†ï¼Œå¾—åˆ°[x,y]åŒºé—´å†…ï¼Œå€¼åœ¨[l,mid]å†…çš„æ•°çš„ä¸ªæ•° if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//å¦‚æœk&lt;=X.è¯´æ˜ç¬¬kå°çš„æ•°åœ¨å·¦è¾¹ã€‚ else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//å¦åˆ™åœ¨å³è¾¹ã€‚ } int getid(int X)//å¾—åˆ°ç¦»æ•£åŒ–åçš„æ•°å€¼ { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//ç¦»æ•£åŒ– for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//æŒ‰é¡ºåºæ’å…¥æ¯ä¸ªå€¼ï¼Œå¾—åˆ°root[i]å¯¹åº”çš„æƒå€¼çº¿æ®µæ ‘ã€‚ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//æŸ¥è¯¢åŒºé—´[x,y]ï¼›è¾“å‡ºåŸå€¼ } return 0; } 3.ç¼ºç‚¹åŠæ³¨æ„äº‹é¡¹å†…å­˜æ± ä¸€èˆ¬ä»1å¼€å§‹ç”¨ï¼Œ$nodes[0]$ä½œä¸ºç©ºç™½ï¼Œå€¼ä¸º$0$ï¼Œå„¿å­èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼Œå€¼è¿˜æ˜¯ä¸º$0$ã€‚ å½“ä½ è¿™ä¸ªç‰ˆæœ¬çš„æ ‘è¿˜æ²¡æœ‰æ”¹è¿‡æŸä¸ªèŠ‚ç‚¹çš„æŸä¸ªå„¿å­æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹çš„è¿™ä¸ªå„¿å­ä¼šæŒ‡å‘$nodes[0]$ï¼Œä¹Ÿå°±ç›¸å½“äºä¸‹é¢éƒ½æ˜¯$0$ï¼Œæ­£å¥½ç¬¦åˆã€‚ æ•°ç»„ä¸€å®šè¦å¼€å¤§ï¼Œå¦‚æœå¼€å¾—ä¸å¤Ÿå¤§å¯èƒ½ä¼šå‡ºç°$MLE$,$TLE$,$RE$,$WA$. ä½†ä¹Ÿä¸è¦å¼€å¤ªå¤§ï¼Œä¸ç„¶ä¼š$MLE$,$CE$. ä¸»å¸­æ ‘æ˜¯é™æ€çš„ï¼Œé‡åˆ°è¦åŠ¨æ€ä¿®æ”¹è€Œä¸æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°ç‰ˆæœ¬çš„é—®é¢˜ï¼Œå°±å¯èƒ½è¦ç”¨æ ‘å¥—æ ‘äº†ã€‚ å¯æŒä¹…åŒ–å¯ä»¥ç”¨åœ¨å¾ˆå¤šæ•°æ®ç»“æ„ä¸Šï¼Œå¹³è¡¡æ ‘ï¼Œçº¿æ®µæ ‘ï¼Œ$trie$æ ‘â€¦â€¦å¯å¤Ÿå¾—å†™ï¼Œä½†å®ƒä»¬çš„æ€æƒ³éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œéƒ½æ˜¯æ¯ä¸ªç‰ˆæœ¬ä¸ä¹‹å‰çš„ç‰ˆæœ¬å…±ç”¨èŠ‚ç‚¹ä»¥èŠ‚çœæ—¶é—´ï¼Œç©ºé—´ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Chtholly-Tree(Old-Driver Tree)","slug":"DS100P-CHTHOLLY-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.110Z","comments":true,"path":"2020/02/07/DS100P-CHTHOLLY-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHTHOLLY-TREE/","excerpt":"","text":"Chtholly-Treeä¼—æ‰€å‘¨çŸ¥ï¼Œæ•°æ®ç»“æ„+ç®—æ³•=ç¨‹åºï¼Œå¯è§æ•°æ®ç»“æ„çš„é‡è¦æ€§æ•°æ®ç»“æ„å äº†æˆ‘ä»¬ç¼–ç¨‹çš„ä¸€å¤§éƒ¨åˆ†ã€‚æ•°æ®ç»“æ„çš„å¤§å®¶æ—ä¸­ï¼Œæœ‰ä¼˜ç¾çš„çº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ç­‰ã€‚ä½†æˆ‘ä»¬ä»Šå¤©çš„ä¸»è§’å´ååˆ†æš´åŠ›ã€‚å¥¹çš„åå­—å«ç‚æœµè‰æ ‘ ç‚æœµè‰æ ‘æ˜¯åŸºäºC++STLåº“ä¸­çš„setçš„æ•°æ®ç»“æ„ã€‚ä¸çº¿æ®µæ ‘ã€å¹³è¡¡æ ‘ç­‰æ ‘å½¢ç»“æ„ç±»ä¼¼ï¼Œç‚æœµè‰æ ‘æ˜¯ç”¨æ¥è§£å†³åŒºé—´é—®é¢˜çš„å¾ˆæš´åŠ›çš„æ ‘å½¢ç»“æ„ã€‚ å¥¹çš„ç‰¹ç‚¹æ˜¯èƒ½å¤Ÿè¿›è¡ŒåŒºé—´æ¨å¹³æ“ä½œï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦æ¥è¿‘O(n log m) ã€‚ä½†å‰ææ˜¯æ•°æ®éšæœºã€‚ä½†ä¸€èˆ¬ä¸ä¼šæœ‰å“ªä¸ªå‡ºé¢˜äººå»å¡è¿™æ ·ä¸€ä¸ªå¹¶ä¸å‡ºåçš„æ•°æ®ç»“æ„ã€‚å¹¶ä¸”è¦æœ‰åŒºé—´æ¨å¹³æ“ä½œï¼Œå¦åˆ™å…‰æ˜¯ä¸€ä¸ªsplitæ—¶é—´å¤æ‚åº¦ä¼šç‚¸ã€‚ ç‚æœµè‰æ ‘çš„æ„é€ é•¿æˆè¿™ä¸ªäºšå­: struct Chtholly { LL L; LL R; //åŒºé—´ mutable LL _val; //å€¼ï¼Œæ³¨æ„ï¼Œå…³é”®å­—mutableæ˜¯å¿…éœ€çš„ï¼Œå¦åˆ™ä¼šåœ¨addå‡½æ•°é‡ŒCE node(LL l, LL r = -1, LL V = 0) : L(l), R(r), _val(V) {} bool operator&lt;(const node &amp;rhs) const { return L &lt; rhs.L; } } Splitæ“ä½œ: inline IT split(int k) { IT it = st.lower_bound(node(k)); if (it != st.end() &amp;&amp; it-&gt;L == k) return it; --it; LL l = it-&gt;L, r = it-&gt;R; LL v = it-&gt;_val; st.erase(it); st.insert(node(l, k - 1, v)); return st.insert(node(k, r, v)).first; } ä¸ºäº†æ“ä½œæ–¹ä¾¿æˆ‘ä»¬è¿™é‡Œæœ‰ä¸€ä¸ªdefine: #define IT set&lt;Chtholly&gt;::iterator assignåŒºé—´æ¨å¹³æ“ä½œï¼Œè¿™ä¹Ÿæ˜¯ç‚æœµè‰æ ‘çš„æ—¶é—´å¤æ‚åº¦ä¿è¯ inline void assign(LL ll, LL rr, LL val) { IT itr = split(rr + 1), itl = split(ll); st.erase(itl, itr); st.insert(node(ll, rr, val)); } ä¸¾å‡ ä¸ªä¾‹å­å§ åŒºé—´æ±‚å’Œ:inline LL Qsum(LL ll, LL rr) { LL res = 0; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) res += (itl-&gt;R - itl-&gt;L + 1) * itl-&gt;_val; return res; } åŒºé—´ç¬¬Kå°:inline LL kth(LL ll, LL rr, LL k) { vector&lt;pair&lt;LL, LL&gt; &gt; vec; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) vec.push_back(pair&lt;LL, LL&gt;(itl-&gt;_val, itl-&gt;R - itl-&gt;L + 1)); sort(vec.begin(), vec.end()); for (auto it = vec.begin(); it != vec.end(); ++it) { k -= it-&gt;second; if (k &lt;= 0) return it-&gt;first; } return -1; } åŒºé—´åŠ inline void add(LL ll, LL rr, LL ad) { IT itr = split(rr + 1), itl = split(ll); for (; itr != itl; ++itl) itl-&gt;_val += ad; } å¹³æ—¶å¤§å®¶è¿˜æ˜¯å°½é‡å°‘ç”¨Â·Â·Â·Â·Â·Â·","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åˆ†å—","slug":"DS100P-FENKUAI","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.112Z","comments":true,"path":"2020/02/07/DS100P-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-FENKUAI/","excerpt":"","text":"åˆ†å—($n\\sqrt n$) åˆ†å—å…¶å®ä¹Ÿæ˜¯ä¸€ç§æš´åŠ›ï¼Œä½†å®ƒæ˜¯ä¸€ç§å·§å¦™çš„æš´åŠ› å®ƒç”¨æ¥å¤„ç†åŒºé—´çš„é—®é¢˜ã€‚ æŠŠè¿™ä¸ªåŒºé—´å¤§æ¦‚åˆ†æˆ$\\sqrt n$å— ç„¶åå†å¤„ç†ï¼šå¯¹äºä¸€ä¸ªæ•´å—ï¼Œå°±æ•´ä¸ªå¤„ç†æ‰ï¼›å¯¹äºä¸€ä¸ªè§’å—ï¼ˆä¸å®Œæ•´çš„å—ï¼‰ï¼Œå°±æš´åŠ›å¤„ç†ã€‚ æ¯”å¦‚åŒºé—´æ±‚å’Œã€‚(éä¸»æµå†™æ³•å‹¿å–·) 1.åˆå§‹åŒ–å¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬è¦å¤„ç†å‡ºå®ƒæ˜¯å“ªä¸ªå—çš„ï¼Œä»¥ä¾¿ä¹‹åå¿«é€Ÿåœ°æ‰¾åˆ°å®ƒæ‰€åœ¨çš„å—ã€‚ å¯¹äºæ¯ä¸ªå—ï¼Œæˆ‘ä»¬è¦ç»Ÿè®¡å‡ºä¹‹åè®¡ç®—ç­”æ¡ˆæ‰€éœ€è¿™ä¸ªå—å†…çš„ç»“æœï¼ˆè¿™é‡Œå°±æ˜¯å—å†…åŒºé—´å’Œï¼‰ï¼Œåœ¨åŒºé—´ä¸­çš„å·¦å³ç«¯ç‚¹ï¼Œä»¥åŠåŒºé—´ä¿®æ”¹çš„æ‡’æ ‡è®°ã€‚ ä»£ç ï¼š struct cude { int l,r,sum,lazy;//å·¦å³ç«¯ç‚¹ï¼ŒåŒºé—´å’Œï¼Œæ‡’æ ‡è®° }cud[400]; int n,a[100010],bel[100010],each,cnt;//åŸæ•°ç»„å¤§å°åŠå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ çš„å—ç¼–å·ï¼Œå—å¤§å°ï¼Œå—æ•° void build() { each=sqrt(n); for(int i=0;i&lt;n;++i)//æ³¨æ„ï¼Œæˆ‘æ˜¯ä»0å¼€å§‹å­˜çš„åŸæ•°ç»„ { bel[i]=i/each;//é¢„å¤„ç†å…ƒç´ å±äºå— cud[bel[i]].sum+=a[i];//åŒºé—´å’Œ } for(int i=0;i*each&lt;n;++i) { ++cnt;//ç»Ÿè®¡å—æ•° cud[i].l=i*each;//å—å·¦ç«¯ç‚¹ cud[i].r=min((i+1)*each-1,n-1);//å—å³ç«¯ç‚¹ï¼Œä¸å¯èƒ½è¾¾åˆ°nï¼Œæ‰€ä»¥å–minï¼Œæœ€å¤šåˆ°n-1 } } 2.ä¿®æ”¹ä¿®æ”¹æ˜¯å¾ˆæš´åŠ›çš„ï¼Œæˆ‘ä»¬å¯¹è¿™ä¸ªåŒºé—´è¿›è¡Œæ‰«æã€‚ æ•´å—å°±åŒºé—´ä¿®æ”¹ï¼Œæ‡’æ ‡è®°ã€‚ è§’å—å°±ç›´æ¥æš´åŠ›æ‰«è¿‡å»ä¿®æ”¹ã€‚ æœ€å¤š$\\sqrt n$ä¸ªæ•´å—ï¼Œæ‰“æ‡’æ ‡è®°$O(1)$ï¼Œå¤æ‚åº¦ä¸º$O(\\sqrt n)$ æœ€å¤š$2$ä¸ªè§’å—ï¼Œä¸€ä¸ªè§’å—æœ€å¤š$\\sqrt n$ä¸ªå…ƒç´ ï¼Œæš´åŠ›ä¿®æ”¹$O(\\sqrt n)$ åŒºé—´ä¿®æ”¹æ€»æ—¶é—´å¤æ‚åº¦$O(\\sqrt n)$ ä»£ç ï¼š void update(int l,int r,int val) { for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i)//æ³¨æ„ä¸è¦è¶…è¿‡å—æ•°ï¼Œæˆ‘çš„å—æ˜¯ä»0å¼€å§‹ç¼–å·çš„ { if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r)//æ•´å—æ‰“æ‡’æ ‡è®° { cud[i].lazy+=val; cud[i].sum+=(cud[i].r-cud[i].l+1)*val; } else//è§’å—æš´åŠ›æ‰« { if(cud[i].l&lt;l)//å±äºæ•´ä¸ªåŒºé—´çš„æœ€å·¦è¾¹çš„è§’å—ï¼Œä½†è¿˜å¯èƒ½æ˜¯æœ€å³è¾¹çš„è§’å—ï¼Œéœ€è¦åˆ¤æ–­ä¸è¦è¶…å‡ºä¿®æ”¹åŒºé—´çš„å³ç«¯ç‚¹ { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } else//ä¸æ˜¯æœ€å·¦è¾¹çš„ï¼Œé‚£è‚¯å®šæ˜¯æœ€å³è¾¹çš„ã€‚ { for(int j=cud[i].l;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } } } } 3.æŸ¥è¯¢æŸ¥è¯¢ä¹Ÿæ˜¯å¾ˆæš´åŠ›çš„ã€‚ åŒæ ·å¯¹è¿™ä¸ªåŒºé—´è¿›è¡Œæ‰«æã€‚ å¦‚æœæ˜¯æ•´å—ï¼Œå°±ç›´æ¥åŠ ä¸Šè¿™ä¸ªå—çš„åŒºé—´å’Œã€‚ å¦‚æœæ˜¯è§’å—ï¼Œå°±è¦å…ˆä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå†æš´åŠ›æŸ¥è¯¢ã€‚ å› ä¸ºæˆ‘ä»¬ä¹‹å‰å¹¶æ²¡æœ‰ä¿®æ”¹å…ƒç´ å€¼ï¼Œåªæ˜¯åŠ ä¸Šäº†æ‡’æ ‡è®°ï¼Œä¿®æ”¹äº†åŒºé—´å’Œã€‚ æ‰€ä»¥æˆ‘ä»¬ç°åœ¨è¦å…ˆä¿®æ”¹è¿™äº›å…ƒç´ çš„å€¼å†æŸ¥è¯¢ï¼Œå¦åˆ™æŸ¥è¯¢åˆ°çš„å€¼æ˜¯ä¿®æ”¹ä¹‹å‰çš„ã€‚ æ—¶é—´å¤æ‚åº¦ä¸ä¿®æ”¹ç›¸åŒï¼Œéƒ½æ˜¯$O(\\sqrt n)$ï¼› ä»£ç ï¼š //ç»†èŠ‚åŒ2.ä¿®æ”¹ int find(int l,int r) { int res=0; for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i) if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r) res+=cud[i].sum; else { if(cud[i].lazy)//ä¸‹ä¼ æ‡’æ ‡è®° { for(int j=cud[i].l;j&lt;=cud[i].r;++j) a[j]+=cud[i].lazy; cud[i].lazy=0; } if(cud[i].l&lt;l) { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) res+=a[j]; } else { for(int j=cud[i].l;j&lt;=r;++j) res+=a[j]; } } } return res; } 4.æ€»ç»“ä½ çœ‹ç€è¿™ä¸ªä¸œè¥¿å¥½åƒå¾ˆæš´åŠ›ï¼Œä½†å®ƒå°±æ˜¯è·‘å¾—è¿‡é¢˜ã€‚ å®ƒçš„æ€»æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\sqrt n)$çš„ï¼Œ$500000$åŠä»¥ä¸Šå°±åˆ«æƒ³å•¦ã€‚ åˆ†å—çš„é¢˜ç›®å¾ˆçµæ´»ï¼Œä½†ä¸€èˆ¬éƒ½å¾ˆæš´åŠ›ï¼Œæœ‰æ—¶åŒºé—´ä¿®æ”¹ä¸èƒ½æ‰“æ‡’æ ‡è®°ï¼Œå°±å¿…é¡»æš´åŠ›ä¿®æ”¹ï¼Œä½†æœ‰æ—¶ä½ åˆå¯ä»¥è·³è¿‡è¿™ä¸ªä¿®æ”¹ï¼Œè¿›è¡Œâ€œå‰ªæâ€ã€‚ å°±åƒèŠ±ç¥æ¸¸å†å„å›½ï¼ŒåŒºé—´å¼€æ–¹å¿…é¡»è¦åœ¨å—é‡Œå»æš´åŠ›å¼€ ä½†æˆ‘ä»¬æƒ³ï¼Œ$1$å’Œ$0$å¼€æ–¹åéƒ½æ˜¯æœ¬èº«ï¼Œå…¶å®ƒæ•°å¼€æ–¹å°±ä¼šå˜å¾—è¶Šæ¥è¶Šå°ï¼Œæœ€ååˆ°$1$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå—å†…æ˜¯å¦å…¨æ˜¯$1$æˆ–$0$ã€‚ å¦‚æœæ˜¯ï¼Œå°±å¯ä»¥è·³è¿‡åœ¨è¿™ä¸ªåŒºé—´é‡Œè¿›è¡Œå¼€æ–¹äº†ï¼Œå› ä¸ºè¿™ä¸ªå—é‡Œçš„å…ƒç´ å¼€æ–¹ä¹‹åéƒ½è¿˜æ˜¯æœ¬èº«ï¼Œæ¯ä¸ªå…ƒç´ å’ŒåŒºé—´å’Œéƒ½æ²¡æœ‰å˜ã€‚ å…¶ä»–çš„å°±æ˜¯æ™®é€šåˆ†å—ã€‚ $\\ $ åœ¨åˆ†å—ï¼Œä½ ç”šè‡³å¯ä»¥æ‰“è¡¨ åœ¨åŒºé—´ä¸­é€‰å–$\\sqrt n$ä¸ªç‰¹å¾ç‚¹ï¼Œå¤„ç†å‡ºå®ƒä»¬é—´çš„ä¿¡æ¯ã€‚ å¯¹æ¯ä¸ªæŸ¥è¯¢ï¼Œé€‰å–æœ€è¿‘çš„ä¸¤ä¸ªç‰¹å¾ç‚¹çš„ä¿¡æ¯å†ä»è¿™ä¸¤ä¸ªç‰¹å¾ç‚¹æš´åŠ›è·³è¿‡å»ã€‚ è¿™æ ·å°±å¯ä»¥ä»£æ›¿è«é˜Ÿå•¦ã€‚ è€Œä¸”åˆ†å—æ²¡æœ‰ä»»ä½•ç¦»çº¿æ“ä½œï¼Œå¯ä»¥åº”å¯¹çœ‹èµ·æ¥åƒè¦ç”¨è«é˜Ÿï¼ˆç¦»çº¿ç®—æ³•ï¼ŒåŒæ ·$O(n\\sqrt n)$ï¼‰æ‰èƒ½è§£å†³ï¼Œä½†åˆå¼ºåˆ¶åœ¨çº¿çš„é¢˜ç›®ã€‚ ä»¥åŠï¼Œæ•´é™¤åˆ†å—ä¸æ˜¯æ•°æ®ç»“æ„ï¼Œæ˜¯æ•°è®ºï¼ï¼ï¼","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---KMP","slug":"DS100P-KMP-STRING","date":"2020-02-07T06:51:04.000Z","updated":"2020-03-22T05:58:03.113Z","comments":true,"path":"2020/02/07/DS100P-KMP-STRING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-KMP-STRING/","excerpt":"","text":"KMPupd:ä»£ç é”…å·²è¡¥ 0x00 å‰è¨€æœ¬æ–‡å’ŒæŸæ’­æ”¾è½¯ä»¶KMPlayeræ²¡æœ‰ä¸€æ¯›é’±å…³ç³»ï¼Œå¹¶ä¸”ï¼š ä¼¦å®¶æ˜¯æ•°æ®ç»“æ„ï¼ 0x01 å¼•å…¥é—®é¢˜è®¾æƒ³è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè®©ä½ æŸ¥æ‰¾åœ¨æ–‡æœ¬ä¸²ä¸­æ¨¡å¼ä¸²çš„ä½ç½®ã€‚ æš´åŠ›åšæ³•æ˜¯æ˜¾ç„¶çš„ï¼Œä¸¾ä¾‹æ¥è¯´ï¼š æ–‡æœ¬ä¸²(text)ï¼š$\\texttt{a b c b c g l x}$ æ¨¡å¼ä¸²(pattern): $\\texttt{b c g l}$ æˆ‘ä»¬ç›´æ¥æš´åŠ›æšä¸¾textä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”ä¾æ¬¡ä¸patternä¸­çš„å­—ç¬¦ä»å¤´å¼€å§‹åŒ¹é…ã€‚æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(nm)$ 0x02 å‘ç°é—®é¢˜è¿™æ ·åšå…¶å®æœ‰å¾ˆå¤šå†—ä½™æ“ä½œã€‚æ¯”å¦‚è¯´ï¼š$\\texttt{b c g l}$ ä¸textä¸­çš„ $\\texttt{b c b c}$ ä¸åŒ¹é…ï¼Œåˆä»ç¬¬textçš„ç¬¬äº”ä¸ªå­—æ¯ $\\texttt{c}$ å¼€å§‹åŒ¹é…ã€‚è¿™æ ·åšæ˜¯æ˜¾ç„¶ä¸å¿…è¦çš„ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºæ¨¡å¼ä¸²æ˜¯ä»¥ $\\texttt{b}$ å¼€å¤´çš„ï¼Œå¯¹äºtextä¸­ç¬¬äº”ä¸ªå­—æ¯ $\\texttt{c}$ æ˜¾ç„¶æˆ‘ä»¬å¯ä»¥ä¸å»åŒ¹é…ã€‚å‘ç°äº†ä»€ä¹ˆå—ï¼Ÿæ¯æ¬¡å¤±é…åæˆ‘ä»¬åªéœ€è¦ä»ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±éƒ¨åˆ†å¼€å§‹åŒ¹é…å³å¯ã€‚è¿™é‡Œçœ‹ä¸æ‡‚æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œåªè¦èƒ½ç†è§£åé¢çš„ä¾‹å­å°±å¯ä»¥äº†ã€‚ 0x03 è§£å†³ä¸€éƒ¨åˆ†é—®é¢˜$\\qquad\\qquad\\quad\\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5\\ \\ 6\\ \\ 7\\ \\ 8\\ \\ 9\\ 10\\ 11$ æ–‡æœ¬ä¸²(text)ï¼š $\\texttt{a b x a b c a b c a b y}$ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ æ¨¡å¼ä¸²(pattern)ï¼š $\\texttt{a b c a b y}$ æˆ‘ä»¬æœ‰ä¸¤ä¸ªæŒ‡é’ˆiå’Œjï¼Œåˆ†åˆ«æŒ‡å‘æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²ã€‚åœ¨i=0,j=0ä»¥åŠi=1,j=1çš„æ—¶å€™éƒ½åŒ¹é…ä¸Šäº†ã€‚ä½†æ˜¯åœ¨i=2,j=2æ—¶å¤±é…äº†ã€‚å¦‚æœæ—¶æœ´ç´ ç®—æ³•çš„è¯ä¼šä»¤i=1,j=0é‡æ–°å¼€å§‹åŒ¹é…ã€‚ç„¶è€Œæˆ‘ä»¬å‘ç°æˆ‘ä»¬å®Œå…¨å¯ä»¥ä»¤i=3,j=0æ¥é‡æ–°åŒ¹é…ã€‚ä¸€ç›´åˆ°i=8,j=5æ—¶ï¼Œå®ƒä»¬åˆå¤±é…äº†ã€‚æˆ‘ä»¬ä»¤jç­‰äºæ¨¡å¼ä¸²å’Œæ–‡æœ¬ä¸²å·²ç»é…å¯¹å®Œæˆçš„éƒ¨åˆ†(å³pattern[0]~pattern[4])çš„æœ€é•¿å…¬å…±å‰ç¼€åç¼€(å³pattern[0,1]å’Œpattern[3,4])çš„å‰ç¼€æœ«å°¾éƒ¨åˆ†+1(å³1+1=2)çš„åœ°æ–¹ï¼Œæ­¤æ—¶çš„text[6,7]å’Œpattern[0,1]éƒ½æ˜¯abä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ç›´æ¥ä»i=8,j=2å¼€å§‹åŒ¹é…ï¼Œå°±å¯ä»¥åŒ¹é…åˆ°æ¨¡å¼ä¸²äº†ã€‚è¿™å°±æ˜¯KMPç„å¦™çš„åœ°æ–¹ã€‚ 0x04 è§£å†³å¦ä¸€éƒ¨åˆ†é—®é¢˜é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼šæˆ‘ä»¬å¦‚ä½•ç¡®å®šæ¨¡å¼ä¸²æœ€é•¿å…¬å…±å‰åç¼€çš„å‰ç¼€æœ«å°¾+1çš„ä½ç½®å‘¢ï¼Ÿæˆ‘ä»¬è¿˜æ˜¯é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥æ„Ÿå—ã€‚ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ æ¨¡å¼ä¸²(pattern)ï¼š $\\texttt{a b c a b y}$ (æ²¡é”™å°±æ˜¯ä¸Šé¢é‚£ä¸ªæˆ‘å¤ªæ‡’äº†) æˆ‘ä»¬å¯ä»¥è®¾æ•°ç»„$next_i$ä¸ºä»¥ $i$ ä¸ºç»“å°¾çš„æ¨¡å¼ä¸²æœ€é•¿å…¬å…±å‰åç¼€çš„å‰ç¼€æœ«å°¾+1çš„ä½ç½®ã€‚ $next_0$æ˜¾ç„¶ä¸º0ã€‚ æˆ‘ä»¬ä¾ç„¶è®¾ä¸¤ä¸ªæŒ‡é’ˆiå’Œjï¼Œiåˆå§‹åŒ–ä¸º0ï¼Œå³æŒ‡å‘æ¨¡å¼ä¸²çš„å¼€å¤´ã€‚jåˆå§‹åŒ–1ï¼Œå³iåé¢ä¸€ä¸ªã€‚ pattern[i]ä¸ç­‰äºpattern[j]ï¼Œä»¤next[i]=0ï¼Œj+=1 pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œä»¤next[i]=0ï¼Œj+=1 æ­¤æ—¶pattern[i]ç­‰äºpattern[j]ï¼Œä»¤next[i]=j+1=1ï¼Œi+=1ï¼Œj+=1 æ­¤æ—¶pattern[i]ç­‰äºpettern[j]ï¼Œä»¤next[i]=j+1=2ï¼Œi+=1,j+=1 æ­¤æ—¶pattern[i]ä¸ç­‰äºpatter[j]ï¼Œå¹¶ä¸”jä¸åœ¨æ¨¡å¼ä¸²çš„å¼€å¤´ï¼Œä»¤j=next[j-1]=2 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œå¹¶ä¸”jä¸åœ¨æ¨¡å¼ä¸²çš„å¼€å¤´ï¼Œä»¤j=next[j-1]=0 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œä½†æ˜¯jå·²ç»è·‘åˆ°å¼€å¤´å»äº†ï¼Œä»¤i+=1 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œå¹¶ä¸”iå·²ç»è·‘åˆ°äº†å°½å¤´ï¼Œæ±‚è§£ç»“æŸã€‚ %å‡ºæ¥nextæ•°ç»„æ˜¯è¿™æ ·çš„:$[0,0,0,1,2,0]$ 0x05 è§£å†³æ‰€æœ‰é—®é¢˜å…¶å®å°±æ˜¯æ”¾ä¸€ä¸‹ä»£ç  æˆ‘è‡ªè®¤ä¸ºè®²çš„è¿˜æ˜¯æ¯”è¾ƒæ¸…æ¥šï¼Œè‡³å°‘æ¯”è“ä¹¦å¥½ã€‚ ä»£ç è™½ç„¶å’Œç½‘ä¸Šå…¶ä»–äººçš„ä¸å¤ªä¸€æ ·ï¼Œä¸å¤ªæ ‡å‡†ï¼Œä½†è¿˜ç®—ç®€æ´ï¼Œè‡³å°‘æ¯”è“ä¹¦å¥½ã€‚ æ€»ä¹‹ä¸€å¥è¯ï¼Œå­¦KMPä¸è¦çœ‹ä¹¦ï¼Œä¸è¦çœ‹ä¹¦ï¼Œä¸è¦çœ‹ä¹¦ï¼ï¼ï¼ä¼šæ­»äººçš„ï¼ï¼ï¼ å¯¹äº†è¿˜æœ‰ä¸€ä¸ªå‘ç‚¹ï¼Œæˆ‘è¿™ä»½ä»£ç ç”¨std::stringä¼šREï¼Œé¬¼çŸ¥é“æˆ‘è°ƒäº†ä¸€ä¸‹åˆå‘ç°æ˜¯è¿™ä¸ªåŸå› æ—¶å¿ƒé‡Œæœ‰å¤šå‚»é€¼ /* * P3375ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é….cpp * Created by boringhacker(c20220233wgy) */ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; namespace MAIN { const int SIZE = 1000000 + 5; int next[SIZE], n, m; char Text[SIZE], Pattern[SIZE]; // string Text, Pattern; å»ä½ çš„std::string void GetNextVal() { int i = 1, j = 0; *next = 0; while (i &lt; n) { if (Pattern[i] == Pattern[j]) next[i] = j + 1, ++i, ++j; else if (j) j = next[j - 1]; else ++i; } } void GetAnswers() { int st = 0, res = -1; int i = 0, j = 0, flag = 0; while (true) { j = st; if (Text[i] == Pattern[j]) { if (!flag) res = i + 1 - st, flag = 1; // if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = 0, flag = 0; è¿™é‡Œå‡ºé”…äº†ï¼Œjåº”è¯¥èµ‹ä¸ºnext[j-1] if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = next[j - 1], flag = 0; else ++i, ++j; st = j; if (i &gt;= m) return ; } else { if (j) st = next[j - 1]; else ++i; flag = 0; } } } void MAIN() { cin &gt;&gt; Text; cin &gt;&gt; Pattern; m = strlen(Text); n = strlen(Pattern); GetNextVal(); GetAnswers(); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; next[i] &lt;&lt; &#39; &#39;; } } signed main() { MAIN::MAIN(); return 0; } æ¬¢è¿æ‰è™«å­","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Link-Cut Tree","slug":"DS100P-LINK-CUT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.127Z","comments":true,"path":"2020/02/07/DS100P-LINK-CUT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-LINK-CUT-TREE/","excerpt":"","text":"Link-Cut Tree0x00æœ¬æ–‡çš„å›¾æ¥è‡ªQiulyçš„åšå®¢æµ…è°ˆlink-cut Tree æœ¬æ–‡ç…§æ¬Qiulyçš„åšå®¢æµ…è°ˆlink-cut Tree lctè¿™ä¸œè¥¿ä¸å¥½å†™ï¼Œæˆ‘è¿™ç§è’Ÿè’»å†™ä¸å¥½æ‰€ä»¥åªèƒ½ç…§æ¬Qiulyï¼Œè·ŸQiulyå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯æˆ‘å­—æ˜¯è‡ªå·±æ‰“çš„â€¦â€¦ 0x01LCTå…¶å®å¯ä»¥çœ‹åšåŠ å¼ºç‰ˆçš„é‡é“¾å‰–åˆ†ï¼Œå¯ä»¥è¯´é‡é“¾å‰–åˆ†èƒ½åšçš„LCTéƒ½èƒ½åšã€‚ä¸ä»…å¦‚æ­¤ï¼ŒLCTä»£ç æ¯”é‡é“¾å‰–åˆ†çŸ­ï¼Œå¸¸æ•°æœ‰æ—¶æ¯”é‡é“¾å‰–åˆ†å°ã€‚ LCTç”±å¾ˆå¤šæ£µSplayç»„æˆï¼Œå…¶ä¸­å°†Splayæ£®æ—ä¸­çš„æ‰€æœ‰Splayè¿æ¥èµ·æ¥çš„å«åš è™šè¾¹ ã€‚Splayä¸­è¾¹å«åšå®è¾¹ã€‚ åŸæ¥çš„æ£®æ—æˆ‘ä»¬å«åšåŸæ£®æ—ï¼Œç”¨å®è¾¹è¿èµ·æ¥çš„ä¸€æ£µæ ‘å«åŸæ ‘ã€‚Splayçš„å…³é”®å­—æ˜¯èŠ‚ç‚¹åœ¨ä¹¦ä¸­çš„æ·±åº¦ã€‚ Splayæ˜¯LCTçš„è¾…åŠ©æ ‘ã€‚fhq-treapå…¶å®ä¹Ÿå¯ä»¥ï¼Œä½†å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¼šå¤šå‡ºä¸€ä¸ª\\log 0x02ä»¥ä¸‹æ˜¯ä¸€äº›LCTå¸¸ç”¨çš„åŸºç¡€æ“ä½œ access(x):å°†xåˆ°rootçš„è·¯å¾„ä¸Šçš„è¾¹å…¨éƒ¨å˜æˆå®è¾¹ï¼Œå¹¶æ–­å¼€ä¸è‡ªå·±å„¿å­çš„è”ç³» findroot(x):æ‰¾å‡ºxæ‰€åœ¨åŸæ ‘çš„root makeroot(x):è®©xå˜ä¸ºæ‰€åœ¨åŸæ ‘çš„root connect(x,y):è¿æ¥xå’Œyæ‰€åœ¨çš„åŸæ ‘ erase(x,y):æ‹†å¼€xå’Œyæ‰€åœ¨çš„åŸæ ‘ split(x,y):å°†x,yæåœ¨ä¸€æ£µè¾…åŠ©æ ‘ Access(x): æ¢å¥è¯æ¥è¯´å°±æ˜¯å°†ç‚¹xåˆ°åŸæ ‘ä¸­rootä¹‹é—´çš„é“¾ä¸¢åˆ°ä¸€ä¸ªsplayé‡Œ ä¸¾ä¸ªä¾‹å­ï¼Œç°åœ¨æœ‰ä¸€ä¸ªæ£®æ—é•¿æˆè¿™æ ·ï¼š&lt;/li&gt;&lt;/ul&gt; ç°åœ¨xä¸º6ã€‚æˆ‘ä»¬access(x)ã€‚ é‚£ä¹ˆ{1-3ï¼Œ3-6}ä¼šå˜ä¸ºå®è¾¹ï¼Œ1-2ä¼šå˜æˆè™šè¾¹ï¼Œå‡è®¾6æœ‰ä¸€å„¿å­nï¼Œä¹‹é—´ç”¨å®è¾¹è¿ç€ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹ä¹Ÿå°†å˜æˆè™šè¾¹ã€‚ æ¯æ¬¡å°† x ç‚¹ splay åˆ°å½“å‰æ‰€åœ¨è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå°†å®ƒçš„å³å„¿å­æ›´æ–°ä¸ºä¸Šä¸€ä¸ª x ï¼Œç„¶åä»¤ x è·³åˆ°å®ƒçš„çˆ¶èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ª x çš„å³å„¿å­è®¾ä¸º0ã€‚ ä¸ºä»€ä¹ˆæ˜¯å³å„¿å­è€Œä¸æ˜¯å·¦å„¿å­å‘¢ï¼Ÿ å› ä¸ºfa[x]çš„æ·±åº¦å°äºxï¼Œè€Œåœ¨Splayé‡Œé¢fa[x]æ˜¯xçš„çˆ¸çˆ¸ï¼Œæ‰€ä»¥xåœ¨Splayä¸­æ˜¯fa[x]çš„å³å„¿å­ã€‚ æˆ‘ä»¬å°† x æ—‹è½¬åˆ°è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å°†å½“å‰åŸæ ‘è¿™æ¡é“¾ä¸Šæ·±åº¦å°äº x (åœ¨ x ä¸Šé¢çš„ç‚¹)ä¸¢åˆ°äº† x çš„å·¦å­æ ‘ä¸Šï¼Œå°† x çš„å³å­æ ‘è®¾ä¸ºä¸Šä¸€ä¸ª x ç‚¹ç›¸å½“äºå°† x åŸæ¥çš„å³å­æ ‘ä¸¢åˆ°äº†æ–°çš„ splay é‡Œé¢(è€Œå®ƒä»¬ä¹‹é—´ç”¨è™šè¾¹ç›¸è¿)ï¼Œå¹¶ä¸”å°†ä¸Šä¸€æ®µé“¾è¿æ¥èµ·æ¥ã€‚ ç°åœ¨å°±å¯ä»¥äº†ã€‚è¿™æ£µæ–° Splay ä¸­åªæœ‰è¿™æ¡é“¾ä¸Šçš„ç»“ç‚¹ï¼Œæ²¡æœ‰å…¶ä»–ä»»ä½•çš„ç»“ç‚¹ã€‚å¦‚æœæˆ‘ä»¬æŒ‡å®šè¦è¿™ä¸‰ä¸ªç»“ç‚¹åŒæ—¶è¿›è¡Œæ“ä½œï¼Œå¯ä»¥ç›´æ¥ä¸‹ä¼ lazy_tagåˆ°è¿™ä¸‰ä¸ªç»“ç‚¹ç»„æˆçš„ Splay çš„æ ¹ç»“ç‚¹å“¦!åˆ°åé¢Splayçš„æ—¶å€™å°±å¯ä»¥ç›´æ¥ä¸‹ä¼ è·Ÿæ–°ç»“ç‚¹ä¿¡æ¯äº†ã€‚ æ€»ä½“è¿‡ç¨‹ï¼š è™šè¾¹ï¼šå„¿å­è®¤çˆ¶ï¼Œçˆ¶ä¸è®¤å­ å®è¾¹ï¼šå„¿å­è®¤çˆ¶ï¼Œçˆ¶ä¹Ÿè®¤å­ ç”¨FlashHuçš„è¯æ¥è¯´ï¼š 1.è½¬åˆ°æ ¹ã€‚ 2.æ¢å„¿å­ã€‚ 3.æ›´æ–°ä¿¡æ¯ã€‚ 4.å½“å‰æ“ä½œç‚¹åˆ‡æ¢ä¸ºè½»è¾¹æ‰€æŒ‡çš„çˆ¶äº²ï¼Œè½¬1ã€‚ inline void Access(int x){ for(register int y=0;x;y=x,x=fa[x]){ Splay(x);//è½¬ ch[x][1]=y;//è®¤å„¿å­äº† pushup(x);//å„¿å­æœ‰å˜åŒ–ï¼Œæ›´æ–° } } findroot(x): é¦–å…ˆè¦æ˜ç™½ï¼š æ ¹èŠ‚ç‚¹æ˜¯çš„æ·±åº¦æœ€å°çš„ æˆ‘ä»¬å¯ä»¥é€šè¿‡xå‘ä¸Šæ‰¾ï¼Œç”¨ Access æ“ä½œå¯ä»¥å°†xå’Œxçš„æ ¹ç»“ç‚¹æåˆ°ä¸€ä¸ª Splay é‡Œã€‚ åˆå› ä¸ºæœ‰BSTçš„æ€§è´¨ï¼šxçš„å·¦å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æƒå€¼ &lt; x &lt; xå³å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æƒå€¼ã€‚ è€Œæˆ‘ä»¬åˆçŸ¥é“ï¼Œåœ¨æ‰§è¡Œå®Œ Access æ“ä½œåï¼Œè¿™è¯¾ Splay é‡Œé¢çš„ç»“ç‚¹æƒå€¼æœ€å¤§çš„(æ·±åº¦æœ€å¤§çš„)å°±æ˜¯xã€‚ äºæ˜¯æˆ‘ä»¬å¯ä»¥å°†x Splay åˆ°è¿™æ£µ Splay çš„æ ¹ç»“ç‚¹ï¼Œé‚£ä¹ˆç°åœ¨æœ€å·¦è¾¹çš„èŠ‚ç‚¹ä¾¿æ˜¯è¿™è¯¾æ ‘çš„æ ¹ç»“ç‚¹äº†ã€‚ inline int findroot(int x){ Access(x);//Accesså°†xå’Œæ ¹ç»“ç‚¹æåˆ°åŒä¸€ä¸ªSplayä¸­ Splay(x);//è½¬åˆ°Splayçš„æ ¹ç»“ç‚¹ while(ch[x][0])pushdown(x),x=ch[x][0];//ä¸æ–­çš„æ‰¾å·¦å„¿å­&amp;æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯ return x;//æœ€å·¦è¾¹çš„å°±æ˜¯æ ¹ç»“ç‚¹äº†ã€‚ } makeroot(x): å°†xåˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„ä¸Šçš„ç‚¹å…¨éƒ¨ç¿»è½¬(å³xå˜æˆäº†æ ¹èŠ‚ç‚¹) å…·ä½“æ“ä½œæ˜¯æˆ‘ä»¬å…ˆå°†xç‚¹ä¸åŸæ ‘ä¸­çš„æ ¹æ‰“é€šä¸€æ¡é“¾ï¼Œé‚£ä¹ˆç°åœ¨å®ƒä»¬å°±åœ¨åŒä¸€æ£µè¾…åŠ©æ ‘é‡Œé¢äº†ï¼Œæˆ‘ä»¬å‘ç°xä¸€å®šæ˜¯åœ¨å®ƒæ‰€åœ¨çš„è¾…åŠ©æ ‘çš„ä¸­åºéå†çš„æœ€åä¸€ä¸ªçš„(å› ä¸ºå®ƒæ˜¯è¿™æ¡é“¾ä¸Šæœ€æ·±çš„ç‚¹)ï¼Œæˆ‘ä»¬æŠŠxç‚¹ splay åˆ°è¾…åŠ©æ ‘çš„æ ¹ä¸Šï¼Œé‚£ä¹ˆxæ˜¾ç„¶æ˜¯æ²¡æœ‰å³å­æ ‘çš„ï¼Œæˆ‘ä»¬è¦å®ç°å°†xç§»åˆ°åŸæ ‘çš„æ ¹ä¸Šï¼Œä¹Ÿå°±æ˜¯å°†xåˆ°æ ¹çš„è¿™æ¡é“¾çš„æ·±åº¦å…¨éƒ¨ç¿»è½¬ä¸€éï¼Œåœ¨è¾…åŠ©æ ‘ä¸Šçš„ä½“ç°å°±æ˜¯å°†æ•´æ£µæ ‘ç¿»è½¬ä¸€éï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸ªç¿»è½¬æ ‡è®°æ¥å‡å°‘å¤æ‚åº¦ã€‚ inline void filp(int x){//Splayæ™®é€šåŒºé—´ç¿»è½¬ swap(ch[x][0],ch[x][1]);r[x]^=1; } inline void makeroot(int x){ Access(x); Splay(x); filp(x);//lazy_tag&amp;ç¿»è½¬åŒºé—´ } split(x,y) è¿™ä¸ªæ“ä½œæ˜¯å°†xåˆ°yä¹‹é—´çš„é‚£æ¡è·¯å¾„ä¸¢åˆ°ä¸€æ£µè¾…åŠ©æ ‘é‡Œï¼Œå¹¶ä¸”è¿™æ£µè¾…åŠ©æ ‘ä»¥yèŠ‚ç‚¹ä¸ºæ ¹ã€‚ Splay ç»´æŠ¤çš„æ˜¯åŸæ ‘ä¸­çš„ä¸€æ¡é“¾ï¼Œæˆ‘ä»¬ä¸èƒ½ä¿è¯x,yä¼šåœ¨åŒä¸€æ¡é“¾é‡Œã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæŠŠxå˜æˆåŸæ ‘çš„æ ¹èŠ‚ç‚¹(è¿™ä¸‹å­Access(y)å°±ä¼šå°†xåˆ°yä¹‹é—´çš„æ‰€æœ‰èŠ‚ç‚¹ä¸¢åˆ°ä¸€ä¸ª Splay ä¸­äº†)ã€‚ inline void split(int x,int y){ makeroot(x);Access(y);Splay(y); } connect(x,y): å°†xå’Œyæ‰€åœ¨åŸæ ‘åˆå¹¶èµ·æ¥ é¦–å…ˆå°†xç‚¹ä¸¢åˆ°åŸæ ‘çš„æ ¹ï¼Œç„¶åå»æ‰¾æ‰¾yçš„æ ¹æ˜¯ä¸æ˜¯xï¼Œå¦‚æœä¸æ˜¯è¯´æ˜x,yä¸åœ¨ä¸€ä¸ªåŸæ ‘å†…ï¼Œæˆ‘ä»¬å°†xçš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºyï¼Œä¹Ÿå°±ç›¸å½“äºä»yåˆ°xè¿äº†ä¸€æ¡è™šè¾¹ã€‚ inline void connect(int x,int y){ makeroot(x);//è½¬åˆ°æ ¹ if(findroot(y)!=x)fa[x]=y;//è¿æ¥ä¸€æ¡è™šè¾¹ / erase(x,y): é¦–å…ˆæˆ‘ä»¬å…ˆæŠŠx,yä¹‹é—´çš„é‚£æ¡è¾¹ç”¨split(x,y)æ‹å‡ºæ¥ï¼Œå› ä¸ºx,yæ˜¯ç›¸é‚»çš„ï¼Œæ‰€ä»¥yçš„å·¦å„¿å­ä¸€å®šæ˜¯xï¼Œå°†å®ƒä»¬çš„çˆ¶å­å…³ç³»æ¶ˆç­æ‰å³å¯ã€‚ æ¶ˆç­çˆ¶å­å…³ç³»æ—¶ä¸€å®šæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š 1.xå’Œyåœ¨ä¸€ä¸ªåŸæ ‘é‡Œ(ä¸åœ¨ä¸€ä¸ªæ ‘é‡Œé¢å¾€å“ªå„¿åˆ‡å•Š) 2.splitä¹‹åxæ˜¯yçš„å·¦å„¿å­ 3.xçš„å³å„¿å­æ˜¯ç©ºçš„(ä¿è¯äº†ä¸­åºéå†ä¸­yç´§è·Ÿåœ¨xçš„åé¢ï¼Œå³æ·±åº¦ç›¸é‚»)(xçš„æƒå€¼(æ·±åº¦)åªæ¯”yå°1ï¼Œè€Œxåˆæ­£å¥½æ˜¯ç›´æ¥è¿ç€yçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•å†æ‰¾åˆ° &gt;x è€Œåˆ &lt;y çš„æ•´æ•°äº†) inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1] fa[x]=ch[y][0]=0; }return; } ä½†æ˜¯å¦‚æœæˆ‘ä»¬åœ¨findrootä¸­æ·»åŠ äº†Splayçš„è¯ï¼Œeraseä¸­xå’Œyçš„çˆ¶å­å…³ç³»å°±å˜äº†ï¼Œéœ€è¦æ”¹ä¸ºè¿™æ ·ï¼Œå¦åˆ™ä¼šå‡ºç°ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„é”™è¯¯ï¼š inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;! fa[y]=ch[x][1]=0;pushup(x); de> 0X03 Splayçš„æ”¹åŠ¨ï¼š æ—‹è½¬çš„æ”¹åŠ¨ï¼š è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œå¦‚æœxçš„çˆ¶äº²èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹yå·²ç»ä¸åœ¨å½“å‰çš„è¿™æ£µè¾…åŠ©æ ‘ä¸Šï¼Œåªéœ€è¦è¿å•å‘è¾¹(ä¹Ÿå°±æ˜¯è™šè¾¹ï¼Œè®¤çˆ¶ä¸è®¤å­)ï¼Œå¦åˆ™æ­£å¸¸è¿å°±è¡Œï¼Œè¿™é‡Œè¦å’Œæ™®é€šçš„rotateåŒºåˆ†å¼€æ¥ã€‚ åšä¸ªå¯¹æ¯”ï¼š ç°åœ¨çš„rotate(x): è¿™é‡Œçš„xå¯ä»¥ä¸æ›´æ–°ï¼Œå› ä¸ºä¼šåœ¨ä¸‹ä¸€æ¬¡rotateæ—¶æ›´æ–°ã€‚ inline void rotate(int x){ int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; x;ch[x][!k]=y,ch[y][k]=v; if(v)fa[v]=y;fa[y]=x,fa[x]=z;pushup(y); } Splayçš„æ”¹åŠ¨ åŒæ ·è¦æ³¨æ„ä¸€ä¸‹åªèƒ½Splayåˆ°è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ŒSplayä¹‹å‰éœ€å…ˆä¸‹ä¼ ä¸€ä¸‹è¿™ä¸€æ¡é“¾ä¸Šéœ€æ“ä½œçš„æ‰€æœ‰çš„ç‚¹ï¼Œç”¨æ ˆæ¥å®Œæˆå³å¯ inline void Splay(int x){ int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=fa[y]; while(top)pushdown( while(get(x)){//åŸºæœ¬æ™®é€šçš„Splay y=fa[x],top=fa[y]; rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); }pushup(x);return; } æœ€åæ”¾ä¸€ä¸‹æ¨¡æ¿é¢˜ä»£ç  #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---çº¿æ®µæ ‘","slug":"DS100P-SEGMENT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.131Z","comments":true,"path":"2020/02/07/DS100P-SEGMENT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SEGMENT-TREE/","excerpt":"","text":"çº¿æ®µæ ‘ â€”LYC(ZBing)($nlogn$) çº¿æ®µæ ‘ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯æ¯ä¸ªæ ‘çš„èŠ‚ç‚¹è®°å½•ä¸€æ¡çº¿æ®µä¸Šçš„ä¸€äº›ä¿¡æ¯ï¼Œéå¸¸çµæ´»ï¼Œå¯ä»¥å®ç°å¾ˆå¤šæ“ä½œï¼Œä½†å¸¸æ•°æ¯”æ ‘çŠ¶æ•°ç»„å¤§ä¸€ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š çº¿æ®µæ ‘çš„ç»å…¸åº”ç”¨å°±æ˜¯ç»Ÿè®¡åŒºé—´å’Œï¼Œæˆ‘ä»¬è¿™é‡Œä¹Ÿç”¨è¿™ä¸ªæ¥è¿›è¡Œçº¿æ®µæ ‘çš„è®²è§£ã€‚ 1).å»ºæ ‘æˆ‘ä»¬å…ˆæ”¾ä»£ç å§ï¼Œçœ‹ä»£ç ç†è§£ã€‚ void build(int l,int r,int x) { if(l==r) { nodes[x]=a[l]; return; } else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=nodes[x&lt;&lt;1]+nodes[(x&lt;&lt;1)+1]; } } é¦–å…ˆï¼Œæˆ‘ä»¬éå†åˆ°çº¿æ®µæ ‘çš„æ¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹ã€‚çº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ä»£è¡¨äº†ä¸€ä¸ªåŒºé—´ï¼Œå½“è¿™ä¸ªåŒºé—´çš„$l=r$æ—¶ï¼Œè¯´æ˜æˆ‘ä»¬åˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ã€‚è¿™ä¸ªå¶å­èŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´åªåŒ…å«äº†$a[l]$è¿™ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å°†è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ç½®ä¸º$a[l]$ã€‚ ç„¶åæˆ‘ä»¬é€’å½’å›å»ï¼Œæ¯ä¸€ä¸ªéå¶å­èŠ‚ç‚¹éƒ½å¯ä»¥æŠŠå®ƒä»£è¡¨çš„åŒºé—´åˆ†æˆä¸¤åŠï¼Œå¯¹åº”å®ƒçš„ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼ˆå¯èƒ½æ²¡æœ‰ä¸¤ä¸ªï¼‰ã€‚å®ƒä¸¤ä¸ªå­èŠ‚ç‚¹çš„å€¼å°±æ˜¯è¿™ä¸¤ä¸ªè¾ƒå°åŒºé—´çš„å…ƒç´ å’Œã€‚ç”±è¿™ä¸¤ä¸ªå­èŠ‚ç‚¹çš„å€¼ä¹Ÿå°±æ˜¯è¿™ä¸¤ä¸ªå°åŒºé—´çš„å…ƒç´ å’Œç›¸åŠ å°±å¯ä»¥å¾—åˆ°å½“å‰èŠ‚ç‚¹ä»£è¡¨åŒºé—´çš„å…ƒç´ å’Œã€‚ æ—¶é—´å¤æ‚åº¦($nlogn$) 2).å•ç‚¹ä¿®æ”¹åƒè¿™ç§åŒºé—´å’Œé—®é¢˜çš„å•ç‚¹ä¿®æ”¹ä¸€èˆ¬éƒ½æ˜¯ç»™ä¸€ä¸ªç‚¹åŠ ä¸Šä¸€ä¸ªå€¼ã€‚ è¿˜æ˜¯å…ˆæ”¾ä»£ç å§ï¼š void update(int l,int r,int x,int pos,int val) { nodes[x]-=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(l,mid,x&lt;&lt;1,pos,val); else update(mid+1,r,(x&lt;&lt;1)+1,pos,val); } è¿˜æ˜¯å…ˆé€’å½’æ‰¾åˆ°è¦ä¿®æ”¹çš„å¶å­èŠ‚ç‚¹ã€‚å…ˆå°†å®ƒçš„å€¼åŠ ä¸Švalã€‚ ç„¶åå†é€’å½’å›å»ï¼Œå› ä¸ºå¾€ä¸‹æ‰¾æ—¶æ‰¾åˆ°çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´éƒ½åŒ…å«è¿™ä¸ªå¶å­èŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´ï¼Œæ‰€ä»¥è¿™äº›èŠ‚ç‚¹çš„å€¼ä¹Ÿè¦åŠ ä¸Švalã€‚ æ—¶é—´å¤æ‚åº¦($logn$) 3).åŒºé—´æŸ¥è¯¢åŒºé—´æŸ¥è¯¢çš„æœ¬è´¨å°±æ˜¯æŠŠè¦æŸ¥è¯¢çš„åŒºé—´æ‹†åˆ†æˆå¾ˆå¤šå°åŒºé—´ï¼Œç›´æ¥åˆ©ç”¨ä¹‹å‰ç»´æŠ¤çš„èŠ‚ç‚¹çš„å€¼è¿›è¡ŒæŸ¥è¯¢ã€‚ int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr||r&lt;=ba) return nodes[x]; int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } æˆ‘ä»¬å¯¹äºå½“å‰é€’å½’æŸ¥æ‰¾åˆ°çš„èŠ‚ç‚¹æ‰€ä»£è¡¨çš„åŒºé—´ä¸è¦æŸ¥è¯¢çš„åŒºé—´è¿›è¡Œåˆ†ç±»è®¨è®ºï¼š $1$&gt;.æ¯«æ— å…³è” å³å½“å‰åŒºé—´çš„å·¦ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´å³ç«¯ç‚¹çš„å³è¾¹æˆ–å½“å‰åŒºé—´çš„å³ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´å·¦ç«¯ç‚¹çš„å·¦è¾¹ã€‚ æ—¢ç„¶ä»–ä»¬æ¯«æ— å…³è”ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¿”å›ä¸€ä¸ªå€¼0ï¼Œå› ä¸ºä»–ä»¬å¯¹è¿™ä¸ªåŒºé—´çš„å’Œæ²¡æœ‰ä»»ä½•è´¡çŒ®ã€‚ $2$&gt;.è¢«åŒ…å« å³å½“å‰åŒºé—´çš„å·¦ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´çš„å·¦ç«¯ç‚¹çš„å³è¾¹ä¸”å½“å‰åŒºé—´çš„å³ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´çš„å³ç«¯ç‚¹çš„å·¦è¾¹ã€‚ æ—¢ç„¶è¿™ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´å…¨éƒ¨å±äºæŸ¥è¯¢åŒºé—´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ²¡æœ‰å¿…è¦å†ç»§ç»­é€’å½’ä¸‹å»äº†ï¼Œç›´æ¥æŠŠè¿™ä¸ªèŠ‚ç‚¹çš„å€¼åŠ ä¸Šå»ã€‚ $3$&gt;.æœ‰éƒ¨åˆ†é‡å ä½†ä¸è¢«åŒ…å« å³ä¸Šä¸¤ç§æƒ…å†µçš„å‰©ä½™æƒ…å†µã€‚ å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬æ²¡æœ‰åŠæ³•æŠŠèŠ‚ç‚¹çš„å€¼ç›´æ¥åŠ ä¸Šå»ï¼Œå› ä¸ºè¿™ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´ä¸å…¨å±äºæŸ¥è¯¢åŒºé—´ã€‚ä¹Ÿä¸èƒ½ç›´æ¥è·³è¿‡ï¼Œå› ä¸ºæœ‰éƒ¨åˆ†èŠ‚ç‚¹å±äºæŸ¥è¯¢åŒºé—´ã€‚æ‰€ä»¥æˆ‘ä»¬ç»§ç»­å‘å®ƒçš„å­èŠ‚ç‚¹é€’å½’ï¼Œç›¸å½“äºæŠŠè¿™ä¸ªåŒºé—´åˆ†æˆä¸¤åŠï¼ŒæŸ¥è¯¢ä¸¤ä¸ªå­åŒºé—´ä¸­å±äºæŸ¥è¯¢åŒºé—´çš„å€¼åŠ èµ·æ¥ã€‚ æ—¶é—´å¤æ‚åº¦ï¼ˆ$logn$ï¼‰ 4).åŒºé—´ä¿®æ”¹é¢å¯¹åŒºé—´ä¿®æ”¹ï¼Œå¦‚æœæˆ‘ä»¬ç»§ç»­ç”¨å•ç‚¹ä¿®æ”¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šé€€å›åˆ°ï¼ˆ$n^2logn$ï¼‰ æ‰€ä»¥æˆ‘ä»¬å¼•å…¥äººç±»çš„æœ¬è´¨æ‡’æ ‡è®°ã€‚ å½“æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªå®Œå…¨æ˜¯è¦ä¿®æ”¹çš„åŒºé—´ï¼Œæˆ‘ä»¬å°±ç›´æ¥æŠŠå®ƒçš„æ‡’æ ‡è®°åŠ ä¸Š$val$ã€‚ å¯¹äºä¸­é€”éå†åˆ°çš„å…¶ä»–åŒºé—´ï¼Œæˆ‘ä»¬ç›´æ¥è®¡ç®—ä¿®æ”¹è¿™ä¸ªåŒºé—´çš„å’Œã€‚ ä»£ç ï¼š void update(int l,int r,int x,int fr,int ba,int val) { if(l&gt;ba||r&lt;fr) return; if(l&gt;=fr&amp;&amp;r&lt;=ba) lazy[x]+=val; else { nodes[x]+=val*max(0,min(r,ba)-max(l,fr)+1); int mid=(l+r)&gt;&gt;1; update(l,mid,x&lt;&lt;1,fr,ba,val); update(mid+1,r,(x&lt;&lt;1)+1,fr,ba,val); } } é•¿å¾—å’ŒåŒºé—´æŸ¥è¯¢å¾ˆåƒå¯¹å§ æ”¹äº†ä¿®æ”¹ä¹‹åï¼Œæˆ‘ä»¬çš„æŸ¥è¯¢ä¹Ÿè¦è¿›è¡Œä¿®æ”¹ã€‚è¦æŠŠæ‰“ä¸Šçš„æ‡’æ ‡è®°è¿›è¡Œä¸‹ä¼ ï¼Œä¸ç„¶æŸ¥è¯¢åˆ°ä¸‹é¢çš„èŠ‚ç‚¹æ—¶ï¼Œä¸‹é¢çš„èŠ‚ç‚¹æ²¡æœ‰è¢«ä¿®æ”¹ã€‚ ä¸‹ä¼ æ—¶åªéœ€è¦è®©å½“å‰èŠ‚ç‚¹åŠ ä¸ŠåŸæ¥åº”åŠ è€Œæ‹–å»¶äº†çš„å€¼ï¼Œè®©å®ƒçš„å·¦å³å„¿å­çš„æ‡’æ ‡è®°åŠ ä¸Šå®ƒçš„æ‡’æ ‡è®°ã€‚å› ä¸ºå½“åˆä¿®æ”¹æ—¶ï¼Œå¹¶æ²¡æœ‰ä¿®æ”¹åˆ°å·¦å³èŠ‚ç‚¹ã€‚æœ€åå†æŠŠæ‡’æ ‡è®°æ¸…é›¶ã€‚ å°±åƒè¿™æ ·ï¼š void pushdown(int l,int r,int x) { nodes[x]+=(r-l+1)*lazy[x]; lazy[x&lt;&lt;1]+=lazy[x]; lazy[(x&lt;&lt;1)+1]+=lazy[x]; lazy[x]=0; } int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(lazy[x]) pushdown(l,r,x); if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[x]; else { int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } } $\\ $ çº¿æ®µæ ‘çš„è®²è§£åˆ°è¿™é‡Œå°±è¿™ä¹ˆå®Œäº†ï¼Œä½†çº¿æ®µæ ‘çš„è¿ç”¨ååˆ†å¹¿æ³›ï¼Œçµæ´»ã€‚è¦ç†Ÿç»ƒæŒæ¡å¹¶è¿ç”¨çº¿æ®µæ ‘ï¼Œè¿˜è¦å¤šåŠ¨è„‘ï¼Œæƒ³å¥½é¢˜ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---è«é˜Ÿ","slug":"DS100P-MO-ALGORITHM","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.128Z","comments":true,"path":"2020/02/07/DS100P-MO-ALGORITHM/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-MO-ALGORITHM/","excerpt":"","text":"è«é˜Ÿ($n\\sqrt{n}$) 0x01è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š å¯¹äºä¸€ä¸ªåºåˆ—$A_1,A_2,\\cdots,A_n$ï¼Œæœ‰å¦‚ä¸‹è¯¢é—® å½¢å¦‚$S\\ \\ l\\ \\ r$çš„å‘½ä»¤è¡¨ç¤ºå¯¹åŒºé—´$[l,r]$æ±‚å’Œï¼Œå¹¶è¾“å‡º å½¢å¦‚$Q\\ \\ l\\ \\ r$è¡¨ç¤º$\\cdots$ æœ¬é¢˜ä¸å¼ºåˆ¶åœ¨çº¿ å¯¹äºè¿™æ ·çš„é™æ€é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ç”¨è«é˜Ÿæ¥è§£å†³ã€‚æ®è¯´è«é˜Ÿæ”¯æŒä¿®æ”¹ä½†æˆ‘å¤ªå¼±ä¸ä¼š ç°åœ¨ä½ æœ‰åŒºé—´$[3,5]$çš„å’Œï¼Œå¯ä»¥æ±‚$[3,6]$çš„åŒºé—´å’Œå—ï¼Ÿæ˜¾ç„¶ï¼Œå°†$[3,5]$çš„åŒºé—´å’ŒåŠ ä¸Š$A_6$å³å¯ã€‚ç±»ä¼¼çš„ï¼Œæ±‚$[2,4]$çš„åŒºé—´å’Œï¼Œæˆ‘ä»¬åªéœ€å‡å»$A_5$å³å¯ã€‚ å¯ä»¥ç»“åˆä¸‹å›¾æ„ŸçŸ¥ä¸€ä¸‹ 0x02å¥½ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æƒ³ä¸€ä¸‹å¦‚ä½•ç»´æŠ¤è¿™ç§è¯¢é—®ä¹‹é—´çš„å…³ç³»ã€‚ å¾ˆå®¹æ˜“æƒ³åˆ°æ’åºï¼Œé¦–å…ˆæˆ‘ä»¬å¯¹è¯¢é—®çš„å·¦ç«¯ç‚¹è¿›è¡Œæ’åºã€‚å†æŠŠæ•´ä¸ªè¯¢é—®åºåˆ—åˆ†ä¸º$\\sqrt{n}$å—ï¼Œæ¯å—ä»¥å†…å†æŒ‰å³ç«¯ç‚¹æ’åºã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®ºï¼š è«é˜Ÿå°±æ˜¯å¯¹äºä¸€ç³»åˆ—çš„è¯¢é—®ï¼Œé€šè¿‡æ’åºå‡å°è¯¢é—®çš„ä¹‹é—´çš„å·®è·ï¼Œç„¶åä»¥è®¡ç®—è´¡çŒ®çš„æ–¹æ³•ç¦»çº¿çš„å¾—å‡ºç­”æ¡ˆ 0x03æ¥ä¸€é“ç®€å•çš„ä¾‹é¢˜ å°Bçš„è¯¢é—®å°B æœ‰ä¸€ä¸ªé•¿ä¸º $n$ çš„æ•´æ•°åºåˆ— $a$ï¼Œå€¼åŸŸä¸º $[1,k]$ã€‚ä»–ä¸€å…±æœ‰ $m$ ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®ç»™å®šä¸€ä¸ªåŒºé—´ $[l,r]$ï¼Œæ±‚ï¼š å…¶ä¸­ $c_i$ è¡¨ç¤ºæ•°å­— $i$ åœ¨ $[l,r]$ ä¸­çš„å‡ºç°æ¬¡æ•°ã€‚å°Bè¯·ä½ å¸®åŠ©ä»–å›ç­”è¯¢é—® è¿™é“é¢˜è®©æˆ‘ä»¬æ±‚ \\sum\\limits_{i=1}^k c_i^2å¼€ä¸€ä¸ªæ¡¶ï¼Œè®¡ç®—æ¯ä¸ªæ•°å‡ºç°çš„æ¬¡æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”±æ­¤è®¡ç®—ç­”æ¡ˆçš„è´¡çŒ®ï¼Œå°±å¯ä»¥å†™å‡ºä»¥ä¸‹çš„ä»£ç  #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int SIZE = 5e4 + 5; struct QueryNode { int l, r; int id; // å‚¨å­˜è¯¢é—®çš„é¡ºåºï¼Œæ–¹ä¾¿è¾“å‡º } Q[SIZE]; int a[SIZE], n, m, k, pos[SIZE]; int cnt[SIZE], ans[SIZE], res; // a:åŸåºåˆ— // pos:æ¯ä¸ªä½ç½®æ‰€å¤„çš„å— // cnt:æ¡¶ // ans:è¯¢é—®çš„ç­”æ¡ˆ // res:æ¯æ¬¡è°ƒæ•´æ‰€å¾—åˆ°çš„è´¡çŒ® inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); } inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); int block = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), pos[i] = i / block; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); // è¿™å››å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (r &lt; Q[i].r) add(++r); // è¿™ä¸‰å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (l &lt; Q[i].l) del(l++); // è¿™äºŒå¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (r &gt; Q[i].r) del(r--); // è¿™ä¸€å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ ans[Q[i].id] = res; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 0x04å…¶å®è«é˜Ÿæ˜¯æœ‰å¥—è·¯çš„ï¼ŒåŸºæœ¬ä¸Šè«é˜Ÿçš„é¢˜éƒ½æ˜¯è¿™æ ·çš„: for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); while (r &lt; Q[i].r) add(++r); while (l &lt; Q[i].l) del(l++); while (r &gt; Q[i].r) del(r--); ans[Q[i].id] = res; } æˆ‘ä»¬åªéœ€è€ƒè™‘$add$å‡½æ•°ä»¥åŠ$del$å‡½æ•°å³å¯","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---splay","slug":"DS100P-SPLAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.132Z","comments":true,"path":"2020/02/07/DS100P-SPLAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SPLAY/","excerpt":"","text":"update:å¢åŠ å‡ é“å¥½ä¸€ç‚¹çš„ä¾‹é¢˜å§ [NOI2004]éƒé—·çš„å‡ºçº³å‘˜ [æ¨¡æ¿]æ–‡è‰ºå¹³è¡¡æ ‘ [SHOI2013]å‘ç‰Œ [TJOI2010]ä¸­ä½æ•° [TJOI2007]ä¹¦æ¶ æ­£æ–‡ï¼šå…³äºSPLAYå…¶å®æˆ‘æ›´åå‘äºæŠŠsplayå«åšcosplay è®²å¹³è¡¡æ ‘æ€»é€ƒä¸è¿‡BST(Binary Search Tree)ï¼ŒäºŒå‰æœç´¢æ ‘ï¼Œä»¥ä¸‹æ˜¯BSTçš„æ€§è´¨ï¼š ä¸€æ£µåˆæ³•çš„BSTæ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½å¸¦æœ‰ä¸€ä¸ªæ•°å€¼ï¼Œæˆ‘ä»¬å°†å…¶ç§°ä¸ºèŠ‚ç‚¹çš„â€œå…³é”®ç â€ã€‚é‚£ä¹ˆå¯¹äºä¸€æ£µBSTä¸Šçš„ä»»æ„èŠ‚ç‚¹ï¼Œæ»¡è¶³ï¼š è¯¥èŠ‚ç‚¹çš„å…³é”®ç ä¸å°äºå®ƒå·¦å­æ ‘çš„ä»»æ„ç»“ç‚¹çš„å…³é”®ç  è¯¥ç»“ç‚¹çš„å…³é”®ç ä¸å¤§äºå®ƒå³å­æ ‘çš„ä»»æ„ç»“ç‚¹çš„å…³é”®ç  æ˜¾ç„¶ï¼ŒBSTçš„ä¸­åºéå†æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ— å»ºç«‹ä¸€æ£µBSTå› ä¸ºç¬”è€…å¾ˆæ‡’ï¼Œä¸æƒ³åˆ°å¤„åˆ¤è¾¹ç•Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸€èˆ¬å¯ä»¥åœ¨ä¸€æ£µç©ºçš„BSTä¸­é¢„å…ˆæ’å…¥ä¸¤ä¸ªç»“ç‚¹ï¼Œä¸€ä¸ªæ­£æ— ç©·ï¼Œä¸€ä¸ªè´Ÿæ— ç©·ï¼Œå¦‚å›¾: const int SIZE = 1e5 + 5; const int INF = 0x7fffffff; struct BSTNode { int l, r; // å·¦å³å„¿å­çš„ç¼–å· int val; // å…³é”®ç  } T[SIZE]; int tot, root; int clone(int val) { // æ–°å»ºèŠ‚ç‚¹ T[++tot].val = val; return tot; } void build() { clone(-INF), clone(INF); root = 1, T[1].r = 2; } ä»¥ä¸Šæ˜¯å»ºæ ‘çš„ä»£ç  é‚£ä¹ˆï¼ŒBSTå°±è®²åˆ°è¿™é‡Œ å¹³è¡¡æ ‘çš„è¯ç”Ÿå½“BSTå½¢æˆä¸€æ¡é“¾çš„æ—¶å€™ï¼Œæ¯æ¬¡æŸ¥è¯¢ä¼šå˜æˆ$O(n^2)$ è¿™ç§æ·±åº¦è¿‡æ·±çš„BSTæ˜¯ä¸å¹³è¡¡çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ç§èƒ½ä¿æŒæ ‘çš„æ·±åº¦åœ¨$\\log(n)$çš„æ•°æ®ç»“æ„ï¼Œäºæ˜¯ä¾¿è¯ç”Ÿäº†å¹³è¡¡æ ‘ SPLAYsplayï¼Œåˆç§°cosplayä¼¸å±•æ ‘ï¼Œæœ‰â€œåºåˆ—ä¹‹ç‹â€çš„ç¾ç§°ï¼Œå¸¸æ•°å·¨å¤§ï¼Œè·‘çš„æ²¡æœ‰$fhq-treap$å¿«ï¼Œä½†è¿™ä¸åœ¨æˆ‘ä»¬çš„è®¨è®ºèŒƒå›´ä»¥å†… æƒ³è±¡ä¸€ä¸‹è¿™æ ·ä¸€é¢—BSTï¼Œæˆ‘ä»¬å…ˆæŠŠå®ƒä»¬çš„å¤§å°å…³ç³»åˆ—å‡ºæ¥ã€‚ YY, X","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ•°ç»„","slug":"DS100P-SUFFIX-ARRAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.134Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-ARRAY/","excerpt":"","text":"åç¼€æ•°ç»„0x01 ä»€ä¹ˆæ˜¯åç¼€æ•°ç»„(Suffix Array)æˆ‘ä»¬çŸ¥é“ï¼Œå¯¹äºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²æœ‰ $n$ ä¸ªåç¼€ï¼Œè­¬å¦‚å¯¹äºå­—ç¬¦ä¸² $DCBAE$ æ¥è¯´ï¼Œå®ƒçš„åç¼€ä¾¿æ˜¯: é‚£ä¹ˆä»€ä¹ˆæ˜¯åç¼€æ•°ç»„( $SA$ )å‘¢ï¼Ÿåœ¨æˆ‘ä»¬å¯¹å­—ç¬¦ä¸²çš„ $n$ ä¸ªåç¼€æ’åºè¿‡åï¼Œæˆ‘ä»¬å®šä¹‰åç¼€æ•°ç»„ï¼š $SA$ æ•°ç»„ï¼šæ’åœ¨ç¬¬iä½çš„æ˜¯ç¬¬ $SA$ [i]ä¸ªåç¼€ å³åç¼€æ•°ç»„ã€‚ åŒæ—¶æˆ‘ä»¬å®šä¹‰ï¼š RANKæ•°ç»„ï¼šæ’åœ¨ç¬¬RANK[i]ä½çš„åç¼€æ˜¯ç¬¬iä¸ªåç¼€ ä¸éš¾çœ‹å‡ºRANKå’Œ $SA$ äº’é€† 0x02 å¦‚ä½•æ±‚å‡º $SA$ æ•°ç»„(ç²—ç•¥çš„)æœ´ç´ çš„åšæ³•æ˜¯ç›´æ¥$sort$ï¼Œ$\\Theta(n^2\\log n)$ çˆ¹å¦ˆæ¨é“ä¸æˆé’¢ã€‚ ç¨å¾®æœ‰ç‚¹è„‘å­éƒ½ä¼šæƒ³åˆ°$hash$ä½†æ˜¯ä¾ç„¶çˆ†ç‚¸ã€‚ å¦‚æœæ·±å…¥æ€è€ƒçš„è¯å¾ˆå®¹æ˜“æƒ³åˆ°å€å¢ï¼Œæ—¶é—´å¤æ‚åº¦ $\\Theta(n\\log n)$ + å¤§å¸¸æ•°ç¢°ä¸Šæ¯’ç˜¤é¢˜å½“åœºå»ä¸–ã€‚ $DC3$ï¼Ÿå¸¸æ•°å¤§ï¼Œæ¿å­éš¾èƒŒã€‚ $LUOGU$ æ—¥æŠ¥æ›¾ç»æœ‰è¿‡ä¸€ç‰‡æ—¥æŠ¥ç»™å‡ºäº†ä¸€ç§è¯±å¯¼æ’åºçš„è§£å†³æ–¹æ³•ï¼Œä½†æ˜¯æˆ‘ä¸æ˜¯å¾ˆç†è§£ã€‚ æˆ‘åœ¨è¿™é‡Œç»™å‡ºä¸€ç§ä¸­æ–‡äº’è”ç½‘ä¸Šå‡ ä¹æ²¡æœ‰ä»»ä½•èµ„æ–™çš„ $SA$ æ•°ç»„çº¿æ€§æ—¶é—´å¤æ‚åº¦æ„é€ æ–¹æ³•(æˆ‘ä¹Ÿä¸çŸ¥é“å«ä»€ä¹ˆåå­—)ã€‚ 0x03 å¦‚ä½•æ±‚å‡º $SA$ æ•°ç»„(å…·ä½“çš„)é¦–å…ˆå®šä¹‰æ–‡æœ¬ä¸² $text$ ä¸ºæˆ‘ä»¬çš„å¾…æ±‚ $SA$ çš„å­—ç¬¦æ•°ç»„ å…¶æ¬¡å®šä¹‰ $suffix_i$ ä¸ºä»¥ $i$ èµ·å¤´çš„ $text$ çš„åç¼€ ç„¶åå®šä¹‰ $type_i = \\begin{cases}L, suffix_i &gt; suffix_{i+1} \\\\\\displaystyle S, suffix_i &lt; suffix_{i+1}\\end{cases}$ å‚è€ƒå›¾ç‰‡(æ‰‹å†™å­—å¯èƒ½æœ‰äº›çœ‹ä¸æ¸…æ¥š)ï¼š å­—ç¬¦ä¸²æœ€åçš„æ˜¯ä»€ä¹ˆï¼Ÿä½ å¯ä»¥è®¤ä¸ºè¿™æ˜¯å› ä¸ºä½œè€…æ‡’ä¸æƒ³åˆ°å¤„åˆ¤è¾¹ç•Œè€ŒåŠ ä¸Šçš„æ¯”å­—ç¬¦ä¸²ä¸­ä»»æ„ä¸€ä¸ªå­—ç¬¦çš„ASCLLç éƒ½å°çš„å­—ç¬¦ å†æ¥å®šä¹‰ $dist_i$ ä¸º $text_i$ è·ç¦»ä¸Šä¸€ä¸ª $type_i$ ä¸º $S$ çš„è·ç¦» å‚è€ƒå›¾ç‰‡(æ‰‹å†™å­—å¯èƒ½æœ‰äº›çœ‹ä¸æ¸…æ¥š)ï¼š å†å®šä¹‰ä¸€ä¸ªæ¡¶ $bucket$ï¼Œä»¥ $text$ ä¸­çš„å­—ç¬¦ä¸ºåŒºåˆ«æ¡¶ä¹‹é—´çš„â€œé”®å€¼â€ã€‚ä¾ç„¶å‚è€ƒå›¾ç‰‡ æˆ‘ä»¬å…¶å®å¯ä»¥å‘ç°æ­¤æ—¶çš„ $bucket$ å·²ç»å’Œæˆ‘ä»¬è¦æ±‚çš„ $SA$ å·®çš„ä¸è¿œäº†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæ¡¶æ’å•Šï¼æ­¤æ—¶çš„æ¡¶å¤–éƒ¨å…¶å®å·²ç»æ˜¯æœ‰åºçš„äº†ï¼Œåªæ˜¯æˆ‘ä»¬å†…éƒ¨è¿˜æ— æ³•ç¡®å®šé¡ºåºã€‚æ¯”å¦‚ $I$ è¿™ä¸ªæ¡¶é‡Œï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®š $suffix_{2},suffix_{5},suffix_{8},suffix_{11}$ çš„æ’åºé¡ºåºï¼Œå› ä¸ºä»–ä»¬å¼€å¤´çš„é¦–å­—æ¯ä¸åŒã€‚é‚£è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿè¯·ç»§ç»­å¾€ä¸‹çœ‹ã€‚ æˆ‘ä»¬å†å®šä¹‰ä¸€ä¸ªæ¡¶ $D_lists$ â€œé”®å€¼â€ ä¸º $list_i$ã€‚å‚è€ƒå›¾ç‰‡(æ³¨æ„æ­¤æ—¶æˆ‘ä»¬ä¸è€ƒè™‘é”®å€¼(å³ $dist$ )ä¸º0çš„æƒ…å†µ) ä»¥é”®å€¼ä¸º1ä¸¾ä¸€ä¸ªä¾‹å­ã€‚å®ƒçš„æ„æ€å°±æ˜¯è¯´ $dist$ ä¸º1çš„æƒ…å†µæœ‰ $suffix_{9},suffix_{3,6}$ è¿™ä¸‰ç§æƒ…å†µã€‚ä¸ $bucket$ è¿™ä¸ªæ¡¶ç±»ä¼¼ä½†ä¸åŒçš„ï¼Œæˆ‘ä»¬èƒ½åˆ†æ¸… $suffix_9$ å’Œ $sufiix_{3,6}$ çš„é¡ºåºï¼Œä½†æˆ‘ä»¬æ— æ³•åˆ†æ¸… $suffix_3$ å’Œ $suffix_6$ çš„é¡ºåºã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹ï¼Œä¸‹æ ‡ä¸º9çš„åç¼€æ˜¯ä»¥ $P$ å¼€å¤´çš„ï¼Œç„¶è€Œä¸‹æ ‡ä¸º3å’Œ6çš„åç¼€å´éƒ½æ˜¯ä»¥ $S$ å¼€å¤´çš„ï¼Œæ‰€ä»¥ $suffix_9$ ä¸€å®šæ’åœ¨ $suffix_{3,6}$ çš„å‰é¢ã€‚$suffix_{3,6}$ å´å› ä¸ºé¦–å­—æ¯ç›¸åŒæ‰€ä»¥æ— æ³•åˆ†æ¸…æ¥šé¡ºåºã€‚ ä¸‹ä¸€æ­¥æˆ‘ä»¬å°è¯•å°†æ‰€æœ‰ $type$ ä¸º $S$ çš„ $suffix$ æ‰¾å‡ºæ¥ æˆ‘ä»¬æŠŠ $bucket$ æ‰«ä¸€éï¼Œå³å¯å¾—å‡ºï¼š å›¾ä¸­çš„ $S-Substring$ å³ä¸ºæˆ‘ä»¬æ‰€æ±‚çš„æ‰€æœ‰ $type$ ä¸º $S$ çš„ $suffix$ã€‚ åŒæ ·ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ $suffix_{2,5,8}$ å“ªä¸ªåœ¨å‰å“ªä¸ªåœ¨åã€‚ä¸€ç§ $naive$ çš„åšæ³•å°±æ˜¯æŠŠ $[2,5,8]$ ä¾æ¬¡+1ï¼Œç›¸å½“äºç›´æ¥æš´åŠ›æ¯”è¾ƒä¸‹ä¸€ä¸ªå­—æ¯ï¼Œç„¶åé€šè¿‡ $D_lists$ æ¥åˆ†æå®ƒä»¬çš„å…ˆåå…³ç³»ã€‚ æˆ‘ä»¬å‘ç°äº†ä¸€ä¸ªæ‚²å‰§çš„äº‹å®ï¼šå·²ç»åŠ åˆ°3äº†ï¼Œæˆ‘ä»¬å´ä¾ç„¶æ— æ³•åˆ†æ¸… $[2,5]$ çš„é¡ºåºã€‚å¦‚æœç»§ç»­åŠ ä¸‹å»æˆ–è®¸å¯ä»¥åˆ†æ¸…å®ƒä»¬çš„é¡ºåºï¼Œä½†æ—¶é—´å¤æ‚åº¦å°±éš¾ä»¥ä¿æŒåœ¨ $\\Theta(n)$ï¼Œæ¢å¥è¯è¯´ï¼Œå®ƒå¾ˆå®¹æ˜“è¢«å¡ã€‚ æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬åˆ†æä¸€ä¸‹è¿™ç§æƒ…å†µå‡ºç°çš„åŸå› ã€‚ æ˜¾ç„¶æ­¤æ—¶ä¸¤ä¸ªåç¼€çš„éƒ¨åˆ†å‰ç¼€æ˜¯ç›¸åŒçš„ã€‚å³ä¸‹å›¾çš„æƒ…å†µï¼š","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘å¥—æ ‘","slug":"DS100P-TREE-COVER-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.137Z","comments":true,"path":"2020/02/07/DS100P-TREE-COVER-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-COVER-TREE/","excerpt":"","text":"æ ‘å¥—æ ‘($nlog^2n$) æ ‘å¥—æ ‘ä¹Ÿæ˜¯ä¸€ç§æš´åŠ›æ€æƒ³ï¼Œå®ƒå¯ä»¥æœ‰å¾ˆå¤šå®ç°ï¼šæ ‘çŠ¶æ•°ç»„å¥—å¹³è¡¡æ ‘ï¼Œä¸»å¸­æ ‘å¥—æ ‘çŠ¶æ•°ç»„â€¦â€¦ ä½†æ˜¯æœ€å¸¸è§çš„è¿˜æ˜¯çº¿æ®µæ•°å¥—å¹³è¡¡æ ‘ã€‚ 1.æ€æƒ³&amp;&amp;å»ºæ ‘æ ‡å‡†è¯´æ³•ï¼šçº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹å¯¹åº”å¹³è¡¡æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚ ??? å…¶å®è¿˜æ˜¯çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹å¯¹åº”ä¸€ä¸ªåŒºé—´ï¼Œä½†æ˜¯æˆ‘ä»¬æŠŠè¿™ä¸ªåŒºé—´å»ºæˆä¸€æ£µå¹³è¡¡æ ‘å°±è¡Œäº†ï¼Œçº¿æ®µæ ‘èŠ‚ç‚¹è®°å½•è¿™ä¸ªåŒºé—´å»ºæˆçš„å¹³è¡¡æ ‘çš„æ ¹èŠ‚ç‚¹å°±è¡Œäº†ã€‚ çº¿æ®µæ ‘æœ‰$logn$å±‚ï¼Œæ¯å±‚çš„èŠ‚ç‚¹å¯¹åº”çš„åŒºé—´èƒ½å¤Ÿæ‹¼æˆä¸€ä¸ªå®Œæ•´çš„åŒºé—´ï¼Œå³æ¯å±‚$n$ä¸ªå¹³è¡¡æ ‘èŠ‚ç‚¹ï¼Œå¹³è¡¡æ ‘æ¯ä¸ªèŠ‚ç‚¹æ’å…¥æ˜¯$logn$çš„ï¼Œæ‰€ä»¥å»ºæ ‘çš„æ—¶é—´å¤æ‚åº¦æ˜¯$nlog^2n$ fhq-treapç¤ºä¾‹ void build(int l,int r,int x) { for(int i=l;i&lt;=r;++i) { split(root[x],a[i],root1,root2); root[x]=merge(merge(root1,newnode(a[i])),root2); } if(l^r) { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); } } 2.æŸ¥è¯¢åŒºé—´æ’åç»™å®šä¸€ä¸ªåŒºé—´å’Œä¸€ä¸ªå€¼ï¼ŒæŸ¥è¯¢åŒºé—´ä¸­æ¯”ä»–å°çš„å…ƒç´ ä¸ªæ•°åŠ 1ã€‚ æˆ‘ä»¬å¯ä»¥åƒçº¿æ®µæ ‘ä¸€æ ·ï¼Œå…ˆæŠŠè¿™ä¸ªåŒºé—´æ‹†åˆ†æˆä¸€äº›èƒ½ç”¨æˆ‘ä»¬ä¹‹å‰å»ºæ ‘å»ºå‡ºçš„å¹³è¡¡æ ‘è¡¨ç¤ºçš„å°åŒºé—´ï¼Œå†æŸ¥è¯¢å°åŒºé—´ä¸­æ¯”è¿™ä¸ªå€¼å°çš„å…ƒç´ ä¸ªæ•°åŠ èµ·æ¥çš„å’Œã€‚ å¾ˆæ˜æ˜¾ f[i,j]=f[i,k]+f[k+1,j]ï¼ˆi\\leq k","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---trieæ ‘","slug":"DS100P-TRIE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-08T12:28:22.937Z","comments":true,"path":"2020/02/07/DS100P-TRIE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TRIE/","excerpt":"","text":"trieæ ‘($\\sum{len}$) $trie$æ ‘ï¼Œä¸æ˜¯ä¸€ç§äºŒå‰æ ‘ï¼Œå®ƒæ˜¯ä¸€ç§å¤šå‰æ ‘ï¼ˆå…¶å®ä¹Ÿå¯ä»¥æ˜¯äºŒå‰æ ‘ï¼‰ å¯ä»¥ç”¨æ¥æ±‚ä¸€å †æ•°ä¸­ä¸¤ä¸ªï¼ˆæˆ–ä¸‰ä¸ªï¼‰å¼‚æˆ–èµ·æ¥çš„æœ€å¤§å€¼ã€‚ å¯ä»¥æŸ¥æ‰¾å•è¯ã€‚ å¯¹äºä¸€äº›æœ‰å‰ç¼€çš„å•è¯ï¼Œæ¯”å¦‚WGY_2333å’ŒWGY_AND_LYC_WRITE_BLOGã€‚ å®ƒä»¬å°±å¯ä»¥å…±ç”¨æ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹ï¼ˆå³WGY_ï¼‰ï¼ŒæŸ¥è¯¢æ—¶å°±å¯ä»¥ä»$\\ $2$\\ $å’Œ$\\ $L$\\ $æ¥å¯¹ä»–ä»¬è¿›è¡ŒåŒºåˆ† æ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯çœ‹çœ‹å®ƒæ˜¯æ€ä¹ˆå®ç°çš„å§ã€‚ 1&gt;.æ’å…¥å¯¹äº$trie$æ ‘ï¼Œæ ‘ä¸Šçš„æ¯ä¸€æ¡è¾¹éƒ½ä»£è¡¨äº†ä¸€ä¸ªå­—æ¯æˆ–è€…ä¸€ä¸ªæ•°å­—ã€‚ æ‰€ä»¥ä¸€ä¸ªèŠ‚ç‚¹ä¼šæœ‰å¾ˆå¤šå„¿å­ï¼Œæˆ‘ä»¬å°±è¦å¼€ä¸€ä¸ªå„¿å­æ•°ç»„$ch$ã€‚ è¦ç»Ÿè®¡è¿™ä¸ªèŠ‚ç‚¹è¢«ç»è¿‡äº†å¤šå°‘æ¬¡ï¼Œä¹Ÿå°±æ˜¯å¤šå°‘å•è¯æœ‰è¿™ä¸ªå‰ç¼€ï¼Œå°±è¦åŠ ä¸€ä¸ª$sum$ã€‚ è¦ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªå•è¯åœ¨è¿™é‡Œç»“æŸï¼Œä¹Ÿå°±æ˜¯è¦æŸ¥è¯¢çš„å•è¯æœ‰å¤šå°‘ä¸ªå·²æ’å…¥çš„å•è¯ä½œå‰ç¼€ï¼Œå°±è¦åŠ ä¸€ä¸ª$end$ã€‚ æ’å…¥æ—¶ï¼Œå…ˆçœ‹è¿™ä¸ªèŠ‚ç‚¹æœ‰æ²¡æœ‰ä½ è¦èµ°çš„é‚£ä¸ªå„¿å­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±æ–°å»ºä¸€ä¸ªï¼Œèµ°ä¸‹å»ã€‚å¦åˆ™å°±ç›´æ¥èµ°åˆ°è¿™ä¸ªå„¿å­ï¼ˆå…±ç”¨èŠ‚ç‚¹å˜›ï¼‰ã€‚ ä»£ç ï¼šï¼ˆä»¥å°å†™å­—æ¯å•è¯ä¸ºä¾‹ï¼‰ struct node { int ch[26],sum,end; }nodes[MAXN]; int root=1,cnt=1; void ins(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].ch[str[i]-&#39;a&#39;]) nodes[x].ch[str[i]-&#39;a&#39;]=++cnt; x=nodes[x].ch[str[i]-&#39;a&#39;]; ++nodes[x].sum; } ++nodes[x].end; } 2&gt;.æŸ¥è¯¢$trie$æ ‘çš„æŸ¥è¯¢æœ‰å¾ˆå¤šç§ï¼Œä¸€èˆ¬ä¾ç…§é¢˜ç›®è¦æ±‚æ¥è‡ªå·±å®šä¹‰ã€‚ æˆ‘ä»¬è¿™é‡Œåˆä»¥å°å†™å­—æ¯å•è¯æŸ¥è¯¢å­˜åœ¨æ€§ä¸ºä¾‹ã€‚ åŒæ ·æ˜¯ä»æœ€ä¸Šé¢çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰è¿™ä¸ªå•è¯ç°åœ¨ä½ç½®å­—æ¯çš„å„¿å­ï¼Œå°±èµ°ä¸‹å»ã€‚å¦åˆ™å°±ç›´æ¥è¿”å›falseï¼Œå› ä¸ºä¹‹å‰æ²¡æœ‰è¿‡å•è¯èµ°è¿‡è¿™æ¡è·¯å¾„,å¦‚æœæœ‰è¿‡è¿™ä¸ªå‰ç¼€çš„å•è¯èµ°è¿‡ï¼Œè‚¯å®šä¼šåˆ›å»ºè¿™ä¸ªèŠ‚ç‚¹ã€‚ æœ€åå†åˆ¤æ–­æœ‰æ²¡æœ‰å•è¯åœ¨è¿™ä¸ªåœ°æ–¹ç»“æŸã€‚ ä»£ç : bool find(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].str[str[i]-&#39;a&#39;]) return false; x=nodes[x].str[str[i]-&#39;a&#39;]; } return nodes[x].end; } trieæ ‘å°±åªæœ‰è¿™ä¹ˆç‚¹ï¼ŒæƒŠä¸æƒŠå–œï¼Œæ„ä¸æ„å¤–","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘é“¾å‰–åˆ†","slug":"DS100P-TREE-CHAIN-SPLITTING","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.136Z","comments":true,"path":"2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","excerpt":"","text":"æ ‘é“¾å‰–åˆ†($nlogn$) æ ‘é“¾å‰–åˆ†å‡†ç¡®åœ°è¯´å¹¶ä¸æ˜¯æ•°æ®ç»“æ„ï¼Œå®ƒåªæ˜¯æ•°æ®ç»“æ„çš„ä¸€ç§åº”ç”¨ã€‚ å®ƒç”¨äºå°†ä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹è½¬æ¢åˆ°ä¸€ä¸ªåºåˆ—ä¸­ï¼Œç„¶åç”¨å„ç§æ•°æ®ç»“æ„ç»´æŠ¤ã€‚ æ‰€ä»¥æˆ‘åªè®²å¦‚ä½•è½¬æ¢å’Œä½¿ç”¨ï¼Œè€Œç»´æŠ¤å°±å› é¢˜è€Œå¼‚äº†ã€‚ æ ‘é“¾å‰–åˆ†æœ‰å¥½å‡ ç§æ–¹æ³•ï¼šé‡é“¾å‰–åˆ†ï¼Œé•¿é“¾å‰–åˆ†â€¦ ä½†æˆ‘å°±è®²æœ€å¸¸ç”¨çš„é‡é“¾å‰–åˆ†ã€‚ é‡é“¾å‰–åˆ†ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯æŒ‰ç…§èŠ‚ç‚¹çš„å­æ ‘å¤§å°æ¥å‰–åˆ†è¿™æ£µæ ‘ã€‚ ä¸€ä¸ªèŠ‚ç‚¹å­èŠ‚ç‚¹ä¸­å­æ ‘å¤§å°æœ€å¤§çš„å­èŠ‚ç‚¹å«åšè¿™ä¸ªèŠ‚ç‚¹çš„é‡å„¿å­ã€‚ ä»¥ä¸€ä¸ªè½»å„¿å­ä¸ºèµ·ç‚¹ï¼Œå…¶ä½™å…¨æ˜¯é‡å„¿å­çš„é“¾å«åšé‡é“¾ã€‚ é‡é“¾ä¸Šçš„è¾¹å«åšé‡è¾¹ã€‚ å°±åƒè¿™æ ·ï¼ˆçº¢è‰²çš„è¾¹ä¸ºé‡è¾¹ï¼‰ å¯ä»¥å‘ç°ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½åœ¨ä¸”ä»…åœ¨ä¸€æ¡é‡é“¾ä¸Šï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™ä¸€æ¡é“¾è½¬æ¢åˆ°ä¸€ä¸ªè¿ç»­çš„åŒºé—´æ¥è¿›è¡Œç»´æŠ¤ã€‚ dfs1æˆ‘ä»¬é‡‡ç”¨dfsçš„å½¢å¼æ¥è¿›è¡Œå‰–åˆ†ï¼Œè®°å½•ä¿¡æ¯ã€‚ ç¬¬ä¸€æ¬¡dfsæˆ‘ä»¬éœ€è¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œå­æ ‘å¤§å°ï¼Œé‡å„¿å­å’Œæ·±åº¦ã€‚ å¾ˆç®€å•å¯¹å§ï¼Œå°±æ˜¯æš´åŠ›$dfs$ï¼Œä½†è¦æ³¨æ„ä¸è¦æœå›åˆ°çˆ¶äº²èŠ‚ç‚¹å’Œä¸€äº›å…¶ä»–çš„å‘ã€‚ ä»£ç ï¼š void dfs1(int x,int last) { fa[x]=last;//è®°å½•çˆ¶äº²èŠ‚ç‚¹ã€‚ sum[x]=1;//åˆå§‹åŒ–å­æ ‘å¤§å°ï¼šè¯¥èŠ‚ç‚¹æœ¬èº«ã€‚ depth[x]=depth[last]+1;//æ·±åº¦ï¼šçˆ¶äº²èŠ‚ç‚¹æ·±åº¦+1ã€‚ int big=0,bi=0;//å¯»æ‰¾é‡å„¿å­ for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^last)//é¿å…é‡æ–°å›åˆ°çˆ¶äº²èŠ‚ç‚¹ { dfs1(e[x][i],x); sum[x]+=sum[e[x][i]]; if(sum[e[x][i]]&gt;big) { big=sum[e[x][i]]; bi=e[x][i]; } } } son[x]=bi;//è®°å½•é‡å„¿å­ã€‚ } //è°ƒç”¨:dfs(root,root) dfs2ç»è¿‡åˆšåˆš$dfs1$çš„å‡†å¤‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œå‰–åˆ†äº†ï¼Œè¿™æ¬¡è®°å½•$dfs$åºï¼Œè½¬æ¢å‡ºçš„åºåˆ—ä¸Šçš„æ¯ä¸€ä¸ªå€¼ï¼Œä»¥åŠæ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨é‡é“¾çš„èµ·ç‚¹ã€‚ æˆ‘ä»¬åœ¨è¿™æ¬¡$dfs$æ—¶åº”è¯¥ä¼˜å…ˆèµ°é‡å„¿å­ï¼Œè¿™æ ·æ‰èƒ½ä½¿ä¸€æ¡é‡é“¾ä¸Šçš„å€¼éƒ½åœ¨åºåˆ—ä¸Šè¿åœ¨ä¸€èµ·ï¼Œæ–¹ä¾¿æˆ‘ä»¬æ“ä½œã€‚ ä»£ç : void dfs2(int x,int last,bool heavier) { dfn[x]=++tot;//è®°å½•dfsåº turn[tot]=val[x];//è®°å½•åºåˆ— if(heavier) hb[x]=hb[fa[x]];// else hb[x]=x;//è®°å½•æ‰€åœ¨é‡é“¾èµ·ç‚¹ if(b[x].son) build2(b[x].son,1);//ä¼˜å…ˆéå†é‡å„¿å­ for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^son[x]&amp;&amp;e[x][i]^fa[x]) build2(e[x][i],0);//é¿å…é‡å¤éå† } } ä¸€ä¸ªèŠ‚ç‚¹çš„$dfs$åºå°±æ˜¯å®ƒåœ¨åºåˆ—ä¸­çš„ä½ç½®ã€‚å¯¹å§ ä½¿ç”¨å¯¹äºä¸€äº›å­æ ‘ä¸Šçš„æ“ä½œï¼Œ$dfs$åºå·²ç»èƒ½å¤Ÿæå®šäº†ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å‰–å‡ºçš„é‡é“¾å¯¹é‚£äº›ç»“ç‚¹é—´è·¯å¾„çš„æ“ä½œè¿›è¡Œåº”å¯¹å°±å¥½äº†ã€‚ å¯¹äºä¸¤ä¸ªèŠ‚ç‚¹é—´çš„è·¯å¾„ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°$LCA$ã€‚è€Œæˆ‘ä»¬è®°å½•äº†é‡é“¾çš„èµ·ç‚¹ï¼Œå¯ä»¥å¤„ç†è¿™æ¡é‡é“¾ï¼Œç„¶åç›´æ¥è·³åˆ°ä¸Šé¢ä¸€æ¡é‡é“¾çš„æœ«ç«¯ã€‚ æ³¨æ„å½“ä¸¤ä¸ªèŠ‚ç‚¹åœ¨åŒä¸€æ¡é‡é“¾æ—¶è·³å‡ºå¾ªç¯ï¼Œåœ¨æœ€åå¤„ç†ä»–ä»¬ä¹‹é—´çš„è·¯å¾„ã€‚ ç”±äºä»–ä»¬å·²ç»åœ¨åŒä¸€æ¡é‡é“¾ä¸Šäº†ï¼Œä»–ä»¬åŠä»–ä»¬ä¹‹é—´çš„èŠ‚ç‚¹$dfs$åºæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥å†å¤„ç†è¿™ä¸ªè¿ç»­åŒºé—´å°±å¥½äº†ã€‚ ä»£ç ï¼š //è®¾solve(x,y)æ˜¯å¯¹xåˆ°yåŒºé—´çš„æ“ä½œ(å› é¢˜è€Œå¼‚) ___ LCA(int x,int y) { int fx=hb[x],fy=hb[y];//å¾—åˆ°é‡é“¾èµ·ç‚¹ while(fx^fy) { if(depth[fx]&lt;depth[fy])//ä»æ·±åº¦å¤§çš„å¾€ä¸Šè·³ { swap(fx,fy); swap(x,y); } solve(dfn[fx],dfn[x]);//å¤„ç†è¿™æ¡é‡é“¾çš„åŒºé—´ x=fa[fx];//è·³åˆ°ä¸Šé¢ä¸€æ¡é‡é“¾ fx=hb[x];//æ›´æ–°é‡é“¾èµ·ç‚¹ } solve(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));//æœ€åå¤„ç†åŒä¸€æ¡é‡é“¾ä¸Šçš„å‰©ä½™æœªå¤„ç†éƒ¨åˆ†ã€‚ //return ans; } 5.ä¸»å¸­æ ‘($nlogn$) â€œä½ æ˜¯ä¸»å¸­æ ‘å—ï¼Ÿæœ‰é‚£ä¹ˆå¤šçˆ·çˆ·ï¼â€â€”â€”$LJS$ã€‚ è¿™å¥è¯è¿ç”¨æ‰“æ¯”æ–¹çš„è¯´æ˜æ–¹æ³•ï¼Œç”ŸåŠ¨å½¢è±¡åœ°è¯´æ˜äº†ä¸»å¸­æ ‘æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¾ˆå¤šçˆ¶äº²çš„ç‰¹ç‚¹ï¼Œä½“ç°è¯´æ˜è¯­è¨€çš„ç”ŸåŠ¨æ€§ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸»å¸­æ ‘çš„å‡ ä¸ªèŠ‚ç‚¹å¯èƒ½å…±ç”¨ä¸€ä¸ªå­èŠ‚ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š ä¸»å¸­æ ‘å¯ä»¥ç”¨æ¥æŸ¥è¯¢é™æ€åŒºé—´ç¬¬kå°ï¼Œé™æ€åŒºé—´å‰kå¤§çš„å’Œç­‰ç­‰ã€‚ï¼ˆç”¨æ³•ååˆ†çµæ´»ï¼‰ æˆ‘ä»¬ä¼šåˆ›å»ºå¾ˆå¤šç‰ˆæœ¬çš„æ ‘ï¼Œä¸€äº›ç‰ˆæœ¬ä¼šå…±ç”¨ä¸€äº›èŠ‚ç‚¹ï¼Œä»¥èŠ‚çœç©ºé—´å’Œæ—¶é—´ã€‚ ä¸»å¸­æ ‘ä¹Ÿå«å¯æŒä¹…åŒ–çº¿æ®µæ ‘ã€‚ä½†å¯æŒä¹…åŒ–è¿˜æœ‰å¾ˆå¤šä¸œè¥¿ã€‚æˆ‘å°±è®²å¯æŒä¹…åŒ–çº¿æ®µæ ‘å§ã€‚ 1.å¦‚ä½•å…±ç”¨èŠ‚ç‚¹æˆ‘ä»¬è€ƒè™‘å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ã€‚ å¦‚æœè¦å¾—åˆ°è¿™ä¸ªåºåˆ—æŸä¸ªå…ƒç´ $x$åŠ ä¸Šä¸€ä¸ªå€¼$val$ä¹‹åçš„æ–°ç‰ˆæœ¬ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæ”¹å˜çš„åªæœ‰å¯¹åº”å…ƒç´ $x$çš„èŠ‚ç‚¹å’Œä»–çš„ç¥–å…ˆä¼šåŠ ä¸Š$val$ã€‚é‚£ä¹ˆå…¶ä»–èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥ä¸ä¸Šä¸€ä¸ªç‰ˆæœ¬å…±ç”¨ã€‚ æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§æ‰¿ä¹‹å‰è¯¥ä½ç½®çš„å€¼å’Œå·¦å³å„¿å­ï¼Œç„¶åæ›´æ–°å€¼ï¼Œå†ç»§ç»­å‘ä¸‹å¯»æ‰¾å…ƒç´ $x$çš„ä½ç½®ï¼Œæœ€åé€’å½’å›æ¥æ›´æ–°è¿™ä¸ªå„¿å­ã€‚ æˆ‘ä»¬ä½¿ç”¨$root$æ•°ç»„æ¥è®°å½•æ¯ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ç¼–å·ã€‚ ä»£ç ï¼š void ins(int l,int r,int pre,int &amp;now,int pos,int val)//åŒºé—´å·¦å³ç«¯ç‚¹ï¼Œä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œå½“å‰ç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œä¿®æ”¹ä½ç½®ï¼Œå¢åŠ çš„å€¼ã€‚ { nodes[++tot]=nodes[pre];//å…ˆæ•´ä¸ªå¤åˆ¶ now=tot;//æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å„¿å­ã€‚ nodes[now].sum+=val;//æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å€¼ if(l==r) return; //å‘ä¸‹ç»§ç»­å¯»æ‰¾ int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //è°ƒç”¨ï¼šins(1,n,root[i-1],root[i],p,v); æœ€å$root[i]$çš„å¼•ç”¨å°±ç›¸å½“äºè®°å½•äº†è¿™ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ã€‚ æŸ¥è¯¢å…¶å®å°±å’Œæ™®é€šçš„çº¿æ®µæ ‘ä¸€æ ·ï¼Œä½†ä¸»å¸­æ ‘çš„ç”¨é€”ä¸æ­¢è¿™ä¸ªã€‚ 2.ä¾‹é¢˜ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ 1ï¼ˆä¸»å¸­æ ‘ï¼‰ å¦‚é¢˜ï¼Œç»™å®š $n$ ä¸ªæ•´æ•°æ„æˆçš„åºåˆ—ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬ $k$ å°å€¼ã€‚ æƒå€¼çº¿æ®µæ ‘ï¼š (çº¿æ®µæ ‘çš„å¦ä¸€ç§åº”ç”¨ï¼Œåªæ˜¯æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æ•´ä¸ªåºåˆ—å€¼åœ¨$[l,r]$åŒºé—´å†…çš„æ•°çš„ä¸ªæ•°) è¿™é“é¢˜è¦æ±‚æŸ¥è¯¢é™æ€åŒºé—´ç¬¬$k$å°ã€‚é‚£ä¹ˆå¯¹äºç¬¬$k$å°è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ ç¦»æ•£åŒ–ï¼š$-1e9\\leq a_i \\leq1e9$ çš„æ•°æ®çº¿æ®µæ ‘è‚¯å®šå¼€ä¸ä¸‹ï¼Œä½†è¿™é“é¢˜åªéœ€è¦æ±‚ç¬¬kå°ï¼Œæ²¡æœ‰å¿…è¦å¼€é‚£ä¹ˆå¤§ï¼Œå¯ä»¥å¯¹æ•°æ®è¿›è¡Œç¦»æ•£åŒ–ã€‚ æˆ‘ä»¬æŒ‰ç…§åºåˆ—çš„é¡ºåºæ’å…¥$a_i$ã€‚å¾—åˆ°æ¯ä¸ª$root[i]$ä»£è¡¨çš„æƒå€¼çº¿æ®µæ ‘ä»£è¡¨ä»$a_1$åˆ°$a_i$çš„æ¯ä¸ªæ•°å€¼çš„å‡ºç°æ¬¡æ•°ã€‚ é‚£ä¹ˆæ ¹æ®å‰ç¼€å’Œçš„æ€æƒ³ï¼ŒåŒºé—´$[l,r]$ä¸­æ¯ä¸ªæ•°å€¼çš„å‡ºç°ä¸ªæ•°å°±æ˜¯$[1,r]$çš„å‡å»$[1,l-1]$çš„ã€‚é‚£ä¹ˆæ•°å€¼çš„åŒºé—´ä¹Ÿå…·æœ‰è¿™ä¸ªæ€§è´¨ã€‚ æ‰€æœ‰å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæˆ‘ä»¬åªéœ€è¦æŸ¥è¯¢ä¸€æ¬¡ï¼Œç”¨$root[r]$å’Œ$root[l-1]$çš„æƒå€¼çº¿æ®µæ ‘å¤„ç†å‡ºåŒºé—´$[l,r]$åº”æœ‰çš„æƒå€¼çº¿æ®µæ ‘ï¼Œå°±å¯ä»¥åƒæ­£å¸¸çš„æƒå€¼çº¿æ®µæ ‘ä¸€æ ·æŸ¥è¯¢ç¬¬kå°äº†ã€‚ ä»£ç ï¼š #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//æ’å…¥ï¼Œåˆ›å»ºæ–°ç‰ˆæœ¬ { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//ç°åœºå¤„ç†ï¼Œå¾—åˆ°[x,y]åŒºé—´å†…ï¼Œå€¼åœ¨[l,mid]å†…çš„æ•°çš„ä¸ªæ•° if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//å¦‚æœk&lt;=X.è¯´æ˜ç¬¬kå°çš„æ•°åœ¨å·¦è¾¹ã€‚ else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//å¦åˆ™åœ¨å³è¾¹ã€‚ } int getid(int X)//å¾—åˆ°ç¦»æ•£åŒ–åçš„æ•°å€¼ { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//ç¦»æ•£åŒ– for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//æŒ‰é¡ºåºæ’å…¥æ¯ä¸ªå€¼ï¼Œå¾—åˆ°root[i]å¯¹åº”çš„æƒå€¼çº¿æ®µæ ‘ã€‚ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//æŸ¥è¯¢åŒºé—´[x,y]ï¼›è¾“å‡ºåŸå€¼ } return 0; } 3.ç¼ºç‚¹åŠæ³¨æ„äº‹é¡¹å†…å­˜æ± ä¸€èˆ¬ä»1å¼€å§‹ç”¨ï¼Œ$nodes[0]$ä½œä¸ºç©ºç™½ï¼Œå€¼ä¸º$0$ï¼Œå„¿å­èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼Œå€¼è¿˜æ˜¯ä¸º$0$ã€‚ å½“ä½ è¿™ä¸ªç‰ˆæœ¬çš„æ ‘è¿˜æ²¡æœ‰æ”¹è¿‡æŸä¸ªèŠ‚ç‚¹çš„æŸä¸ªå„¿å­æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹çš„è¿™ä¸ªå„¿å­ä¼šæŒ‡å‘$nodes[0]$ï¼Œä¹Ÿå°±ç›¸å½“äºä¸‹é¢éƒ½æ˜¯$0$ï¼Œæ­£å¥½ç¬¦åˆã€‚ æ•°ç»„ä¸€å®šè¦å¼€å¤§ï¼Œå¦‚æœå¼€å¾—ä¸å¤Ÿå¤§å¯èƒ½ä¼šå‡ºç°$MLE$,$TLE$,$RE$,$WA$. ä½†ä¹Ÿä¸è¦å¼€å¤ªå¤§ï¼Œä¸ç„¶ä¼š$MLE$,$CE$. ä¸»å¸­æ ‘æ˜¯é™æ€çš„ï¼Œé‡åˆ°è¦åŠ¨æ€ä¿®æ”¹è€Œä¸æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°ç‰ˆæœ¬çš„é—®é¢˜ï¼Œå°±å¯èƒ½è¦ç”¨æ ‘å¥—æ ‘äº†ã€‚ å¯æŒä¹…åŒ–å¯ä»¥ç”¨åœ¨å¾ˆå¤šæ•°æ®ç»“æ„ä¸Šï¼Œå¹³è¡¡æ ‘ï¼Œçº¿æ®µæ ‘ï¼Œ$trie$æ ‘â€¦â€¦å¯å¤Ÿå¾—å†™ï¼Œä½†å®ƒä»¬çš„æ€æƒ³éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œéƒ½æ˜¯æ¯ä¸ªç‰ˆæœ¬ä¸ä¹‹å‰çš„ç‰ˆæœ¬å…±ç”¨èŠ‚ç‚¹ä»¥èŠ‚çœæ—¶é—´ï¼Œç©ºé—´ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---fhq-treap","slug":"DS100P-FHQ-TREAP","date":"2020-02-05T06:51:05.000Z","updated":"2020-02-20T02:48:47.113Z","comments":true,"path":"2020/02/05/DS100P-FHQ-TREAP/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-FHQ-TREAP/","excerpt":"","text":"fhq-treap($nlogn$) $fhq-treap$æ˜¯ä¸€ç§äºŒå‰æœç´¢æ ‘ã€‚æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼šä¸­åºéå†æ˜¯ä¸€ä¸ªä¸é™åºåˆ—ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å„¿å­å°äºç­‰äºå®ƒï¼Œå³å„¿å­å¤§äºç­‰äºå®ƒã€‚ ä½†å®ƒå’Œ$treap$ä¸€æ ·ï¼Œéƒ½æ»¡è¶³å †çš„æ€§è´¨ï¼šä»»æ„çˆ¶èŠ‚ç‚¹çš„é”®å€¼å¤§äº(ç­‰äº)æˆ–å°äº(ç­‰äº)å­èŠ‚ç‚¹çš„é”®å€¼ã€‚ å®ƒå¯ä»¥åšæ™®é€šå¹³è¡¡æ ‘ï¼ˆåŸºæœ¬æ“ä½œï¼‰ï¼Œæ–‡è‰ºå¹³è¡¡æ ‘ï¼ˆåŒºé—´æ“ä½œï¼‰ï¼Œè¿˜å¯ä»¥å¯æŒä¹…åŒ–ã€‚ ä½†å¸¸æ•°ç•¥å¤§ã€‚ å®šä¹‰ï¼š struct node { int l,r,num,key,cum; //å·¦å„¿å­ï¼Œå³å„¿å­ï¼Œæœ¬èŠ‚ç‚¹çš„å€¼ï¼Œé”®å€¼ï¼Œå­æ ‘å¤§å° }nodes[MAXN]; 1.æƒå€¼fhq-treapæƒå€¼$fhq-treap$çš„æ„æ€æ˜¯ï¼Œå®ƒè¿™æ—¶å€™æ—¢æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œåˆæ»¡è¶³å †çš„æ€§è´¨ã€‚ å…ˆè®²è®²è¾…åŠ©æ“ä½œå§ï¼š update:ç”¨æ¥æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å­æ ‘å¤§å°ã€‚ ä»£ç å®ç°ï¼š void update(int x) { nodes[x].cum=nodes[nodes[x].l].cum+nodes[nodes[x].r].cum+1; } å› ä¸ºä¸€ä¸ªèŠ‚ç‚¹çš„å­æ ‘å¤§å°ç­‰äºå®ƒå·¦å³å„¿å­çš„å­æ ‘å¤§å°åŠ ä¸Šå®ƒæœ¬èº«å˜›ã€‚ newnode:æ–°å»ºä¸€ä¸ªå€¼ä¸ºæŒ‡å®šå€¼çš„èŠ‚ç‚¹å¹¶è¿”å›å®ƒçš„ç¼–å·ã€‚ ä»£ç å®ç°ï¼š int newnode(int val) { nodes[++tot].cum=1; nodes[tot].num=val; nodes[tot].key=rand(); return tot; } ä¸»è¦æ“ä½œæœ‰ä¸¤ä¸ªï¼š 1&gt;.åˆ†è£‚splitè¿™é‡Œçš„åˆ†è£‚æŒ‰ç…§æƒå€¼åˆ†è£‚ï¼Œå³æŠŠåŸæ ‘æŒ‰ç…§æƒå€¼$val$åˆ†æˆä¸¤æ£µæ ‘ï¼Œä¸€æ£µ$X$ä¸­çš„æƒå€¼å…¨éƒ¨å°äºç­‰äº$val$ï¼Œå¦ä¸€æ£µyçš„æƒå€¼å…¨éƒ¨å¤§äº$val$ã€‚è€Œè¿™ä¸¤æ£µæ ‘éƒ½è¦æ»¡è¶³ä¸¤ä¸ªæ€§è´¨ã€‚ è¦å®ç°è¿™ä¸ªæ“ä½œï¼Œæˆ‘ä»¬è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†ï¼ŒæŠŠæ•´æ£µæ ‘åˆ†æˆä¸¤åŠã€‚ æˆ‘ä»¬è¿›è¡Œåˆ†ç±»è®¨è®ºï¼šç°åœ¨éå†åˆ°çš„èŠ‚ç‚¹ç¼–å·ä¸º$now$ã€‚ 1).å½“$now=0$æ—¶ è¿™æ—¶ï¼Œnowæ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæ²¡æœ‰åŠæ³•åˆ†è£‚ã€‚ 2).å½“$nodes[now].num\\leq val$æ—¶ è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠå®ƒçš„å·¦å­æ ‘çš„æƒå€¼éƒ½å°äºç­‰äº$val$,é‚£ä¹ˆä»–ä»¬å…¨éƒ¨éƒ½å±äº$X$ã€‚ é‚£ä¹ˆå®ƒçš„å³å­æ ‘å¯èƒ½æ˜¯$X$çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯$Y$çš„ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­åˆ†è£‚å³å­æ ‘ï¼Œä½†ç”±äºå³è¾¹çš„æ•°è¦æ¯”$nodes[now].num$å¤§ï¼Œæ¥ä¸‹æ¥åˆ†è£‚å‡ºçš„å°äºç­‰äº$val$çš„å­æ ‘éœ€è¦æ¥åœ¨å½“å‰åˆ†å‡ºçš„$X$æ ‘çš„å³å­æ ‘ä¸Šã€‚ 3).å¦åˆ™ è¿™ä¸ªæ—¶å€™è¿™ä¸ªèŠ‚ç‚¹å’Œå®ƒçš„å³å­æ ‘çš„æƒå€¼éƒ½å¤§äº$val$ï¼Œé‚£ä¹ˆä»–ä»¬å…¨éƒ¨å±äº$Y$ã€‚ ä½†å®ƒçš„å·¦å­æ ‘å¯èƒ½æœ‰ä¸€éƒ¨åˆ†å±äº$X$ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­åˆ†è£‚å·¦å­æ ‘ã€‚é“ç†åŒä¸Šã€‚ ä¸Šé¢æ“ä½œå·²ç»ä¿è¯äº†åˆ†å‡ºçš„äºŒå‰æ ‘æ»¡è¶³äºŒå‰æ ‘æ€§è´¨ã€‚è€Œå †æ€§è´¨ä¹Ÿå¾—åˆ°äº†æ»¡è¶³ï¼Œå› ä¸ºä»åŸæ ‘ä¸Šå¾€ä¸‹åˆ†ï¼Œåˆ†åˆ°èŠ‚ç‚¹çš„é”®å€¼ä¹Ÿæ˜¯æœ‰åºçš„ã€‚ é€’å½’è¿”å›å‰è¿˜è¦è®°å¾—$update$ä¸€ä¸‹ï¼Œæ›´æ–°åˆ†è£‚åçš„å­æ ‘å¤§å°ã€‚ æ˜¯ä¸æ˜¯è¿˜æ˜¯ä¸æ‡‚ï¼Ÿè¿˜æ˜¯çœ‹ä»£ç å’Œä»£ç æ³¨é‡Šå§ï¼š //x,yä»£è¡¨ä»nowè¿™ä¸ªèŠ‚ç‚¹åˆ†è£‚å‡ºçš„ä¸¤æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä½¿ç”¨å¼•ç”¨è¿”å›å€¼ã€‚ void split(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0;//æƒ…å†µ1).æ— æ³•ç»§ç»­åˆ†è£‚ï¼Œæ‰€ä»¥ä¸¤æ£µæ ‘éƒ½æ˜¯ç©ºã€‚ else { if(nodes[now].num&lt;=val)//æƒ…å†µ2). { x=now;//å·¦å­æ ‘å’Œè¿™ä¸ªèŠ‚ç‚¹éƒ½å±äºXæ ‘ï¼Œæ¥åˆ°ä¹‹å‰åˆ†è£‚åˆ°çš„åœ°æ–¹ã€‚å³å­æ ‘åœ¨ä¸‹é¢ä¼šå—åˆ°ä¿®æ”¹ï¼Œæ‰€ä»¥å³å­æ ‘å¹¶æ²¡æœ‰è¢«ç›´æ¥åŒ…æ‹¬ã€‚ split(nodes[now].r,val,nodes[x].r,y);//ç»§ç»­åˆ†è£‚å³å­æ ‘ã€‚æ¥ä¸‹æ¥åˆ†è£‚å‡ºå±äºXæ ‘çš„æ ¹èŠ‚ç‚¹ä½ç½®åº”è¯¥æ˜¯nodes[x].rï¼Œyçš„ä½ç½®æ²¡æœ‰å˜åŠ¨ã€‚ } else//æƒ…å†µ3). { y=now; split(nodes[now].l,val,x,nodes[y].l);//åŒä¸Š } update(now); //ç”±äºæ— è®ºè¿›å…¥å“ªä¸ªåˆ¤æ–­ï¼Œä½œäº†æ”¹å˜çš„èŠ‚ç‚¹éƒ½ç­‰äºnow,æ‰€ä»¥å¯ä»¥ç›´æ¥æ›´æ–°nowã€‚ } } //è°ƒç”¨ï¼šsplit(root,v,root1,root2) æœ€åä¼ å›çš„å€¼å°±ç›¸å½“äºç»™$root1$,$root2$èµ‹å€¼ã€‚ $root1$,$root2$å°±æ˜¯åˆ†è£‚å‡ºçš„$X$æ ‘å’Œ$Y$æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ 2&gt;.åˆå¹¶mergeå³æŠŠä¸¤é¢—åƒåˆšåˆšä¸Šé¢åˆ†è£‚å‡ºæ¥çš„ä¸¤é¢—æ ‘åˆå¹¶æˆä¸€æ£µæ»¡è¶³ä¸¤ä¸ªæ€§è´¨çš„æ ‘ã€‚ æˆ‘ä»¬åˆè¦åˆ†ç±»è®¨è®ºï¼šç°åœ¨éœ€è¦åˆå¹¶çš„èŠ‚ç‚¹æ˜¯$x$,$y$ã€‚ï¼ˆç¤ºä¾‹å°æ ¹å †ï¼‰ 1).$x=0$|$\\ $|$y=0$ åªæœ‰ä¸€æ£µæ ‘ï¼Œç›´æ¥è¿”å›è¿™æ£µæ ‘ã€‚ 2).$nodes[x].key&lt;nodes[y].key$ $x$èŠ‚ç‚¹çš„é”®å€¼æ›´å°ï¼Œæ‰€ä»¥$x$åº”è¯¥åœ¨$y$çš„ä¸Šé¢ã€‚ $y$çš„å€¼ä¸€å®šå¤§äº$x$,æ‰€ä»¥æŠŠ$y$å’Œ$x$çš„å³å­æ ‘è¿›è¡Œåˆå¹¶ã€‚ 3).å¦åˆ™ $y$åº”è¯¥åœ¨$x$çš„ä¸Šé¢ã€‚ $x$çš„å€¼ä¸€å®šå°äº$y$ï¼Œæ‰€ä»¥æŠŠ$y$çš„å·¦å„¿å­å’Œ$x$è¿›è¡Œåˆå¹¶ã€‚ ä»£ç ï¼š int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } å­¦ä¼šäº†è¿™ä¸¤ä¸ªæ“ä½œä¹‹åï¼Œå°±å¯ä»¥å®ç°æ™®é€šå¹³è¡¡æ ‘çš„æ‰€æœ‰æ“ä½œäº†ã€‚ 3.æ’å…¥æ’å…¥çš„ä»£ç åªæœ‰ä¸¤è¡Œï¼Œéå¸¸ç®€å•ã€‚ åªéœ€è¦æŠŠåŸæ•°æŒ‰è¦æ’å…¥çš„å€¼$val$å¤§å°åˆ†è£‚ï¼Œä¸€è¾¹$x$å°äºç­‰äº$val$ï¼Œå¦ä¸€è¾¹$y$å¤§äº$val$ã€‚ å†æŠŠ$x$ä¸è¿™ä¸ªå€¼èŠ‚ç‚¹åˆå¹¶ï¼ˆå¾—åˆ°$z$ï¼‰ï¼Œæœ€åä¸$y$åˆå¹¶ã€‚ å› ä¸º$x$çš„èŠ‚ç‚¹å…¨éƒ¨å°äºç­‰äº$val$,$z$çš„èŠ‚ç‚¹å…¨éƒ¨å°äº$y$ã€‚æ»¡è¶³æˆ‘ä»¬ä¹‹å‰åˆå¹¶ä¸¤æ£µæ ‘çš„æ¡ä»¶ã€‚ ä»£ç ï¼š void ins(int val) { split(root,val,root1,root2); root=merge(merge(root1,newnode(val)),root2); } 4.åˆ é™¤å…ˆæŠŠè¦åˆ é™¤çš„å€¼$val$ä»åŸæ ‘ä¸­åˆ†è£‚å‡ºæ¥ï¼Œåˆ æ‰ä¸€ä¸ªå†åˆå¹¶å›å»ã€‚ æ€ä¹ˆåœ¨å¾ˆå¤šçš„$val$ä¸­åˆ æ‰ä¸€ä¸ªå‘¢ã€‚ æˆ‘ä»¬æŠŠ$val$å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹åˆå¹¶èµ·æ¥ï¼Œå°±ç›¸å½“äºæŠ›å¼ƒäº†è¿™ä¸ªæ ¹èŠ‚ç‚¹ã€‚ è¿™æ ·ä¿è¯äº†å¦‚æœæœ‰è¿™ä¸ªå€¼ï¼Œä¸€å®šä¼šè¢«åˆ æ‰ï¼Œå› ä¸ºå¦‚æœæœ‰ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹è‚¯å®šæœ‰ã€‚ ä»£ç ï¼š void del(int val) { split(root,val,root1,root2); split(root1,val-1,root1,root3); root3=merge(nodes[root3].l,nodes[root3].r); root=merge(merge(root1,root3),root2); } 5.å‰é©±/åç»§æˆ‘ä»¬æŠŠå°äº/å¤§äºæŸ¥è¯¢å€¼$val$çš„å­æ ‘åˆ†è£‚å‡ºæ¥ï¼Œç”±äºåˆ†è£‚å‡ºçš„å­æ ‘ä¾ç„¶æ»¡è¶³äºŒå‰æ ‘æ€§è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥æŸ¥è¯¢è¿™ä¸ªå­æ ‘ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼ï¼ŒæŸ¥è¯¢å‡ºçš„å€¼å°±æ˜¯ç­”æ¡ˆã€‚æœ€åè®°å¾—åˆå¹¶å›å»ã€‚ ä»£ç ï¼š int pre(int val) { split(root,val-1,root1,root2); int now=root1,res=-INF; if(now) { while(nodes[now].r) now=nodes[now].r; res=nodes[now].num; } root=merge(root1,root2); return res; } int nxt(int val) { split(root,val,root1,root2); int now=root2,res=INF; if(now) { while(nodes[now].l) now=nodes[now].l; res=nodes[now].num; } root=merge(root1,root2); return res; } 6.ç¬¬kå°å¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œ$fhq-treap$æ²¡æœ‰ç‰¹æ®Šçš„è§£å†³æ–¹æ³•ã€‚æ‰€ä»¥å’Œ$treap$ä¸€æ ·ã€‚ ç”±äºäºŒå‰æœç´¢æ ‘ä¸­åºéå†ä¸ºä¸é™åºåˆ—ï¼Œæˆ‘ä»¬åˆ†æƒ…å†µè®¨è®ºï¼š 1&gt;.å·¦å­æ ‘å¤§å°$+1$ç­‰äº$k$ã€‚ è¯´æ˜å½“å‰èŠ‚ç‚¹å°±æ˜¯ç¬¬$k$å°ã€‚ 2&gt;.å·¦å­æ ‘å¤§å°å°äºç­‰äº$k$ è¯´æ˜ç¬¬$k$å¤§åœ¨å·¦è¾¹ï¼Œé‚£ä¹ˆå‘å·¦è¾¹ç»§ç»­å¯»æ‰¾ç¬¬kå°ã€‚ 3&gt;.å¦åˆ™ ç¬¬$k$å°åœ¨å³è¾¹ï¼Œä½†å·¦è¾¹å’Œå½“å‰ç»“ç‚¹éƒ½æ¯”ç¬¬$k$å°ã€‚æ‰€ä»¥ç¬¬kå°æ˜¯åœ¨å³è¾¹çš„ç¬¬$k-nodes[nodes[x].l].sum-1$å°ã€‚ ä»£ç ï¼š int top(int val) { int x=root; while(x) { if(nodes[nodes[x].l].sum+1==val) break; if(nodes[nodes[x].l].sum&gt;=val) x=nodes[x].l; else { val-=(1+nodes[nodes[x].l].sum); x=nodes[x].r; } } return nodes[x].num; } 7.æ’åæ’åçš„å®šä¹‰æ˜¯æ¯”ä¸€ä¸ªæ•°å°çš„æ•°çš„ä¸ªæ•°åŠ $1$ã€‚ é€šè¿‡å®šä¹‰å°±èƒ½å¾—å‡ºåšæ³•ï¼š æŠŠæ¯”æŸ¥è¯¢å€¼å°çš„å­æ ‘åˆ†ç¦»å‡ºæ¥ï¼Œè¿™æ£µå­æ ‘çš„å¤§å°å°±æ˜¯æ¯”è¿™ä¸ªæ•°å°çš„æ•°çš„ä¸ªæ•°ã€‚å†åŠ $1$å°±èƒ½å¾—åˆ°ç­”æ¡ˆäº†ã€‚ ä»£ç ï¼š int rank(int val) { split(root,val-1,root1,root2); int res=nodes[root1].sum+1; root=merge(root1,root2); return res; } 2.åŒºé—´fhq-treapåŒºé—´$fhq-treap$ç»´æŠ¤äº†ä¸€ä¸ªåŒºé—´ï¼Œä¸­åºéå†æ•´ä¸ª$fhq-treap$å°±å¯ä»¥å¾—åˆ°è¿™ä¸ªåºåˆ—ã€‚å½“ç„¶ï¼Œè¿™æ—¶å€™å®ƒè‚¯å®šå°±ä¸èƒ½æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨äº†ã€‚ä½†å®ƒè¿˜å¯ä»¥æ»¡è¶³å †çš„æ€§è´¨ã€‚ ä¸ºäº†ç»´æŠ¤åŒºé—´ï¼Œæˆ‘ä»¬çš„$split$æ“ä½œéœ€è¦æ›´æ”¹ï¼š æ¯æ¬¡åˆ†è£‚ä¸€ä¸ªåŒºé—´å‡ºæ¥ï¼šæŠŠè¿™ä¸ªåºåˆ—çš„å‰$siz$é¡¹åˆ†å‡ºæ¥ä¸ºä¸€ä¸ªå­æ ‘$X$,å‰©ä½™å¦ä¸€ä¸ªå­æ ‘$Y$ã€‚ åˆåˆ†ç±»è®¨è®ºï¼š 1&gt;.$nodes[nodes[x].l].sum&lt;k$ è¿™è¯´æ˜å½“å‰ç»“ç‚¹çš„å·¦å­æ ‘å’Œè‡ªèº«éƒ½å±äº $X$ï¼Œæˆ‘ä»¬å†æŠŠå³å­æ ‘çš„å‰$k-nodes[nodes[x].l].sum-1$é¡¹åˆ†ç»™$X$å°±å¥½äº†ã€‚ 2&gt;.å¦åˆ™ å‰$k$é¡¹åœ¨å½“å‰ç»“ç‚¹çš„å·¦å­æ ‘ä¸­ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹å’Œå®ƒçš„å³å­æ ‘å±äº$Y$ã€‚ ä»£ç ï¼š void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[nodes[now].l].sum&lt;k) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } ä½†$merge$æ“ä½œä¸éœ€è¦å¤ªå¤§å˜åŠ¨ï¼Œåªéœ€è¦åŠ ä¸Šæ‡’æ ‡è®°ä¸‹ä¼ å°±è¡Œäº†ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ å…¶å®åŒºé—´æ“ä½œçš„åˆ†è£‚é™¤äº†æ ‡è®°ä¸‹ä¼ ä¹‹å¤–ä¸æƒå€¼ç‰ˆæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ï¼Œåªæ˜¯è¿™é‡Œåˆ†è£‚çš„æƒå€¼æ˜¯ç¬¬kå°ã€‚ æ ‡è®°ä¸‹ä¼ æ˜¯ä¸ªå¤§å‘ï¼Œæœ‰æ ‡è®°æ—¶ï¼Œæ¯å½“ä½ è¦å¯¹ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼ˆæ— è®ºæ˜¯ä¿®æ”¹è¿˜æ˜¯æŸ¥è¯¢ï¼‰æ—¶ï¼Œè¦å…ˆä¸‹ä¼ æ ‡è®°ï¼Œå¦åˆ™ä¹‹åèƒ½ä¼šä¼ é”™ä½ç½®ï¼Œå› ä¸ºä½ å¯èƒ½æ›´æ”¹äº†å®ƒçš„å­èŠ‚ç‚¹ã€‚ 1.åŒºé—´å’Œæˆ‘ä»¬åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸­å†åŠ ä¸Šä¸€ä¸ªå˜é‡è®°å½•å®ƒå’Œå®ƒå­æ ‘çš„å’Œã€‚ é‚£ä¹ˆæ¯æ¬¡å­æ ‘å¤§å°æ›´æ–°æ—¶ï¼Œå­æ ‘å’Œä¹Ÿè¦æ›´æ–°ã€‚ å°±åœ¨$update$é‡ŒåŠ ä¸€å¥è¯æ›´æ–°å­æ ‘å’Œå°±å¥½ã€‚ æŸ¥è¯¢åŒºé—´å’Œæ—¶å°±æŠŠè¿™ä¸ªåŒºé—´åˆ†è£‚å‡ºæ¥ï¼Œç›´æ¥æŸ¥è¯¢è¿™ä¸ªåŒºé—´æ ¹èŠ‚ç‚¹çš„å­æ ‘å’Œå°±è¡Œäº†ã€‚ 2.åŒºé—´ç¿»è½¬åŒºé—´æ“ä½œåŸºæœ¬é æ‡’æ ‡è®°æ¥å®Œæˆã€‚è¿™äº›æ ‡è®°éƒ½ä¼šç»§ç»­ä¸‹ä¼ ç»™å­èŠ‚ç‚¹ã€‚ ç¿»è½¬å°±ç”¨ä¸€ä¸ª$bool$æ‡’æ ‡è®°å°±å¥½äº†ã€‚ é¦–å…ˆè¯´æ˜åŒºé—´ç¿»è½¬çš„åŸç†ï¼š å…ˆæŠŠè¿™ä¸ªåŒºé—´åˆ†è£‚å‡ºæ¥ã€‚ è¦ä½¿åŒºé—´ç¿»è½¬ï¼Œå°±ç›¸å½“äºè¦æŠŠè¿™ä¸ªåŒºé—´å€’ç€éå†ã€‚ å·¦ä¸­å³$-&gt;$å³ä¸­å·¦ å³æˆ‘ä»¬è¦å¯¹äºæ¯ä¸ªèŠ‚ç‚¹éå†æ—¶å…ˆéå†å³è¾¹ï¼Œå†éå†æœ¬èŠ‚ç‚¹ï¼Œæœ€åéå†å·¦è¾¹ã€‚ é‚£æˆ‘ä»¬æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å„¿å­äº¤æ¢å°±è¡Œäº†ã€‚ æ‰€ä»¥æˆ‘ä»¬ç›´æ¥æŠŠè¿™ä¸ªåŒºé—´å‰–å‡ºæ¥ï¼ŒæŠŠå®ƒçš„æ ¹èŠ‚ç‚¹æ‰“ä¸Šæ ‡è®°ï¼Œå†åˆå¹¶å›å»å°±å¥½äº†ã€‚ 3.åŒºé—´åŠ æ³•åŒºé—´åŠ æ³•å°±åƒçº¿æ®µæ ‘ä¸€æ ·çš„æ‡’æ ‡è®°å°±å¥½äº†ã€‚ å…¶å®ä¸åŒºé—´ç¿»è½¬çš„å®ç°æ–¹å¼ç±»ä¼¼ï¼Œæˆ‘å°±ä¸è®²äº†ã€‚ 4.å¦‚ä½•å‰–å‡ºåŒºé—´[l,r]æˆ‘ä»¬æŠŠåºåˆ—$[1,n]$åˆ†æˆ3æ®µ$[1,l-1]$,$[l,r]$,$[r+1,n]$ ç¬¬ä¸€æ®µçš„é•¿åº¦æ˜¯$l-1$,ç¬¬äºŒæ®µçš„é•¿åº¦æ˜¯$r-l+1$ æˆ‘ä»¬å°±æŒ¨ä¸ªæŠŠå®ƒä»¬$split$å‡ºæ¥å°±å¥½äº†ã€‚ ä»£ç : split(root,l-1,root1,root2); split(root2,r-l+1,root2,root3); $root2$å³ä¸º$[l,r]$åŒºé—´çš„æ ¹ç»“ç‚¹ã€‚ $\\ $ ç”±æ­¤åˆ¤æ–­ï¼Œå¹³è¡¡æ ‘æ¯”çº¿æ®µæ ‘è¿˜è¦ä¸‡èƒ½ï¼Œä½†å¸¸æ•°å·¨å¤§ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘çŠ¶æ•°ç»„","slug":"DS100P-BINARY-INDEXED-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-20T02:48:47.106Z","comments":true,"path":"2020/02/05/DS100P-BINARY-INDEXED-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-BINARY-INDEXED-TREE/","excerpt":"","text":"æ ‘çŠ¶æ•°ç»„($nlogn$) æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§å¸¸æ•°è¾ƒå°çš„ï¼Œèƒ½å¤Ÿå®ç°åŒºé—´åŠ æ³•ï¼ŒåŒºé—´æŸ¥è¯¢çš„æ•°æ®ç»“æ„ã€‚ å…¶ä¸­æœ€ç„å¦™çš„æ“ä½œå°±æ˜¯$lowbit$äº†,å®ƒæ˜¯ä½¿æ ‘çŠ¶æ•°ç»„å¸¸æ•°è¿›ä¸€æ­¥ç¼©å°çš„åŠŸè‡£ã€‚ 1).lowbitè¿™ä¸ªæ“ä½œç”¨æ¥æ‰¾åˆ°$x$ä»å³å¾€å·¦æ•°çš„ç¬¬ä¸€ä¸ªä¸º1çš„ä½ã€‚ å…ˆçœ‹ä¸€çœ‹è¿™ä¸ªæ“ä½œçš„å®ç°å§ï¼š$lowbit(x)=(x$&amp;$(-x))$ ($x$ä¸€èˆ¬ä¸ºæ­£æ•´æ•°) è¯´å®ƒå¾ˆç„å¦™æ˜¯å› ä¸ºå®ƒå¾ˆçŸ­ï¼Œä½†å¾ˆæœ‰æ•ˆï¼›å®ƒå……åˆ†åœ°åˆ©ç”¨äº†ä½è¿ç®—çš„é«˜æ•ˆã€‚ ä½†æˆ‘ä»¬è¦ç†è§£å®ƒçš„åŸç†ã€‚ ä½è¿ç®—å˜›ï¼Œæˆ‘ä»¬å…ˆæŠŠxè½¬åŒ–æˆ2è¿›åˆ¶è¡¥ç ã€‚é‚£ä¹ˆxæ˜¯æ­£æ•´æ•°ï¼Œå®ƒçš„äºŒè¿›åˆ¶è¡¥ç å°±æ˜¯ä»–è‡ªèº«ï¼Œä¸”å…¶ä¸­è‚¯å®šæœ‰ä¸€ä¸ª1ã€‚ $-x$çš„äºŒè¿›åˆ¶è¡¨ç¤ºåˆ™æ˜¯å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„åç +1ï¼›å³æŠŠé™¤ç¬¦å·ä½å¤–çš„æ‰€æœ‰ä½å–åï¼Œå†$+1$ã€‚ æˆ‘ä»¬æŠŠè¿™ä¸¤ä¸ªæ­¥éª¤åˆ†å¼€ï¼Œå…ˆæŠŠæ‰€æœ‰ä½å–åï¼Œæ­¤æ—¶xä¸å®ƒä¸èµ·æ¥ç­‰äº0ã€‚å†$+1$ï¼Œå°±ä¼šä½¿ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½å˜ä¸º1ï¼šå› ä¸ºå¦‚æœç¬¬ä¸€ä½æ˜¯0ï¼Œé‚£ä¹ˆè¿™ä½å°±ä¼šå˜æˆ1ï¼›å¦åˆ™å°±ä¼šå¾€å‰è¿›1ä½ï¼Œç»è¿‡é€’å½’ï¼Œå°±èƒ½ä½¿ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½å˜ä¸º1ã€‚ ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½çš„å·¦è¾¹çš„æ•°æ²¡æœ‰è¢«æ”¹å˜è¿‡ï¼Œæ‰€ä»¥ä¸èµ·æ¥ä¾ç„¶æ˜¯0ï¼›å³è¾¹çš„æ•°ç»è¿‡è¿›ä½éƒ½å˜æˆäº†0ï¼Œä¸ç®¡æ€æ ·ä¸éƒ½æ˜¯0ã€‚è€Œè¿™ä¸€ä½æœ¬èº«ç°åœ¨æ˜¯1ï¼ŒåŸæ¥æ˜¯0ï¼Œè¯´æ˜è¿™ä¸€ä½åŸæ¥æ˜¯1ï¼Œä¸èµ·æ¥å°±æ˜¯1ã€‚è€Œè¿™ä¸€ä½æ˜¯ç¬¬ä¸€ä¸ªä¸º0çš„ä½ï¼Œé‚£ä¹ˆå®ƒåŸæ¥å°±æ˜¯ç¬¬ä¸€ä¸ªä¸º1çš„ä½ã€‚ 2).å•ç‚¹ä¿®æ”¹é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª$nodes$æ•°ç»„ã€‚ $nodes[i]$å‚¨å­˜$a[i-lowbit(i)+1]$åˆ°$a[i]$çš„å’Œã€‚ é‚£ä¹ˆå¦‚æœæˆ‘ä»¬ç»™$a[i]$åŠ ä¸Šäº†$x$,é‚£ä¹ˆ$nodes[i]$è‚¯å®šåŒ…æ‹¬$a[i]$ï¼Œä¹Ÿè¦åŠ ä¸Š$x$; $lowbit(i+lowbit(i))$çš„å€¼è‚¯å®šå¤§äº$lowbit(i)$,æ‰€ä»¥$nodes[i+lowbit(i)]$ä¹Ÿè¦åŠ ä¸Š$x$; å†ç»§ç»­é€’å½’ä¸‹å»ï¼Œä¸€ç›´åˆ°æ•°ç»„çš„è¾¹ç•Œä¸ºæ­¢ã€‚ é‚£å¦‚ä½•è¯´æ˜$nodes[i+lowbit(i)]$å°±æ˜¯ç¬¬ä¸€ä¸ªåŒ…å«$nodes[i]$çš„æ•°å‘¢ï¼Ÿ æˆ‘ä»¬æŒ‰ç…§$lowbit(i)$æŠŠ$nodes[MAXN]$åˆ†ä¸º$log(MAXN)$å±‚ï¼Œé‚£ä¹ˆä¸å¯èƒ½æœ‰åŒå±‚åŠä¸‹å±‚èŠ‚ç‚¹åŒ…å«$nodes[i]$ï¼Œé™¤äº†å®ƒè‡ªå·±ã€‚ æ‰€ä»¥æˆ‘ä»¬å‘ä¸Šå±‚èŠ‚ç‚¹å¯»æ‰¾ï¼Œå°±è¦æŠŠ$lowbit(i)$è¿™ä¸€ä½æ¶ˆæ‰ä¸”æ•°å­—è¦å¢å¤§ï¼Œç›´æ¥åŠ ä¸Š$lowbit(i)$å°±å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸º$lowbit(i)$è¿™ä¸€ä½å¾€å³éƒ½æ˜¯0ï¼Œè¦æŠŠè¿™ä¸€ä½æ¶ˆæ‰ï¼Œéœ€è¦åŠ ä¸Šçš„æ•°ä¸­æ²¡æœ‰æ¯”$lowbit(i)$æ›´å°çš„ã€‚ æ‰€ä»¥$nodes[i+lowbit(i)]$å°±æ˜¯ç¬¬ä¸€ä¸ªåŒ…å«$nodes[i]$çš„æ•°ã€‚ ä»£ç  void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } 3).åŒºé—´æŸ¥è¯¢ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰å¦‚æœæˆ‘ä»¬è¦æŸ¥è¯¢åŒºé—´$[l,r]$çš„å’Œï¼Œæˆ‘ä»¬å¯ä»¥è¿ç”¨å‰ç¼€å’Œæ€æƒ³ï¼ŒæŠŠå®ƒè½¬æ¢æˆæ±‚$[1,r]-[1,l-1]$çš„å€¼ã€‚ é‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆäº†æ±‚åŒºé—´$[1,x]$çš„å’Œã€‚ ç”±äºå®šä¹‰ï¼Œ$nodes[x]$å‚¨å­˜çš„æ˜¯$a[x-lowbit(x)+1]$åˆ°$a[x]$çš„å’Œï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥ç¼©å°é—®é¢˜è§„æ¨¡ï¼š$query[1,x]=query[1,x-lowbit(x)]+nodes[x]$,ä¸€ç›´åˆ°0ä¸ºæ­¢ã€‚ ä»£ç  int ask(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int query(int l,int r) { return ask(r)-ask(l-1); } 4).åŒºé—´ä¿®æ”¹åŠæŸ¥è¯¢ä¸Šé¢çš„æ“ä½œåªæ”¯æŒå•ç‚¹ä¿®æ”¹ï¼Œé‚£ä¹ˆå¦‚ä½•åŒºé—´ä¿®æ”¹å‘¢ï¼Œä¸€ä¸ªä¸€ä¸ªåœ°æ”¹è‚¯å®šä¼šç‚¸ã€‚æˆ‘ä»¬é‡‡ç”¨å·®åˆ†çš„æ€æƒ³ï¼Œå°†åŒºé—´ä¿®æ”¹è½¬åŒ–ä¸ºå•ç‚¹ä¿®æ”¹ã€‚ æˆ‘ä»¬å…ˆæ€è€ƒå¦‚ä½•ç”¨å·®åˆ†æ•°ç»„$c[n]$æ±‚$a[1]+a[2]+\\cdots+a[n-1]+a[n]$ã€‚ $c[1]n+c[2](n-1)+\\cdots+c[n-1]*2+c[n]$ è¿™ä¸ªå¼å­é‡Œçš„c[i]å’Œiæ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œä¸å¤ªå¥½æ“ä½œï¼Œäºæ˜¯æˆ‘ä»¬æŠŠå®ƒå˜ä¸ªå½¢ï¼š $(c[1]+c[2]+\\cdots+c[n-1]+c[n])(n+1)-(c[1]+c[2]2+\\cdots+c[n-1](n-1)+c[n]n)$ è¿™æ ·å°±å¥½ç»´æŠ¤å¤šäº†ï¼šæˆ‘ä»¬åªéœ€è¦å¼€ä¸¤ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤$c[1]+c[2]+\\cdots+c[i]$å’Œ$c[1]+c[2]2+\\cdots+c[i]i$($nodes[MAXN]$,$exnodes[MAXN]$) å¯¹äºä¸€ä¸ªåŒºé—´ä¿®æ”¹â€”â€”$[l,r]$åŠ $x$ã€‚ å°†æ‰€æœ‰åŒ…å«$c[l]$çš„$nodes$åŠ $x$,$exnodes$åŠ $lx$($(c[l]+x)l==c[l]l+xl$) å°†æ‰€æœ‰åŒ…å«$c[r+1]$çš„$nodes$å‡$x$,$exnodes$å‡$(r-1)x$($(c[r+1]+x)(r+1)==c[r+1](r+1)+x(r+1)$) å¯¹äºä¸€ä¸ªåŒºé—´è¯¢é—®â€”â€”$[l,r]$ ç­‰ä»·äº$[1,r]-[1,l-1]$ å¯¹äº$[1,x]$ ç”±ä¸Šé¢çš„å¼å­å¾—å‡ºåšæ³•:ä»¥$nodes$æŸ¥è¯¢$(c[1]+c[2]+\\cdots+c[x-1]+c[x])(x+1)$ï¼Œä»¥$exnodes$æŸ¥è¯¢$(c[1]+c[2]2+\\cdots+c[x-1](x-1)+c[x]x)$,å†å°†å®ƒä»¬ç›¸å‡ã€‚ ä»£ç  void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } void exupdate(int x,int val) { while(x&lt;=MAXN) { exnodes[x]+=val; x+=lowbit(x); } } int find(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int exfind(int x) { int res=0; while(x) { res+=exnodes[x]; x-=lowbit(x); } return res; } void modify(int l,int r,int x) { update(l,x); exupdate(l,l*x); update(r+1,-x); exupdate(r+1,-(r+1)*x); } int ask(int x) { return find(x)*(x+1)-exfind(x); } int query(int l,int r) { return ask(r)-ask(l-1); } //(ä¸‹é¢ä¸¤ä¸ªå…ˆå’•äº†ï¼Œæˆ‘æ²¡çœ‹åˆ°å“ªé“é¢˜è¦ç”¨â€¦â€¦) 5).äºŒç»´å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢6).äºŒç»´åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ç³»åˆ—ç›®å½•åŠå‰è¨€","slug":"DS100P-INDEX-AND-PREWORDS","date":"2020-02-05T06:51:04.000Z","updated":"2020-04-19T00:34:59.129Z","comments":true,"path":"2020/02/05/DS100P-INDEX-AND-PREWORDS/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-INDEX-AND-PREWORDS/","excerpt":"","text":"å‰è¨€$\\qquad \\qquad \\qquad$ljsæäº†ä¸€ä¸ªdp100é¢˜ï¼Œç„¶ålycå‘Šè¯‰æˆ‘æˆ‘ä»¬æä¸€ä¸ªæ•°æ®ç»“æ„100é¢˜å§ $\\qquad \\qquad \\qquad$äºæ˜¯æˆ‘å°±æ¥äº†ï¼Œè¿˜å¸¦æ¥ä¸€ä¸ªç½‘ç»œæµ(å®ƒæ­»äº†ï¼Œè¢«lycæ€æ­»çš„) ç”±äºæŸWGYç¡¬æ˜¯æŠŠç½‘ç»œæµåŠ è¿›å»äº†ï¼Œæ‰€ä»¥æˆ‘åªèƒ½é‡å¼€ä¸€ä¸ªâ€¦â€¦ï¼ˆæˆ‘ä¸ºä»€ä¹ˆè¦è®©ä»–å»ºå¸–å­ï¼‰$\\qquad \\qquad \\qquad$(å®ƒæ­»äº†ï¼Œè¢«wgyæ€æ­»çš„) æˆ‘æ˜¯ä¸ä¼šå†™ç½‘ç»œæµçš„ï¼ï¼ï¼$\\qquad \\qquad \\qquad$(å®ƒæ­»äº†ï¼Œè¢«wgyæ€æ­»çš„) å‰æœŸæˆ‘ä¼šå…ˆæŠŠå„ä¸ªæ•°æ®ç»“æ„çš„æ¨¡æ¿å…ˆå†™ä¸€éï¼Œå…ˆæŠŠåŸºç¡€è®²æ¸…æ¥šã€‚$\\qquad \\qquad \\qquad$å’•å’•å’• åæœŸå†åŠ ä¸€äº›æœ‰ä»·å€¼çš„é¢˜ç›®æ¥è®²è§£ã€‚$\\qquad \\qquad \\qquad$(æˆ‘å¯èƒ½ä¼šå…ˆå’•æ‰éƒ¨åˆ†æ¨¡æ¿â€¦â€¦) $\\qquad \\qquad \\qquad$//å…ˆæŠŠå‘æŒ–å¥½ é¢˜è§£éƒ¨åˆ†$\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 1~10é¢˜ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 11~20é¢˜ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 21~30é¢˜ æ•°æ®ç»“æ„å­¦ä¹ ç¬”è®°éƒ¨åˆ†$\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘çŠ¶æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-fhq-treap $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-çº¿æ®µæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-trieæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘é“¾å‰–åˆ† $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-ä¸»å¸­æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘å¥—æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åˆ†å— $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-è«é˜Ÿ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Link-Cut Tree $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Chtholly-Tree(Old-Driver Tree) $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-KMP $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-splay $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€è‡ªåŠ¨æœº $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Sqrt-Tree $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å—çŠ¶æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å—çŠ¶é“¾è¡¨ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘ä¸Šåˆ†å— $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-çŒ«æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ”¯é…æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å·¦åæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åŸºäºå¾ªç¯çš„çº¿æ®µæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-ç¬›å¡å°”æ ‘ï¼ˆå¨±ä¹å‘","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]}]}