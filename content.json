{"meta":{"title":"BoringHacker's Blog","subtitle":"Stay Hungry, Stay Foolish","description":null,"author":"BoringHacker","url":"www.orchid-any.cf"},"pages":[{"title":"Comments","date":"2020-01-17T07:04:09.000Z","updated":"2020-01-17T07:05:20.286Z","comments":true,"path":"Comments/index.html","permalink":"www.orchid-any.cf/Comments/index.html","excerpt":"","text":"随便说点什么吧(记得改昵称)233…"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-06T09:29:20.533Z","comments":false,"path":"bangumi/index.html","permalink":"www.orchid-any.cf/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"Havefun","date":"2019-12-21T13:04:04.000Z","updated":"2020-01-15T08:32:06.232Z","comments":true,"path":"Havefun/index.html","permalink":"www.orchid-any.cf/Havefun/index.html","excerpt":"","text":""},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-05T10:53:40.037Z","comments":false,"path":"about/index.html","permalink":"www.orchid-any.cf/about/index.html","excerpt":"","text":"BoringHacker 与&nbsp; BoringHacker&nbsp; （ BoringHacker ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"www.orchid-any.cf/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-05T10:46:24.855Z","comments":true,"path":"comment/index.html","permalink":"www.orchid-any.cf/comment/index.html","excerpt":"","text":"念两句话 人渣的本愿，苏联的解体。 【现代】noip毒瘤《洛谷·个人主页》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"donate/index.html","permalink":"www.orchid-any.cf/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"lab/index.html","permalink":"www.orchid-any.cf/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"www.orchid-any.cf/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-06T05:21:26.670Z","comments":true,"path":"links/index.html","permalink":"www.orchid-any.cf/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"www.orchid-any.cf/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"tags/index.html","permalink":"www.orchid-any.cf/tags/index.html","excerpt":"","text":""},{"title":"Game","date":"2020-02-05T11:21:36.000Z","updated":"2020-02-05T13:10:04.895Z","comments":false,"path":"game/index.html","permalink":"www.orchid-any.cf/game/index.html","excerpt":"","text":"2048","keywords":null},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"www.orchid-any.cf/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"www.orchid-any.cf/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"}],"posts":[{"title":"SQRT-TREE","slug":"DS100P-SQRT-TREE","date":"2020-02-07T10:49:19.000Z","updated":"2020-02-07T10:49:19.126Z","comments":true,"path":"2020/02/07/DS100P-SQRT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SQRT-TREE/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"BLOCK-ARRAY","slug":"DS100P-BLOCK-ARRAY","date":"2020-02-07T10:48:41.000Z","updated":"2020-02-07T10:48:41.197Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-ARRAY/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"BLOCK-LIST","slug":"DS100P-BLOCK-LIST","date":"2020-02-07T10:48:26.000Z","updated":"2020-02-07T10:48:26.214Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-LIST/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-LIST/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"DS100P-TREE-FENKUAI","slug":"DS100P-TREE-FENKUAI","date":"2020-02-07T10:43:01.000Z","updated":"2020-02-07T10:47:33.462Z","comments":true,"path":"2020/02/07/DS100P-TREE-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-FENKUAI/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"数据结构100题 ---后缀全家桶 之 后缀自动机","slug":"DS100P-SUFFIX-AUTOMATON","date":"2020-02-07T10:14:33.000Z","updated":"2020-02-07T10:46:58.918Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-AUTOMATON/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-AUTOMATON/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"数据结构100题 ---后缀全家桶 之 后缀树","slug":"DS100P-SUFFIX-TREE","date":"2020-02-07T10:14:14.000Z","updated":"2020-02-07T10:47:20.870Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-TREE/","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"数据结构100题 ---树状数组","slug":"DS100P-BINARY-INDEXED-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:34:14.511Z","comments":true,"path":"2020/02/05/DS100P-BINARY-INDEXED-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-BINARY-INDEXED-TREE/","excerpt":"","text":"树状数组($nlogn$) 树状数组是一种常数较小的，能够实现区间加法，区间查询的数据结构。 其中最玄妙的操作就是$lowbit$了,它是使树状数组常数进一步缩小的功臣。 1).lowbit这个操作用来找到$x$从右往左数的第一个为1的位。 先看一看这个操作的实现吧：$lowbit(x)=(x$&amp;$(-x))$ ($x$一般为正整数) 说它很玄妙是因为它很短，但很有效；它充分地利用了位运算的高效。 但我们要理解它的原理。 位运算嘛，我们先把x转化成2进制补码。那么x是正整数，它的二进制补码就是他自身，且其中肯定有一个1。 $-x$的二进制表示则是它的二进制表示的反码+1；即把除符号位外的所有位取反，再$+1$。 我们把这两个步骤分开，先把所有位取反，此时x与它与起来等于0。再$+1$，就会使从右往左数第一个为零的位变为1：因为如果第一位是0，那么这位就会变成1；否则就会往前进1位，经过递归，就能使从右往左数第一个为零的位变为1。 从右往左数第一个为零的位的左边的数没有被改变过，所以与起来依然是0；右边的数经过进位都变成了0，不管怎样与都是0。而这一位本身现在是1，原来是0，说明这一位原来是1，与起来就是1。而这一位是第一个为0的位，那么它原来就是第一个为1的位。 2).单点修改首先我们定义一个$nodes$数组。 $nodes[i]$储存$a[i-lowbit(i)+1]$到$a[i]$的和。 那么如果我们给$a[i]$加上了$x$,那么$nodes[i]$肯定包括$a[i]$，也要加上$x$; $lowbit(i+lowbit(i))$的值肯定大于$lowbit(i)$,所以$nodes[i+lowbit(i)]$也要加上$x$; 再继续递归下去，一直到数组的边界为止。 那如何说明$nodes[i+lowbit(i)]$就是第一个包含$nodes[i]$的数呢？ 我们按照$lowbit(i)$把$nodes[MAXN]$分为$log(MAXN)$层，那么不可能有同层及下层节点包含$nodes[i]$，除了它自己。 所以我们向上层节点寻找，就要把$lowbit(i)$这一位消掉且数字要增大，直接加上$lowbit(i)$就可以做到这一点，因为$lowbit(i)$这一位往右都是0，要把这一位消掉，需要加上的数中没有比$lowbit(i)$更小的。 所以$nodes[i+lowbit(i)]$就是第一个包含$nodes[i]$的数。 代码 void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } 3).区间查询（单点修改）如果我们要查询区间$[l,r]$的和，我们可以运用前缀和思想，把它转换成求$[1,r]-[1,l-1]$的值。 那么问题转化成了求区间$[1,x]$的和。 由于定义，$nodes[x]$储存的是$a[x-lowbit(x)+1]$到$a[x]$的和，那么我们可以进一步缩小问题规模：$query[1,x]=query[1,x-lowbit(x)]+nodes[x]$,一直到0为止。 代码 int ask(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int query(int l,int r) { return ask(r)-ask(l-1); } 4).区间修改及查询上面的操作只支持单点修改，那么如何区间修改呢，一个一个地改肯定会炸。我们采用差分的思想，将区间修改转化为单点修改。 我们先思考如何用差分数组$c[n]$求$a[1]+a[2]+\\cdots+a[n-1]+a[n]$。 $c[1]n+c[2](n-1)+\\cdots+c[n-1]*2+c[n]$ 这个式子里的c[i]和i没有什么关系，不太好操作，于是我们把它变个形： $(c[1]+c[2]+\\cdots+c[n-1]+c[n])(n+1)-(c[1]+c[2]2+\\cdots+c[n-1](n-1)+c[n]n)$ 这样就好维护多了：我们只需要开两个树状数组维护$c[1]+c[2]+\\cdots+c[i]$和$c[1]+c[2]2+\\cdots+c[i]i$($nodes[MAXN]$,$exnodes[MAXN]$) 对于一个区间修改——$[l,r]$加$x$。 将所有包含$c[l]$的$nodes$加$x$,$exnodes$加$lx$($(c[l]+x)l==c[l]l+xl$) 将所有包含$c[r+1]$的$nodes$减$x$,$exnodes$减$(r-1)x$($(c[r+1]+x)(r+1)==c[r+1](r+1)+x(r+1)$) 对于一个区间询问——$[l,r]$ 等价于$[1,r]-[1,l-1]$ 对于$[1,x]$ 由上面的式子得出做法:以$nodes$查询$(c[1]+c[2]+\\cdots+c[x-1]+c[x])(x+1)$，以$exnodes$查询$(c[1]+c[2]2+\\cdots+c[x-1](x-1)+c[x]x)$,再将它们相减。 代码 void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } void exupdate(int x,int val) { while(x&lt;=MAXN) { exnodes[x]+=val; x+=lowbit(x); } } int find(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int exfind(int x) { int res=0; while(x) { res+=exnodes[x]; x-=lowbit(x); } return res; } void modify(int l,int r,int x) { update(l,x); exupdate(l,l*x); update(r+1,-x); exupdate(r+1,-(r+1)*x); } int ask(int x) { return find(x)*(x+1)-exfind(x); } int query(int l,int r) { return ask(r)-ask(l-1); } //(下面两个先咕了，我没看到哪道题要用……) 5).二维单点修改，区间查询6).二维区间修改，区间查询","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---Chtholly-Tree(Old-Driver Tree)","slug":"DS100P-CHTHOLLY-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T03:21:46.486Z","comments":true,"path":"2020/02/05/DS100P-CHTHOLLY-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-CHTHOLLY-TREE/","excerpt":"","text":"Chtholly-Tree众所周知，数据结构+算法=程序，可见数据结构的重要性数据结构占了我们编程的一大部分。数据结构的大家族中，有优美的线段树、树状数组等。但我们今天的主角却十分暴力。她的名字叫珂朵莉树 珂朵莉树是基于C++STL库中的set的数据结构。与线段树、平衡树等树形结构类似，珂朵莉树是用来解决区间问题的很暴力的树形结构。 她的特点是能够进行区间推平操作，并且时间复杂度接近O(n log m) 。但前提是数据随机。但一般不会有哪个出题人去卡这样一个并不出名的数据结构。并且要有区间推平操作，否则光是一个split时间复杂度会炸。 珂朵莉树的构造长成这个亚子: struct Chtholly { LL L; LL R; //区间 mutable LL _val; //值，注意，关键字mutable是必需的，否则会在add函数里CE node(LL l, LL r = -1, LL V = 0) : L(l), R(r), _val(V) {} bool operator&lt;(const node &amp;rhs) const { return L &lt; rhs.L; } } Split操作: inline IT split(int k) { IT it = st.lower_bound(node(k)); if (it != st.end() &amp;&amp; it-&gt;L == k) return it; --it; LL l = it-&gt;L, r = it-&gt;R; LL v = it-&gt;_val; st.erase(it); st.insert(node(l, k - 1, v)); return st.insert(node(k, r, v)).first; } 为了操作方便我们这里有一个define: #define IT set&lt;Chtholly&gt;::iterator assign区间推平操作，这也是珂朵莉树的时间复杂度保证 inline void assign(LL ll, LL rr, LL val) { IT itr = split(rr + 1), itl = split(ll); st.erase(itl, itr); st.insert(node(ll, rr, val)); } 举几个例子吧 区间求和:inline LL Qsum(LL ll, LL rr) { LL res = 0; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) res += (itl-&gt;R - itl-&gt;L + 1) * itl-&gt;_val; return res; } 区间第K小:inline LL kth(LL ll, LL rr, LL k) { vector&lt;pair&lt;LL, LL&gt; &gt; vec; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) vec.push_back(pair&lt;LL, LL&gt;(itl-&gt;_val, itl-&gt;R - itl-&gt;L + 1)); sort(vec.begin(), vec.end()); for (auto it = vec.begin(); it != vec.end(); ++it) { k -= it-&gt;second; if (k &lt;= 0) return it-&gt;first; } return -1; } 区间加inline void add(LL ll, LL rr, LL ad) { IT itr = split(rr + 1), itl = split(ll); for (; itr != itl; ++itl) itl-&gt;_val += ad; } 平时大家还是尽量少用······","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---fhq-treap","slug":"DS100P-FHQ-TREAP","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:38:48.433Z","comments":true,"path":"2020/02/05/DS100P-FHQ-TREAP/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-FHQ-TREAP/","excerpt":"","text":"fhq-treap($nlogn$) $fhq-treap$是一种二叉搜索树。满足二叉搜索树的性质：中序遍历是一个不降序列。也就是说，一个节点的左儿子小于等于它，右儿子大于等于它。 但它和$treap$一样，都满足堆的性质：任意父节点的键值大于(等于)或小于(等于)子节点的键值。 它可以做普通平衡树（基本操作），文艺平衡树（区间操作），还可以可持久化。 但常数略大。 定义： struct node { int l,r,num,key,cum; //左儿子，右儿子，本节点的值，键值，子树大小 }nodes[MAXN]; 1.权值fhq-treap权值$fhq-treap$的意思是，它这时候既满足二叉搜索树的性质，又满足堆的性质。 先讲讲辅助操作吧： update:用来更新当前节点的子树大小。 代码实现： void update(int x) { nodes[x].cum=nodes[nodes[x].l].cum+nodes[nodes[x].r].cum+1; } 因为一个节点的子树大小等于它左右儿子的子树大小加上它本身嘛。 newnode:新建一个值为指定值的节点并返回它的编号。 代码实现： int newnode(int val) { nodes[++tot].cum=1; nodes[tot].num=val; nodes[tot].key=rand(); return tot; } 主要操作有两个： 1&gt;.分裂split这里的分裂按照权值分裂，即把原树按照权值$val$分成两棵树，一棵$X$中的权值全部小于等于$val$，另一棵y的权值全部大于$val$。而这两棵树都要满足两个性质。 要实现这个操作，我们要从根节点开始遍历，把整棵树分成两半。 我们进行分类讨论：现在遍历到的节点编号为$now$。 1).当$now=0$时 这时，now是一个空节点，没有办法分裂。 2).当$nodes[now].num\\leq val$时 这个节点以及它的左子树的权值都小于等于$val$,那么他们全部都属于$X$。 那么它的右子树可能是$X$的，也可能是$Y$的。 所以我们需要继续分裂右子树，但由于右边的数要比$nodes[now].num$大，接下来分裂出的小于等于$val$的子树需要接在当前分出的$X$树的右子树上。 3).否则 这个时候这个节点和它的右子树的权值都大于$val$，那么他们全部属于$Y$。 但它的左子树可能有一部分属于$X$。 所以我们需要继续分裂左子树。道理同上。 上面操作已经保证了分出的二叉树满足二叉树性质。而堆性质也得到了满足，因为从原树上往下分，分到节点的键值也是有序的。 递归返回前还要记得$update$一下，更新分裂后的子树大小。 是不是还是不懂？还是看代码和代码注释吧： //x,y代表从now这个节点分裂出的两棵树的根节点，使用引用返回值。 void split(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0;//情况1).无法继续分裂，所以两棵树都是空。 else { if(nodes[now].num&lt;=val)//情况2). { x=now;//左子树和这个节点都属于X树，接到之前分裂到的地方。右子树在下面会受到修改，所以右子树并没有被直接包括。 split(nodes[now].r,val,nodes[x].r,y);//继续分裂右子树。接下来分裂出属于X树的根节点位置应该是nodes[x].r，y的位置没有变动。 } else//情况3). { y=now; split(nodes[now].l,val,x,nodes[y].l);//同上 } update(now); //由于无论进入哪个判断，作了改变的节点都等于now,所以可以直接更新now。 } } //调用：split(root,v,root1,root2) 最后传回的值就相当于给$root1$,$root2$赋值。 $root1$,$root2$就是分裂出的$X$树和$Y$树的根节点。 2&gt;.合并merge即把两颗像刚刚上面分裂出来的两颗树合并成一棵满足两个性质的树。 我们又要分类讨论：现在需要合并的节点是$x$,$y$。（示例小根堆） 1).$x=0$|$\\ $|$y=0$ 只有一棵树，直接返回这棵树。 2).$nodes[x].key&lt;nodes[y].key$ $x$节点的键值更小，所以$x$应该在$y$的上面。 $y$的值一定大于$x$,所以把$y$和$x$的右子树进行合并。 3).否则 $y$应该在$x$的上面。 $x$的值一定小于$y$，所以把$y$的左儿子和$x$进行合并。 代码： int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } 学会了这两个操作之后，就可以实现普通平衡树的所有操作了。 3.插入插入的代码只有两行，非常简单。 只需要把原数按要插入的值$val$大小分裂，一边$x$小于等于$val$，另一边$y$大于$val$。 再把$x$与这个值节点合并（得到$z$），最后与$y$合并。 因为$x$的节点全部小于等于$val$,$z$的节点全部小于$y$。满足我们之前合并两棵树的条件。 代码： void ins(int val) { split(root,val,root1,root2); root=merge(merge(root1,newnode(val)),root2); } 4.删除先把要删除的值$val$从原树中分裂出来，删掉一个再合并回去。 怎么在很多的$val$中删掉一个呢。 我们把$val$子树根节点的左右节点合并起来，就相当于抛弃了这个根节点。 这样保证了如果有这个值，一定会被删掉，因为如果有，那么根节点肯定有。 代码： void del(int val) { split(root,val,root1,root2); split(root1,val-1,root1,root3); root3=merge(nodes[root3].l,nodes[root3].r); root=merge(merge(root1,root3),root2); } 5.前驱/后继我们把小于/大于查询值$val$的子树分裂出来，由于分裂出的子树依然满足二叉树性质，所以我们可以直接查询这个子树中的最大值/最小值，查询出的值就是答案。最后记得合并回去。 代码： int pre(int val) { split(root,val-1,root1,root2); int now=root1,res=-INF; if(now) { while(nodes[now].r) now=nodes[now].r; res=nodes[now].num; } root=merge(root1,root2); return res; } int nxt(int val) { split(root,val,root1,root2); int now=root2,res=INF; if(now) { while(nodes[now].l) now=nodes[now].l; res=nodes[now].num; } root=merge(root1,root2); return res; } 6.第k小对于这个问题，$fhq-treap$没有特殊的解决方法。所以和$treap$一样。 由于二叉搜索树中序遍历为不降序列，我们分情况讨论： 1&gt;.左子树大小$+1$等于$k$。 说明当前节点就是第$k$小。 2&gt;.左子树大小小于等于$k$ 说明第$k$大在左边，那么向左边继续寻找第k小。 3&gt;.否则 第$k$小在右边，但左边和当前结点都比第$k$小。所以第k小是在右边的第$k-nodes[nodes[x].l].sum-1$小。 代码： int top(int val) { int x=root; while(x) { if(nodes[nodes[x].l].sum+1==val) break; if(nodes[nodes[x].l].sum&gt;=val) x=nodes[x].l; else { val-=(1+nodes[nodes[x].l].sum); x=nodes[x].r; } } return nodes[x].num; } 7.排名排名的定义是比一个数小的数的个数加$1$。 通过定义就能得出做法： 把比查询值小的子树分离出来，这棵子树的大小就是比这个数小的数的个数。再加$1$就能得到答案了。 代码： int rank(int val) { split(root,val-1,root1,root2); int res=nodes[root1].sum+1; root=merge(root1,root2); return res; } 2.区间fhq-treap区间$fhq-treap$维护了一个区间，中序遍历整个$fhq-treap$就可以得到这个序列。当然，这时候它肯定就不能满足二叉搜索树的性质了。但它还可以满足堆的性质。 为了维护区间，我们的$split$操作需要更改： 每次分裂一个区间出来：把这个序列的前$siz$项分出来为一个子树$X$,剩余另一个子树$Y$。 又分类讨论： 1&gt;.$nodes[nodes[x].l].sum&lt;k$ 这说明当前结点的左子树和自身都属于 $X$，我们再把右子树的前$k-nodes[nodes[x].l].sum-1$项分给$X$就好了。 2&gt;.否则 前$k$项在当前结点的左子树中，那么当前节点和它的右子树属于$Y$。 代码： void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[nodes[now].l].sum&lt;k) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } 但$merge$操作不需要太大变动，只需要加上懒标记下传就行了（如果有的话） 其实区间操作的分裂除了标记下传之外与权值版没有什么差别，只是这里分裂的权值是第k小。 标记下传是个大坑，有标记时，每当你要对一个节点的子节点进行操作（无论是修改还是查询）时，要先下传标记，否则之后能会传错位置，因为你可能更改了它的子节点。 1.区间和我们在每个节点中再加上一个变量记录它和它子树的和。 那么每次子树大小更新时，子树和也要更新。 就在$update$里加一句话更新子树和就好。 查询区间和时就把这个区间分裂出来，直接查询这个区间根节点的子树和就行了。 2.区间翻转区间操作基本靠懒标记来完成。这些标记都会继续下传给子节点。 翻转就用一个$bool$懒标记就好了。 首先说明区间翻转的原理： 先把这个区间分裂出来。 要使区间翻转，就相当于要把这个区间倒着遍历。 左中右$-&gt;$右中左 即我们要对于每个节点遍历时先遍历右边，再遍历本节点，最后遍历左边。 那我们把每个节点的左右儿子交换就行了。 所以我们直接把这个区间剖出来，把它的根节点打上标记，再合并回去就好了。 3.区间加法区间加法就像线段树一样的懒标记就好了。 其实与区间翻转的实现方式类似，我就不讲了。 4.如何剖出区间[l,r]我们把序列$[1,n]$分成3段$[1,l-1]$,$[l,r]$,$[r+1,n]$ 第一段的长度是$l-1$,第二段的长度是$r-l+1$ 我们就挨个把它们$split$出来就好了。 代码: split(root,l-1,root1,root2); split(root2,r-l+1,root2,root3); $root2$即为$[l,r]$区间的根结点。 $\\ $ 由此判断，平衡树比线段树还要万能，但常数巨大。","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题系列目录及前言","slug":"DS100P-INDEX-AND-PREWORDS","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-07T10:50:19.916Z","comments":true,"path":"2020/02/05/DS100P-INDEX-AND-PREWORDS/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-INDEX-AND-PREWORDS/","excerpt":"","text":"前言$\\qquad \\qquad \\qquad$ljs搞了一个dp100题，然后lyc告诉我我们搞一个数据结构100题吧 $\\qquad \\qquad \\qquad$于是我就来了，还带来一个网络流(它死了，被lyc杀死的) 由于某WGY硬是把网络流加进去了，所以我只能重开一个……（我为什么要让他建帖子）$\\qquad \\qquad \\qquad$(它死了，被wgy杀死的) 我是不会写网络流的！！！$\\qquad \\qquad \\qquad$(它死了，被wgy杀死的) 前期我会先把各个数据结构的模板先写一遍，先把基础讲清楚。$\\qquad \\qquad \\qquad$咕咕咕 后期再加一些有价值的题目来讲解。$\\qquad \\qquad \\qquad$(我可能会先咕掉部分模板……) $\\qquad \\qquad \\qquad$//先把坑挖好 题解部分$\\qquad \\qquad \\qquad$数据结构100题 —-数据结构集合 $\\qquad \\qquad \\qquad$数据结构100题 1~10题 $\\qquad \\qquad \\qquad$数据结构100题 11~20题 $\\qquad \\qquad \\qquad$数据结构100题 21~30题 数据结构学习笔记部分$\\qquad \\qquad \\qquad$数据结构100题 —-树状数组 $\\qquad \\qquad \\qquad$数据结构100题 —-线段树 $\\qquad \\qquad \\qquad$数据结构100题 —-trie树 $\\qquad \\qquad \\qquad$数据结构100题 —-树链剖分 $\\qquad \\qquad \\qquad$数据结构100题 —-fhq-treap $\\qquad \\qquad \\qquad$数据结构100题 —-树套树 $\\qquad \\qquad \\qquad$数据结构100题 —-分块 $\\qquad \\qquad \\qquad$数据结构100题 —-莫队 $\\qquad \\qquad \\qquad$数据结构100题 —-Link-Cut Tree $\\qquad \\qquad \\qquad$数据结构100题 —-Chtholly-Tree(Old-Driver Tree) $\\qquad \\qquad \\qquad$数据结构100题 —-KMP $\\qquad \\qquad \\qquad$数据结构100题 —-splay $\\qquad \\qquad \\qquad$数据结构100题 —-后缀全家桶 之 后缀数组","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---分块","slug":"DS100P-FENKUAI","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:37:14.283Z","comments":true,"path":"2020/02/05/DS100P-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-FENKUAI/","excerpt":"","text":"分块($n\\sqrt n$) 分块其实也是一种暴力，但它是一种巧妙的暴力 它用来处理区间的问题。 把这个区间大概分成$\\sqrt n$块 然后再处理：对于一个整块，就整个处理掉；对于一个角块（不完整的块），就暴力处理。 比如区间求和。(非主流写法勿喷) 1.初始化对于每个元素，我们要处理出它是哪个块的，以便之后快速地找到它所在的块。 对于每个块，我们要统计出之后计算答案所需这个块内的结果（这里就是块内区间和），在区间中的左右端点，以及区间修改的懒标记。 代码： struct cude { int l,r,sum,lazy;//左右端点，区间和，懒标记 }cud[400]; int n,a[100010],bel[100010],each,cnt;//原数组大小及元素，每个元素的块编号，块大小，块数 void build() { each=sqrt(n); for(int i=0;i&lt;n;++i)//注意，我是从0开始存的原数组 { bel[i]=i/each;//预处理元素属于块 cud[bel[i]].sum+=a[i];//区间和 } for(int i=0;i*each&lt;n;++i) { ++cnt;//统计块数 cud[i].l=i*each;//块左端点 cud[i].r=min((i+1)*each-1,n-1);//块右端点，不可能达到n，所以取min，最多到n-1 } } 2.修改修改是很暴力的，我们对这个区间进行扫描。 整块就区间修改，懒标记。 角块就直接暴力扫过去修改。 最多$\\sqrt n$个整块，打懒标记$O(1)$，复杂度为$O(\\sqrt n)$ 最多$2$个角块，一个角块最多$\\sqrt n$个元素，暴力修改$O(\\sqrt n)$ 区间修改总时间复杂度$O(\\sqrt n)$ 代码： void update(int l,int r,int val) { for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i)//注意不要超过块数，我的块是从0开始编号的 { if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r)//整块打懒标记 { cud[i].lazy+=val; cud[i].sum+=(cud[i].r-cud[i].l+1)*val; } else//角块暴力扫 { if(cud[i].l&lt;l)//属于整个区间的最左边的角块，但还可能是最右边的角块，需要判断不要超出修改区间的右端点 { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } else//不是最左边的，那肯定是最右边的。 { for(int j=cud[i].l;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } } } } 3.查询查询也是很暴力的。 同样对这个区间进行扫描。 如果是整块，就直接加上这个块的区间和。 如果是角块，就要先下传懒标记，再暴力查询。 因为我们之前并没有修改元素值，只是加上了懒标记，修改了区间和。 所以我们现在要先修改这些元素的值再查询，否则查询到的值是修改之前的。 时间复杂度与修改相同，都是$O(\\sqrt n)$； 代码： //细节同2.修改 int find(int l,int r) { int res=0; for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i) if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r) res+=cud[i].sum; else { if(cud[i].lazy)//下传懒标记 { for(int j=cud[i].l;j&lt;=cud[i].r;++j) a[j]+=cud[i].lazy; cud[i].lazy=0; } if(cud[i].l&lt;l) { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) res+=a[j]; } else { for(int j=cud[i].l;j&lt;=r;++j) res+=a[j]; } } } return res; } 4.总结你看着这个东西好像很暴力，但它就是跑得过题。 它的总时间复杂度是$O(n\\sqrt n)$的，$500000$及以上就别想啦。 分块的题目很灵活，但一般都很暴力，有时区间修改不能打懒标记，就必须暴力修改，但有时你又可以跳过这个修改，进行“剪枝”。 就像花神游历各国，区间开方必须要在块里去暴力开 但我们想，$1$和$0$开方后都是本身，其它数开方就会变得越来越小，最后到$1$，所以我们可以维护一个块内是否全是$1$或$0$。 如果是，就可以跳过在这个区间里进行开方了，因为这个块里的元素开方之后都还是本身，每个元素和区间和都没有变。 其他的就是普通分块。 $\\ $ 在分块，你甚至可以打表 在区间中选取$\\sqrt n$个特征点，处理出它们间的信息。 对每个查询，选取最近的两个特征点的信息再从这两个特征点暴力跳过去。 这样就可以代替莫队啦。 而且分块没有任何离线操作，可以应对看起来像要用莫队（离线算法，同样$O(n\\sqrt n)$）才能解决，但又强制在线的题目。 以及，整除分块不是数据结构，是数论！！！","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---KMP","slug":"DS100P-KMP-STRING","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T03:11:48.061Z","comments":true,"path":"2020/02/05/DS100P-KMP-STRING/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-KMP-STRING/","excerpt":"","text":"KMPupd:代码锅已补 0x00 前言本文和某播放软件KMPlayer没有一毛钱关系，并且： 伦家是数据结构！ 0x01 引入问题设想这样一个问题： 给你两个字符串，让你查找在文本串中模式串的位置。 暴力做法是显然的，举例来说： 文本串(text)：$a\\ b\\ c\\ b\\ c\\ g\\ l\\ x$ 模式串(pattern): $b\\ c\\ g\\ l$ 我们直接暴力枚举text中的每一个字符，并且依次与pattern中的字符从头开始匹配。时间复杂度为 $\\Theta(nm)$ 0x02 发现问题这样做其实有很多冗余操作。比如说：$b\\ c\\ g\\ l$ 与text中的 $b\\ c\\ b\\ c$ 不匹配，又从第text的第五个字母 $c$ 开始匹配。这样做是显然不必要的。为什么呢？因为模式串是以 $b$ 开头的，对于text中第五个字母 $c$ 显然我们可以不去匹配。发现了什么吗？每次失配后我们只需要从两个字符串的最长公共部分开始匹配即可。这里看不懂没有什么关系，只要能理解后面的例子就可以了。 0x03 解决一部分问题$\\qquad\\qquad\\quad\\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5\\ \\ 6\\ \\ 7\\ \\ 8\\ \\ 9\\ 10\\ 11$ 文本串(text)： $a\\ \\ b\\ \\ x\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ 模式串(pattern)： $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ 我们有两个指针i和j，分别指向文本串和模式串。在i=0,j=0以及i=1,j=1的时候都匹配上了。但是在i=2,j=2时失配了。如果时朴素算法的话会令i=1,j=0重新开始匹配。然而我们发现我们完全可以令i=3,j=0来重新匹配。一直到i=8,j=5时，它们又失配了。我们令j等于模式串和文本串已经配对完成的部分(即pattern[0]~pattern[4])的最长公共前缀后缀(即pattern[0,1]和pattern[3,4])的前缀末尾部分+1(即1+1=2)的地方，此时的text[6,7]和pattern[0,1]都是ab也就是说我们可以直接从i=8,j=2开始匹配，就可以匹配到模式串了。这就是KMP玄妙的地方。 0x04 解决另一部分问题那么问题来了：我们如何确定模式串最长公共前后缀的前缀末尾+1的位置呢？我们还是通过一个例子来感受。 $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ 模式串(pattern)： $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ (没错就是上面那个我太懒了) 我们可以设数组$next_i$为以 $i$ 为结尾的模式串最长公共前后缀的前缀末尾+1的位置。 $next_0$显然为0。 我们依然设两个指针i和j，i初始化为0，即指向模式串的开头。j初始化1，即i后面一个。 pattern[i]不等于pattern[j]，令next[i]=0，j+=1 pattern[i]依然不等于pattern[j]，令next[i]=0，j+=1 此时pattern[i]等于pattern[j]，令next[i]=j+1=1，i+=1，j+=1 此时pattern[i]等于pettern[j]，令next[i]=j+1=2，i+=1,j+=1 此时pattern[i]不等于patter[j]，并且j不在模式串的开头，令j=next[j-1]=2 此时pattern[i]依然不等于pattern[j]，并且j不在模式串的开头，令j=next[j-1]=0 此时pattern[i]依然不等于pattern[j]，但是j已经跑到开头去了，令i+=1 此时pattern[i]依然不等于pattern[j]，并且i已经跑到了尽头，求解结束。 %出来next数组是这样的:$[0,0,0,1,2,0]$ 0x05 解决所有问题其实就是放一下代码 我自认为讲的还是比较清楚，至少比蓝书好。 代码虽然和网上其他人的不太一样，不太标准，但还算简洁，至少比蓝书好。 总之一句话，学KMP不要看书，不要看书，不要看书！！！会死人的！！！ 对了还有一个坑点，我这份代码用std::string会RE，鬼知道我调了一下午发现是这个原因时心里有多傻逼 /* * P3375【模板】KMP字符串匹配.cpp * Created by boringhacker(c20220233wgy) */ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; namespace MAIN { const int SIZE = 1000000 + 5; int next[SIZE], n, m; char Text[SIZE], Pattern[SIZE]; // string Text, Pattern; 去你的std::string void GetNextVal() { int i = 1, j = 0; *next = 0; while (i &lt; n) { if (Pattern[i] == Pattern[j]) next[i] = j + 1, ++i, ++j; else if (j) j = next[j - 1]; else ++i; } } void GetAnswers() { int st = 0, res = -1; int i = 0, j = 0, flag = 0; while (true) { j = st; if (Text[i] == Pattern[j]) { if (!flag) res = i + 1 - st, flag = 1; // if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = 0, flag = 0; 这里出锅了，j应该赋为next[j-1] if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = next[j - 1], flag = 0; else ++i, ++j; st = j; if (i &gt;= m) return ; } else { if (j) st = next[j - 1]; else ++i; flag = 0; } } } void MAIN() { cin &gt;&gt; Text; cin &gt;&gt; Pattern; m = strlen(Text); n = strlen(Pattern); GetNextVal(); GetAnswers(); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; next[i] &lt;&lt; &#39; &#39;; } } signed main() { MAIN::MAIN(); return 0; } 欢迎捉虫子","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---莫队","slug":"DS100P-MO-ALGORITHM","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T03:13:41.479Z","comments":true,"path":"2020/02/05/DS100P-MO-ALGORITHM/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-MO-ALGORITHM/","excerpt":"","text":"莫队($n\\sqrt{n}$) 0x01考虑这样一个问题： 对于一个序列$A_1,A_2,\\cdots,A_n$，有如下询问 形如$S\\ \\ l\\ \\ r$的命令表示对区间$[l,r]$求和，并输出 形如$Q\\ \\ l\\ \\ r$表示$\\cdots$ 本题不强制在线 对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改但我太弱不会 现在你有区间$[3,5]$的和，可以求$[3,6]$的区间和吗？显然，将$[3,5]$的区间和加上$A_6$即可。类似的，求$[2,4]$的区间和，我们只需减去$A_5$即可。 可以结合下图感知一下 0x02好，接下来我们想一下如何维护这种询问之间的关系。 很容易想到排序，首先我们对询问的左端点进行排序。再把整个询问序列分为$\\sqrt{n}$块，每块以内再按右端点排序。 所以我们可以得出以下结论： 莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案 0x03来一道简单的例题 小B的询问小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求： 其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。小B请你帮助他回答询问 这道题让我们求 \\sum\\limits_{i=1}^k c_i^2开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int SIZE = 5e4 + 5; struct QueryNode { int l, r; int id; // 储存询问的顺序，方便输出 } Q[SIZE]; int a[SIZE], n, m, k, pos[SIZE]; int cnt[SIZE], ans[SIZE], res; // a:原序列 // pos:每个位置所处的块 // cnt:桶 // ans:询问的答案 // res:每次调整所得到的贡献 inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); } inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); int block = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), pos[i] = i / block; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); // 这四句都是在对当前的区间对于询问的区间进行调整 while (r &lt; Q[i].r) add(++r); // 这三句都是在对当前的区间对于询问的区间进行调整 while (l &lt; Q[i].l) del(l++); // 这二句都是在对当前的区间对于询问的区间进行调整 while (r &gt; Q[i].r) del(r--); // 这一句都是在对当前的区间对于询问的区间进行调整 ans[Q[i].id] = res; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 0x04其实莫队是有套路的，基本上莫队的题都是这样的: for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); while (r &lt; Q[i].r) add(++r); while (l &lt; Q[i].l) del(l++); while (r &gt; Q[i].r) del(r--); ans[Q[i].id] = res; } 我们只需考虑$add$函数以及$del$函数即可","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---后缀全家桶 之 后缀数组","slug":"DS100P-SUFFIX-ARRAY","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T03:19:50.589Z","comments":true,"path":"2020/02/05/DS100P-SUFFIX-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-SUFFIX-ARRAY/","excerpt":"","text":"后缀数组0x01 什么是后缀数组(Suffix Array)我们知道，对于一个长度为 $n$ 的字符串有 $n$ 个后缀，譬如对于字符串 $DCBAE$ 来说，它的后缀便是: 那么什么是后缀数组( $SA$ )呢？在我们对字符串的 $n$ 个后缀排序过后，我们定义后缀数组： $SA$ 数组：排在第i位的是第 $SA$ [i]个后缀 即后缀数组。 同时我们定义： RANK数组：排在第RANK[i]位的后缀是第i个后缀 不难看出RANK和 $SA$ 互逆 0x02 如何求出 $SA$ 数组(粗略的)朴素的做法是直接$sort$，$\\Theta(n^2\\log n)$ 爹妈恨铁不成钢。 稍微有点脑子都会想到$hash$但是依然爆炸。 如果深入思考的话很容易想到倍增，时间复杂度 $\\Theta(n\\log n)$ + 大常数碰上毒瘤题当场去世。 $DC3$？常数大，板子难背。 $LUOGU$ 日报曾经有过一片日报给出了一种诱导排序的解决方法，但是我不是很理解。 我在这里给出一种中文互联网上几乎没有任何资料的 $SA$ 数组线性时间复杂度构造方法(我也不知道叫什么名字)。 0x03 如何求出 $SA$ 数组(具体的)首先定义文本串 $text$ 为我们的待求 $SA$ 的字符数组 其次定义 $suffix_i$ 为以 $i$ 起头的 $text$ 的后缀 然后定义 $type_i = \\begin{cases}L, suffix_i &gt; suffix_{i+1} \\\\\\displaystyle S, suffix_i &lt; suffix_{i+1}\\end{cases}$ 参考图片(手写字可能有些看不清楚)： 字符串最后的是什么？你可以认为这是因为作者懒不想到处判边界而加上的比字符串中任意一个字符的ASCLL码都小的字符 再来定义 $dist_i$ 为 $text_i$ 距离上一个 $type_i$ 为 $S$ 的距离 参考图片(手写字可能有些看不清楚)： 再定义一个桶 $bucket$，以 $text$ 中的字符为区别桶之间的“键值”。依然参考图片 我们其实可以发现此时的 $bucket$ 已经和我们要求的 $SA$ 差的不远了。为什么呢？桶排啊！此时的桶外部其实已经是有序的了，只是我们内部还无法确定顺序。比如 $I$ 这个桶里，我们无法确定 $suffix_{2},suffix_{5},suffix_{8},suffix_{11}$ 的排序顺序，因为他们开头的首字母不同。那该怎么办呢？请继续往下看。 我们再定义一个桶 $D_lists$ “键值” 为 $list_i$。参考图片(注意此时我们不考虑键值(即 $dist$ )为0的情况) 以键值为1举一个例子。它的意思就是说 $dist$ 为1的情况有 $suffix_{9},suffix_{3,6}$ 这三种情况。与 $bucket$ 这个桶类似但不同的，我们能分清 $suffix_9$ 和 $sufiix_{3,6}$ 的顺序，但我们无法分清 $suffix_3$ 和 $suffix_6$ 的顺序。为什么呢？我们来看，下标为9的后缀是以 $P$ 开头的，然而下标为3和6的后缀却都是以 $S$ 开头的，所以 $suffix_9$ 一定排在 $suffix_{3,6}$ 的前面。$suffix_{3,6}$ 却因为首字母相同所以无法分清楚顺序。 下一步我们尝试将所有 $type$ 为 $S$ 的 $suffix$ 找出来 我们把 $bucket$ 扫一遍，即可得出： 图中的 $S-Substring$ 即为我们所求的所有 $type$ 为 $S$ 的 $suffix$。 同样，我们不知道 $suffix_{2,5,8}$ 哪个在前哪个在后。一种 $naive$ 的做法就是把 $[2,5,8]$ 依次+1，相当于直接暴力比较下一个字母，然后通过 $D_lists$ 来分析它们的先后关系。 我们发现了一个悲剧的事实：已经加到3了，我们却依然无法分清 $[2,5]$ 的顺序。如果继续加下去或许可以分清它们的顺序，但时间复杂度就难以保持在 $\\Theta(n)$，换句话说，它很容易被卡。 怎么办呢？我们分析一下这种情况出现的原因。 显然此时两个后缀的部分前缀是相同的。即下图的情况：","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---Link-Cut Tree","slug":"DS100P-LINK-CUT-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:48:17.341Z","comments":true,"path":"2020/02/05/DS100P-LINK-CUT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-LINK-CUT-TREE/","excerpt":"","text":"Link-Cut Tree0x00本文的图来自Qiuly的博客浅谈link-cut Tree 本文照搬Qiuly的博客浅谈link-cut Tree lct这东西不好写，我这种蒟蒻写不好所以只能照搬Qiuly，跟Qiuly唯一的区别就是我字是自己打的…… 0x01LCT其实可以看做加强版的重链剖分，可以说重链剖分能做的LCT都能做。不仅如此，LCT代码比重链剖分短，常数有时比重链剖分小。 LCT由很多棵Splay组成，其中将Splay森林中的所有Splay连接起来的叫做 虚边 。Splay中边叫做实边。 原来的森林我们叫做原森林，用实边连起来的一棵树叫原树。Splay的关键字是节点在书中的深度。 Splay是LCT的辅助树。fhq-treap其实也可以，但均摊时间复杂度会多出一个\\log 0x02以下是一些LCT常用的基础操作 access(x):将x到root的路径上的边全部变成实边，并断开与自己儿子的联系 findroot(x):找出x所在原树的root makeroot(x):让x变为所在原树的root connect(x,y):连接x和y所在的原树 erase(x,y):拆开x和y所在的原树 split(x,y):将x,y搞在一棵辅助树 Access(x): 换句话来说就是将点x到原树中root之间的链丢到一个splay里 举个例子，现在有一个森林长成这样：&lt;/li&gt;&lt;/ul&gt; 现在x为6。我们access(x)。 那么{1-3，3-6}会变为实边，1-2会变成虚边，假设6有一儿子n，之间用实边连着，那么这条边也将变成虚边。 每次将 x 点 splay 到当前所在辅助树的根节点，将它的右儿子更新为上一个 x ，然后令 x 跳到它的父节点，第一个 x 的右儿子设为0。 为什么是右儿子而不是左儿子呢？ 因为fa[x]的深度小于x，而在Splay里面fa[x]是x的爸爸，所以x在Splay中是fa[x]的右儿子。 我们将 x 旋转到辅助树的根节点，也就是将当前原树这条链上深度小于 x (在 x 上面的点)丢到了 x 的左子树上，将 x 的右子树设为上一个 x 点相当于将 x 原来的右子树丢到了新的 splay 里面(而它们之间用虚边相连)，并且将上一段链连接起来。 现在就可以了。这棵新 Splay 中只有这条链上的结点，没有其他任何的结点。如果我们指定要这三个结点同时进行操作，可以直接下传lazy_tag到这三个结点组成的 Splay 的根结点哦!到后面Splay的时候就可以直接下传跟新结点信息了。 总体过程： 虚边：儿子认父，父不认子 实边：儿子认父，父也认子 用FlashHu的话来说： 1.转到根。 2.换儿子。 3.更新信息。 4.当前操作点切换为轻边所指的父亲，转1。 inline void Access(int x){ for(register int y=0;x;y=x,x=fa[x]){ Splay(x);//转 ch[x][1]=y;//认儿子了 pushup(x);//儿子有变化，更新 } } findroot(x): 首先要明白： 根节点是的深度最小的 我们可以通过x向上找，用 Access 操作可以将x和x的根结点搞到一个 Splay 里。 又因为有BST的性质：x的左子树所有结点的权值 &lt; x &lt; x右子树所有结点的权值。 而我们又知道，在执行完 Access 操作后，这课 Splay 里面的结点权值最大的(深度最大的)就是x。 于是我们可以将x Splay 到这棵 Splay 的根结点，那么现在最左边的节点便是这课树的根结点了。 inline int findroot(int x){ Access(x);//Access将x和根结点搞到同一个Splay中 Splay(x);//转到Splay的根结点 while(ch[x][0])pushdown(x),x=ch[x][0];//不断的找左儿子&amp;更新节点信息 return x;//最左边的就是根结点了。 } makeroot(x): 将x到根结点的路径上的点全部翻转(即x变成了根节点) 具体操作是我们先将x点与原树中的根打通一条链，那么现在它们就在同一棵辅助树里面了，我们发现x一定是在它所在的辅助树的中序遍历的最后一个的(因为它是这条链上最深的点)，我们把x点 splay 到辅助树的根上，那么x显然是没有右子树的，我们要实现将x移到原树的根上，也就是将x到根的这条链的深度全部翻转一遍，在辅助树上的体现就是将整棵树翻转一遍，我们可以写个翻转标记来减少复杂度。 inline void filp(int x){//Splay普通区间翻转 swap(ch[x][0],ch[x][1]);r[x]^=1; } inline void makeroot(int x){ Access(x); Splay(x); filp(x);//lazy_tag&amp;翻转区间 } split(x,y) 这个操作是将x到y之间的那条路径丢到一棵辅助树里，并且这棵辅助树以y节点为根。 Splay 维护的是原树中的一条链，我们不能保证x,y会在同一条链里。 所以我们可以先把x变成原树的根节点(这下子Access(y)就会将x到y之间的所有节点丢到一个 Splay 中了)。 inline void split(int x,int y){ makeroot(x);Access(y);Splay(y); } connect(x,y): 将x和y所在原树合并起来 首先将x点丢到原树的根，然后去找找y的根是不是x，如果不是说明x,y不在一个原树内，我们将x的父节点设为y，也就相当于从y到x连了一条虚边。 inline void connect(int x,int y){ makeroot(x);//转到根 if(findroot(y)!=x)fa[x]=y;//连接一条虚边 / erase(x,y): 首先我们先把x,y之间的那条边用split(x,y)拎出来，因为x,y是相邻的，所以y的左儿子一定是x，将它们的父子关系消灭掉即可。 消灭父子关系时一定满足以下条件： 1.x和y在一个原树里(不在一个树里面往哪儿切啊) 2.split之后x是y的左儿子 3.x的右儿子是空的(保证了中序遍历中y紧跟在x的后面，即深度相邻)(x的权值(深度)只比y小1，而x又正好是直接连着y的，所以我们无法再找到 &gt;x 而又 &lt;y 的整数了) inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1] fa[x]=ch[y][0]=0; }return; } 但是如果我们在findroot中添加了Splay的话，erase中x和y的父子关系就变了，需要改为这样，否则会出现一些奇奇怪怪的错误： inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;! fa[y]=ch[x][1]=0;pushup(x); de> 0X03 Splay的改动： 旋转的改动： 这里需要注意一下，如果x的父亲节点的父亲节点y已经不在当前的这棵辅助树上，只需要连单向边(也就是虚边，认父不认子)，否则正常连就行，这里要和普通的rotate区分开来。 做个对比： 现在的rotate(x): 这里的x可以不更新，因为会在下一次rotate时更新。 inline void rotate(int x){ int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; x;ch[x][!k]=y,ch[y][k]=v; if(v)fa[v]=y;fa[y]=x,fa[x]=z;pushup(y); } Splay的改动 同样要注意一下只能Splay到辅助树的根节点，Splay之前需先下传一下这一条链上需操作的所有的点，用栈来完成即可 inline void Splay(int x){ int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=fa[y]; while(top)pushdown( while(get(x)){//基本普通的Splay y=fa[x],top=fa[y]; rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); }pushup(x);return; } 最后放一下模板题代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; }","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---splay","slug":"DS100P-SPLAY","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T03:15:11.688Z","comments":true,"path":"2020/02/05/DS100P-SPLAY/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-SPLAY/","excerpt":"","text":"update:增加几道好一点的例题吧 [NOI2004]郁闷的出纳员 [模板]文艺平衡树 [SHOI2013]发牌 [TJOI2010]中位数 [TJOI2007]书架 正文：关于SPLAY其实我更偏向于把splay叫做cosplay 讲平衡树总逃不过BST(Binary Search Tree)，二叉搜索树，以下是BST的性质： 一棵合法的BST每个节点上都带有一个数值，我们将其称为节点的“关键码”。那么对于一棵BST上的任意节点，满足： 该节点的关键码不小于它左子树的任意结点的关键码 该结点的关键码不大于它右子树的任意结点的关键码 显然，BST的中序遍历是一个递增的序列 建立一棵BST因为笔者很懒，不想到处判边界，所以我们一般可以在一棵空的BST中预先插入两个结点，一个正无穷，一个负无穷，如图: const int SIZE = 1e5 + 5; const int INF = 0x7fffffff; struct BSTNode { int l, r; // 左右儿子的编号 int val; // 关键码 } T[SIZE]; int tot, root; int clone(int val) { // 新建节点 T[++tot].val = val; return tot; } void build() { clone(-INF), clone(INF); root = 1, T[1].r = 2; } 以上是建树的代码 那么，BST就讲到这里 平衡树的诞生当BST形成一条链的时候，每次查询会变成$O(n^2)$ 这种深度过深的BST是不平衡的。所以我们需要一种能保持树的深度在$\\log(n)$的数据结构，于是便诞生了平衡树 SPLAYsplay，又称cosplay伸展树，有“序列之王”的美称，常数巨大，跑的没有$fhq-treap$快，但这不在我们的讨论范围以内 想象一下这样一颗BST，我们先把它们的大小关系列出来。 YY, X","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---线段树","slug":"DS100P-SEGMENT-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:35:24.434Z","comments":true,"path":"2020/02/05/DS100P-SEGMENT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-SEGMENT-TREE/","excerpt":"","text":"线段树 —LYC(ZBing)($nlogn$) 线段树，顾名思义，就是每个树的节点记录一条线段上的一些信息，非常灵活，可以实现很多操作，但常数比树状数组大一点。 就像这样： 线段树的经典应用就是统计区间和，我们这里也用这个来进行线段树的讲解。 1).建树我们先放代码吧，看代码理解。 void build(int l,int r,int x) { if(l==r) { nodes[x]=a[l]; return; } else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=nodes[x&lt;&lt;1]+nodes[(x&lt;&lt;1)+1]; } } 首先，我们遍历到线段树的每一个叶子节点。线段树的每个节点都代表了一个区间，当这个区间的$l=r$时，说明我们到达了叶子节点。这个叶子节点代表的区间只包含了$a[l]$这一个数，所以我们只需要将这个节点的值置为$a[l]$。 然后我们递归回去，每一个非叶子节点都可以把它代表的区间分成两半，对应它的两个子节点（可能没有两个）。它两个子节点的值就是这两个较小区间的元素和。由这两个子节点的值也就是这两个小区间的元素和相加就可以得到当前节点代表区间的元素和。 时间复杂度($nlogn$) 2).单点修改像这种区间和问题的单点修改一般都是给一个点加上一个值。 还是先放代码吧： void update(int l,int r,int x,int pos,int val) { nodes[x]-=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(l,mid,x&lt;&lt;1,pos,val); else update(mid+1,r,(x&lt;&lt;1)+1,pos,val); } 还是先递归找到要修改的叶子节点。先将它的值加上val。 然后再递归回去，因为往下找时找到的每一个节点代表的区间都包含这个叶子节点代表的区间，所以这些节点的值也要加上val。 时间复杂度($logn$) 3).区间查询区间查询的本质就是把要查询的区间拆分成很多小区间，直接利用之前维护的节点的值进行查询。 int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr||r&lt;=ba) return nodes[x]; int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } 我们对于当前递归查找到的节点所代表的区间与要查询的区间进行分类讨论： $1$&gt;.毫无关联 即当前区间的左端点在查询区间右端点的右边或当前区间的右端点在查询区间左端点的左边。 既然他们毫无关联，那么我们就返回一个值0，因为他们对这个区间的和没有任何贡献。 $2$&gt;.被包含 即当前区间的左端点在查询区间的左端点的右边且当前区间的右端点在查询区间的右端点的左边。 既然这个节点代表的区间全部属于查询区间内，那么我们就没有必要再继续递归下去了，直接把这个节点的值加上去。 $3$&gt;.有部分重叠但不被包含 即上两种情况的剩余情况。 对于这种情况，我们没有办法把节点的值直接加上去，因为这个节点代表的区间不全属于查询区间。也不能直接跳过，因为有部分节点属于查询区间。所以我们继续向它的子节点递归，相当于把这个区间分成两半，查询两个子区间中属于查询区间的值加起来。 时间复杂度（$logn$） 4).区间修改面对区间修改，如果我们继续用单点修改，时间复杂度会退回到（$n^2logn$） 所以我们引入人类的本质懒标记。 当我们找到了一个完全是要修改的区间，我们就直接把它的懒标记加上$val$。 对于中途遍历到的其他区间，我们直接计算修改这个区间的和。 代码： void update(int l,int r,int x,int fr,int ba,int val) { if(l&gt;ba||r&lt;fr) return; if(l&gt;=fr&amp;&amp;r&lt;=ba) lazy[x]+=val; else { nodes[x]+=val*max(0,min(r,ba)-max(l,fr)+1); int mid=(l+r)&gt;&gt;1; update(l,mid,x&lt;&lt;1,fr,ba,val); update(mid+1,r,(x&lt;&lt;1)+1,fr,ba,val); } } 长得和区间查询很像对吧 改了修改之后，我们的查询也要进行修改。要把打上的懒标记进行下传，不然查询到下面的节点时，下面的节点没有被修改。 下传时只需要让当前节点加上原来应加而拖延了的值，让它的左右儿子的懒标记加上它的懒标记。因为当初修改时，并没有修改到左右节点。最后再把懒标记清零。 就像这样： void pushdown(int l,int r,int x) { nodes[x]+=(r-l+1)*lazy[x]; lazy[x&lt;&lt;1]+=lazy[x]; lazy[(x&lt;&lt;1)+1]+=lazy[x]; lazy[x]=0; } int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(lazy[x]) pushdown(l,r,x); if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[x]; else { int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } } $\\ $ 线段树的讲解到这里就这么完了，但线段树的运用十分广泛，灵活。要熟练掌握并运用线段树，还要多动脑，想好题。","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---trie树","slug":"DS100P-TRIE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:40:31.526Z","comments":true,"path":"2020/02/05/DS100P-TRIE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-TRIE/","excerpt":"","text":"trie树($\\sum{len}$) $trie$树，不是一种二叉树，它是一种多叉树（其实也可以是二叉树） 可以用来求一堆数中两个（或三个）异或起来的最大值。 可以查找单词。 对于一些有前缀的单词，比如WGY_2333和WGY_AND_LYC_WRITE_BLOG。 它们就可以共用树上的一些节点（即WGY_），查询时就可以从$\\ $2$\\ $和$\\ $L$\\ $来对他们进行区分 所以我们还是看看它是怎么实现的吧。 1&gt;.插入对于$trie$树，树上的每一条边都代表了一个字母或者一个数字。 所以一个节点会有很多儿子，我们就要开一个儿子数组$ch$。 要统计这个节点被经过了多少次，也就是多少单词有这个前缀，就要加一个$sum$。 要统计有多少个单词在这里结束，也就是要查询的单词有多少个已插入的单词作前缀，就要加一个$end$。 插入时，先看这个节点有没有你要走的那个儿子，如果没有，就新建一个，走下去。否则就直接走到这个儿子（共用节点嘛）。 代码：（以小写字母单词为例） struct node { int ch[26],sum,end; }nodes[MAXN]; int root=1,cnt=1; void ins(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].ch[str[i]-&#39;a&#39;]) nodes[x].ch[str[i]-&#39;a&#39;]=++cnt; x=nodes[x].ch[str[i]-&#39;a&#39;]; ++nodes[x].sum; } ++nodes[x].end; } 2&gt;.查询$trie$树的查询有很多种，一般依照题目要求来自己定义。 我们这里又以小写字母单词查询存在性为例。 同样是从最上面的根节点开始。如果当前节点有这个单词现在位置字母的儿子，就走下去。否则就直接返回false，因为之前没有过单词走过这条路径,如果有过这个前缀的单词走过，肯定会创建这个节点。 最后再判断有没有单词在这个地方结束。 代码: bool find(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].str[str[i]-&#39;a&#39;]) return false; x=nodes[x].str[str[i]-&#39;a&#39;]; } return nodes[x].end; } trie树就只有这么点，惊不惊喜，意不意外","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---树链剖分","slug":"DS100P-TREE-CHAIN-SPLITTING","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:43:12.769Z","comments":true,"path":"2020/02/05/DS100P-TREE-CHAIN-SPLITTING/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-TREE-CHAIN-SPLITTING/","excerpt":"","text":"树链剖分($nlogn$) 树链剖分准确地说并不是数据结构，它只是数据结构的一种应用。 它用于将一棵树上的节点转换到一个序列中，然后用各种数据结构维护。 所以我只讲如何转换和使用，而维护就因题而异了。 树链剖分有好几种方法：重链剖分，长链剖分… 但我就讲最常用的重链剖分。 重链剖分，顾名思义，就是按照节点的子树大小来剖分这棵树。 一个节点子节点中子树大小最大的子节点叫做这个节点的重儿子。 以一个轻儿子为起点，其余全是重儿子的链叫做重链。 重链上的边叫做重边。 就像这样（红色的边为重边） 可以发现，每个节点都在且仅在一条重链上，我们就可以把这一条链转换到一个连续的区间来进行维护。 dfs1我们采用dfs的形式来进行剖分，记录信息。 第一次dfs我们需要记录每个节点的父亲，子树大小，重儿子和深度。 很简单对吧，就是暴力$dfs$，但要注意不要搜回到父亲节点和一些其他的坑。 代码： void dfs1(int x,int last) { fa[x]=last;//记录父亲节点。 sum[x]=1;//初始化子树大小：该节点本身。 depth[x]=depth[last]+1;//深度：父亲节点深度+1。 int big=0,bi=0;//寻找重儿子 for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^last)//避免重新回到父亲节点 { dfs1(e[x][i],x); sum[x]+=sum[e[x][i]]; if(sum[e[x][i]]&gt;big) { big=sum[e[x][i]]; bi=e[x][i]; } } } son[x]=bi;//记录重儿子。 } //调用:dfs(root,root) dfs2经过刚刚$dfs1$的准备，我们可以进行剖分了，这次记录$dfs$序，转换出的序列上的每一个值，以及每个节点所在重链的起点。 我们在这次$dfs$时应该优先走重儿子，这样才能使一条重链上的值都在序列上连在一起，方便我们操作。 代码: void dfs2(int x,int last,bool heavier) { dfn[x]=++tot;//记录dfs序 turn[tot]=val[x];//记录序列 if(heavier) hb[x]=hb[fa[x]];// else hb[x]=x;//记录所在重链起点 if(b[x].son) build2(b[x].son,1);//优先遍历重儿子 for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^son[x]&amp;&amp;e[x][i]^fa[x]) build2(e[x][i],0);//避免重复遍历 } } 一个节点的$dfs$序就是它在序列中的位置。对吧 使用对于一些子树上的操作，$dfs$序已经能够搞定了，我们只需要用剖出的重链对那些结点间路径的操作进行应对就好了。 对于两个节点间的路径，我们很容易想到$LCA$。而我们记录了重链的起点，可以处理这条重链，然后直接跳到上面一条重链的末端。 注意当两个节点在同一条重链时跳出循环，在最后处理他们之间的路径。 由于他们已经在同一条重链上了，他们及他们之间的节点$dfs$序是连续的，所以再处理这个连续区间就好了。 代码： //设solve(x,y)是对x到y区间的操作(因题而异) ___ LCA(int x,int y) { int fx=hb[x],fy=hb[y];//得到重链起点 while(fx^fy) { if(depth[fx]&lt;depth[fy])//从深度大的往上跳 { swap(fx,fy); swap(x,y); } solve(dfn[fx],dfn[x]);//处理这条重链的区间 x=fa[fx];//跳到上面一条重链 fx=hb[x];//更新重链起点 } solve(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));//最后处理同一条重链上的剩余未处理部分。 //return ans; } 5.主席树($nlogn$) “你是主席树吗？有那么多爷爷！”——$LJS$。 这句话运用打比方的说明方法，生动形象地说明了主席树每个节点可能有很多父亲的特点，体现说明语言的生动性。 也就是说，主席树的几个节点可能共用一个子节点。 就像这样： 主席树可以用来查询静态区间第k小，静态区间前k大的和等等。（用法十分灵活） 我们会创建很多版本的树，一些版本会共用一些节点，以节省空间和时间。 主席树也叫可持久化线段树。但可持久化还有很多东西。我就讲可持久化线段树吧。 1.如何共用节点我们考虑单点修改的线段树。 如果要得到这个序列某个元素$x$加上一个值$val$之后的新版本，我们发现，改变的只有对应元素$x$的节点和他的祖先会加上$val$。那么其他节点我们可以与上一个版本共用。 所以我们每次新建一个节点，继承之前该位置的值和左右儿子，然后更新值，再继续向下寻找元素$x$的位置，最后递归回来更新这个儿子。 我们使用$root$数组来记录每个版本的根节点编号。 代码： void ins(int l,int r,int pre,int &amp;now,int pos,int val)//区间左右端点，上一个版本中对应这个区间的点，当前版本中对应这个区间的点，修改位置，增加的值。 { nodes[++tot]=nodes[pre];//先整个复制 now=tot;//更新上一个节点的儿子。 nodes[now].sum+=val;//更新当前节点的值 if(l==r) return; //向下继续寻找 int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //调用：ins(1,n,root[i-1],root[i],p,v); 最后$root[i]$的引用就相当于记录了这个版本的根节点。 查询其实就和普通的线段树一样，但主席树的用途不止这个。 2.例题【模板】可持久化线段树 1（主席树） 如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。 权值线段树： (线段树的另一种应用，只是每个节点维护整个序列值在$[l,r]$区间内的数的个数) 这道题要求查询静态区间第$k$小。那么对于第$k$小这种问题，我们要使用权值线段树 离散化：$-1e9\\leq a_i \\leq1e9$ 的数据线段树肯定开不下，但这道题只需要求第k小，没有必要开那么大，可以对数据进行离散化。 我们按照序列的顺序插入$a_i$。得到每个$root[i]$代表的权值线段树代表从$a_1$到$a_i$的每个数值的出现次数。 那么根据前缀和的思想，区间$[l,r]$中每个数值的出现个数就是$[1,r]$的减去$[1,l-1]$的。那么数值的区间也具有这个性质。 所有对于每个询问，我们只需要查询一次，用$root[r]$和$root[l-1]$的权值线段树处理出区间$[l,r]$应有的权值线段树，就可以像正常的权值线段树一样查询第k小了。 代码： #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//插入，创建新版本 { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//现场处理，得到[x,y]区间内，值在[l,mid]内的数的个数 if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//如果k&lt;=X.说明第k小的数在左边。 else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//否则在右边。 } int getid(int X)//得到离散化后的数值 { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//离散化 for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//按顺序插入每个值，得到root[i]对应的权值线段树。 for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//查询区间[x,y]；输出原值 } return 0; } 3.缺点及注意事项内存池一般从1开始用，$nodes[0]$作为空白，值为$0$，儿子节点指向自己，值还是为$0$。 当你这个版本的树还没有改过某个节点的某个儿子时，这个节点的这个儿子会指向$nodes[0]$，也就相当于下面都是$0$，正好符合。 数组一定要开大，如果开得不够大可能会出现$MLE$,$TLE$,$RE$,$WA$. 但也不要开太大，不然会$MLE$,$CE$. 主席树是静态的，遇到要动态修改而不是生成一个新版本的问题，就可能要用树套树了。 可持久化可以用在很多数据结构上，平衡树，线段树，$trie$树……可够得写，但它们的思想都是相似的，都是每个版本与之前的版本共用节点以节省时间，空间。","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]},{"title":"数据结构100题 ---树套树","slug":"DS100P-TREE-COVER-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-06T02:42:02.735Z","comments":true,"path":"2020/02/05/DS100P-TREE-COVER-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-TREE-COVER-TREE/","excerpt":"","text":"树套树($nlog^2n$) 树套树也是一种暴力思想，它可以有很多实现：树状数组套平衡树，主席树套树状数组…… 但是最常见的还是线段数套平衡树。 1.思想&amp;&amp;建树标准说法：线段树的每个节点对应平衡树的一个节点。 ??? 其实还是线段树每个节点对应一个区间，但是我们把这个区间建成一棵平衡树就行了，线段树节点记录这个区间建成的平衡树的根节点就行了。 线段树有$logn$层，每层的节点对应的区间能够拼成一个完整的区间，即每层$n$个平衡树节点，平衡树每个节点插入是$logn$的，所以建树的时间复杂度是$nlog^2n$ fhq-treap示例 void build(int l,int r,int x) { for(int i=l;i&lt;=r;++i) { split(root[x],a[i],root1,root2); root[x]=merge(merge(root1,newnode(a[i])),root2); } if(l^r) { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); } } 2.查询区间排名给定一个区间和一个值，查询区间中比他小的元素个数加1。 我们可以像线段树一样，先把这个区间拆分成一些能用我们之前建树建出的平衡树表示的小区间，再查询小区间中比这个值小的元素个数加起来的和。 很明显 f[i,j]=f[i,k]+f[k+1,j]（i\\leq k","categories":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Learning","slug":"Learning","permalink":"www.orchid-any.cf/categories/Learning/"}]}]}