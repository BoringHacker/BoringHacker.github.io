{"meta":{"title":"BoringHacker's Blog","subtitle":"Stay Hungry, Stay Foolish","description":null,"author":"BoringHacker","url":"www.orchid-any.cf"},"pages":[{"title":"Comments","date":"2020-01-17T07:04:09.000Z","updated":"2020-01-17T07:05:20.286Z","comments":true,"path":"Comments/index.html","permalink":"www.orchid-any.cf/Comments/index.html","excerpt":"","text":"随便说点什么吧(记得改昵称)233…"},{"title":"Havefun","date":"2019-12-21T13:04:04.000Z","updated":"2020-01-15T08:32:06.232Z","comments":true,"path":"Havefun/index.html","permalink":"www.orchid-any.cf/Havefun/index.html","excerpt":"","text":""},{"title":"Tools","date":"2020-02-15T09:56:00.000Z","updated":"2020-02-18T07:41:09.961Z","comments":true,"path":"Tools/index.html","permalink":"www.orchid-any.cf/Tools/index.html","excerpt":"","text":"For ljes(滑稽)函数求导工具 函数输入框: 自变量: 阶数: 0 1 2 3 4 5 6 7 8 9 10 不定积分计算器 请输入你需要积分的函数表达式: 自变量: 定积分计算器 请输入你需要积分的函数表达式: 自变量: 从: 到: 极限计算器 请输入一个函数并计算极限: 极限变量: x趋向于: 极限类型 双侧极限 右侧极限 左侧极限 函数图像绘制工具函数输入框: X 坐标, 从: 到: Y 坐标, 从: 到: 分数计算器 输入一个分数表达式: 方程求解 输入逗号以分隔多个方程: 表达式化简 输入一个表达式来简化: 因式分解工具 请输入您需要分解因式的表达式：: 阶乘计算器 请输入一个非负整数: 组合数计算器 组合数计算方法，从N项中选出M项. 是否具有顺序? 是 否 元素是否可以选择一次以上? 是 否 N = M = 反函数计算器 输入函数来计算其反函数: 表达式计算器 输入要计算的表达式: 质数发生器和校验器 输入一个自然数，并选择相应的功能: 检验是否为质数 下一个质数 上一个质数 整数分解工具 请输入您需要分解的整数: 斐波那契数计算工具 请输入一个非负整数: 伯努利数发生器 请输入一个非负整数: 欧拉数计算工具 请输入一个非负整数: 统计计算器 输入一个空格，逗号或新行分隔的数字: 平均数 中位数 调和平均数 几何平均数 最小 最大 范围 方差 更正方差 标准偏差 更正的标准偏差 变异系数 平均偏差 中位数偏差 偏度 矩阵计算器 输入矩阵 A: 矩阵的行列式 转置矩阵 矩阵迹 矩阵的秩 逆矩阵 特征值 下三角矩阵 A2 矩阵运算 输入矩阵 A:输入矩阵 B: 加法 减法 乘法","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"www.orchid-any.cf/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-05T10:53:40.037Z","comments":false,"path":"about/index.html","permalink":"www.orchid-any.cf/about/index.html","excerpt":"","text":"BoringHacker 与&nbsp; BoringHacker&nbsp; （ BoringHacker ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-05T10:46:24.855Z","comments":true,"path":"comment/index.html","permalink":"www.orchid-any.cf/comment/index.html","excerpt":"","text":"念两句话 人渣的本愿，苏联的解体。 【现代】noip毒瘤《洛谷·个人主页》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"donate/index.html","permalink":"www.orchid-any.cf/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"Blog","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-08T10:34:13.512Z","comments":false,"path":"lab/index.html","permalink":"www.orchid-any.cf/lab/index.html","excerpt":"","text":"咕咕咕。。。","keywords":"博客是怎样诞生的"},{"title":"Animes","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-18T07:39:33.709Z","comments":false,"path":"bangumi/index.html","permalink":"www.orchid-any.cf/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"Game","date":"2020-02-05T11:21:36.000Z","updated":"2020-02-16T00:10:50.973Z","comments":false,"path":"game/index.html","permalink":"www.orchid-any.cf/game/index.html","excerpt":"","text":"教程 2048 flappy bird 五子棋 生火间 水果忍者","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-15T23:36:15.000Z","comments":true,"path":"links/index.html","permalink":"www.orchid-any.cf/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"www.orchid-any.cf/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"www.orchid-any.cf/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"www.orchid-any.cf/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-08T06:03:27.000Z","updated":"2020-02-18T07:40:39.616Z","comments":true,"path":"tags/index.html","permalink":"www.orchid-any.cf/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"www.orchid-any.cf/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"「题解」洛谷P3267侦察守卫","slug":"SOL-P3267","date":"2020-02-18T12:02:53.000Z","updated":"2020-02-19T01:14:32.701Z","comments":true,"path":"2020/02/18/SOL-P3267/","link":"","permalink":"www.orchid-any.cf/2020/02/18/SOL-P3267/","excerpt":"","text":"题意简述给你一棵树，放置守卫在某个点上面需要一定代价和一定的有效范围。让你覆盖若干指定点，求最小代价 题解算法标签：$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 树DPDP状态定义:$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 说实话这道题定状态不好定。 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 那么我们从头来看，当 $d =0$ 的时候，我们就是在求树的最大独立集，定义显而易见。 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $d\\neq 0$ 我们可以照搬原来的定义，把它扩展一下。 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $f_{i,j}$ 表示以 $i$ 为根结点的子树已经完全被覆盖让然后还能向上覆盖 $j$ 层的最小代价 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $g_{i,j}=$ 表示以 $i$ 为根结点的子树还有 $j$ 层没有覆盖的最小代价 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 需要注意的是 $j$ 本质上是带有方向性的，可以类比向量的概念。 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 边界条件很显然，$f_{i,0}=val_{i}$ 此时当前结点需要被覆盖。 $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 其他情况： \\begin{cases} f_{i,j}=val_{i},j\\in [1,d] \\\\ \\displaystyle f_{i,j}=\\infty,j=d+1 \\end{cases}$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ 状态转移方程倒是比较好想，这里就不再赘述。 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } int val[500005], f[500005][25]; int g[500005][25], vis[500005]; int n, m, d, tot, head[500005]; int nxt[1000005], to[1000005]; std::vector &lt; std::vector &lt; int &gt; &gt; G(500005); void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; G[x].push_back(y); G[y].push_back(x); } void DP(int x, int fa) { if (vis[x]) g[x][0] = f[x][0] = val[x]; for (int i = 1; i &lt;= d; ++i) f[x][i] = val[x]; f[x][d + 1] = 0x3f3f3f3f; for (int i = head[x]; i; i = nxt[i]) { int y = to[i]; if (y ^ fa) { DP(y, x); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[y][j + 1] + g[x][j + 1], f[x][j] + g[y][j]); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[x][j + 1], f[x][j]); g[x][0] = f[x][0]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] += g[y][j - 1]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] = std::min(g[x][j - 1], g[x][j]); } } } signed main() { read(n, d); for (int i = 1; i &lt;= n; ++i) read(val[i]); read(m); for (int i = 0, x; i &lt; m; ++i) read(x), vis[x] = 1; for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); DP(1, 0); printf(&quot;%d\\n&quot;, g[1][0]); }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"www.orchid-any.cf/tags/动态规划/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"「笔记」快速傅里叶变换","slug":"NOTE-FAST-FOURIER-TRANSFORM","date":"2020-02-17T01:27:53.000Z","updated":"2020-02-18T10:15:54.861Z","comments":true,"path":"2020/02/17/NOTE-FAST-FOURIER-TRANSFORM/","link":"","permalink":"www.orchid-any.cf/2020/02/17/NOTE-FAST-FOURIER-TRANSFORM/","excerpt":"","text":"本文搬运自C20211013李琰Luogu 楔子一道板子题 题意：求两个大整数相乘的积. 选手1：我会$\\mathsf{unsigned\\ long\\ long}$！ 预计得分：$0\\mathsf{pts}$ 选手2：我会高精！ 预计得分：$30\\mathsf{pts}$ 选手3：我会$\\mathsf{Python}$！ 预计得分：$\\cdots$ (选手3被众人围殴致死) 卷积思想引入 1求两个无符号整数相乘的积. 在这里，我们并不是想编写一个程序来实现上述功能，而是老老实实用纸笔计算. 例： 计算 $21\\times121$ 解： \\quad\\ \\ 21\\times\\ 121 \\quad\\ \\ 21\\ 42\\!\\!\\!\\!21 \\!2541答：$21\\times121=2541.$ 回顾刚才的计算过程，我们分析一下$2541$的每一位数字是怎么得出来的. $1=1\\times1$ $4=2\\times1+2\\times2$ $5=2\\times2+1\\times1$ $2=2\\times1$ 我们用数组$A$存储$21$这个数，$B$存储$121$，$C$存储答案，则 $C_0=A_0\\times B_0$ $C_1=A_1\\times B_0+A_0\\times B_1$ $C_2=A_1\\times B_1+A_0\\times B_2$ $C_3=A_1\\times B_2$ 观察下标，我们发现两个正整数相乘的结果满足下面规律： C_k=\\sum^k_{i=0}A_i\\times B_{k-i}引入 2求两个多项式相乘的积. 同上例，我们依然用纸笔计算之. 例： 计算$(1+2x)(1+2x+x^2)$ 解： $(1+2x)(1+2x+x^2)=1+2x+x^2+2x+4x^2+2x^3=1+4x+5x^2+2x^3$ 根据计算过程分析各项系数，有： $1=1\\times1$ $4=2\\times1+2\\times2$ $5=2\\times2+1\\times1$ $2=2\\times1$ 这里我们用数组$A$存储$(1+2x)$的系数，$B$存储$(1+2x+x^2)$的系数，$C$存储答案的系数，则： $C_0=A_0\\times B_0$ $C_1=A_1\\times B_0+A_0\\times B_1$ $C_2=A_1\\times B_1+A_0\\times B_2$ $C_3=A_1\\times B_2$ 我们发现，两个多项式乘积的系数满足下面的规律： C_k=\\sum^k_{i=0}A_i\\times B_{k-i}卷积？！我们观察上面两个式子，可以看出它们具有相同的形式，我们称这种形式为卷积. 形象理解： “卷积”，“积”自然指乘积，而“卷”的含义如图： 第一次尝试#include&lt;cmath&gt; #include&lt;cstdio&gt; const int N = 1000005, mod = 998244353; int A[N], B[N], C[N]; int a, b; void mutiply() { for(int k = 0; k &lt; a + b - 1; ++k) for(int i = 0; i &lt;= k; ++i) C[k] += (A[i]*B[k-i]); } int main() { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); ++a,++b; for(int i=0;i&lt;a;++i)scanf(&quot;%d&quot;,A+i); for(int i=0;i&lt;b;++i)scanf(&quot;%d&quot;,B+i); mutiply(); for(int i=0;i&lt;a+b-1;++i)printf(&quot;%d &quot;,C[i]); return 0; } 干得漂亮！我们收获了$44\\mathsf{pts}$的佳绩！ 另一种方法之前有用到这样一个思路，对于任意多项式$F$，我们可以采用将其升幂排列，再存储其系数的办法来表示出$F$. 这里谈谈另外一种办法. 众所周知，两点确定一条直线，用解析几何的语言描述，就是$y=ax+b$由两个有序点对${(x_0,y_0),(x_1,y_1)}$唯一地确定. 为什么？因为我们知道了这两个点的坐标，将其带入进解析式，得到二元一次方程组，再解这个方程组，得到$a$和$b$的值. 当$y=ax^2+bx+c$时呢？进一步地，当$y=a_0x^0+a_1x^1+\\cdots+a_nx^n$时呢？ 我们可以看出，式子$y=a_0x^0+a_1x^1+\\cdots+a_nx^n$有$(n+1)$个系数，如果我们要唯一地确定它，就需要$(n+1)$个点的坐标联立起来解出系数. 也就是说，$(n+1)$个有序点对可以唯一表示一个多项式，我们称其为“点值表示法” 但是它有什么用？我们知道，将两个浮点数相乘的时间复杂度是$O(1)$的，那么，假设我们有两个多项式$A$和$B$，不妨设它们为$(1+2x)$和$(1+2x+x^2)$，接下来，我们计算它们在一些点上的值： x\\quad A\\quad B 0\\quad\\ 1\\quad\\ 1 1\\quad\\ 3\\quad\\ 4 2\\quad\\ 5\\quad\\ 9 3\\quad7\\quad16 4\\quad9\\quad25将$A$列和$B$列对应的数相乘，记作$C$列，则 x\\quad C 0\\quad\\ 1 1\\quad12 2\\quad45 3\\ \\ 112 4\\ \\ 225在上面我们求得$A\\times B$，我们将$x=\\{0,1,2,3,4\\}$代入$A\\times B$， x\\quad A\\times B 0\\quad\\quad\\quad\\ 1 1\\quad\\quad\\quad12 2\\quad\\quad\\quad45 3\\quad\\quad\\ \\ 112 4\\quad\\quad\\ \\ 225相等？！是的，当我们转换为点值表示法时，两个多项式在某点上的值的乘积等于两个多项式的乘积在某点上的值.(显然$F(x)\\times G(x)=F(x)\\times G(x)$，等号左边是点值表示法的$F$和$G$在$x$处的值的乘积，等号右边是它们的乘积在$x$处的值，慢慢品味.) 设这两个多项式是$m$和$n$次的，则它们的乘积是$(m+n)$次的，所以，我们只要计算这两个多项式在$(m+n+1)$个点上的值并一一相乘，就可以确定这两个多项式的乘积. 时间复杂度？$O(n+m)\\qquad\\mathsf{Good\\ Job!}$ 且慢$1)$如何将点值表示法转换为系数表示法？ $2)$我们该如何选取那些待计算的点？显然，我们需要在这些点上计算它的平方，立方甚至更高次方，而且，如果我们能合理地选择待计算的点，那么计算将会极大地简化. 接下来我们将会看到一类名叫单位根的复数，结合分治思想后可以将时间复杂度降低到$O(n\\log n)$. 但首先，我们还是要了解$\\cdots$ 复数复数是形如$a+bi$的数，其中$a,b\\in\\mathrm{R},i=\\sqrt{-1}$. 将全体复数的集合称作$\\mathrm{C}$ 复数的三则运算（除法现在还用不到） $(a+bi)+(c+di)=(a+b)+(c+d)i$ $(a+bi)-(c+di)=(a-b)+(c-d)i$ $(a+bi)\\times(c+di)=(ac-bd)+(bc+ad)i$ 证明：注意$i^2=-1$，利用结合律，分配律即证. 注：复数也满足结合律，分配律和幂运算规则. 欧拉公式和单位根欧拉公式：$e^{i\\theta}=\\cos\\theta+i\\sin\\theta$ 注意到$e^{(2a+1)\\pi i}=-1,e^{2a\\pi i}=1,a\\in\\mathrm{N}$ 则方程$x^n=1$的根（称作单位根，记作$\\omega^k_n$)为 \\omega^k_n=e^{\\frac{2k\\pi}{n}i}=\\cos\\frac{2k\\pi}{n}+i\\sin\\frac{2k\\pi}{n}证明：由$(a^x)^p=a^{xp}$结合欧拉公式即证得其为方程的根. 单位根的性质$1)\\omega^k_n=\\omega^{k\\%n}_n$ 证：$\\omega^k_n=\\cos\\dfrac{2k\\pi}{n}+i\\sin\\dfrac{2k\\pi}{n}=\\cos\\dfrac{2(k\\%n)\\pi}{n}+i\\sin\\dfrac{2(k\\%n)\\pi}{n}=\\omega^{k\\%n}_n$ 其中倒数第二步是当$k\\ge n$时，将$k$约去得到$k\\%n$. $2)\\omega^k_n=(\\omega^1_n)^k$ 证：$\\omega^k_n=e^{\\frac{2k\\pi}{n}i}=e^{\\frac{2\\pi}{n}i\\times k}=(e^{\\frac{2\\pi}{n}i})^k=(\\omega^1_n)^k$ $3)\\omega^0_n=1$ 证：$\\omega^0_n=\\cos0+i\\sin0=1+0i=1$ $4)\\omega^k_n\\times \\omega^j_n=\\omega^{k+j}_n$ 证：$\\omega^k_n\\times \\omega^j_n=(\\omega^1_n)^k\\times(\\omega^1_n)^j=(\\omega^1_n)^{k+j}=\\omega^{k+j}_n$ $5)\\omega^{pk}_{pn}=\\omega^k_n$ 证：$\\omega^{pk}_{pn}=e^{\\frac{2pk\\pi}{pn}i}=e^{\\frac{2k\\pi}{n}i}=\\omega^k_n$ $6)\\omega^{k+\\frac{n}{2}}_n=-\\omega^k_n$ 证：$\\omega^{k+\\frac{n}{2}}_n=\\omega^{\\frac{2k+n}{2}}_n=e^{\\frac{(2k+n)\\pi}{n}i}=e^{\\frac{2k\\pi}{n}i+\\pi i}=e^{\\frac{2k\\pi}{n}i}\\times e^{\\pi i}=-e^{\\frac{2k\\pi}{n}i}=-\\omega^k_n$ 回到多项式关于复数和单位根的性质已经说得够多了，现在把注意力放到多项式中. 前面有提到分治思想，现在我们来好好研究一下. 设多项式$F(x)=a_0x^0+a_1x^1+\\cdots+a_{n-1}x^{n-1}=\\sum^{n-1}_{i=0}a_ix^i$，则它可以唯一地表示成两个多项式的和.哪两个？请看： F(x)=\\sum^{n-1}_{i=0}a_ix^i=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{2i}+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{2i+1}即：按照次数的奇偶性将多项式$F$分成$L,R$两个部分. 那么，为什么要这么分？请继续向下看. 记 L(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{i} R(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{i}则 F(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{2i}+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{2i+1}=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}(x^2)^i+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}(x^2)^i\\times x=L(x^2)+xR(x^2)重头戏这里$F$是$(n-1)$次的多项式，需要$n$个点来确定. 将单位根$\\omega^k_n$代入 F(x)=L(x^2)+xR(x^2)得 F(\\omega^k_n)=L(\\omega^{2k}_n)+\\omega^k_nR(\\omega^{2k}_n)即 (1):\\qquad F(\\omega^k_n)=L(\\omega^{k}_{\\frac{n}{2}})+\\omega^k_nR(\\omega^{k}_{\\frac{n}{2}})则我们得到了$F(x)$在$\\omega^0_n,\\omega^1_n,\\cdots,\\omega^{\\frac n2-1}_n$这$\\dfrac n2$个点上的值. 那另外$\\dfrac n2$点上的值呢？ 将单位根$\\omega^{k+\\frac n2}_n$代入 F(x)=L(x^2)+xR(x^2)得 F(\\omega^k_n)=L(\\omega^{2k+n}_n)+\\omega^{k+\\frac n2}_nR(\\omega^{2k+n}_n)即 F(\\omega^k_n)=L(\\omega^{2k}_n)+\\omega^{k+\\frac n2}_nR(\\omega^{2k}_n)即 (2):\\qquad F(\\omega^k_n)=L(\\omega^{k}_{\\frac{n}{2}})-\\omega^k_nR(\\omega^{k}_{\\frac{n}{2}})则我们得到了$F(x)$在$\\omega^{\\frac n2}_n,\\omega^{\\frac n2+1}_n,\\cdots,\\omega^{n-1}_n$这另外$\\dfrac n2$个点上的值. 对比$(1)$和$(2)$，可以看出它们之间只差了一个正负号. 所以只要知道$L$和$R$在$\\omega^0_{\\frac n2},\\omega^1_{\\frac n2},\\cdots,\\omega^{\\frac n2-1}_{\\frac n2}$的值，就可以在$O(n)$的时间复杂度内唯一地确定$F$. 那么，如何求得$L$和$R$在这些点上的值呢？ 注意到：$L$和$R$都是$\\dfrac n2$项的多项式！ 分治所以，我们将规模为$n$的多项式求值问题分解成了规模为$\\dfrac n2$的子问题！ 递归地求解即可. 一个小细节：为了避免出现$2\\nmid n$的情况，我们强行向高位补零，补成一个具有$2^k$项的多项式. 综合运用这就是$\\mathsf{DFT}$：离散傅里叶变换！ 代码实现： void dft(comp *f,int len) { if(len==1)return ; comp *fL=f,*fR=f+len/2; for(int k=0;k&lt;len;k++)G[k]=f[k]; for(int k=0;k&lt;len/2;k++)L[k]=G[k&lt;&lt;1],R[k]=G[k&lt;&lt;1|1]; dft(L,len/2); dft(R,len/2); comp W(cos(2*pi/len),sin(2*pi/len)),b(1,0); for(int k=0;k&lt;len/2;k++) { G[k]=L[k]+b*R[k]; G[k+len/2]=L[k]-b*R[k]; b*=W; } for(int k=0;k&lt;len;k++)f[k]=G[k]; } 反过来设$G(z)=\\mathcal{F}[F(x)]$，则$F(x)=\\mathcal F^{-1}[G(z)]$. 其中$\\mathcal F$称作（离散）傅里叶变换，$\\mathcal F^{-1}$称作（离散）逆傅里叶变换，又称$\\mathsf{IDFT}$. $\\mathsf{I}:\\mathsf{Inversed}$ IDFT原理 结论： （$f_i,g_i$为$F,G$第$i$项的系数） nf_k=\\sum^{n-1}_{i=0}\\omega^{-ki}_ng_i负数次单位根？ 由定义知$\\omega^{-k}_n=(\\omega^{-1}_n)^k$ 那么$\\omega^{-1}_n=\\cos-\\dfrac{2\\pi}{n}+i\\sin-\\dfrac{2\\pi}{n}=\\cos\\dfrac{2\\pi}{n}-i\\sin\\dfrac{2\\pi}{n}$ 证明？诱导公式！ 优化将递归转换为循环，避免数组的拷贝，我们可以写出以下代码，这就是经典的快速傅里叶变换！ #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; const int N = 5100000, mod = 998244353; const double pi=acos(-1); int n,m; struct comp { comp (double _a=0,double _b=0){a=_a,b=_b;} double a,b; comp operator + (comp const &amp;B) const {return comp(a+B.a,b+B.b);} comp operator - (comp const &amp;B) const {return comp(a-B.a,b-B.b);} comp operator * (comp const &amp;B) const {return comp(a*B.a-b*B.b,a*B.b+b*B.a);} }F[N],G[N]; int t[N]; void fft(comp *f,bool flag) { for (int i=0;i&lt;n;i++) if (i&lt;t[i])swap(f[i],f[t[i]]); for(int p=2;p&lt;=n;p&lt;&lt;=1) { int len=p&gt;&gt;1; comp W(cos(2*pi/p),sin(2*pi/p)); if(!flag)W.b*=-1; for(int k=0;k&lt;n;k+=p) { comp b(1,0); for(int l=k;l&lt;k+len;l++) { comp temp=b*f[len+l]; f[len+l]=f[l]-temp; f[l]=f[l]+temp; b=b*W; } } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;F[i].a); for (int i=0;i&lt;=m;i++)scanf(&quot;%lf&quot;,&amp;F[i].b); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(int i=0;i&lt;n;i++)t[i]=(t[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); fft(F,1); for(int i=0;i&lt;n;++i)F[i]=F[i]*F[i]; fft(F,0); for(int i=0;i&lt;=m;++i)printf(&quot;%d &quot;,(int)(F[i].b/n/2+0.49)); return 0; } 三次变两次优化上面的代码中有体现 设$P=F+iG$ 则$P^2=F^2-G^2+2iFG$ 即，将输入当作一个多项式的实部和虚部，将其$\\mathsf{FFT}$后自乘，再$\\mathsf{IFFT}$回来，输出就是虚部除以$2$ 最终尝试$\\mathtt{Accepted!}$ 习题和拓展阅读#6393 快速数论变换 \\mathrm{END.}","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"数学","slug":"数学","permalink":"www.orchid-any.cf/tags/数学/"},{"name":"FFT","slug":"FFT","permalink":"www.orchid-any.cf/tags/FFT/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"「题解」洛谷P2000拯救世界","slug":"SOL-P2000","date":"2020-02-16T01:46:20.000Z","updated":"2020-02-18T10:15:27.508Z","comments":true,"path":"2020/02/16/SOL-P2000/","link":"","permalink":"www.orchid-any.cf/2020/02/16/SOL-P2000/","excerpt":"","text":"生成函数裸题。 把所有情况罗列出来: kkk: 金: $1+x^6+x^{12}+\\dots=\\frac{1}{1-x^6}$ 木: $1+x+x^2+\\dots+x^9=\\frac{1-x^{10}}{1-x}$ 水块: $1+x+x^2+\\dots+x^5=\\frac{1-x^6}{1-x}$ 火: $1+x^4+x^8+\\dots=\\frac{1}{1-x^4}$ 土: $1+x+x^2+\\dots+x^7=\\frac{1-x^8}{1-x}$ lzn: 金: $1+x^2+x^4+\\dots=\\frac{1}{1-x^2}$ 木: $1+x=\\frac{1-x^2}{1-x}$ 水: $1+x^8+x^{16}+\\dots=\\frac{1}{1-x^8}$ 火: $1+x^{10}+x^{20}+\\dots=\\frac{1}{1-x^{10}}$ 土: $1+x+x^2+x^3=\\frac{1-x^4}{1-x}$ 凉心出题人友好的卡了精度并且顺便卡了pypy。所以，人生苦短，Ruby用我 n = gets.to_i print (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"数学","slug":"数学","permalink":"www.orchid-any.cf/tags/数学/"},{"name":"生成函数","slug":"生成函数","permalink":"www.orchid-any.cf/tags/生成函数/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 91~100题","slug":"DS100P-91-100-P","date":"2020-02-08T06:03:45.000Z","updated":"2020-02-18T10:15:02.883Z","comments":true,"path":"2020/02/08/DS100P-91-100-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-91-100-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 81~90题","slug":"DS100P-81-90-P","date":"2020-02-08T06:03:43.000Z","updated":"2020-02-18T10:14:39.850Z","comments":true,"path":"2020/02/08/DS100P-81-90-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-81-90-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 71~80题","slug":"DS100P-71-80-P","date":"2020-02-08T06:03:41.000Z","updated":"2020-02-18T10:14:17.538Z","comments":true,"path":"2020/02/08/DS100P-71-80-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-71-80-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 61~70题","slug":"DS100P-61-70-P","date":"2020-02-08T06:03:39.000Z","updated":"2020-02-18T10:13:41.177Z","comments":true,"path":"2020/02/08/DS100P-61-70-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-61-70-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 51~60题","slug":"DS100P-51-60-P","date":"2020-02-08T06:03:37.000Z","updated":"2020-02-18T10:13:09.552Z","comments":true,"path":"2020/02/08/DS100P-51-60-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-51-60-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 41~50题","slug":"DS100P-41-50-P","date":"2020-02-08T06:03:35.000Z","updated":"2020-02-18T10:12:17.446Z","comments":true,"path":"2020/02/08/DS100P-41-50-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-41-50-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 31~40题","slug":"DS100P-31-40-P","date":"2020-02-08T06:03:33.000Z","updated":"2020-02-18T10:11:51.013Z","comments":true,"path":"2020/02/08/DS100P-31-40-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-31-40-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 21~30题","slug":"DS100P-21-30-P","date":"2020-02-08T06:03:31.000Z","updated":"2020-02-18T10:11:17.254Z","comments":true,"path":"2020/02/08/DS100P-21-30-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-21-30-P/","excerpt":"","text":"21.P4172 [WC2006]水管局长SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦），嘟嘟作为水管局长的工作就是：每天供水公司可能要将一定量的水从 $x$ 处送往 $y$ 处，嘟嘟需要为供水公司找到一条从 $A$ 至 $B$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。 在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。 不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。 这道题只有删边操作，我们可以把这个过程看做是加边操作，这样好处理一点。 题目保证了图无论怎么删边都保证联通，所以我们可以先把图删完。删完后我们呢求出图的MST, 那么任意两点在这颗MST上走都是最优的别问我怎么证贪心是用来证的吗。我们可以用LCT来维护这颗MST，Splay维护区间最大值(也就是链上的最大值) 考虑加边操作。上面我提到了一个贪心：任意两点在这颗MST上走都是最优的。如果此时我们在MST上任意加一条边都会形成一个环。我们可以从任意一点入环，任意一点出环，方向随意。可以发现我们的最优解始终能避开最长的一条边！ 考察这个环，用lct的split操作提出链的信息，查出最大的权值。发现我们可以通过删除权值最大的边来保证环上的最优。 怎么求出这条边呢？显然我们可以二分来找 再来考虑一个问题：如何维护边呢？ 考虑用一个点来表示一条边。 最后逆序加边，把答案逆序输出即可 (良心题解) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace LinkCutTree { const int SIZE = 12e4 + 5; struct SPLAY { int ch[2]; int fa; int key; int maxValue; int lazyTag; } T[SIZE]; stack &lt; int &gt; MemoryWaste; #define ls T[x].ch[0] #define rs T[x].ch[1] #define WhichSon(x) (T[T[x].fa].ch[1] == x) #define IsRoot(x) (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x) void UpdateMessage(int x) { T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue); } void UpdateSons(int x) { if (T[x].lazyTag) { ls ^= rs ^= ls ^= rs; T[x].lazyTag = 0; T[ls].lazyTag ^= 1; T[rs].lazyTag ^= 1; } } void RotateNode(int x) { int y = T[x].fa; if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x; bool k = WhichSon(x); T[x].fa = T[y].fa; T[y].fa = x; T[y].ch[k] = T[x].ch[k ^ 1]; T[T[y].ch[k]].fa = y; T[x].ch[k ^ 1] = y; UpdateMessage(y); UpdateMessage(x); } void LinkSplay(int x) { int u = x; while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa; MemoryWaste.push(u); while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop(); for (; !IsRoot(x); RotateNode(x)) { int y = T[x].fa; if (!IsRoot(y)) RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y); } } void AccessEdge(int x) { for (int u = x, y = 0; u; y = u, u = T[u].fa) { LinkSplay(u); T[u].ch[1] = y; UpdateMessage(u); } } void MakeRoot(int x) { AccessEdge(x); LinkSplay(x); T[x].lazyTag ^= 1; } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); } void LinkTree(int x, int y) { MakeRoot(x); T[x].fa = y; } void CutTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); T[x].fa = T[y].ch[0] = 0; } int FindByKey(int x, int u) { if (T[x].key == u) return x; else if (T[ls].maxValue == u) return FindByKey(ls, u); else return FindByKey(rs, u); } } // namespace LinkCutTree using namespace LinkCutTree; int F[1005][1005], U[101000], V[101000]; int OP[101000], ans[101000], n, m, QueryNumber; struct EdgeNode { int x, y; int val, key; EdgeNode() { key = 1; } friend bool operator &lt; (EdgeNode X, EdgeNode Y) { return X.val &lt; Y.val; } } e[101000]; struct UnionFindSet { int fa[1010]; int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { int u = find(x), v = find(y); if (u ^ v) fa[u] = v; } void init(int n, int m) { for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) { if (e[i].key &amp;&amp; find(e[i].x) ^ find(e[i].y)) { merge(e[i].x, e[i].y); LinkTree(e[i].x, n + i); LinkTree(e[i].y, n + i); } } } } ufs; signed main() { read(n, m, QueryNumber); for (int i = 1; i &lt;= m; ++i) read(e[i].x, e[i].y, e[i].val); sort(e + 1, e + 1 + m); for (int i = 1; i &lt;= m; ++i) { F[e[i].x][e[i].y] = i; F[e[i].y][e[i].x] = i; T[n + i].key = e[i].val; } for (int i = 1; i &lt;= QueryNumber; ++i) { read(OP[i], U[i], V[i]); if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0; } ufs.init(n, m); int EdgeCount = 0; for (int i = QueryNumber; i &gt;= 1; --i) { SplitTree(U[i], V[i]); if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue; else { int Temporary = FindByKey(V[i], T[V[i]].maxValue); if (T[F[U[i]][V[i]] + n].key &lt; T[V[i]].maxValue) { CutTree(e[Temporary - n].x, Temporary); CutTree(e[Temporary - n].y, Temporary); LinkTree(U[i], F[U[i]][V[i]] + n); LinkTree(V[i], F[U[i]][V[i]] + n); } } } for (int i = EdgeCount; i &gt;= 1; --i) write(io_l, ans[i]); return 0; } 22.P3302 [SDOI2013]森林小Z有一片森林，含有N个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有M条边。 小Z希望执行T个操作，操作有两类： Q x y k查询点x到点y路径上所有的权值中，第k小的权值是多少。此操作保证点x和点y连通，同时这两个节点的路径上至少有k个点。 L x y在点x和点y之间连接一条边。保证完成此操作后，仍然是一片森林。 为了体现程序的在线性，我们把输入数据进行了加密。设lastans为程序上一次输出的结果，初始的时候lastans为0。 对于一个输入的操作Q x y k,其真实操作为Q x^lastans y^lastans k^lastans。 对于一个输入的操作L x y，其真实操作为L x^lastans y^lastans。其中^运算符表示异或，等价于pascal中的xor运算符。 请写一个程序來帮助小Z完成这些操作。 查询操作显然可以用主席树来完成，然而连接树的操作又让我们想到了lct。怎么办呢？主席树+LCT？(据说还真有人这么干) 启发式合并！ 没错，我们用选择用主席树来完成这道题，合并时采用启发式合并。 具体来说就是每次合并时都用大小较小的树往大的合并，然后暴力遍历大小较小的树更新倍增数组和主席树即可 #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 9e4 + 5; const int LSIZE = SIZE &lt;&lt; 7; const int GSIZE = SIZE &lt;&lt; 1; int n, m, q, waste; int tot, rt[LSIZE], b[SIZE]; int pri_n, edge_tot, a[SIZE]; int Head[GSIZE], Next[GSIZE]; int Vertex[GSIZE], Weight[GSIZE]; int f[SIZE][LSIZE / SIZE &gt;&gt; 2]; int dp[SIZE], fa[SIZE], id[SIZE]; int size[SIZE], vis[SIZE]; struct TreeNode { int l, r; int size; } tr[LSIZE]; void add(int x, int y, int z = 1) { Vertex[++edge_tot] = y, Weight[edge_tot] = z; Next[edge_tot] = Head[x], Head[x] = edge_tot; } int find_set(int x) { return x == fa[x] ? x : fa[x] = find_set(fa[x]); } int make(int l, int r) { int u = ++tot; if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u; else return 0; } void modify(int &amp;u, int pre, int l, int r, int x) { u = ++tot; tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1}; if (l ^ r) if (mid &gt;= x) modify(tr[u].l, tr[pre].l, l, mid, x); else modify(tr[u].r, tr[pre].r, mid + 1, r, x); else return ; } int query(int x, int y, int lca, int fa_lca, int l, int r, int k) { if (l ^ r) if (_size_ &gt;= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k); else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_); else return l; } void dfs(int x, int _rt_) { for (int i = 1; i &lt; 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]); #define y Vertex[i] for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_); #undef y } int get_lca(int x, int y) { if (dp[x] &lt; dp[y]) x ^= y ^= x ^= y; for (int i = 16; i &gt;= 0; --i) if (f[x][i] &amp;&amp; dp[f[x][i]] &gt;= dp[y]) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } signed main() { read(waste, n, m, q); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); pri_n = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b; for (int i = 1, x, y; i &lt;= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1); *rt = make(1, pri_n); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i; int ans = 0, lastans = 0; for (int enum_q = 0; enum_q &lt; q; ++enum_q) { char opt[5]; int x, y, k, lca; read(opt), read(x, y); x ^= lastans, y ^= lastans; if (*opt == &#39;Q&#39;) read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]); else { add(x, y, 1); add(y, x, 1); int u = find_set(x); int v = find_set(y); if (size[u] &lt; size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v; f[y][0] = x; fa[y] = x; dp[y] = dp[x] + 1; vis[y] = true; size[u]++; dfs(y, v); } } return 0; } 23.P3250 [HNOI2016]网络一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。 由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种： 在某两个服务器之间出现一条新的数据交互请求； 某个数据交互结束请求； 某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。 你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。 提供 $\\Theta(n\\log^3n)$ 的暴力树剖打法。 本来我想搞树套树+树剖的，但发现Splay常数过大容易T爆，fhq-treap也炸了。 后来我幡然醒悟我们只需要开两个优先队列一个放添加的值，一个放删除的值。 碰到查询操作时先比较两个堆的堆顶，如果相同显然它被删掉了，两个栈同时弹出；不相同时添加元素队列的队首就是答案。 而且这道题开O2效果特别明显，2.x s 能变成 xxx ms! #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define CheckSize ((d[top[x]] &lt; d[top[y]]) &amp;&amp; (x ^= y ^= x ^= y)) #define ForGraph int i = Head[x], y = Vertex[i]; i; i = Next[i], y = Vertex[i] #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace HNOI2016_Network { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { const int SIZE = 2e5 + 5; const int GSIZE = SIZE &lt;&lt; 1; namespace SegmentTree { priority_queue &lt; int &gt; I[SIZE&lt;&lt;1], D[SIZE&lt;&lt;1]; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) void DoModify(int k, int l, int r, int x, int y, int val, int opt) { if (!(l &gt; y || r &lt; x)) if (l &gt;= x &amp;&amp; r &lt;= y) if (opt) I[k].push(val); else D[k].push(val); else DoModify(ls, l, mid, x, y, val, opt), DoModify(rs, mid + 1, r, x, y, val, opt); } int GetAnswer(int k, int l, int r, int x) { while (I[k].size() &amp;&amp; D[k].size() &amp;&amp; I[k].top() == D[k].top()) I[k].pop(), D[k].pop(); int res = I[k].size() ? I[k].top() : -1; if (l ^ r) if (mid &gt;= x) res = max(res, GetAnswer(ls, l, mid, x)); else res = max(res, GetAnswer(rs, mid + 1, r, x)); return res; } } // namespace SegmentTree namespace TreeChainSplitting { int tx[SIZE], ty[SIZE], tk[SIZE]; int Head[SIZE], Vertex[GSIZE]; int Next[GSIZE], EdgeCount; int fa[SIZE], size[SIZE]; int d[SIZE], son[SIZE]; int dfn[SIZE], rnk[SIZE]; int top[SIZE], tot; int edge_tot = 0, n, m; struct Vector2 { int x; int y; friend bool operator &lt; (Vector2 rhs1, Vector2 rhs2) { return rhs1.x &lt; rhs2.x; } } Vec2[SIZE]; void add(int x, int y) { Vertex[++edge_tot] = y; Next[edge_tot] = Head[x]; Head[x] = edge_tot; } void dfs1(int x, int fa) { size[x] = 1, TreeChainSplitting::fa[x] = fa, d[x] = d[fa] + 1; for (ForGraph) if (y ^ fa) dfs1(y, x), size[x] += size[y], ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)); } void dfs2(int x, int tp) { top[x] = tp, dfn[x] = ++tot, rnk[tot] = x; if (son[x]) dfs2(son[x], tp); for (ForGraph) if (y ^ fa[x] &amp;&amp; y ^ son[x]) dfs2(y, y); } void ModifySubTree(int x, int y, int val, int opt, int tp = 0) { while (top[x] ^ top[y]) CheckSize, Vec2[++tp] = {dfn[top[x]], dfn[x]}, x = fa[top[x]]; if (dfn[x] &gt; dfn[y]) x ^= y ^= x ^= y; Vec2[++tp] = {dfn[x], dfn[y]}; sort(Vec2 + 1, Vec2 + 1 + tp); int Sys = 1; for (int i = 1; i &lt;= tp; ++i) ((Sys &lt; Vec2[i].x) &amp;&amp; (SegmentTree::DoModify(1, 1, n, Sys, Vec2[i].x - 1, val, opt), 1)), Sys = Vec2[i].y + 1; if (Sys &lt;= n) SegmentTree::DoModify(1, 1, n, Sys, n, val, opt); } void main() { read(n, m); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); dfs1(1, 0), dfs2(1, 1); for (int i = 1, x, y, k, t, opt; i &lt;= m; ++i) { read(opt); if (opt == 0) read(x, y, k), ModifySubTree(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k; else if (opt == 1) read(t), ModifySubTree(tx[t], ty[t], tk[t], 0); else if (opt == 2) read(x), write(io_l, SegmentTree::GetAnswer(1, 1, n, dfn[x])); } } } // namespace TreeChainSplittin } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace HNOI2016_Network signed main() { HNOI2016_Network::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::TreeChainSplitting::main(); } 24.P4211 [LNOI2014]LCA给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。有q次询问，每次询问给出l r z，求$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$ 问题可以转化为求点到根的距离+1，询问l到r的结点到根的距离和。 这相当于是在求结点到根的点权+1的和。 那么该怎么办呢？ 显然我们可以离线得到所有的询问，然后将差分询问，也就是查询 $[1,r]-[1,l-1]$ 我们可以在l-1和r处打标记，然后遍历树的结点有标记就执行查询操作。 方便起见我们可以用树链剖分来维护，时间复杂度n乘上一个Log方n。 (对了我的代码特别玄学，查询部分循环版本在luogu上T了，在lojA了，递归版本在luoguA了，在lojT了！) (我对这份代码除了缓缓地打出一个问号也不能说什么了) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define IT vector &lt; int &gt;::iterator #define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i] #define CheckSize ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define TCS TreeChainSplitting #define CFS ChainForwardStar #define PS ProblemSolver #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e4 + 5; namespace ChainForwardStar { const int SIZE = ::SIZE; int tot_, Vert[SIZE]; int Head[SIZE], Next[SIZE]; void AddLine(int x, int y) { Vert[++tot_] = y; Next[tot_] = Head[x]; Head[x] = tot_; } } // namespace ChainForwardStar using CFS::Head; using CFS::Vert; using CFS::Next; using CFS::AddLine; namespace TreeChainSplitting { const int SIZE = ::SIZE; const int MOD = 201314; int n, m, tot, d[SIZE]; int fa[SIZE], size[SIZE]; int son[SIZE], top[SIZE]; int dfn[SIZE], rnk[SIZE]; int ask[SIZE], ans[SIZE]; vector &lt; int &gt; GFY[SIZE]; vector &lt; int &gt; FI[SIZE]; int sum[SIZE &lt;&lt; 2], lf[SIZE &lt;&lt; 2]; void Prepare(int x) { size[x] = 1, d[x] = d[fa[x]] + 1; for (ForGraph) Prepare(y), size[x] += size[y], CheckSize; } void Prepare(int x, int tp) { rnk[dfn[x] = ++tot] = x, top[x] = tp; if (son[x]) Prepare(son[x], tp); for (ForGraph) if (y ^ son[x]) Prepare(y, y); } #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define L_RECUR ls, l, mid, x, y #define R_RECUR rs, mid + 1, r, x, y #define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD, \\ sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k], \\ lf[rs] += lf[k], lf[k] = 0 #define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD void ModifyChain(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k]; else { UpdateSons(k, l, r); if (mid &gt;= x) ModifyChain(L_RECUR); if (mid &lt; y) ModifyChain(R_RECUR); UpdateMessages(k); } } void ModifySubTree(int x) { if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]); } int QueryChain(int k, int l, int r, int x, int y, int res = 0) { if (l &gt;= x &amp;&amp; r &lt;= y) return sum[k]; UpdateSons(k, l, r); if (mid &gt;= x) res += QueryChain(L_RECUR, 0); if (mid &lt; y) res += QueryChain(R_RECUR, 0); return res; } int QuerySubTree(int x, int res = 0) { // luogu-only if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res; } // int QuerySubTree(int x, int res = 0) { // loj-only // while (x) { // res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]); // x = fa[top[x]]; // } // return res; // } } // namespace TreeChainSplitting namespace ProblemSolver { void main() { read(TCS::n), read(TCS::m); for (int i = 2; i &lt;= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i); TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1); int L, R; for (int i = 1; i &lt;= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i]; for (int i = 1; i &lt;= TCS::n; ++i) { TCS::ModifySubTree(i); for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]); for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]); } for (int i = 1; i &lt;= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD); } } // namespace ProblemSover signed main() { PS::main(); } 25.「2018 集训队互测 Day 3」北校门外的未来前言这道题绝对是我目前来说做题用时最长的一道题（总共花了我五天时间左右） 说一下我这几天的心路历程吧： Day1:嗯？我好像发现了一道有趣的题目？洛谷上好像没有。。算了，做一下试试。。。 Day2:cow，这道题是道什么题？口胡一下LCT？算了算了看看题解。。。笛卡尔树是什么？？学吧学吧。。。 Day3：上半天：cow学不动了。。。更一下博客吧(广告位)；下半天：继续吧。。。 Day4:上半天：好像有点想法了。。。完善一下。。找找锅。。；下半天(确切的说是晚上。。)：开始码咯！ Day5：上半天：调了5个小时后过了；下半天：写写题解咯 正文Description 如果你不想阅读故事，请直接跳到题意部分。 转眼间，已是三年流转。 夏日法桐的绿荫，代替了秋季的萧索，衬托着 LCR 和神犇成长的背影。 身后的北校门，也不再是当年学生试图摧毁的，束缚自由的枷锁，而成了青春记忆的符号。 又到了神犇和 LCR 相遇的地方 —— 北校门外的树下。这棵神奇的树早已不是 K 项树的形态。每时每刻，它都以新的独特方式演绎着生命。 谁也没有开口，他和她静静地注视着魔法般生长的自然种子。初始时，这棵树只有一个点，LCR 将其标号为 $1$。此后，每过一段时间，就会有一个新节点从原有的某个点出生长出来，LCR 会给它分配一个尚未使用过的不超过 $n$ 的正整数编号。 树中生活着一些小精灵。它们总停留在节点上，如果一个精灵在编号 $u$ 的节点，那么它可以一步跳到任何编号 $v$ 的满足 $u,v$ 之间的简单路径上不存在异于 $u,v$ 的编号大于 $\\min(u,v)$ 的点处。 在观察这棵树的过程中，LCR 产生了一些疑问。她想知道，对于一对节点编号 $u,v$，从节点 $u$ 跳到节点 $v$ 最少需要几步。 神犇轻松地解决了这些问题。最终，树渐渐停止了生长，但神犇仍然陶醉其中。 一只飘渺的手搭上了神犇的肩膀。他回过头，看到 LCR 正在微笑。 “亲爱的少年，神犇君。” “你是否想过，为什么精灵会依照我编号的法则而运动呢？” 神犇一时语塞。瞬间，LCR 的手变得虚幻了起来，如同明灭的火炬。 “你的成长，是这变化世界的一个切面。感谢你与我度过的时光。不要留恋 …… 我的随风飘散，正是与你们同在。” “再见了，神犇君。” LCR 消失了，神犇机械地转过身，却发现背后的树也已消失无踪。 “神犇，神犇 ……” 茫然若失的神犇背后传来了渐行渐近的呼叫。神犇转过身，发现机房里的蒟蒻 LCA 正向他跑来。 “又是一年毕业季了呢。学长你还好吗？” “也许吧。” 神犇望向校门外的树原先的位置，“LCR 走了，但她的背影会吸引着我们的人生。” LCA 沉默了。他和神犇一同望向树消失的地方，持续片刻。 “所谓中二的幻想，才是我们相对的有限的主观能动性唯一的立场吧，不要给自己设限啊，LCA。我们去追寻她 …… 追寻自然的精灵。也许这就是我们的初心也说不定。” 这次是 LCA 目送神犇的背影渐行渐远了。 “再见了，学长。” 某少女附中，又迎来了新的一年。 那么，你能够回答 LCR 提出的问题吗？ 题意对于一棵树 $T=(V,E)$，$V$ 中每个点有一个互不相同的正整数标号。我们用点 $i$ 表示编号为 $i$ 的点。 定义这棵树的谷图为 $G(T)=(V,E’)$。$G(T)$ 是无向简单图。存在边 $(u,v)\\in E’$ 当且仅当在 $T$ 中，不存在一个异于 $u,v$ 的点 $x$ 满足 $x$ 在从 $u$ 到 $v$ 的简单路径上且其编号大于 $\\min(u,v)$。 有一棵树 $T$，初始时只有一个点，编号为 $1$，接下来有 $q$ 次操作，操作有以下两种： $\\texttt{1 u v}$ 表示加入一个编号为 $v$ 的节点并与当前编号为 $u$ 的节点相连（保证任何时刻不会有两个编号相同的节点）； $\\texttt{2 u v}$ 表示查询 $G(T)$ 中点 $u$ 到 $v$ 的最短路（每条边长度均为 $1$）。 请你回答所有查询。 题目好长咳咳咳。。。（最关键的是我读完过后重读一遍发现背景与题目无关。。。靠! 不扯了说正事儿。。。 动态问题其实很烦人对吧？这里我们可以假设原问题为静态问题。 静态问题就很好处理对吧？都是显然做法。那么问题又回到动态问题，对于加点操作，事实上我的做法十分**，利用Splay的性质乱搞。打出了一个像模拟一样的东西 其实我也不太清楚我是怎么过的。。。因为我的做法很玄学+暴力，所以。。。大家意会一下。 如果实在要看题解的话，我这里有一篇，不过估计也没人能看懂，反正你看了就知道了。至于其他的题解想都别想了我翻墙去隔壁Google都没找到，基本上是找不道的。。。Link 放个代码，大家意会一下。。。(404行好评) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define SIZE_CHECKER ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; vector &lt; vector &lt; int &gt; &gt; G(SIZE); int n, m, st[SIZE], tp, F[SIZE]; int _time[SIZE], _down[SIZE]; int OP[SIZE], U[SIZE], V[SIZE]; void init(int n) { for (int i = 1; i &lt;= n; ++i) F[i] = i; } int find(int x) { if (x ^ F[x]) F[x] = find(F[x]); return F[x]; } namespace CartesianTree { vector &lt; vector &lt; int &gt; &gt; GCT(SIZE); int son[SIZE], fa[SIZE]; int top[SIZE], size[SIZE]; int low[SIZE], d[SIZE]; int tot, ls[SIZE], rs[SIZE]; void Prepare1(int x) { while (_time[st[tp]] &gt; _time[x] &amp;&amp; tp) _down[st[tp--]] = x; st[++tp] = x; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto y : GCT[x]) Prepare1((fa[y] = x, y)), size[x] += size[y], SIZE_CHECKER; } void Prepare2(int x) { ls[x] = ++tot; if (!top[x]) top[x] = x; if (!son[x]) return (void)(rs[x] = tot); top[son[x]] = top[x]; for (auto y : GCT[x]) Prepare2(y); rs[x] = tot; } int GetLCA(int x, int y) { while (top[x] ^ top[y]) d[top[x]] &gt; d[top[y]] ? x = fa[top[x]] : y = fa[top[y]]; return d[x] &lt; d[y] ? x : y; } int Behavior(int x, int y) { while (top[x] ^ top[y]) if (fa[x = top[x]] ^ y) x = fa[x]; else return x; return son[y]; } bool FindRule(int x, int y) { return ls[x] &lt; ls[y]; } bool CheckForFun(int x, int y) { int std = *(upper_bound(GCT[y].begin(), GCT[y].end(), x, FindRule) - 1); return !(ls[low[std]] &gt; rs[x] || ls[x] &gt; ls[low[std]]); } void Main() { init(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; find(j)) GCT[i].pub(find(j)), F[find(j)] = i; Prepare1(n), Prepare2(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; j) low[Behavior(j, i)] = j; } } // namespace CartesianTree #define CT CartesianTree namespace LinkCutTree { struct SPLAY { int ch[2]; int fa; int sum; int key; } data[SIZE]; int next[SIZE], root[SIZE]; #define WhichSon(x) (data[data[x].fa].ch[1] == x) void UpdateMessages(int x) { data[x].sum = data[data[x].ch[0]].sum + data[data[x].ch[1]].sum + data[x].key; } void RotateNode(int x) { int y = data[x].fa, z = data[y].fa; int k = WhichSon(x); if (root[y]) root[y] = 0, root[x] = root[y] ^ 1; else data[z].ch[data[z].ch[1] == y] = x; data[x].fa = data[y].fa; data[y].ch[k] = data[x].ch[k ^ 1]; if (data[y].ch[k]) data[data[x].ch[k ^ 1]].fa = y; data[x].ch[k ^ 1] = y; data[y].fa = x; UpdateMessages(y), UpdateMessages(x); } void SplayToRoot(int x) { for (int y; !root[x]; RotateNode(x)) if (!root[y = data[x].fa]) RotateNode(data[data[y].fa].ch[0] ^ y ^ data[y].ch[0] ^ x ? x : y); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); if (data[x].ch[1]) root[data[x].ch[1]] = 1; if (data[x].ch[1] = y) root[y] = 0; UpdateMessages(x); } } void Behavior(int u, int v) { if (u &gt; v) { F[v] = u; data[v].fa = u; data[v].key = 1; data[v].sum = 1; return ; } int x = _down[v], rhs = u; SplayToRoot(x); int rsp = 0, cpy = 0, now = data[x].ch[0]; if (now) { while (data[now].ch[1]) now = data[now].ch[1]; SplayToRoot(now); while (data[x].fa ^ now) RotateNode(x); root[x] = 1; data[now].ch[1] = 0; UpdateMessages(now); } now = data[x].fa; if (next[now] == x) next[now] = v; data[v].key = data[v].sum = data[x].key; if (now) next[v] = x; SplayToRoot(x); data[x].fa = v; data[v].fa = now; data[x].key = 0; UpdateMessages(x); while (u) { SplayToRoot(u); if (data[u].ch[1]) root[data[u].ch[1]] = 1; data[u].ch[1] = rsp; if (data[u].ch[1]) root[rsp] = 0; UpdateMessages(u); if (data[u].sum) { x = u; while (233) if (data[x].ch[1] &amp;&amp; data[data[x].ch[1]].sum) x = data[x].ch[1]; else if (!data[x].key) x = data[x].ch[0]; else break; SplayToRoot(x); if (x &gt;= v) break; u = data[x].ch[0]; if (u) { while (data[u].ch[1]) u = data[u].ch[1]; SplayToRoot(u); data[u].ch[1] = 0; root[x] = 1; UpdateMessages(u); } else u = data[x].fa; if (u &gt;= v) break; SplayToRoot(rhs); if (now = data[rhs].ch[1]) root[now] = 1, data[rhs].ch[1] = 0; if (now = next[rhs]) { SplayToRoot(now); data[now].fa = u; data[now].key = 1; UpdateMessages(now); next[rhs] = 0; } u = F[x]; rhs = F[x]; data[x].key = 0; UpdateMessages(x); SplayToRoot(x); while (data[x].ch[1]) x = data[x].ch[1]; SplayToRoot(x); data[x].ch[1] = cpy; if (data[x].ch[1]) { data[cpy].fa = x, root[cpy] = 0, data[x].ch[1] = cpy; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(x); cpy = x; rsp = 0; } else rsp = u, u = data[u].fa; } F[v] = F[_down[v]]; F[_down[v]] = v; if (!F[v]) { SplayToRoot(v); x = v; while (data[x].ch[1]) x = data[x].ch[1]; if (cpy) { data[x].ch[1] = cpy; root[cpy] = 0; data[cpy].fa = x; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(v); x = data[v].ch[1]; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); } else if (cpy) { x = cpy; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); data[x].fa = v; } } pii GetDis(int x, int t) { if (x ^ t) { AccessEdge(x); SplayToRoot(x); int st = x; int fir = 0, sec = 0; while (x) if (x &lt; t) sec = x, x = data[x].ch[0]; else x = data[x].ch[1]; SplayToRoot(sec); x = data[sec].ch[1]; fir = data[x].sum; if (!fir) return mp(0, st); while (233) { if (data[data[x].ch[0]].sum) x = data[x].ch[0]; else if (!data[x].key) sec = x, x = data[x].ch[1]; else { if (data[x].ch[0]) { x = data[x].ch[0]; while (data[x].ch[1]) x = data[x].ch[1]; sec = x; } break; } } return mp(fir, sec); } else return mp(0, x); } int GetAnswers(int x, int y) { if (x ^ y) { if (x &gt; y) x ^= y ^= x ^= y; int sys = CT::GetLCA(x, y); if (sys ^ y) { pii t1 = GetDis(x, sys); pii t2 = GetDis(y, sys); return t1.fir + t2.fir + ((CT::CheckForFun(t1.sec, sys) &amp;&amp; CT::CheckForFun(t2.sec, sys)) ^ 1) + 2; } else { pii t = GetDis(x, sys); return t.fir + (CT::CheckForFun(t.sec, sys) ^ 1) + 1; } } else return 0; } } // namespace LinkCutTree #define LCT LinkCutTree namespace SOLVER { void Main() { read(m), read(m); n = 1; for (int i = 1; i &lt;= m; ++i) { read(OP[i], U[i], V[i]); if (OP[i] ^ 1) continue; G[U[i]].pub(V[i]); G[V[i]].pub(U[i]); _time[V[i]] = i; n = max(n, V[i]); } for (int i = 1; i &lt;= n; ++i) LCT::root[i] = true; CT::Main(); F[1] = 0; for (int i = 1; i &lt;= m; ++i) { if (OP[i] ^ 2) LCT::Behavior(U[i], V[i]); else write(io_l, LCT::GetAnswers(U[i], V[i])); } } } signed main() { SOLVER::Main(); } 26.P1121 环状最大两段子段和给出一段环状序列，即认为$A_1$和$A_N$是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。 一共三个关键词: 环状 最大 两段子段和 显然这是一道DP题。。。然而我们可以把它搞成线段树! 普通的最大子段和相信大家都能够用线段树来完成。 无非就是记录区间和、区间最大子段和、区间最大前缀和、区间最大后缀和 然后合并时更新信息即可 那么两段子段和该怎么搞呢? 其实也不费脑子废笔 首先套路的讨论这两段的位置，我们可以发现有5种情况（画画图示意一下可能很丑反正意思你们能懂就行 总结出来我们需要在线段树里维护的东西有： 区间和 区间最大前缀 区间最大后缀 区间最大子段和 区间最大前缀+后缀 区间最大中间+后缀 区间最大前缀+中间 区间两段最大子段和 每行长度不下降看着还是很爽的。。。 具体实现看代码中的注释 // 省略快读和一堆预处理命令 const int SIZE = 4e5 + 5; const int INF = ~0U &gt;&gt; 1; struct TreeNode { // 这里的意思应该很明确 int sum; int maxSum; int maxSumDouble; int maxPrefixSum; int maxSuffixSum; int maxPrePlusSuf; int maxPrePlusMid; int maxSufPlusMid; } data[SIZE&lt;&lt;2]; int ints[SIZE&lt;&lt;1], ans = -INF, n; TreeNode UpdateMessages(TreeNode x, TreeNode y) { // 这是重点 TreeNode res; res.sum = x.sum + y.sum; // 区间和标记上传 res.maxSum = max(x.maxSum, y.maxSum); // // 区间最大子段和标记上传 res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // 再把自己和两个儿子的最大前/后缀和的和比较 res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // 其实下面都差不多 res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // 实在不懂看上面的图 res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // 看了就明白了。。。 res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf); res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum); res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid); res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum); res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum); res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble); res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid); return res; } void Initialization(int k, int l) { // 给线段树结点赋初值 data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l]; data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF; } void BuildTree(int k, int l, int r) { if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]); else Initialization(k, l); } TreeNode GetAnswers(int k, int l, int r, int x, int y) { if (l ^ x || r ^ y) { if (mid &gt;= y) return GetAnswers(ls, l, mid, x, y); if (mid &lt; x) return GetAnswers(rs, mid + 1, r, x, y); return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y)); } else return data[k]; } signed main() { read(n); for (int i = 1; i &lt;= n; ++i) read(ints[i]), ints[i + n] = ints[i]; BuildTree(1, 1, n &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) ans = max(ans, GetAnswers(1, 1, n &lt;&lt; 1, i, i + n - 1).maxSumDouble); write(io_l, ans); } 27.【中午的题目】分糖果小 Z 带着新买的糖果来拜访舅舅家，舅舅家的 $K$ 个孩子看见小 Z 带着糖果来拜访变得欣喜若狂，他们都希望吃到好吃的糖果。正当小 Z 准备给 $K$ 个孩子分糖果时，舅舅却让小 Z 尽量少分点，免得孩子们蛀牙。 小 Z 带来的糖果比较特别，一共有 $N$ 个糖果连成一串，编号为 $1\\ldots N$，第 $i$ 个糖果有一个数值 $a[i]$ 表示蛀牙的可能性，数值越大的糖果越容易导致蛀牙，多个糖果的蛀牙值认为是各个糖果的蛀牙值之和。 现在小 Z 打算取 $N$ 个糖果的前若干个，分成 $K$ 段分给 $K$ 个孩子。小 Z 好奇，他该怎么分糖果，才能使得分到糖果蛀牙值最大的孩子尽可能不蛀牙 首先暴力做法显然。 首先前缀和然后对前缀和离散化 二分答案然后check里面dp，$dp_i$ 为区间 $[1,i]$ 最多能分成的块数。 dp方程显然为 $dp_i=max{dp_j}+1$。 这样转移是 $\\Theta(n^2)$ 的，显然T飞。 考虑树状数组优化，需要区间最大值和单点修改操作。 时间复杂度 $\\Theta(n\\log^2n)$ #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; __int64 , __int64 &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const __int64 SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; __int64 fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register __int64 i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const __int64 SIZE = 1e6 + 5; const __int64 INF = 0x7fffffff; __int64 a[SIZE], bit[SIZE]; __int64 dp[SIZE], n, k, T; vector &lt; __int64 &gt; disc; void add(__int64 x, __int64 y) { for (; x &gt; 0; x -= x &amp; -x) bit[x] = max(bit[x], y); } __int64 ask(__int64 x, __int64 lim, __int64 res = -INF) { for (; x &lt; lim; x += x &amp; -x) res = max(res, bit[x]); return res; } void Discretization(__int64 x) { disc.clear(); disc.pb(0); for (__int64 i = 1; i &lt;= n; ++i) disc.pb(a[i]); sort(disc.begin(), disc.end()); disc.erase(unique(disc.begin(), disc.end()), disc.end()); } bool Check(__int64 x) { Discretization(x); for (__int64 i = 1; i &lt;= (__int64)disc.size(); ++i) { for (__int64 j = i; j &lt; (__int64)disc.size(); j += j &amp; -j) bit[i] = -INF; for (__int64 j = i; j &gt; 0; j -= j &amp; -j) bit[i] = -INF; } *dp = 0; add(lower_bound(disc.begin(), disc.end(), 0) - disc.begin() + 1, *dp); for (__int64 i = 1; i &lt;= n; ++i) { dp[i] = ask(lower_bound(disc.begin(), disc.end(), a[i] - x) - disc.begin() + 1, disc.size() + 1) + 1; add(lower_bound(disc.begin(), disc.end(), a[i]) - disc.begin() + 1, dp[i]); if (k &lt;= dp[i]) return 1; } return 0; } signed main() { for (read(T); T; --T) { read(n, k); for (__int64 i = 1; i &lt;= n; ++i) read(a[i]), a[i] += a[i - 1]; __int64 l = -INF * SIZE, r = SIZE * INF; while (l &lt; r - 1) if (Check(mid)) r = mid; else l = mid; write(io_l, r); } return 0; } 28.P2163 [SHOI2007]园丁的烦恼很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。 有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……” “那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。 “嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……” “是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。 “该死的，你究竟是什么来头？” “陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。 看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。 这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。 。。。居然没有看到主席树题解。 这差不多就是一道主席树的板题了。 首先对x排序，然后动态开点一个一个的insert进去。 对于询问直接就二分取出横轴的范围l和r 然后询问root[r]-root[l-1]就好了 #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (data[rt].l) #define rs (data[rt].r) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; int , int &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; const int INF = 1e7; int n, m, tot, rt[SIZE]; struct TreeNode { int l, r; int sum; } data[SIZE &lt;&lt; 5]; struct TwoNode { int x, y; } ints[SIZE]; struct BinarySeach { int upper_bound(int x) { int l = 1, r = n + 1; while (l &lt; r - 1) if (ints[mid].x &gt; x) r = mid; else l = mid; return l; } int lower_bound(int x) { int l = 0, r = n; while (l &lt; r - 1) if (ints[mid].x &gt;= x) r = mid; else l = mid; return r; } } BS; bool cmp(const TwoNode&amp; x, const TwoNode&amp; y) { return x.x &lt; y.x; } void update(int &amp;rt, int l, int r, int x) { data[++tot] = data[rt]; ++data[rt = tot].sum; if (l ^ r) if (mid &gt;= x) update(ls, l, mid, x); else update(rs, mid + 1, r, x); else return ; } int queryf(int rt, int l, int r, int x, int y) { if (l &gt; y || r &lt; x || !rt) return 0; else if (l &gt;= x &amp;&amp; r &lt;= y) return data[rt].sum; else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y); } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i].x, ints[i].y); sort(ints + 1, ints + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) update(rt[i] = rt[i - 1], 0, INF, ints[i].y); for (int i = 1, a, b, c, d; i &lt;= m; ++i) { read(a, b, c, d); write(io_l, queryf(rt[BS.upper_bound(c)], 0, INF, b, d) - queryf(rt[BS.lower_bound(a) - 1], 0, INF, b, d)); } return 0; } 29.P5220 特工的信息流$\\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。以及，每个城市都有一个信息流的流量 $a_i$。 $\\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。 请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。 此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。 他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。 WGY：LCT这道题的题意是真的绕，我前前后后读了不下五遍才大概意会。。。 做数据结构的题一般都要先浓缩题意。这道题是让我们求后缀积之和，再加上修改操作就基本上确定用LCT了 需要维护的信息有前缀积之和,后缀积之和，区间乘法三个信息。 对于修改操作，直接上LCT的套路makeroot和access。 对于询问操作，我们直接按照LCT的套路用makeroot和access把链给搞出来。 其实这就相当于一道LCT的板题吧。。。全部都是基础操作。。。 完整代码在这里Link 如果链接失效了就这个Link const int SIZE = 1e5 + 5; const int M_SIZE = 2e5 + 5; const int MOD = 20924; int head[M_SIZE], nxt[M_SIZE]; int to[M_SIZE], ints[SIZE]; int waste[SIZE], n, m, top, tot; struct SPLAY { int fa; int ch[2]; int prod; int preprod; int sufprod; int lztg; } data[SIZE]; void AddEdge(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } bool IsRoot(int x) { return ((data[data[x].fa].ch[1] ^ x) &amp;&amp; (data[data[x].fa].ch[0] ^ x)); } bool WhichSon(int x) { return (data[data[x].fa].ch[1] == x); } void UpdateMessages(int x) { data[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD; data[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD; data[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD; } void UpdateSons(int x) { if (data[x].lztg) { swap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]); swap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]); swap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod); swap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod); data[data[x].ch[0]].lztg ^= 1; data[data[x].ch[1]].lztg ^= 1; data[x].lztg = 0; } } void RotateNode(int x) { int y = data[x].fa; int z = data[y].fa; int k = WhichSon(x); if (!IsRoot(y)) data[z].ch[WhichSon(y)] = x; data[y].fa = x; data[data[y].fa].fa = z; if (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y; data[y].ch[k] = data[x].ch[k ^ 1]; data[x].ch[k ^ 1] = y; UpdateMessages(y); } void SplayToRoot(int x) { int y = waste[top = 1] = x; while (!IsRoot(y)) waste[++top] = y = data[y].fa; while (top) UpdateSons(waste[top--]); for (; !IsRoot(x); RotateNode(x)) if (!IsRoot((y = data[x].fa))) RotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y); UpdateMessages(x); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); data[x].ch[1] = y; UpdateMessages(x); } } void MakeRoot(int x) { AccessEdge(x); SplayToRoot(x); swap(data[x].ch[0], data[x].ch[1]); swap(data[x].preprod, data[x].sufprod); data[x].lztg ^= 1; UpdateMessages(x); } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); SplayToRoot(y); } void Prepare(int x) { data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; for (int i = head[x]; i; i = nxt[i]) if (to[i] ^ data[x].fa) data[to[i]].fa = x, Prepare(to[i]); } int GetAnswers(int x, int y) { SplitTree(x, y); UpdateSons(y); return data[y].sufprod; } void Behavior(int x, int y) { SplitTree(x, x); ints[x] += y; ints[x] %= MOD; data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i]); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x); (*data).prod = 1; Prepare(1); for (int i = 0, x, y; i &lt; m; ++i) { char opt[5]; read(opt); read(x, y); if (*opt ^ &#39;C&#39;) write(io_l, GetAnswers(x, y)); else Behavior(x, y); } return 0; } LYC:TCS","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 11~20题","slug":"DS100P-11-20-P","date":"2020-02-08T06:03:29.000Z","updated":"2020-02-18T10:10:34.914Z","comments":true,"path":"2020/02/08/DS100P-11-20-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-11-20-P/","excerpt":"","text":"11.P3203 [HNOI2010]弹飞绵羊某天，$Lostmonkey$ 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。 游戏一开始，$Lostmonkey$ 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。 绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，$Lostmonkey$ 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 每个弹力装置只会对应一个位置可以弹到，也就是说我们可以把它看作一条边，而且不会有环这种**玩意。 对于修改弹力系数，我们可以用断边连边来维护 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = 2e5 + 5; class LinkCutTree { public: struct SPLAY { int val; int fa; int ch[2]; } T[SIZE]; inline bool isroot(int x) { return !(T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline void push(int x) { T[x].val = T[T[x].ch[0]].val + T[T[x].ch[1]].val + 1; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, k = T[y].ch[1] == x, w = T[x].ch[!k]; (isroot(y)) &amp;&amp; (T[z].ch[T[z].ch[1] == y] = x); T[x].ch[!k] = y, T[y].ch[k] = w; (w) &amp;&amp; (T[w].fa = y); T[y].fa = x; T[x].fa = z; push(y); } inline void splay(int x) { for(; isroot(x); rotate(x)) { int y = T[x].fa, z = T[y].fa; (isroot(y)) &amp;&amp; (rotate(T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? x : y), 1); } push(x); } inline void access(int x) { for(int y = 0; x; x = T[y = x].fa) splay(x), T[x].ch[1] = y, push(x); } } lct_mast; int n, m; signed main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1, s; i &lt;= n; ++i) { lct_mast.T[i].val = 1; scanf(&quot;%d&quot;, &amp;s); (i + s &lt;= n) &amp;&amp; (lct_mast.T[i].fa = i + s); } for(scanf(&quot;%d&quot;, &amp;m); m; --m) { int opt, x, y; scanf(&quot;%d&quot;, &amp;opt), scanf(&quot;%d&quot;, &amp;x); if (opt ^ 2) { lct_mast.access(x + 1); lct_mast.splay(x + 1); printf(&quot;%d\\n&quot;, lct_mast.T[x + 1].val); } else { scanf(&quot;%d&quot;, &amp;y); lct_mast.access(x + 1); lct_mast.splay(x + 1); lct_mast.T[x + 1].ch[0] = lct_mast.T[lct_mast.T[x + 1].ch[0]].fa = 0; (x + y + 1 &lt;= n) &amp;&amp; (lct_mast.T[x + 1].fa = x + y + 1); lct_mast.push(x + 1); } } return 0; } 12.SP4487 GSS6 - Can you answer these queries VIThe first line of the input contains an integer N.The following line contains N integers, representing the startingsequence A1..AN, _(|Ai| &lt;= 10000)_. The third line contains an integer Q. The next Q lines contains the operations in following form: I x y: insert element y at position x _(between x - 1 and x)_.D x : delete the element at position x.R x y: replace element at position x with y.Q x y: print max{Ai + Ai+1 + .. + Aj | x &lt;= i &lt;= j &lt;= y}. All given positions are valid, and given values are between -10000 and +10000. The sequence will never be empty. 这道题显然是一道平衡树的裸题，唯一的难度就是求最大子段和。 可以类比线段树维护最大子段和，维护$lmax$以x为根的前缀最大和、$rmax$以x为根的后缀最大和、$maxsum$最大子段和以及$sum$总和 对于$Update$我们可以对是否有左右孩子做讨论。 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; using namespace std; const int SIZE = 2e5 + 5; int n, m, tot, root, a[SIZE]; struct SPLAY { int fa; int ch[2]; int siz; int val; int sum; int lmax; int rmax; int maxsum; } T[SIZE]; vector &lt; int &gt; st; inline int newnode(int v = 0) { int x; if (st.empty()) x = ++tot; else x = st.back(), st.pop_back(); T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].siz = 1; T[x].val = T[x].sum = T[x].maxsum = v; T[x].lmax = T[x].rmax = max(v, 0); return x; } inline void delnode(int x) { T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].sum = T[x].lmax = T[x].rmax = T[x].maxsum = 0; T[x].siz = 1; st.push_back(x); } inline bool which(int x) { if (T[T[x].fa].ch[0] == x) return 0; if (T[T[x].fa].ch[1] == x) return 1; return -1; } inline void update(int x) { T[x].sum = T[x].val; T[x].siz = 1; if (T[x].ch[0]) T[x].sum += T[T[x].ch[0]].sum, T[x].siz += T[T[x].ch[0]].siz; if (T[x].ch[1]) T[x].sum += T[T[x].ch[1]].sum, T[x].siz += T[T[x].ch[1]].siz; if (T[x].ch[0] &amp;&amp; T[x].ch[1]) { T[x].lmax = max(T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val + T[T[x].ch[1]].lmax); T[x].rmax = max(T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val + T[T[x].ch[0]].rmax); T[x].maxsum = max({T[T[x].ch[0]].maxsum, T[T[x].ch[1]].maxsum, T[T[x].ch[0]].rmax + T[x].val + T[T[x].ch[1]].lmax}); } else if (T[x].ch[0]) { T[x].lmax = max({T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val, 0}); T[x].rmax = max(T[x].val + T[T[x].ch[0]].rmax, 0); T[x].maxsum = max(T[T[x].ch[0]].maxsum, T[T[x].ch[0]].rmax + T[x].val); } else if (T[x].ch[1]) { T[x].lmax = max(T[x].val + T[T[x].ch[1]].lmax, 0); T[x].rmax = max({T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val, 0}); T[x].maxsum = max(T[T[x].ch[1]].maxsum, T[T[x].ch[1]].lmax + T[x].val); } else { T[x].maxsum = T[x].val; T[x].lmax = T[x].rmax = max(T[x].val, 0); } } inline void rotate(int x) { if (!x) return; int w = which(x), y = T[x].fa; if (~which(y)) T[T[y].fa].ch[which(y)] = x; T[x].fa = T[y].fa; T[y].ch[w] = T[x].ch[w ^ 1]; if (T[x].ch[w ^ 1]) T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int &amp;goal) { if (x == goal) return; int p = T[goal].fa; for (int y; T[x].fa ^ p; rotate(x)) y = T[x].fa, (T[y].fa ^ p) &amp;&amp; (rotate(which(y) ^ which(x) ? x : y), 1); goal = x; } inline int kth_element(int x, int k) { while (233) { if (T[x].ch[0] &amp;&amp; k &lt;= T[T[x].ch[0]].siz) x = T[x].ch[0]; else { if (T[x].ch[0]) k -= T[T[x].ch[0]].siz; if (!--k) return x; x = T[x].ch[1]; } } } inline void insert(int &amp;rt, int p, int val) { int x = kth_element(rt, p); splay(x, rt); int y = kth_element(rt, p + 1); splay(y, T[rt].ch[1]); T[y].ch[0] = newnode(val); T[T[y].ch[0]].fa = y; update(T[y].ch[0]); update(y), update(x); } inline void erase(int &amp;rt, int p) { int y = kth_element(rt, p); splay(y, rt); int x = kth_element(rt, p + 1); splay(x, T[rt].ch[1]); int z = T[x].ch[1]; T[z].fa = y; T[y].ch[1] = z; delnode(x); update(y); } inline void modify(int &amp;rt, int p, int val) { int x = kth_element(rt, p + 1); splay(x, rt); T[x].val = val; update(x); } inline int find(int &amp;rt, int l, int r) { int x = kth_element(rt, l); splay(x, rt); int y = kth_element(rt, r + 2); splay(y, T[rt].ch[1]); return T[T[y].ch[0]].maxsum; } inline void make(int p, int l, int r) { int mid = (l + r) &gt;&gt; 1; T[p].val = a[mid]; if (mid - 1 &gt;= l) T[p].ch[0] = newnode(), T[T[p].ch[0]].fa = p, make(T[p].ch[0], l, mid - 1); if (mid + 1 &lt;= r) T[p].ch[1] = newnode(), T[T[p].ch[1]].fa = p, make(T[p].ch[1], mid + 1, r); update(p); } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int root = newnode(); make(root, 0, n + 1); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { char opt[2]; int x, y; scanf(&quot;%s %d&quot;, opt, &amp;x); if (*opt ^ &#39;D&#39;) scanf(&quot;%d&quot;, &amp;y); if (*opt == &#39;I&#39;) insert(root, x, y); if (*opt == &#39;D&#39;) erase(root, x); if (*opt == &#39;R&#39;) modify(root, x, y); if (*opt == &#39;Q&#39;) printf(&quot;%d\\n&quot;, find(root, x, y)); } return 0; } 13.Count on a tree给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u$,$v$,$k$ 你需要回答 $u \\text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。 LYC树上的路径问题，我们一般都要用树链剖分。 静态第$k$小的问题，我们一般用主席树。 经过严谨分析，我们得出，这道题是树剖加主席树。 把树剖成重链之后像主席树模板那样按$dfs$序插入每个数(让同一条重链在主席树的$root$数组中成为一个连续的区间，方便统计)，然后我们要查询$u$,$v$两个节点间的第$k$小。 和模板不一样的地方来了：这里的区间第$k$小的区间不连续。 我们回想模板的思想过程： 通过差分得出区间内每个数值出现的个数。 既然这次区间是不连续的，我们就每次都把这些不连续的子区间统计一遍，再加起来就好了，就相当于是把这些子区间合起来。 具体来说，就是树剖$LCA$时记录每个区间的左右端点。使用主席树查询时再把原来的对于一个区间的统计改为对很多区间的统计就好了。 剩下的就和模板一样了。 代码： #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int n,m,p,a[100010],last,u,v,w,fa[100010],dep[100010],son[100010],siz[100010],dfn[100010],ton[100010],hb[100010],tot,be[100010],en[100010],cnt,root[100010],cntot; struct node { int l,r,sum; }nodes[4000010]; vector&lt;int&gt; e[100010],pri; int getID(int val) { return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1; }//离散化 void dfs1(int x,int las) { dep[x]=dep[las]+1; fa[x]=las; siz[x]=1; int b=-1e9,s=0; for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las) { dfs1(y,x); siz[x]+=siz[y]; if(siz[y]&gt;b) { b=siz[y]; s=y; } } } son[x]=s; } void dfs2(int x,int las,int heavy) { if(heavy) hb[x]=hb[las]; else hb[x]=x; dfn[x]=++tot; ton[tot]=a[x]; if(son[x]) dfs2(son[x],x,1); for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las&amp;&amp;y^son[x]) dfs2(y,x,0); } } void LCA(int x,int y) { int fx=hb[x],fy=hb[y]; while(fx^fy) { if(dep[fx]&lt;dep[fy]) { swap(fx,fy); swap(x,y); } be[++cnt]=root[dfn[fx]-1]; en[cnt]=root[dfn[x]];//记录每一个区间的左端点-1和右端点，相当于原来find(int l,int r,int p1,int p2,int k)中的p1,p2。 x=fa[fx]; fx=hb[x]; } be[++cnt]=root[min(dfn[x],dfn[y])-1]; en[cnt]=root[max(dfn[x],dfn[y])]; //所有的子区间中的数包含且仅包含了u到v的最短路径上的所有点。因为树剖LCA会用一个一个区间覆盖所有点，而我们记录了每一个区间。 }//树剖 void ins(int l,int r,int pre,int &amp;now,int pos) { nodes[++cntot]=nodes[pre]; now=cntot; ++nodes[now].sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos); } int find(int l,int r,int k) { if(l==r) return pri[l-1];//一直到确定第k小的位置；返回原值。 int X=0; for(int i=1;i&lt;=cnt;++i) X+=(nodes[nodes[en[i]].l].sum-nodes[nodes[be[i]].l].sum); //临时统计u到v的最短路径上的所有点权中在[l,mid]中的数的个数。 int mid=(l+r)&gt;&gt;1; if(k&lt;=X)//k&lt;=X,说明第k小在左边 { for(int i=1;i&lt;=cnt;++i)//把每个端点都往左下跳。使它代表的值为这个区间的元素值在[l,mid]的个数。 { en[i]=nodes[en[i]].l; be[i]=nodes[be[i]].l; } //然后我们就可以去缩小范围，去查询[l,mid]这个区间了。 return find(l,mid,k); } else//否则，第k小是右边的第k-X小 { for(int i=1;i&lt;=cnt;++i)//把每个端点都往右下跳。道理同上。 { en[i]=nodes[en[i]].r; be[i]=nodes[be[i]].r; } return find(mid+1,r,k-X);//继续查找 } }//主席树 int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } for(int i=1;i&lt;n;++i) { scanf(&quot;%d %d&quot;,&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); dfs1(1,1); dfs2(1,1,0); p=pri.size(); for(int i=1;i&lt;=n;++i) ins(1,p,root[i-1],root[i],getID(ton[i]));//按dfs序插入 for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); u^=last; cnt=0; LCA(u,v); last=find(1,p,w); printf(&quot;%d\\n&quot;,last); } return 0; } WGY对于每一个节点$x$，先令$rt_x=rt_{x-1}$，然后在$rt_x$中插入$a_i$，这样其实每个节点维护的都是节点到根的信息 对于查询操作中的每一个$(x,y)$，我们可以用$rt_x+rt_y-rt_{lca_{x,y}}-rt_{fa_{lca_{x,y}}}$来得到答案 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) const int SIZE = 1e5 + 5; struct TreeNode { int l, r; int size; } fhq[SIZE &lt;&lt; 5]; int n, m, tot, fa[SIZE], rt[SIZE]; int a[SIZE], rnk[SIZE], dp[SIZE], inq[30][SIZE], lastans, Q[SIZE]; std::vector &lt; std::vector &lt; int &gt; &gt; G(SIZE); inline bool cmp(int x, int y) { return a[x] &lt; a[y]; } inline void newnode(int t, int p) { fhq[++tot] = fhq[rt[t]]; rt[t] = tot; int u = rt[t], l = 1, r = n; while (l ^ r) { fhq[u].size++; if (p &lt;= mid) fhq[++tot] = fhq[fhq[u].l], fhq[u].l = tot, u = fhq[u].l, r = mid; else fhq[++tot] = fhq[fhq[u].r], fhq[u].r = tot, u = fhq[u].r, l = mid + 1; } fhq[u].size++; } inline int find(int a, int b, int c, int d, int l, int r, int u) { if (l ^ r) if (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size &gt;= u) return find(fhq[a].l, fhq[b].l, fhq[c].l, fhq[d].l, l, mid, u); else return find(fhq[a].r, fhq[b].r, fhq[c].r, fhq[d].r, mid + 1, r, u - (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size)); else return l; } inline void dfs(int x, int fa) { dp[x] = dp[fa] + 1; rt[x] = rt[fa]; ::fa[x] = fa; newnode(x, a[x]); for (int i = 0; i &lt; (int)G[x].size(); ++i) if (G[x][i] ^ fa) dfs(G[x][i], x); } inline int lca_mast(int x, int y) { if (dp[x] &lt; dp[y]) std::swap(x, y); for (int i = 0; dp[x] - dp[y]; ++i) if ((1 &lt;&lt; i) &amp; (dp[x] - dp[y])) x = inq[i][x]; if (x ^ y) { for (int i = 25; i &gt;= 0; --i) if (inq[i][x] ^ inq[i][y]) x = inq[i][x], y = inq[i][y]; return fa[x]; } else return x; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), Q[i] = i; std::sort(Q + 1, Q + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) rnk[i] = a[Q[i]], a[Q[i]] = i; for (int i = 1, x, y; i &lt; n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); dfs(1, 0); for (int i = 1; i &lt;= n; ++i) inq[0][i] = fa[i]; for (int i = 1; i &lt; 26; ++i) for (int j = 1; j &lt;= n; ++j) inq[i][j] = inq[i - 1][inq[i - 1][j]]; for (int i = 1; i &lt;= m; ++i) { int x, y, z; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); x ^= lastans; int lca = lca_mast(x, y); printf(&quot;%d\\n&quot;, lastans = rnk[find(rt[x], rt[y], rt[lca], rt[fa[lca]], 1, n, z)]); } return 0; } 14.P2486 [SDOI2011]染色 WGY可以把首先把连接不同色点的边权设置为1，同色的设为9，这样整个问题就变成了查询路径上的权值和。 显然，我们可以用暴力$LinkCutTree$或$TreeChainSplitting$来搞，这里给出$LCT$的做法。 维护每一个$Splay$节点的最左端点的值和最右端点的颜色，对于它的老汉节点，我们可以找出它的前驱和后继的颜色。这样就可以累计它和前驱和后继连边的权值和辣 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define lson (fhq[x].ch[0]) #define rson (fhq[x].ch[1]) using namespace std; #define DEBUG 1 // debug toggle struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m; class LinkCutTree { public: struct SPLAY { int w, c; int l, r; int tag, rev; int fa, ch[2]; } fhq[SIZE]; // The fhq-treap replaces the splay // Struct SPLAY int stack[SIZE], tp; inline bool isroot(int x) { return fhq[fhq[x].fa].ch[0] ^ x &amp;&amp; fhq[fhq[x].fa].ch[1] ^ x; } inline void tr_dn1(int x) { if (fhq[x].rev) swap(lson, rson), swap(fhq[lson].l, fhq[lson].r), swap(fhq[rson].l, fhq[rson].r), fhq[lson].rev ^= 1, fhq[rson].rev ^= 1, fhq[x].rev = 0; } inline void tr_dn2(int x) { if (fhq[x].tag) fhq[x].l = fhq[x].r = fhq[x].c = fhq[x].tag, fhq[lson].tag = fhq[rson].tag = fhq[x].tag, fhq[x].w = fhq[x].tag = 0; } inline void tr_dn(int x) { tr_dn1(x), tr_dn2(x); } inline void tr_up_(int x) { tr_dn(lson), tr_dn(rson); fhq[x].w = fhq[lson].w + fhq[rson].w; } inline void tr_up1(int x) { if (lson) fhq[x].l = fhq[lson].l, ((fhq[x].c ^ fhq[lson].r) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].l = fhq[x].c; } inline void tr_up2(int x) { if (rson) fhq[x].r = fhq[rson].r, ((fhq[x].c ^ fhq[rson].l) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].r = fhq[x].c; } inline void tr_up(int x) { tr_up_(x); tr_up1(x); tr_up2(x); } inline void rotate(int x) { int y = fhq[x].fa, z = fhq[y].fa, k = fhq[y].ch[1] == x; if (!isroot(y)) fhq[z].ch[fhq[z].ch[1] == y] = x; fhq[x].fa = z; fhq[y].ch[k] = fhq[x].ch[k ^ 1], fhq[fhq[x].ch[k ^ 1]].fa = y; fhq[x].ch[k ^ 1] = y; fhq[y].fa = x; tr_up(y); } inline void splay1(int x) { stack[tp = 1] = x; for (int i = x; !isroot(i); i = fhq[i].fa) stack[++tp] = fhq[i].fa; while (tp) tr_dn(stack[tp--]); } inline void splay2(int x) { for (; !isroot(x); rotate(x)) { int y = fhq[x].fa, z = fhq[y].fa; if (!isroot(y)) (fhq[y].ch[1] ^ x ^ fhq[z].ch[1] ^ y) ? rotate(x) : rotate(y); } } inline void splay(int x) { splay1(x), splay2(x); tr_up(x); } inline void access(int x) { for (int y = 0; x; y = x, x = fhq[x].fa) splay(x), rson = y, tr_up(x); } inline void makeroot(int x) { access(x), splay(x), fhq[x].rev ^= 1; } inline int findroot(int x) { access(x), splay(x); while (lson) x = lson; return x; } inline void split(int x, int y) { makeroot(x), access(y), splay(y); } inline void connect(int x, int y) { makeroot(x), fhq[x].fa = y; } } lct_mast; // Class LinkCutTree signed main() { io.read(n), io.read(m); for (int i = 1, x; i &lt;= n; ++i) io.read(x), lct_mast.fhq[i].c = lct_mast.fhq[i].l = lct_mast.fhq[i].r = x; for (int i = 1, x, y; i &lt; n; ++i) io.read(x), io.read(y), lct_mast.connect(x, y); for (int i = 1, a, b, c; i &lt;= m; ++i) { char ch = getchar(); while (ch ^ &#39;C&#39; &amp;&amp; ch ^ &#39;Q&#39;) ch = getchar(); if (ch ^ &#39;Q&#39;) io.read(a), io.read(b), io.read(c), lct_mast.split(a, b), lct_mast.fhq[b].tag = c; else io.read(a), io.read(b), lct_mast.split(a, b), io.write(lct_mast.fhq[b].w + 1, &#39;\\n&#39;); } return 0; } LYC15.「ZJOI2017」树状数组漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的OI比赛经历。那是一道基础的树状数组题。 给出一个长度为$n$的数组$A$，初始值都为0，接下来进行$m$次操作，操作有两种： * 1 x，表示将 $A_{x}$ 变成 $\\left ( A_{x}+ 1 \\right )$ mod 2。 * 2 l r，表示询问 $ \\left ( \\sum_{i=l}^{r} A_{i} \\right )$ mod 2。 尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常young 的她写了如下的算法： 其中 lowbit($x$) 表示数字 $x$ 最低的非 0 二进制位，例如 lowbit(5) = 1, lowbit(12) = 4。进行第一类操作的时候就调用 Add($x$)，第二类操作的时候答案就是 Query($l$,$r$)。 如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了： Add 和 Find 中 $x$ 变化的方向反了。因此这个程序在最终测试时华丽的爆 0 了。 然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对 拍的原因。 现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的 感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $\\left [ l_{i},r_{i} \\right ]$ 范围内 等概率随机 的。 具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 0，接下来进行了 $m$ 次操作： * 1 $l$ $r$，表示在区间 $\\left [ l, r \\right ]$ 中等概率选取一个 $x$ 并执行 Add($x$)。 * 2 $l$ $r$，表示询问执行 Query$\\left ( l, r \\right )$得到的结果是正确的概率是多少。 这道题$\\cdots$，没什么可讲的吧？二维线段树蛮干就好了 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; typedef long long int ull; const int SIZE = 1e5 + 5; const int MOD = 998244353; struct TreeNode { int l, r; int val; } tr[SIZE * 400]; int rt[SIZE * 20], n, q, tot; inline ull result(ull p, ull q) { ull res = p * q; res %= MOD; return res = (res + (1 - p + MOD) * (1 - q + MOD) % MOD) % MOD; } inline ull fast_pow(ull x, ull y) { ull res = 1; for (; y; y &gt;&gt;= 1, (x *= x) %= MOD) if (y &amp; 1) (res *= x) %= MOD; return res % MOD; } inline void modifies(int l, int r, int &amp;rt, int x, int y, ull p) { if (!rt) rt = ++tot, tr[rt].val = 1; if (l &gt;= x &amp;&amp; r &lt;= y) return (void)(tr[rt].val = result(p, tr[rt].val)); if (mid &gt;= x) modifies(l, mid, tr[rt].l, x, y, p); if (mid &lt; y) modifies(mid + 1, r, tr[rt].r, x, y, p); } inline void modify(int l, int r, int rt, int lx, int rx, int ly, int ry, ull p) { if (l &gt;= lx &amp;&amp; r &lt;= rx) return (void)(modifies(1, n, ::rt[rt], ly, ry, p)); if (mid &gt;= lx) modify(l, mid, rt &lt;&lt; 1, lx, rx, ly, ry, p); if (mid &lt; rx) modify(mid + 1, r, rt &lt;&lt; 1 | 1, lx, rx, ly, ry, p); } inline ull finds(int l, int r, int rt, int x) { if (!rt) return 1; if (l ^ r) if (mid &gt;= x) return result(tr[rt].val, finds(l, mid, tr[rt].l, x)); else return result(tr[rt].val, finds(mid + 1, r, tr[rt].r, x)); else return tr[rt].val; } inline ull find(int l, int r, int rt, int x, int y) { if (l ^ r) if (mid &gt;= x) return result(finds(1, n, ::rt[rt], y), find(l, mid, rt &lt;&lt; 1, x, y)); else return result(finds(1, n, ::rt[rt], y), find(mid + 1, r, rt &lt;&lt; 1 | 1, x, y)); else return finds(1, n, ::rt[rt], y); } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 0; i &lt; q; ++i) { int opt, l, r; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;l, &amp;r); if (opt ^ 1) printf(&quot;%lld\\n&quot;, find(0, n, 1, l - 1, r)); else { ull p = fast_pow(r - l + 1, MOD - 2); if (l &gt; 1) modify(0, n, 1, 1, l - 1, l, r, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, 1, l - 1, 0); if (r &lt; n) modify(0, n, 1, l, r, r + 1, n, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, r + 1, n, 0); modify(0, n, 1, l, r, l, r, (1 - p * 2 % MOD + MOD) % MOD), modify(0, n, 1, 0, 0, l, r, p); } } return 0; } 16.P2161 [SHOI2009]会场预约// 未免LJS吐槽不贴题面了 这道题正解应该是平衡树或者BIT，这里提供一种简便的STL做法。 对于第一个操作，我们可以令有冲突的预约相等，避免set特性坑死一票人 对于第二个操作直接输出set的大小即可 // 省略头文件和快读 struct LaLaLand { int l, r; bool operator &lt; (const LaLaLand&amp; rhs) const { return r &lt; rhs.l; } }; set &lt; LaLaLand &gt; st; int T; signed main() { for (read(T); T; --T) { char opt[5]; read(opt); int l, r, cnt = 0; if (*opt == &#39;A&#39;) { read(l, r); LaLaLand tmp = {l, r}; IT it = st.find(tmp); while (it != st.end()) ++cnt, st.erase(it), it = st.find(tmp); st.insert(tmp); write(io_l, cnt); } else write(io_l, st.size()); } return 0; } 17.SP11470 TTM - To the moon一个长度为n的数组，4种操作 ： C l r d：区间 $[l,r]$ 中的数都加 $d$ ，同时当前的时间戳加 $1$。 Q l r：查询当前时间戳区间 $[l,r]$ 中所有数的和 。 H l r t：查询时间戳 $t$ 区间 $[l,r]$ 的和 。 B t：将当前时间戳置为 $t$ 。 这道题正解应该是主席树+标记永久化，我来提供一种代码极短(压行后不到1K)的做法(怎么感觉我就没什么正经解法) 维护一个差分数组，将每次询问看作是两次前缀和相减 然后…就没有然后了，其它都是模板的主席树，只是修改用差分就好了 18.P4168 [Violet]蒲公英在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。 为了简化起见，我们把所有的蒲公英看成一个长度为n的序列 $(a_1,a_2..a_n)$，其中 $a_i$ 为一个正整数，表示第i棵蒲公英的种类编号。 而每次询问一个区间 [l,r]，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。 注意，你的算法必须是在线的 LYC:这就是传说中的分块打表了 由于强制在线，莫队是不可能的了 求区间众数，我们可以按之前讲的分块打表技术，处理出每两个特征点的每个元素的出现个数和当前众数。 对于每个询问，由于众数问题不容易往回收（要重新找众数），我们选取左右端点往内的最近的特征点 继承（注意不是直接把这个区间的答案拿来接着用，因为不能回退，如果直接用又不回退，下次调用时会调到错误的结果）这个区间的答案，利用这个区间之前统计的元素出现个数 向外扩张，统计出要询问的答案 最后要把刚刚统计众数加上的元素个数清掉（回溯最初处理好的状态） 代码：（这里块大小我开的$n^{2/3}$，开$\\sqrt n$好像开不下） #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; vector&lt;int&gt; pri; int n,m,a[40010],each,cnt[40][40][40010],MAX[40][40],lans,l,r,ans,tmp[40010]; int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); each=pow(n,2.0/3); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); for(int i=1;i&lt;=n;++i) a[i]=lower_bound(pri.begin(),pri.end(),a[i])-pri.begin()+1;//离散化 for(int i=1,p=1;i&lt;=n;i+=each,++p) { for(int j=i+each-1,q=p;j&lt;=n;j+=each,++q) { for(int k=i;k&lt;=j;++k) { ++cnt[p][q][a[k]]; if(cnt[p][q][a[k]]&gt;cnt[p][q][MAX[p][q]]||(cnt[p][q][a[k]]==cnt[p][q][MAX[p][q]]&amp;&amp;a[k]&lt;MAX[p][q])) MAX[p][q]=a[k]; } } }//初始化（打表） for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d&quot;,&amp;l,&amp;r); l=(l+lans-1)%n+1; r=(r+lans-1)%n+1; if(l&gt;r) swap(l,r);//强制在线 if(r-l&gt;2*each) { int p=ceil(1.0*(l-1)/each)+1; int q=ceil(1.0*(r+1)/each)-1;//得到向内收缩的端点 ans=MAX[p][q];//继承答案 for(int i=(p-1)*each;i&gt;=l;--i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } for(int i=q*each+1;i&lt;=r;++i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1];//获得原值 printf(&quot;%d\\n&quot;,lans); for(int i=(p-1)*each;i&gt;=l;--i) --cnt[p][q][a[i]]; for(int i=q*each+1;i&lt;=r;++i) --cnt[p][q][a[i]];//回溯 } else//区间太小，如果两个端点在一个块内，向内收缩就会重复统计整个块，所以暴力统计 { ans=0; for(int i=l;i&lt;=r;++i) { ++tmp[a[i]]; if(tmp[a[i]]&gt;tmp[ans]||(tmp[a[i]]==tmp[ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1]; printf(&quot;%d\\n&quot;,lans); for(int i=l;i&lt;=r;++i) --tmp[a[i]];//回溯清零 } } return 0; } WGY:这道题luogu的数据很水，于是…于是…我们直接离散化+暴力就能过！ 然后….然后就没了(这次真的不是我不想写，是真的没什么写的…) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 50000 + 5; int a[SIZE], b[SIZE]; int cnt[SIZE], x; int l, r, n, m, l0, r0; signed main() { io.read(n), io.read(m); for (int i = 1; i &lt;= n; ++i) io.read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b; while (m--) { io.read(l0), io.read(r0); l = (l0 + x - 1) % n + 1; r = (r0 + x - 1) % n + 1; if (l &gt; r) swap(l, r); for (int i = l; i &lt;= r; ++i) cnt[a[i]]++; int MAX = 0, pos = 0; for (int i = 1; i &lt;= len; ++i) if (MAX &lt; cnt[i]) MAX = cnt[i], pos = i; printf(&quot;%d\\n&quot;, b[pos]); x = b[pos]; memset(cnt, 0, sizeof cnt); } } 19.[CQOI2014]排序机械臂为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$ ，并把左起第一个物品至 $P_1$ 间的物品 (即区间 $[1,P_1]$ 间的物品) 反序；第二次找到第二低的物品的位置 $P_2$ ，并把左起第二个至 $P_2$ 间的物品 (即区间 $[2,P_2]$ 间的物品) 反序……最终所有的物品都会被排好序。 上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$ ，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序…… 你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$ 低的物品所在位置 $P_i$ ，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。 LYC：我们乍一看这道题 “哟！区间翻转平衡树裸题，还6倍经验？！” 再一看，每次翻转区间第一个到元素值最小的一个，再删除最小的一个 ？？？ 元素值最小的一个 应该怎么维护呢 我们可以在update里顺便维护这个子树中最小的值是第几个和它的大小（我脑残维护了前面有几个数）。 针对这个进行分类讨论： 1).当前结点的值比左右子树的最小值都小 那么最小值是当前结点的值。 它前面的元素个数是左子树的大小（中序遍历为原序列） 2).左子树的最小值最小 完美继承左子树的两个值。 3).右子树的最小值最小 最小值不用说了吧。 它前面的个数就是左子树的大小加一（当前结点）再加上右子树中在它前面的元素个数 因为子树不变时，那我们维护的这个值也不变。子树变了，那就肯定要更新。 然后再每次都查询最小的元素在哪一个位置，删掉它再翻转前面的区间就好了 代码： #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,tot,root,root1,root2,root3,c[100010]; struct node { int l,r,num,key,sum; int s,smum;//最小值大小，前面的元素个数 bool rev;//翻转标记 }nodes[100010]; struct laji { int v,ID; }a[100010]; bool cmp(laji one,laji two) { if(one.v^two.v) return one.v&lt;two.v; return one.ID&lt;two.ID; }//离散化，顺便解决如果值相同，保持原有相对位置的问题 int newnode(int val) { nodes[++tot].s=val;//最小值设为自己，前面没有数 nodes[tot].num=val; nodes[tot].key=rand(); nodes[tot].sum=1; return tot; } void pushdown(int x) { swap(nodes[x].l,nodes[x].r);//首先交换左右儿子 nodes[x].smum=nodes[x].sum-(nodes[x].smum+1);//整个子树翻转过来，则最小值的位置就要翻过来 //原来前面的元素个数：nodes[x].smum //原位置: nodes[x].smum+1 //翻转位置：nodes[x].sum-(nodes[x].smum+1)+1 //翻转后前面的元素个数：nodes[x].sum-(nodes[x].smum+1) nodes[nodes[x].l].rev^=1; nodes[nodes[x].r].rev^=1;//下传标记 nodes[x].rev=0;//记得清空 } void update(int x) { nodes[x].sum=nodes[nodes[x].l].sum+nodes[nodes[x].r].sum+1; if(nodes[nodes[x].l].rev) pushdown(nodes[x].l); if(nodes[nodes[x].r].rev) pushdown(nodes[x].r);//如果左右子树有标记，也要下传，否则更新出的值不对 if(nodes[x].num&lt;nodes[nodes[x].l].s&amp;&amp;nodes[x].num&lt;nodes[nodes[x].r].s)//分类讨论情况1 { nodes[x].s=nodes[x].num; nodes[x].smum=nodes[nodes[x].l].sum; } else if(nodes[nodes[x].l].s&lt;nodes[nodes[x].r].s)//情况2 { nodes[x].s=nodes[nodes[x].l].s; nodes[x].smum=nodes[nodes[x].l].smum; } else//情况3 { nodes[x].s=nodes[nodes[x].r].s; nodes[x].smum=nodes[nodes[x].r].smum+nodes[nodes[x].l].sum+1; } } void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[now].rev) pushdown(now);//下面要用到它的儿子，所以我们要下传标记 if(nodes[nodes[now].l].sum&lt;siz) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { if(nodes[x].rev) pushdown(x); nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { if(nodes[y].rev) pushdown(y); nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } int main() { srand(20060515); nodes[0].num=nodes[0].s=1e9;//处理节点为空的特殊情况为极大值，使更新叶子节点时不会把0更新进去 scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i].v); a[i].ID=i; } sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;++i) c[a[i].ID]=i;//离散化 for(int i=1;i&lt;=n;++i) root=merge(root,newnode(c[i]));//处理原序列，直接把当前元素插入到它前面元素的右边 for(int i=1;i&lt;=n;++i) { if(nodes[root].rev) pushdown(root);//如果根节点有翻转标记要翻转，否则最小值的位置是反的。 printf(&quot;%d &quot;,nodes[root].smum+i);//还有之前的i-1个已经被删除的数 split(root,nodes[root].smum,root1,root2); split(root2,1,root2,root3);//删除这个数 nodes[root1].rev^=1;//翻转前面的区间 root=merge(root1,root3); } return 0; } WGY:SplayNB！！！区间操作直接秒过！！(具体题解参考LYC，我就放个代码) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 100000 + 5; struct SPLAY { int fa; int size; int val; int rev; int ch[2]; } t[SIZE]; int n, root, tot, pos[SIZE]; struct InputNode { int id; int val; } a[SIZE]; bool cmp1(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.val ^ rsp.val ? rhs.val &lt; rsp.val : rhs.id &lt; rsp.id; } bool cmp2(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.id &lt; rsp.id; } void update(int x) { t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; } void transf(int x) { if (t[x].rev) { swap(t[x].ch[0], t[x].ch[1]); t[t[x].ch[0]].rev ^= 1; t[t[x].ch[1]].rev ^= 1; t[x].rev = 0; } } int make(int fa, int l, int r) { if (l &gt; r) return 0; int p = ++tot; return(t[p].val = a[mid].val, t[p].fa = fa, pos[a[mid].val] = p, t[p].ch[0] = make(p, l, mid - 1), t[p].ch[1] = make(p, mid + 1, r), update(p), p); } void rotate(int x) { int y = t[x].fa, z = t[y].fa; transf(y), transf(x); int k = t[t[x].fa].ch[1] == x; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[y].ch[k]].fa = y; t[y].fa = x; t[x].ch[k ^ 1] = y; t[x].fa = z; if (z) t[z].ch[y == t[z].ch[1]] = x; update(y), update(x); } void splay(int x, int goal) { for (int y; (y = t[x].fa) ^ goal; rotate(x)) if (t[y].fa ^ goal) rotate(t[t[x].fa].ch[1] ^ x ^ y ^ t[t[y].fa].ch[1] ? x : y); if (!goal) root = x; } int behavior() { transf(root); int x = t[root].ch[1]; while (transf(x), t[x].ch[0]) x = t[x].ch[0]; return x; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i + 1].val), a[i + 1].id = i + 1; a[1].val = 0, a[n + 2].val = n + 1; sort(a + 2, a + 2 + n, cmp1); for (int i = 2; i &lt;= n + 1; ++i) a[i].val = i - 1; sort(a + 2, a + 2 + n, cmp2); root = make(0, 1, n + 2); for (int i = 1; i &lt;= n; ++i) { int x = pos[i]; splay(x, 0); printf(&quot;%d &quot;, t[t[x].ch[0]].size); x = behavior(); int y = pos[i - 1]; splay(y, 0); splay(x, y); t[t[x].ch[0]].rev ^= 1; } return 0; } 20.[SHOI2013]扇形面积并(权值线段树&amp;扫描线) 给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。 LYC:这道题要用到扫描线的思想,那扫描线是什么呢? 扫描线： 经典应用：给出一堆矩阵，求它们覆盖的总面积 数据范围恶心死了，$10^5$个矩阵，矩阵的坐标的绝对值小于$10^9$。 看到这个数据范围我们就知道：要离散化。 之后呢，我们把每个矩阵的左右边界都转换成添加和删除。 我们用一条扫描线从左到右扫过去，线段树来维护现在整条扫描线的被覆盖情况。 矩阵的左边就是添加以这个矩阵的上下边界点为端点的线段。 右边再右边一个就转换成删除。 每走过一个点，我们就用线段树统计当前扫描线被这些矩阵覆盖了多少，再把答案加上去就好了。 模板我就不写啦其实是我不会 $\\ $ 好了那我们来看这道题吧。 一堆圆心相同的扇形，求被至少$k$个扇形覆盖的面积。 我们先单看一条从圆心射出的射线。 由于每个扇形的圆心是相同的。 所以覆盖每个地方的扇形数量是向外递减的。 那么被至少$k$个扇形覆盖的地方就在从外到内第$k$个扇形，它被刚好或者多于$k$个扇形所覆盖，更向内的地方的数量则更多，也是大于等于$k$。 所以我们可以用权值线段树来维护每个地方有多少个扇形边界。从而查找从外到内第$k$个扇形边界。 运用扫描线思想，把给出的扇形的两个角度值转换成添加和删除一个扇形边界。 实现有很多坑，自己看注释吧。 代码： #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; long long n,m,k,nodes[400010],a1,a2,ans,s,now; struct cir { long long r; bool insorex;//1为添加，2为删除 }cur; vector&lt;cir&gt; op[2000010];//用来储存在每个角度的修改 void ins(long long l,long long r,long long x,long long pos) { ++nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,x&lt;&lt;1,pos); else ins(mid+1,r,x&lt;&lt;1|1,pos); } } void exins(long long l,long long r,long long x,long long pos)//权值线段树删除 { --nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) exins(l,mid,x&lt;&lt;1,pos); else exins(mid+1,r,x&lt;&lt;1|1,pos); } } long long find(long long l,long long r,long long x,long long val)//权值线段树查找从外到内第k个 { if(l==r) return l; long long mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1|1]) return find(mid+1,r,x&lt;&lt;1|1,val); else return find(l,mid,x&lt;&lt;1,val-nodes[x&lt;&lt;1|1]); } int main() { scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;k); for(long long i=1;i&lt;=n;++i) { scanf(&quot;%lld %lld %lld&quot;,&amp;cur.r,&amp;a1,&amp;a2); s=max(s,cur.r); a1+=m; a2+=m;//a1,a2可能是负数 //转换成添加和修改 if(a1&gt;a2)//这个扇形跨越了分界线，需要拆成两半 { cur.insorex=1; op[a1+1].push_back(cur); op[1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } else { cur.insorex=1; op[a1+1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } } for(long long i=1;i&lt;=m*2;++i)//注意是半开区间(-Pi,Pi] { for(long long j=0;j&lt;op[i].size();++j)//进行修改操作 { cur=op[i][j]; if(cur.insorex) { ins(1,s,1,cur.r); ++now; } else { exins(1,s,1,cur.r); --now;//统计现在总共有多少个 } } if(now&gt;=k)//有k个才统计，不然容易出锅 { long long tmp=find(1,s,1,k); ans+=tmp*tmp;//圆面积公式：Pi*r*r } } printf(&quot;%lld\\n&quot;,ans); return 0; } WGY提供树状数组+二分做法，复杂度$O(n\\log^2n)$ 树状数组写起来短，常数小，动动脑子可以套在很多题目上，它不香嘛 题目让我们求目前覆盖的第 $k$ 大，我们可以把原来的覆盖位置差分一下，然后二分即可 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m, k, a[SIZE]; LL tree[SIZE], ans; vector &lt; int &gt; In[SIZE&lt;&lt;1], Out[SIZE&lt;&lt;1]; void Add(int x, int y) { for (; x &lt; SIZE; x += x &amp; -x) tree[x] += y; } int Ask(int x, int res = 0) { for (; x; x -= x &amp; -x) res += tree[x]; return res; } int KthElement(int k) { int l = 1, r = SIZE - 5; while (l &lt; r) if (Ask(mid) &lt; k) l = mid + 1; else r = mid; return l; } signed main() { io.read(m), io.read(n), io.read(k); int L, R; for (int i = 1; i &lt;= m; ++i) { io.read(a[i]); io.read(L); io.read(R); if (L &lt; R) L += n + 1, R += n, In[L].pub(i), Out[R + 1].pub(i); else L ^= R ^= L ^= R, L += n, R += n + 1, In[1].pub(i), Out[L + 1].pub(i), In[R].pub(i); } int now = 0, x; for (int i = 1; i &lt;= (n&lt;&lt;1); ++i) { for (int j = 0; j &lt; In[i].size(); ++j) Add(a[In[i][j]], 1); for (int j = 0; j &lt; Out[i].size(); ++j) Add(a[Out[i][j]], -1); now += In[i].size() - Out[i].size(); if (now &gt;= k) x = KthElement(now - k + 1), ans += (LL)x * x; } printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 1~10题","slug":"DS100P-1-10-P","date":"2020-02-08T06:03:27.000Z","updated":"2020-02-18T10:10:03.954Z","comments":true,"path":"2020/02/08/DS100P-1-10-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-1-10-P/","excerpt":"","text":"1.「一本通 4.6 例 1」营业额统计原题来自：HNOI 2002 Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。 Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。 经济管理学上定义了一种最小波动值来衡量这种情况：记该天以前某一天的营业额为 $a_i$，该天营业额为 $b$，则该天的最小波动值 $\\delta=\\min |a_i-b|$，当最小波动值越大时，就说明营业情况越不稳定。而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。 你的任务就是编写一个程序帮助 Tiger 来计算这一个值，第一天的最小波动值为第一天的营业额。 一句话题意给出一个 $n$ 个数的数列 $\\{a_n\\}$，对于第 $i$ 个元素 $a_i$，定义 $f_i=\\min |a_i-a_j|$，其中 $1\\le j\\lt i,f_1=a_1$。求 $\\sum f_i$。 没什么可说的，就是板子，可以用来调一下指针版splay。不过我发现指针版跑的飞慢是在搞嘛 还是正经说一下吧 这道题要查询最小波动值。我们只需要把x的前驱和后继求出来，看一下谁跟x的关系更好离的更近，再算出答案，再把这个数insert进去就好了 #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define mid (l + r &gt;&gt; 1) #define int long long using namespace std; const int SIZE = (1 &lt;&lt; 15) + 5; const int INF = 0x7fffffff; struct SplayNode { SplayNode *son[2], *fa; int val, siz; SplayNode(SplayNode *fa = NULL, int val = 0) : fa(fa), val(val) { *son = *(son + 1) = NULL; siz = 1; } inline bool islyczbing() { return this == fa-&gt;son[1]; } inline int rnk() { return 1 + (*son ? (*son)-&gt;siz : 0); } inline void up() { siz = 1 + (*son ? (*son)-&gt;siz : 0) + ((*(son + 1)) ? (*(son + 1))-&gt;siz : 0); } } * root; inline void rotate(SplayNode *x) { bool k = x-&gt;islyczbing(); SplayNode *y = x-&gt;fa, *z = y-&gt;fa, *w = x-&gt;son[!k]; if (root == y) root = x; else z-&gt;son[y-&gt;islyczbing()] = x; x-&gt;fa = z; y-&gt;fa = x; x-&gt;son[!k] = y; y-&gt;son[k] = w; if (w) w-&gt;fa = y; y-&gt;up(); x-&gt;up(); } inline void cosplay(SplayNode *x) { while (x != root) { if (x-&gt;fa != root) rotate(x-&gt;islyczbing() ^ x-&gt;fa-&gt;islyczbing() ? x : x-&gt;fa); rotate(x); } } inline void insert(int val) { if (!root) return (void)(root = new SplayNode(NULL, val)); SplayNode *p = root, *fa = NULL; while (p) { fa = p; p = p-&gt;son[val &gt; p-&gt;val]; } p = new SplayNode(fa, val); fa-&gt;son[val &gt; fa-&gt;val] = p; cosplay(p); } inline int getpre(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &gt; p-&gt;val) lst = p, p = p-&gt;son[1]; else p = p-&gt;son[0]; } if (lst) return cosplay(lst), lst-&gt;val; return -INF; } inline int getnext(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &lt; p-&gt;val) lst = p, p = p-&gt;son[0]; else p = p-&gt;son[1]; } if (lst) return cosplay(lst), lst-&gt;val; return INF; } signed main() { root = NULL; int n; scanf(&quot;%lld&quot;, &amp;n); int ans = 0; for (int i = 1, x; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;x); if (i == 1) ans += x; else ans += min(x - getpre(x + 1), getnext(x - 1) - x); insert(x); } printf(&quot;%lld\\n&quot;, ans); return 0; } 2.[SHOI2013]发牌在一些扑克游戏里，如德州扑克，发牌是有讲究的。一般称呼专业的发牌手为荷官。荷官在发牌前，先要销牌（burn card）。所谓销牌，就是把当前在牌库顶的那一张牌移动到牌库底，它用来防止玩家猜牌而影响游戏。 假设一开始，荷官拿出了一副新牌，这副牌有N 张不同的牌，编号依次为1到N。由于是新牌，所以牌是按照顺序排好的，从牌库顶开始，依次为1, 2,……直到N，N 号牌在牌库底。为了发完所有的牌，荷官会进行N 次发牌操作，在第i 次发牌之前，他会连续进行Ri次销牌操作， Ri由输入给定。请问最后玩家拿到这副牌的顺序是什么样的？ 举个例子，假设N = 4，则一开始的时候，牌库中牌的构成顺序为{1, 2, 3, 4}。 假设R1=2，则荷官应该连销两次牌，将1 和2 放入牌库底，再将3 发给玩家。目前牌库中的牌顺序为{4, 1, 2}。 假设R2=0，荷官不需要销牌，直接将4 发给玩家，目前牌库中的牌顺序为{1,2}。 假设R3=3，则荷官依次销去了1, 2, 1，再将2 发给了玩家。目前牌库仅剩下一张牌1。 假设R4=2，荷官在重复销去两次1 之后，还是将1 发给了玩家，这是因为1 是牌库中唯一的一张牌。 splay题解 by wgy这道题还蛮简单的，用splay找出1-x的区间，然后把它转到后面去，再删除第一个数就好了 需吸氧 #pragma GCC optimize(2) #pragma GCC optimize(3) #pragma GCC optimize(&quot;Ofast&quot;) #pragma GCC optimize(&quot;inline&quot;) #pragma GCC optimize(&quot;-fgcse&quot;) #pragma GCC optimize(&quot;-fgcse-lm&quot;) #pragma GCC optimize(&quot;-fipa-sra&quot;) #pragma GCC optimize(&quot;-ftree-pre&quot;) #pragma GCC optimize(&quot;-ftree-vrp&quot;) #pragma GCC optimize(&quot;-fpeephole2&quot;) #pragma GCC optimize(&quot;-ffast-math&quot;) #pragma GCC optimize(&quot;-fsched-spec&quot;) #pragma GCC optimize(&quot;unroll-loops&quot;) #pragma GCC optimize(&quot;-falign-jumps&quot;) #pragma GCC optimize(&quot;-falign-loops&quot;) #pragma GCC optimize(&quot;-falign-labels&quot;) #pragma GCC optimize(&quot;-fdevirtualize&quot;) #pragma GCC optimize(&quot;-fcaller-saves&quot;) #pragma GCC optimize(&quot;-fcrossjumping&quot;) #pragma GCC optimize(&quot;-fthread-jumps&quot;) #pragma GCC optimize(&quot;-funroll-loops&quot;) #pragma GCC optimize(&quot;-fwhole-program&quot;) #pragma GCC optimize(&quot;-freorder-blocks&quot;) #pragma GCC optimize(&quot;-fschedule-insns&quot;) #pragma GCC optimize(&quot;inline-functions&quot;) #pragma GCC optimize(&quot;-ftree-tail-merge&quot;) #pragma GCC optimize(&quot;-fschedule-insns2&quot;) #pragma GCC optimize(&quot;-fstrict-aliasing&quot;) #pragma GCC optimize(&quot;-fstrict-overflow&quot;) #pragma GCC optimize(&quot;-falign-functions&quot;) #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;) #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;) #pragma GCC optimize(&quot;-fsched-interblock&quot;) #pragma GCC optimize(&quot;-fpartial-inlining&quot;) #pragma GCC optimize(&quot;no-stack-protector&quot;) #pragma GCC optimize(&quot;-freorder-functions&quot;) #pragma GCC optimize(&quot;-findirect-inlining&quot;) #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;) #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;) #pragma GCC optimize(&quot;inline-small-functions&quot;) #pragma GCC optimize(&quot;-finline-small-functions&quot;) #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;) #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;) #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;) #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;) #pragma GCC optimize(&quot;inline-functions-called-once&quot;) #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;) #pragma GCC optimize(2) #pragma GCC optimize(3) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;cctype&gt; #define mid (l + r &gt;&gt; 1) using namespace std; const int SIZE = 7e5 + 5; struct SPLAY { int siz; int val; int ch[2]; int fa; } T[SIZE]; int root, n, R[SIZE], tot; template &lt; typename T &gt; inline void read ( T &amp;a ) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T &gt; inline T read ( T _checkType, bool _Typeflag ) { T f = 1, a = 0; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } template &lt; typename T &gt; inline void write ( T x, char end_, int st = 0 ) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10, end_, st + 1); putchar(x % 10 + &#39;0&#39;); if (!st) putchar(end_); } inline void update(int u) { T[u].siz = T[T[u].ch[0]].siz + T[T[u].ch[1]].siz + 1; } inline int make(int l, int r, int fa) { int u = ++tot; T[u].siz = 1; T[u].val = mid; T[u].ch[0] = T[u].ch[1] = 0; T[u].fa = fa; if (mid &gt; l) T[u].ch[0] = make(l, mid - 1, u); if (mid &lt; r) T[u].ch[1] = make(mid + 1, r, u); update(u); return u; } inline void rotate(int x) { int y = T[x].fa; int z = T[y].fa; int w = T[y].ch[1] == x; T[z].ch[T[z].ch[1] == y] = x; T[x].fa = z; T[y].ch[w] = T[x].ch[w ^ 1]; T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int goal) { for (; T[x].fa ^ goal; rotate(x)) { int y = T[x].fa; int z = T[y].fa; if (z ^ goal) T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y); } if (!goal) root = x; } inline int getRank(int x) { int u = root; while (233) { if (x &lt;= T[T[u].ch[0]].siz) u = T[u].ch[0]; else { x -= T[T[u].ch[0]].siz + 1; if (!x) return u; u = T[u].ch[1]; } } } inline int getcard(int x) { if (x) { splay(getRank(x), 0); int u = root; root = T[u].ch[1]; T[root].fa = 0; T[u].ch[1] = 0; update(u); splay(getRank(T[root].siz), 0); if (u) T[u].fa = root; if (root) T[root].ch[1] = u, update(root); } int ranker = getRank(1); int res = T[ranker].val; splay(ranker, 0); if (T[ranker].ch[1]) T[root = T[ranker].ch[1]].fa = 0; return res; } signed main() { read(n); root = make(1, n, 0); for (int i = 1; i &lt;= n; ++i) { read(R[i]); write(getcard(R[i] % T[root].siz), &#39;\\n&#39;); } return 0; } 权值线段树题解 by lyc:对于这道题，平衡树 常数太大 不开O2基本都会超时。 所以我们用常数更小一些的线段树来解决这道题。 首先，这道题有7e5张牌，我们采用权值线段树的做法，每个节点记录它对应的区间还剩多少张牌。那么建树操作就很显然了对吧 然后我们考虑销牌操作，由于销牌后整个序列依旧按从小到大有序（1，2，3，4 -&gt;1，3，4），我们设定一个指针now，指向当前牌堆里的最后一张牌在目前牌堆中大小的排名，初始为0（n%n），每次销掉a张牌，我们就将now向右移a位，使它指向销完牌后牌堆里的最后一张，再将now加一，得到当前排队顶的牌在牌堆中的排名，根据定义，在权值线段树中查找第now个还存在的数就得到了这次删去的牌的编号。输出后还要记得把这张牌在权值线段树中删掉，再把now减一，使它重新指向牌堆里的最后一张牌。 代码： #include&lt;cstdio&gt; int n,nodes[80000010],now,a; void writing(int x) { if(!x) return; writing(x/10); putchar((x%10)+&#39;0&#39;); } void read(int &amp;hhh) { int x=0; char c=getchar(); while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)) c=getchar(); x=c^&#39;0&#39;; c=getchar(); while((c&lt;=&#39;9&#39;)&amp;(c&gt;=&#39;0&#39;)) { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^&#39;0&#39;); c=getchar(); } hhh=x; } void build(int l,int r,int x) { if(l==r) nodes[x]=1; else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=r-l+1; } } int kth(int l,int r,int x,int val) { if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1]) return kth(l,mid,x&lt;&lt;1,val); else return kth(mid+1,r,(x&lt;&lt;1)+1,val-nodes[x&lt;&lt;1]); } else return l; } void del(int l,int r,int x,int val) { --nodes[x]; if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=mid) del(l,mid,x&lt;&lt;1,val); else del(mid+1,r,(x&lt;&lt;1)+1,val); } } int main() { read(n); build(1,n,1); for(int i=n;i;--i) { read(a); now=(now+a)%i+1; int cur=kth(1,n,1,now); writing(cur); putchar(&#39;\\n&#39;); del(1,n,1,cur); --now; } return 0; } 3.数列分块入门 8给出一个长为 $n$ 的数列，以及 $n$ 个操作，操作涉及区间询问等于一个数 $c$ 的元素，并将这个区间的所有元素改为 $c$。 本题的重点在于并将这个区间的所有元素改为c 区间推平操作！ 有了区间推平，我们第一时间会想到什么？线段树|分块？ ODT！！！！ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;cctype&gt; #include &lt;utility&gt; #include &lt;set&gt; #define IT set&lt;TreeNode&gt;::iterator using namespace std; inline int getInt() { int a = 0, f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } inline void outInt(int x) { char buffer[20]; int length = 0; bool minus = x &lt; 0; if (minus) x = -x; do { buffer[length++] = x % 10 + &#39;0&#39;; x /= 10; } while (x); if (minus) buffer[length++] = &#39;-&#39;; do { putchar(buffer[--length]); } while (length); } struct TreeNode { int lef; int rig; mutable int val; TreeNode(int l, int r = -1, int v = 0) : lef(l), rig(r), val(v) {} friend bool operator &lt; (const TreeNode &amp;rhs) const { return lef &lt; rhs.lef; } } ; set&lt;TreeNode&gt; st; int n = getInt(); inline IT split(int pos) { IT it = st.lower_bound(TreeNode(pos)); if (it != st.end() &amp;&amp; it-&gt;lef == pos) return it; it--; int l = it-&gt;lef, r = it-&gt;rig; int v = it-&gt;val; st.erase(it); st.insert(TreeNode(l, pos - 1, v)); return st.insert(TreeNode(pos, r, v)).first; } inline void assign(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); st.erase(itl, itr); st.insert(TreeNode(l, r, v)); } inline int query(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); int res = 0; for (; itl != itr; ++itl) res += (itl-&gt;rig - itl-&gt;lef + 1) * (itl-&gt;val == v); return res; } signed main() { for (int i = 1; i &lt;= n; ++i) { int x = getInt(); st.insert(TreeNode(i, i, x)); } for (int i = 1; i &lt;= n; ++i) { int l = getInt(); int r = getInt(); int v = getInt(); printf(&quot;%d\\n&quot;, query(l, r, v)); assign(l, r, v); } return 0; } 4.SP3267 DQUERY - D-query$Given$ $a$ $sequence$ $of$ $n$ $numbers$ $and$ $a$ $number$ $of$ $d-queries.$ $A$ $d-query$ $is$ $a$ $pair$ $(i,$ $j)$ $(1$ $≤$ $i$ $≤$ $j$ $≤$ $n).$ $For$ $each$ $d-query$ $(i,$ $j),$ $you$ $have$ $to$ $return$ $the$ $number$ $of$ $distinct$ $elements$ $in$ $the$ $subsequence$ $a_i$,$a_{i+1},\\cdots,a_j$ 这道题的树状数组的做法是离线的。 首先按询问的右端点排序，然后用树状数组把没有出现过的值加上去，把出现过的减去，最后统计答案即可 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; const int SIZE = 1e6 + 5; int n, m, tree[SIZE], ans[SIZE]; int list[SIZE], tag[SIZE]; pair &lt; pair &lt; int , int &gt; , int &gt; st[SIZE]; inline bool _rule(pair &lt; pair &lt; int , int &gt; , int &gt; x, pair &lt; pair &lt; int , int &gt; , int &gt; y) { return x.first.second &lt; y.first.second; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;list[i]); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;st[i].first.first, &amp;st[i].first.second), st[i].second = i; sort(st + 1, st + 1 + m, _rule); int zblyc = 1; for (int i = 1; i &lt;= m; ++i) { for (int j = zblyc; j &lt;= st[i].first.second; ++j) { if (tag[list[j]]) for (int x = tag[list[j]]; x &lt;= n; x += x &amp; -x) tree[x]--; tag[list[j]] = j; for (int x = j; x &lt;= n; x += x &amp; -x) tree[x]++; } zblyc = st[i].first.second + 1; int lef = 0, rig = 0; for (int x = st[i].first.second; x; x -= x &amp; -x) rig += tree[x]; for (int x = st[i].first.first - 1; x; x -= x &amp; -x) lef += tree[x]; ans[st[i].second] = rig - lef; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 5.P1231 教辅的组成注：本题我已搬运到OJ，数据已经齐全，略卡时间和空间，但均在合理范围，我的代码已通过，请求公开 Link 蒟蒻HansBug在一本语文书里面发现了一本答案，然而他却明明记得这书应该还包含一份练习题。 然而出现在他眼前的书多得数不胜数，其中有书，有答案，有练习册。已知一个完整的书册均应该包含且仅包含一本书、一本练习册和一份答案，然而现在全都乱做了一团。 许多书上面的字迹都已经模糊了，然而HansBug还是可以大致判断这是一本书还是练习册或答案，并且能够大致知道一本书和答案以及一本书和练习册的对应关系（即仅仅知道某书和某答案、某书和某练习册有可能相对应，除此以外的均不可能对应）。 既然如此，HansBug想知道在这样的情况下，最多可能同时组合成多少个完整的书册。 虽然这并不是数据结构的题，但我觉得搬上来也不错，毕竟网络流是个好东西。 这道题我自己码了半天RE结果看了Siyuan的题解后才发现我add_edge传参传错了。话说为什么传参错会RE 大概讲一下这道题的思路吧 看到题目很容易想到跑费用流二分图匹配，但这道题不行。 为什么呢？ 因为他有三个部分 那么直接跑最大流吧！ 但这里还有一个问题，就是一本书作为中间的部分有可能会被重复利用绿色产品 Siyuan曾经这样说道： 因此我们就要引入拆点的思想。我们的目的是：即使一本书与多个联系册有关系，它流出的流量也只能是 1。所以我们把每个代表书的点拆成左右两个点，左边的点和练习册连边，右边的点和答案连边；当然左右对应点也要连一条容量为 1 的边 有了拆点的思想我们就可以直接跑最大流啦! #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE_N = 4e6 + 5; const int SIZE_M = 1e6 + 5; const int INF = 1 &lt;&lt; 30; int n1, n2, n3, m, tot = 1, s, t; int path[SIZE_N], ter[SIZE_M]; int head[SIZE_N], edge[SIZE_M]; int _next[SIZE_N], ver[SIZE_M]; int depth[SIZE_N], cur[SIZE_N]; inline int getid(int p, int x) { switch (p) { case 1: return x; case 2: return n2 + x; case 3: return n2 + n1 + x; case 4: return n2 + (n1 &lt;&lt; 1) + x; } } inline void add_edge(int from, int to, int dis) { ver[++tot] = to, edge[tot] = dis, _next[tot] = head[from], head[from] = tot; } inline int bfs() { memset(depth, 0, sizeof depth); memcpy(cur, head, sizeof head); queue &lt; int &gt; Q; Q.push(s), depth[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = head[x]; i; i = _next[i]) { if (!depth[ver[i]] &amp;&amp; edge[i]) depth[ver[i]] = depth[x] + 1, Q.push(ver[i]); } } return depth[t]; } inline int dfs(int x, int flow) { if (x == t) return flow; int res = 0; for (int i = cur[x]; i &amp;&amp; res &lt; flow; i = _next[i]) { cur[x] = i; if (depth[ver[i]] == depth[x] + 1 &amp;&amp; edge[i]) { int tmp = dfs(ver[i], min(edge[i], flow - res)); if (tmp) edge[i] -= tmp, edge[i ^ 1] += tmp, res += tmp; } } if (res &lt; flow) depth[x] = -1; return res; } inline int dinic() { int res = 0; for (int x; bfs(); ) while (x = dfs(s, INF)) res += x; return res; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n1, &amp;n2, &amp;n3); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(1, to), getid(2, from), 1); add_edge(getid(2, from), getid(1, to), 0); } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(3, from), getid(4, to), 1); add_edge(getid(4, to), getid(3, from), 0); } for (int i = 1; i &lt;= n1; ++i) add_edge(getid(2, i), getid(3, i), 1), add_edge(getid(3, i), getid(2, i), 0); s = 0, t = (n1 &lt;&lt; 1) + n2 + n3 + 1; for (int i = 1; i &lt;= n2; ++i) add_edge(s, getid(1, i), 1), add_edge(getid(1, i), s, 0); for (int i = 1; i &lt;= n3; ++i) add_edge(getid(4, i), t, 1), add_edge(t, getid(4, i), 0); printf(&quot;%d\\n&quot;, dinic()); return 0; } 6.[USACO12OPEN]书架Bookshelf当农夫约翰闲的没事干的时候，他喜欢坐下来看书。多年过去，他已经收集了 N 本书 (1 &lt;= N &lt;= 100,000)， 他想造一个新的书架来装所有书。 每本书 i 都有宽度 W(i) 和高度 H(i)。书需要按顺序添加到一组书架上；比如说，第一层架子应该包含书籍1 … k，第二层架子应该以第k + 1本书开始，以下如此。每层架子的总宽度最大为L（1≤L≤1,000,000,000）。每层的高度等于该层上最高的书的高度，并且整个书架的高度是所有层的高度的总和，因为它们都垂直堆叠。 请帮助农夫约翰计算整个书架的最小可能高度。 有N(1 &lt;= N &lt;= 100000)本书，每本书有一个宽度W(i)，高度H(i)，(1 &lt;= H(i) &lt;= 1,000,000; 1 &lt;= W(i) &lt;= L)。 现在有足够多的书架，书架宽度最多是L (1 &lt;= L &lt;= 1,000,000,000)，把书按顺序（先放1，再放2…..）放入书架。某个书架的高度是该书架中所放的最高的书的高度。 将所有书放入书架后，求所有书架的高度和的最小值？ 首先考虑$O(N^2)$的暴力DP，很好写出以下的转移方程： F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))其中满足 W_{j+1},W_{j+2},\\cdots,W_i\\le L不难发现$W$的限制满足单调性，所以我们可以通过二分得到 也就是说 F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))满足 left_i\\le j所以我们可以用线段树优化，维护区间赋值，区间最小值，单点修改三个操作。 但这样还不够，我们还需要开一个单调栈，当然单调队列也可以(不过我懒) 枚举每一个位置然后找出第一个大于$H_i$的位置$lef$，将$[lef+1,i]$这段区间的值赋为$H_i$ 进而可以发现我们只需要每次区间修改$H$的值，查询直接在这一段区间查询就好了 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) using namespace std; typedef long long ull; const int SIZE = 100000 + 5; const ull INF = 1e18; stack &lt; ull &gt; S; ull n, limit, W[SIZE], H[SIZE], pre[SIZE]; ull list[SIZE], dp[SIZE], val[SIZE &lt;&lt; 2]; ull minval[SIZE &lt;&lt; 2], flag[SIZE &lt;&lt; 2]; inline void make(int k, int l, int r) { minval[k] = val[k] = flag[k] = INF; if (l ^ r) make(lson, l, mid), make(rson, mid + 1, r); } inline void push(int k) { if (flag[k] ^ INF) { minval[lson] = val[lson] + flag[k]; minval[rson] = val[rson] + flag[k]; flag[lson] = flag[rson] = flag[k]; flag[k] = INF; } } inline int update(int k, int l, int r, int x, int y, int v) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k] = val[k] + v, flag[k] = v, 0; push(k); if (mid &gt;= x) update(lson, l, mid, x, y, v); if (mid &lt; y) update(rson, mid + 1, r, x, y, v); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); return 0; } inline void modify(int k, int l, int r, int x) { if (l ^ r) { push(k); if (mid &gt;= x) modify(lson, l, mid, x); else modify(rson, mid + 1, r, x); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); } else minval[k] = INF, val[k] = dp[l - 1]; } inline ull query(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k]; push(k); ull res = INF; if (mid &gt;= x) res = min(res, query(lson, l, mid, x, y)); if (mid &lt; y) res = min(res, query(rson, mid + 1, r, x, y)); return res; } signed main() { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;limit); make(1, 1, n); S.push(1); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld %lld&quot;, &amp;H[i], &amp;W[i]), list[i] = list[i - 1] + W[i]; for (int i = 2; i &lt;= n; ++i) { while (S.size() &amp;&amp; H[i] &gt; H[S.top()]) S.pop(); if (S.size()) pre[i] = S.top(); S.push(i); } for (int i = 1; i &lt;= n; ++i) { modify(1, 1, n, i); if (pre[i] + 1 &lt;= i) update(1, 1, n, pre[i] + 1, i, H[i]); int lef = lower_bound(list, list + 1 + i, list[i] - limit) - list; if (lef &lt; i) dp[i] = query(1, 1, n, lef + 1, i); } printf(&quot;%lld\\n&quot;, dp[n]); return 0; } 7.P1110 [ZJOI2007]报表统计Q的妈妈是一个出纳，经常需要做一些统计报表的工作。今天是妈妈的生日，小Q希望可以帮妈妈分担一些工作，作为她的生日礼物之一。 经过仔细观察，小Q发现统计一张报表实际上是维护一个非负整数数列，并且进行一些查询操作。 在最开始的时候，有一个长度为N的整数序列，并且有以下三种操作： INSERT i k：在原数列的第i个元素后面添加一个新元素kk；如果原数列的第ii个元素已经添加了若干元素，则添加在这些元素的最后（见下面的例子）MIN_GAP：查询相邻两个元素的之间差值（绝对值）的最小值MIN_SORT_GAP：查询所有元素中最接近的两个元素的差值（绝对值）例如一开始的序列为5, 3, 15,3,1。 执行操作INSERT 2 9将得到：5, 3, 9, 15,3,9,1，此时MIN_GAP为22，MIN_SORT_GAP为22。 再执行操作INSERT 2 6将得到：5, 3, 9, 6, 15,3,9,6,1 注意这个时候原序列的第22个元素后面已经添加了一个99，此时添加的66应加在99的后面。这个时候MIN_GAP为22，MIN_SORT_GAP为11。 于是小Q写了一个程序，使得程序可以自动完成这些操作，但是他发现对于一些大的报表他的程序运行得很慢，你能帮助他改进程序么？ 待坑，先留着 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define sgt_mid ((SGT[k].l + SGT[k].r) &gt;&gt; 1) #define mid ((l + r) &gt;&gt; 1) #define U int k, int l, int r #define H int k, int x, int val #define transfer SGT[k].val = min(SGT[lson].val, SGT[rson].val) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) #define LRE lson, l, mid #define RRE rson, mid + 1, r #define LWA lson, x, val #define RWA rson, x, val #define int long long using namespace std; const int SIZE = 500000 + 5; const int INF = 0x7fffffff; int a[SIZE], b[SIZE], root; int n, m, tot, MIN_GAP, MIN_SORT_GAP; struct SPLAY { int ch[2]; int val; int fa; } SBT[SIZE]; struct TREE { int l; int r; int val; } SGT[SIZE]; template &lt; typename T &gt; inline T ads(T x) { return x &gt; 0 ? x : -x; } /*****************SplayArea*****************/ inline void rotate(int x) { int y = SBT[x].fa; int z = SBT[y].fa; int w = SBT[y].ch[1] == x; SBT[z].ch[SBT[z].ch[1] == y] = x; SBT[x].fa = z; SBT[y].ch[w] = SBT[x].ch[w ^ 1]; SBT[SBT[x].ch[w ^ 1]].fa = y; SBT[x].ch[w ^ 1] = y; SBT[y].fa = x; } inline void splay(int x, int goal) { for (; SBT[x].fa ^ goal; rotate(x)) { int y = SBT[x].fa; int z = SBT[y].fa; if (z ^ goal) SBT[z].ch[1] ^ y ^ SBT[y].ch[1] ^ x ? rotate(x) : rotate(y); } if (!goal) root = x; } inline void insert(int x) { int u = root, fa = 0; while (u &amp;&amp; SBT[u].val ^ x) fa = u, u = SBT[u].ch[x &gt; SBT[u].val]; if (u) return ; u = ++tot; SBT[u].fa = fa; if (fa) SBT[fa].ch[x &gt; SBT[fa].val] = u; SBT[u].val = x; splay(u, 0); } inline void find(int x) { int u = root; if (!u) return ; while (SBT[u].ch[x &gt; SBT[u].val] &amp;&amp; SBT[u].val ^ x) u = SBT[u].ch[x &gt; SBT[u].val]; splay(u, 0); } inline int next_(int x, int f) { find(x); int u = root; if (SBT[u].val == x) return SBT[u].val; if (SBT[u].val &lt; x &amp;&amp; !f) return SBT[u].val; if (SBT[u].val &gt; x &amp;&amp; f) return SBT[u].val; u = SBT[u].ch[f]; while (SBT[u].ch[f ^ 1]) u = SBT[u].ch[f ^ 1]; return SBT[u].val; } /*****************EndSplay*****************/ /*****************SegmentTreeArea*****************/ inline void make(U) { SGT[k].l = l, SGT[k].r = r; if (l ^ r) make(LRE), make(RRE), transfer; else SGT[k].val = ads(a[l] - a[l - 1]); } inline void modify(H) { if (SGT[k].l ^ SGT[k].r) if (sgt_mid &gt;= x) modify(LWA), transfer; else modify(RWA), transfer; else SGT[k].val = val; } /*****************EndSegmentTree*****************/ inline void Initialize() { MIN_GAP = INF, MIN_SORT_GAP = INF; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); insert(INF), insert(-INF); a[0] = INF, a[n + 1] = INF; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); if (i ^ 1) { int l_limit = next_(a[i], false), r_limit = next_(a[i], true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(l_limit - a[i]), ads(r_limit - a[i]))); } insert(a[i]); b[i] = a[i]; } make(1, 1, n); for (int i = 1; i &lt;= m; ++i) { char S[SIZE]; scanf(&quot;%s&quot;, S); if (*S == &#39;I&#39;) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); int l_limit = next_(y, false); int r_limit = next_(y, true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(y - l_limit), ads(y - r_limit))); insert(y); MIN_GAP = min(MIN_GAP, ads(b[x] - y)); modify(1, x + 1, ads(a[x + 1] - y)); b[x] = y; } else if (S[4] == &#39;G&#39;) printf(&quot;%d\\n&quot;, min(MIN_GAP, SGT[1].val)); else printf(&quot;%d\\n&quot;, MIN_SORT_GAP); } } signed main() { Initialize(); return 0; } 8.Link Cut Tree （动态树）给定 n 个点以及每个点的权值，要你处理接下来的 m 个操作。操作有四种，操作从 0 到 3 编号。点从 1 到 n 编号。 0 x y 代表询问从 x 到 y 的路径上的点的权值的 xor 和。保证 x 到 y 是联通的。 1 x y 代表连接 x 到 y，若 x 到 y 已经联通则无需连接。 2 x y 代表删除边 (x,y)，不保证边 (x,y) 存在。 3 x y 代表将点 x 上的权值变成 y。 模板题没什么好说的，放一下代码就好了，如果要学LCT可以自己看博客(首先要学splay(not fhq-treap)) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; } // 需要233.cpp 9.P5227 [AHOI2013]连通图给定一个无向连通图和若干个小集合，每个小集合包含一些边，对于每个集合，你需要确定将集合中的边删掉后改图是否保持联通。集合间的询问相互独立 定义一个图为联通的当且仅当对于任意的两个顶点，都存在一条路径连接它们 暴力LCT，维护把时间当成权值的最大生成树 因为我们是离线算法，所以我们可以得到每一条边的删除时间 顺便维护一个权值最小的边的编号 %:include &lt;cstdio&gt; %:include &lt;iostream&gt; %:include &lt;algorithm&gt; %:include &lt;cstring&gt; %:include &lt;queue&gt; using namespace std; const int SIZE = 1e7 + 5; const int INF = 0x7fffffff; struct ReadNode &lt;% template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) &lt;% a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; %&gt; template &lt; typename T&gt; void write(T x) &lt;% if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); %&gt; template &lt; typename T&gt; void operator &lt;&lt; (T x) &lt;% write(x); %&gt; %&gt; win; int n, m; /******************LinkCutTree******************/ class LinkCutTree &lt;% public: struct TreeNode &lt;% int ch&lt;:2:&gt;; int fa; int val; int siz; int cnt; int miv; bool rev; %&gt; T&lt;:SIZE:&gt;; inline void exch(int &amp;x, int &amp;y) &lt;% x ^= y ^= x ^= y; %&gt; inline void push1(int x) &lt;% T&lt;:x:&gt;.siz = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.siz + T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz +T&lt;:x:&gt;.cnt + (x &lt;= n); x &gt; n &amp;&amp; (T&lt;:x:&gt;.miv = x); %&gt; inline void push2(int x) &lt;% (T&lt;:x:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv); (T&lt;:T&lt;:x:&gt;.miv:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv); %&gt; inline void transfer(int x) &lt;% push1(x); push2(x); %&gt; inline bool which(int x) &lt;% return T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; == x; %&gt; inline bool isroot(int x) &lt;% return (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:0:&gt; ^ x) &amp;&amp; (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; ^ x); %&gt; inline void rotate(int x) &lt;% int y = T&lt;:x:&gt;.fa, z = T&lt;:y:&gt;.fa, w = which(x), test = which(y), s = T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt;; (!isroot(y)) &amp;&amp; (T&lt;:z:&gt;.ch&lt;:test:&gt; = x); T&lt;:y:&gt;.ch&lt;:w:&gt; = s, T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt; = y; (s) &amp;&amp; (T&lt;:s:&gt;.fa = y); T&lt;:x:&gt;.fa = z, T&lt;:y:&gt;.fa = x; transfer(y); %&gt; inline void reverse(int x) &lt;% exch(T&lt;:x:&gt;.ch&lt;:0:&gt;, T&lt;:x:&gt;.ch&lt;:1:&gt;), T&lt;:x:&gt;.rev ^= 1; %&gt; inline void push_down(int x) &lt;% if (T&lt;:x:&gt;.rev) &lt;% if (T&lt;:x:&gt;.ch&lt;:0:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:0:&gt;); if (T&lt;:x:&gt;.ch&lt;:1:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:1:&gt;); T&lt;:x:&gt;.rev = 0; %&gt; %&gt; inline void push_up(int x) &lt;% (!isroot(x)) &amp;&amp; (push_up(T&lt;:x:&gt;.fa), 1); push_down(x); %&gt; inline void splay(int x) &lt;% push_up(x); for (; !isroot(x); rotate(x)) (!isroot(T&lt;:x:&gt;.fa)) &amp;&amp; ((which(x) == which(T&lt;:x:&gt;.fa) ? rotate(T&lt;:x:&gt;.fa) : rotate(x)), 1); transfer(x); %&gt; inline void access(int x) &lt;% for (int i = 0; x; x = T&lt;:i = x:&gt;.fa) splay(x), T&lt;:x:&gt;.cnt += T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz, T&lt;:x:&gt;.cnt -= T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt; = i:&gt;.siz, transfer(x); %&gt; inline void makeroot(int x) &lt;% access(x), splay(x), reverse(x); %&gt; inline void split(int x, int y) &lt;% makeroot(y), access(x), splay(x); %&gt; inline int getroot(int x) &lt;% access(x), splay(x), push_down(x); for (; T&lt;:x:&gt;.ch&lt;:0:&gt;; push_down(x = T&lt;:x:&gt;.ch&lt;:0:&gt;)); return splay(x), x; %&gt; inline void init(int length, int data) &lt;% for (int i = 0; i &lt;= length; ++i) T&lt;:i:&gt;.val = data; %&gt; inline void connect(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = x, T&lt;:x:&gt;.cnt += T&lt;:y:&gt;.siz, transfer(x); %&gt; inline void erase(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = T&lt;:x:&gt;.ch&lt;:0:&gt; = 0, transfer(x); %&gt; inline bool find() &lt;% return access(1), splay(1), (T&lt;:1:&gt;.siz == n); %&gt; %&gt; lct_mast; /*****************EndLinkCutTree*****************/ int now&lt;:SIZE:&gt;, num, ans&lt;:SIZE:&gt;, st&lt;:SIZE:&gt;, top; struct EdgeNode &lt;% int from; int to; int dis; %&gt; edge&lt;:SIZE:&gt;; struct LycNode &lt;% bool opt, tag; int idx; %&gt; H&lt;:SIZE:&gt;; signed main() &lt;% win &gt;&gt; n; win &gt;&gt; m; lct_mast.init(n, INF); for (int i = 1; i &lt;= m; ++i) &lt;% int x, y; win &gt;&gt; x; win &gt;&gt; y; edge&lt;:i:&gt; = &lt;%x, y%&gt;; now&lt;:i:&gt; = i; H&lt;:++num:&gt; = &lt;%1, 0, i%&gt;; %&gt; int k, tot = m; win &gt;&gt; k; for (int i = 1; i &lt;= k; ++i) &lt;% int x; win &gt;&gt; x; for (int j = 1; j &lt;= x; ++j) &lt;% int y; win &gt;&gt; y; edge&lt;:now&lt;:y:&gt;:&gt;.dis = i - 1; lct_mast.T&lt;:now&lt;:y:&gt; + n:&gt;.val = i - 1; H&lt;:++num:&gt; = &lt;%0, 0, now&lt;:y:&gt;%&gt;; edge&lt;:++tot:&gt;.from = edge&lt;:now&lt;:y:&gt;:&gt;.from; edge&lt;:tot:&gt;.to = edge&lt;:now&lt;:y:&gt;:&gt;.to; now&lt;:y:&gt; = tot; st&lt;:++top:&gt; = now&lt;:y:&gt;; %&gt; H&lt;:++num:&gt;.tag = true; if (i ^ k) while (top) H&lt;:++num:&gt; = &lt;%1, 0, st&lt;:top--:&gt;%&gt;; %&gt; for (int i = 1; i &lt;= m; ++i) if (!edge&lt;:now&lt;:i:&gt;:&gt;.dis) edge&lt;:now&lt;:i:&gt;:&gt;.dis = k, lct_mast.T&lt;:now&lt;:i:&gt; + n:&gt;.val = k; tot += n; for (int i = 1; i &lt;= tot; ++i) lct_mast.T&lt;:i:&gt;.siz = 1; for (int i = 1; i &lt;= num; ++i) &lt;% if (H&lt;:i:&gt;.tag) puts(lct_mast.find() ? &quot;Connected&quot; : &quot;Disconnected&quot;); else &lt;% int j = H&lt;:i:&gt;.idx, from = edge&lt;:j:&gt;.from; int to = edge&lt;:j:&gt;.to, dis = edge&lt;:j:&gt;.dis; lct_mast.makeroot(from); if (H&lt;:i:&gt;.opt) &lt;% if (lct_mast.getroot(to) == from) &lt;% int mix = lct_mast.T&lt;:from:&gt;.miv; if (lct_mast.T&lt;:mix:&gt;.val &gt;= dis) continue; lct_mast.erase(edge&lt;:mix - n:&gt;.from, mix); lct_mast.erase(edge&lt;:mix - n:&gt;.to, mix); %&gt; lct_mast.connect(from, j + n); lct_mast.connect(to, j + n); %&gt; else &lt;% if (lct_mast.getroot(to) == from) &lt;% lct_mast.transfer(j + n); if (!lct_mast.T&lt;:j + n:&gt;.fa &amp;&amp; !lct_mast.T&lt;:j + n:&gt;.siz) continue; lct_mast.erase(edge&lt;:j:&gt;.from, j + n); lct_mast.erase(edge&lt;:j:&gt;.to, j + n); %&gt; %&gt; %&gt; %&gt; return 0; %&gt; 10.[TJOI2018]异或现在有一颗以$1$为根节点的由$n$个节点组成的树，树上每个节点上都有一个权值$v_i$。现在有$Q$次操作，操作如下： $1\\;x\\;y$：查询节点$x$的子树中与$y$异或结果的最大值 $2\\;x\\;y\\;z$：查询路径$x$到$y$上点与$z$异或结果最大值 这是一道可持久化$01Trie$树+树链剖分的好题。 但是树剖是出了名的难打，仔细看题，可以发现只需要$DFS$序便可以解决问题 对于第一个操作，直接用$DFS$序维护$sub_tree$的信息即可 对于第二个操作，可以考虑在$DFS$遍历整棵树的同时插入权值 查询的话直接上$LCA$ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = (100000 + 5) &lt;&lt; 1; int head[SIZE], ver[SIZE]; int nxt[SIZE], edge[SIZE]; int n, q, fuck, a[SIZE]; inline void pushEdge(int x, int y, int z) { ver[++fuck] = y, edge[fuck] = z; nxt[fuck] = head[x], head[x] = fuck; } struct ZeroOneTrie { int root[SIZE], cnt; int trie[SIZE &lt;&lt; 6][2]; int frie[SIZE &lt;&lt; 6]; ZeroOneTrie() { root[0] = cnt = 1; } inline void insert(int last, int &amp;lyc, int x) { int rt = lyc = ++cnt; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; trie[rt][!now] = trie[last][!now]; trie[rt][now] = ++cnt; rt = trie[rt][now]; last = trie[last][now]; frie[rt] = frie[last] + 1; } } inline int find(int l, int r, int x) { int res = 0; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; if (frie[trie[r][!now]] - frie[trie[l][!now]]) { r = trie[r][!now]; l = trie[l][!now]; res |= 1 &lt;&lt; i; } else { r = trie[r][now]; l = trie[l][now]; } } return res; } } t0, t1; int dfn[SIZE], L[SIZE], R[SIZE]; int num, fa[SIZE][30], depth[SIZE]; inline void dfs(int x, int pre) { t1.insert(t1.root[pre], t1.root[x], a[x]); fa[x][0] = pre; depth[x] = depth[pre] + 1; L[x] = ++num; dfn[num] = a[x]; for (int i = head[x]; ~i; i = nxt[i]) if (ver[i] ^ pre) dfs(ver[i], x); R[x] = num; } inline int lca_mast(int x, int y) { if (depth[x] &lt; depth[y]) swap(x, y); for (int i = 25; ~i; --i) if (depth[fa[x][i]] &gt;= depth[y]) x = fa[x][i]; if (x ^ y) { for (int i = 25; ~i; --i) if (fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0]; } else return x; } signed main() { memset(head, -1, sizeof head); scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt; n; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); pushEdge(from, to, 1); pushEdge(to, from, 1); } dfs(1, 0); for (int j = 1; j &lt;= 25; ++j) for (int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (int i = 1; i &lt;= n; ++i) t0.insert(t0.root[i - 1], t0.root[i], dfn[i]); for (int i = 1; i &lt;= q; ++i) { int opt, x, y, z; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt ^ 1) { scanf(&quot;%d&quot;, &amp;z); int ans = lca_mast(x, y); printf(&quot;%d\\n&quot;, max(t1.find(t1.root[fa[ans][0]], t1.root[x], z), t1.find(t1.root[fa[ans][0]], t1.root[y], z))); } else { printf(&quot;%d\\n&quot;, t0.find(t0.root[L[x] - 1], t0.root[R[x]], y)); } } return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"数据结构100题 ---圆方树","slug":"DS100P-ROUND-SQUARE-TREE","date":"2020-02-08T05:44:40.000Z","updated":"2020-02-18T10:08:35.526Z","comments":true,"path":"2020/02/08/DS100P-ROUND-SQUARE-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-ROUND-SQUARE-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---博弈树","slug":"DS100P-GAME-TREE","date":"2020-02-08T05:41:27.000Z","updated":"2020-02-18T10:07:40.909Z","comments":true,"path":"2020/02/08/DS100P-GAME-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-GAME-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---虚树","slug":"DS100P-VIRTUAL-TREE","date":"2020-02-08T05:40:33.000Z","updated":"2020-02-18T10:07:04.195Z","comments":true,"path":"2020/02/08/DS100P-VIRTUAL-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-VIRTUAL-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---环套树","slug":"DS100P-RING-TREE","date":"2020-02-08T05:39:43.000Z","updated":"2020-02-18T10:06:38.730Z","comments":true,"path":"2020/02/08/DS100P-RING-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-RING-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---左偏树","slug":"DS100P-LEFT-SIDE-TREE","date":"2020-02-08T05:39:04.000Z","updated":"2020-02-18T10:05:45.641Z","comments":true,"path":"2020/02/08/DS100P-LEFT-SIDE-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-LEFT-SIDE-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---支配树","slug":"DS100P-DOMINATION-TREE","date":"2020-02-08T05:38:18.000Z","updated":"2020-02-18T10:05:07.263Z","comments":true,"path":"2020/02/08/DS100P-DOMINATION-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-DOMINATION-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---基环树","slug":"DS100P-BASE-RING-TREE","date":"2020-02-08T05:37:33.000Z","updated":"2020-02-18T10:04:39.551Z","comments":true,"path":"2020/02/08/DS100P-BASE-RING-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-BASE-RING-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---猫树","slug":"DS100P-CAT-TREE","date":"2020-02-08T05:37:14.000Z","updated":"2020-02-18T10:04:00.997Z","comments":true,"path":"2020/02/08/DS100P-CAT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-CAT-TREE/","excerpt":"","text":"0x01 引子首先引入这样一种问题：给定 $n$ 的范围，再给出一个长度为 $n$ 的序列，然后给出各种询问，询问的数量大于 $n$。比如说 $n=10^{6},q=10^{7}$。 考虑线段树，$\\log n$ 的查询当场死亡。 那么怎么办呢？猫锟大大就给出了一种 不支持修改但是可以做到 $\\Theta(n\\log n)$ 预处理 $\\Theta(1)$ 查询的数据结构——猫树 ，给大家分享一下原文章Link。 0x02 预处理部分具体过程按我的理解，猫树其实可以看做像 $DP$ 一样 把分治的过程记录下来 的东西。 举例来说，我们现在需要你查询序列的区间最大值和区间和之类的 具有区间可加性 的信息，查询区间为 $[l,r]$。 递归的来想，区间 $[l,r]$ 是由区间 $[l,mid]$ 和 $[mid+1,r]$ 两个区间合并而来的，那么我们是否能够使用预处理的手段使得所有可能的询问区间都可以通过合并来 $\\Theta(1)$ 得出答案呢？答案是没问题。 接下来我们看看具体的步骤： step1:我们将整个序列分为两部分，即 $[1,mid]$ 和 $[mid+1,n]$step2:分别从 $mid$ 向左从 $mid+1$ 向右，遍历整个区间step3:维护信息。比如说区间最大值，那么对于从 $mid$ 开始向左的区间，$maxvalue_{i}=max\\{max_{i+1},a_{i}\\}$，对于从 $mid+1$ 开始向右的区间同理step4:复读机 时间复杂度就像线段树一样，猫树是一颗二叉树，深度最多为 $\\log_{2}n$ 层，每一层我们需要 $\\Theta(n)$ 的时间进行维护信息的工作，所以预处理的时间复杂度为 $\\Theta(n\\log n)$。 啊对了，空间复杂度也是 $\\Theta(n\\log n)$，想想就明白了，这里为了节省篇幅就略掉了。 0x03 处理询问部分具体过程对于一个 询问 区间，我们可以把它放在某个 已经经过预处理的 并且 询问 区间经过 已经经过预处理的 的区间的 中点 的区间里。简而言之，我们设询问区间为 $q$，我们把 $q$ 放在一个区间 $t$ 里面，$t$ 的定义是已经经过预处理，并且询问区间 $q$ 跨过区间 $t$ 的中点。 为什么呢？其实很简单，既然 $t$ 已经经过了预处理，那么 $t$ 的中点把 $q$ 分成的两部分也一定经过了预处理，我们就可以 $\\Theta(1)$ 的合并了。 没有图始终没有感觉对吧？那么上图来理解吧。 这是一棵牛逼的树，我们给他取名叫牛逼树 哦！现在牛逼树上有了一个询问！ 哈！牛逼树上的询问成功的被第三层的某个区间分割啦！耶！ 平生没有这么傻过 时间复杂度查询的复杂度貌似是 $\\Theta(\\log n)$？不不不，既然前面说了查询是 $\\Theta(1)$ 的，那就一定是。接下来我们谈一谈优化的内容。 时间复杂度优化仔细想想如果我们不从根结点出发，而是从叶子结点来的话，这就是在求两个结点的 $LCA$ 嘛！但是有什么用呢？仔细想想，我们的牛逼猫树是一颗二叉树，而二叉树的 $LCA$ 是什么？ 这里有一个重要的性质，二叉树两个结点的 $LCA$ 就是二进制下的它们的编号的 最长公共前缀 。 比如说 $7$ 号结点和 $5$ 号结点的 $LCA$ 就是： $(0111)_{2}\\ \\ \\ (0101)_{2}$ 也就是 $(01)_{2}$ 也就是 $1$ 号结点。 那么我们如何找出两个数的二进制最长公共前缀呢？ 我们可以发现，我们将两个节点 $xor$ 起来，就能够去掉它们的最长公共前缀。于是我们就可以使用x&gt;&gt;log2[x^y]来获得两个结点的 $LCA$。 0x03 例题与代码# SP1043 GSS1 - Can you answer these queries I给出了序列 $A[1],A[2],…,A[N]$ 。 ($a[i]≤15007,1≤N≤50000$ )。查询定义如下： 查询 $(x,y)=\\max\\{a[i]+a[i+1]+…+a[j];x≤i≤j≤y\\}$。 给定$M$个查询，程序必须输出这些查询的结果。 题目让我们查询最大子段和，并且没有修改操作，我们可以通过猫树来玩这道题。 具体步骤上文已经写了，对于这道 板 题，我们可以直接记录最大子段和以及最大前缀和即可。 代码： // 省略了一些头文件、快读、预处理命令等东西，完整代码请移步至https://vjudge.net/solution/24123955 const int SIZE = 2e5 + 5; const int LOG_SIZE = 20; int n, m, real = 2, ints[SIZE]; // real:把n映射为2的幂形式 // ints:原序列 namespace CatsTree { int log2[SIZE]; // 预处理log2 int nodes[SIZE]; // 结点 int ans[LOG_SIZE][SIZE]; // 最大子段和 int preans[LOG_SIZE][SIZE]; // 最大前缀和 void MakeLog() { for (int i = 2, lim = real &lt;&lt; 1; i &lt;= lim; ++i) log2[i] = log2[i &gt;&gt; 1] + 1; } void BuildTree(int k, int l, int r, int s) { if (l ^ r) { ans[s][mid] = preans[s][mid] = ints[mid]; int pre, sum; pre = sum = ints[mid]; sum = sum &gt; 0 ? sum : 0; for (int i = mid - 1; i &gt;= l; --i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i + 1]); preans[s][i] = max(sum, preans[s][i + 1]); sum = sum &gt; 0 ? sum : 0; } ans[s][mid + 1] = preans[s][mid + 1] = ints[mid + 1]; pre = sum = ints[mid + 1]; sum = sum &gt; 0 ? sum : 0; for (int i = mid + 2; i &lt;= r; ++i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i - 1]); preans[s][i] = max(sum, preans[s][i - 1]); sum = sum &gt; 0 ? sum : 0; } BuildTree(ls, l, mid, s + 1); BuildTree(rs, mid + 1, r, s + 1); } else nodes[l] = k; } int GetAnswers(int l, int r) { if (l ^ r) { int s = log2[nodes[l]] - log2[nodes[l] ^ nodes[r]]; return max(ans[s][l] + ans[s][r], max(preans[s][l], preans[s][r])); } else return ints[l]; } } #define CT CatsTree void init() { read(n); while (real &lt; n) real &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) read(ints[i]); CT::BuildTree(1, 1, real, 1); CT::MakeLog(); } void solving() { read(m); for (int i = 0, l, r; i &lt; m; ++i) read(l, r), write(io_l, CT::GetAnswers(l, r)); } signed main() { init(); solving(); }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---K-D Tree","slug":"DS100P-K-D-TREE","date":"2020-02-07T12:03:42.000Z","updated":"2020-02-18T10:03:32.468Z","comments":true,"path":"2020/02/07/DS100P-K-D-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-K-D-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---Sqrt-Tree","slug":"DS100P-SQRT-TREE","date":"2020-02-07T10:49:19.000Z","updated":"2020-02-18T10:03:01.436Z","comments":true,"path":"2020/02/07/DS100P-SQRT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SQRT-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---块状数组","slug":"DS100P-BLOCK-ARRAY","date":"2020-02-07T10:48:41.000Z","updated":"2020-02-18T10:02:34.138Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-ARRAY/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---块状链表","slug":"DS100P-BLOCK-LIST","date":"2020-02-07T10:48:26.000Z","updated":"2020-02-18T10:02:00.609Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-LIST/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-LIST/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---树上分块","slug":"DS100P-TREE-FENKUAI","date":"2020-02-07T10:43:01.000Z","updated":"2020-02-18T09:59:53.333Z","comments":true,"path":"2020/02/07/DS100P-TREE-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-FENKUAI/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---后缀全家桶 之 后缀自动机","slug":"DS100P-SUFFIX-AUTOMATON","date":"2020-02-07T10:14:33.000Z","updated":"2020-02-18T09:59:18.508Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-AUTOMATON/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-AUTOMATON/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---后缀全家桶 之 后缀树","slug":"DS100P-SUFFIX-TREE","date":"2020-02-07T10:14:14.000Z","updated":"2020-02-18T09:58:53.787Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---Chtholly-Tree(Old-Driver Tree)","slug":"DS100P-CHTHOLLY-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:57:52.601Z","comments":true,"path":"2020/02/07/DS100P-CHTHOLLY-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHTHOLLY-TREE/","excerpt":"","text":"Chtholly-Tree众所周知，数据结构+算法=程序，可见数据结构的重要性数据结构占了我们编程的一大部分。数据结构的大家族中，有优美的线段树、树状数组等。但我们今天的主角却十分暴力。她的名字叫珂朵莉树 珂朵莉树是基于C++STL库中的set的数据结构。与线段树、平衡树等树形结构类似，珂朵莉树是用来解决区间问题的很暴力的树形结构。 她的特点是能够进行区间推平操作，并且时间复杂度接近O(n log m) 。但前提是数据随机。但一般不会有哪个出题人去卡这样一个并不出名的数据结构。并且要有区间推平操作，否则光是一个split时间复杂度会炸。 珂朵莉树的构造长成这个亚子: struct Chtholly { LL L; LL R; //区间 mutable LL _val; //值，注意，关键字mutable是必需的，否则会在add函数里CE node(LL l, LL r = -1, LL V = 0) : L(l), R(r), _val(V) {} bool operator&lt;(const node &amp;rhs) const { return L &lt; rhs.L; } } Split操作: inline IT split(int k) { IT it = st.lower_bound(node(k)); if (it != st.end() &amp;&amp; it-&gt;L == k) return it; --it; LL l = it-&gt;L, r = it-&gt;R; LL v = it-&gt;_val; st.erase(it); st.insert(node(l, k - 1, v)); return st.insert(node(k, r, v)).first; } 为了操作方便我们这里有一个define: #define IT set&lt;Chtholly&gt;::iterator assign区间推平操作，这也是珂朵莉树的时间复杂度保证 inline void assign(LL ll, LL rr, LL val) { IT itr = split(rr + 1), itl = split(ll); st.erase(itl, itr); st.insert(node(ll, rr, val)); } 举几个例子吧 区间求和:inline LL Qsum(LL ll, LL rr) { LL res = 0; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) res += (itl-&gt;R - itl-&gt;L + 1) * itl-&gt;_val; return res; } 区间第K小:inline LL kth(LL ll, LL rr, LL k) { vector&lt;pair&lt;LL, LL&gt; &gt; vec; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) vec.push_back(pair&lt;LL, LL&gt;(itl-&gt;_val, itl-&gt;R - itl-&gt;L + 1)); sort(vec.begin(), vec.end()); for (auto it = vec.begin(); it != vec.end(); ++it) { k -= it-&gt;second; if (k &lt;= 0) return it-&gt;first; } return -1; } 区间加inline void add(LL ll, LL rr, LL ad) { IT itr = split(rr + 1), itl = split(ll); for (; itr != itl; ++itl) itl-&gt;_val += ad; } 平时大家还是尽量少用······","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---主席树","slug":"DS100P-CHAIRMAN-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:58:24.474Z","comments":true,"path":"2020/02/07/DS100P-CHAIRMAN-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHAIRMAN-TREE/","excerpt":"","text":"主席树($nlogn$) “你是主席树吗？有那么多爷爷！”——$LJS$。 这句话运用打比方的说明方法，生动形象地说明了主席树每个节点可能有很多父亲的特点，体现说明语言的生动性。 也就是说，主席树的几个节点可能共用一个子节点。 就像这样： 主席树可以用来查询静态区间第k小，静态区间前k大的和等等。（用法十分灵活） 我们会创建很多版本的树，一些版本会共用一些节点，以节省空间和时间。 主席树也叫可持久化线段树。但可持久化还有很多东西。我就讲可持久化线段树吧。 1.如何共用节点我们考虑单点修改的线段树。 如果要得到这个序列某个元素$x$加上一个值$val$之后的新版本，我们发现，改变的只有对应元素$x$的节点和他的祖先会加上$val$。那么其他节点我们可以与上一个版本共用。 所以我们每次新建一个节点，继承之前该位置的值和左右儿子，然后更新值，再继续向下寻找元素$x$的位置，最后递归回来更新这个儿子。 我们使用$root$数组来记录每个版本的根节点编号。 代码： void ins(int l,int r,int pre,int &amp;now,int pos,int val)//区间左右端点，上一个版本中对应这个区间的点，当前版本中对应这个区间的点，修改位置，增加的值。 { nodes[++tot]=nodes[pre];//先整个复制 now=tot;//更新上一个节点的儿子。 nodes[now].sum+=val;//更新当前节点的值 if(l==r) return; //向下继续寻找 int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //调用：ins(1,n,root[i-1],root[i],p,v); 最后$root[i]$的引用就相当于记录了这个版本的根节点。 查询其实就和普通的线段树一样，但主席树的用途不止这个。 2.例题【模板】可持久化线段树 1（主席树） 如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。 权值线段树： (线段树的另一种应用，只是每个节点维护整个序列值在$[l,r]$区间内的数的个数) 这道题要求查询静态区间第$k$小。那么对于第$k$小这种问题，我们要使用权值线段树 离散化：$-1e9\\leq a_i \\leq1e9$ 的数据线段树肯定开不下，但这道题只需要求第k小，没有必要开那么大，可以对数据进行离散化。 我们按照序列的顺序插入$a_i$。得到每个$root[i]$代表的权值线段树代表从$a_1$到$a_i$的每个数值的出现次数。 那么根据前缀和的思想，区间$[l,r]$中每个数值的出现个数就是$[1,r]$的减去$[1,l-1]$的。那么数值的区间也具有这个性质。 所有对于每个询问，我们只需要查询一次，用$root[r]$和$root[l-1]$的权值线段树处理出区间$[l,r]$应有的权值线段树，就可以像正常的权值线段树一样查询第k小了。 代码： #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//插入，创建新版本 { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//现场处理，得到[x,y]区间内，值在[l,mid]内的数的个数 if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//如果k&lt;=X.说明第k小的数在左边。 else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//否则在右边。 } int getid(int X)//得到离散化后的数值 { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//离散化 for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//按顺序插入每个值，得到root[i]对应的权值线段树。 for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//查询区间[x,y]；输出原值 } return 0; } 3.缺点及注意事项内存池一般从1开始用，$nodes[0]$作为空白，值为$0$，儿子节点指向自己，值还是为$0$。 当你这个版本的树还没有改过某个节点的某个儿子时，这个节点的这个儿子会指向$nodes[0]$，也就相当于下面都是$0$，正好符合。 数组一定要开大，如果开得不够大可能会出现$MLE$,$TLE$,$RE$,$WA$. 但也不要开太大，不然会$MLE$,$CE$. 主席树是静态的，遇到要动态修改而不是生成一个新版本的问题，就可能要用树套树了。 可持久化可以用在很多数据结构上，平衡树，线段树，$trie$树……可够得写，但它们的思想都是相似的，都是每个版本与之前的版本共用节点以节省时间，空间。","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---分块","slug":"DS100P-FENKUAI","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:57:15.472Z","comments":true,"path":"2020/02/07/DS100P-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-FENKUAI/","excerpt":"","text":"分块($n\\sqrt n$) 分块其实也是一种暴力，但它是一种巧妙的暴力 它用来处理区间的问题。 把这个区间大概分成$\\sqrt n$块 然后再处理：对于一个整块，就整个处理掉；对于一个角块（不完整的块），就暴力处理。 比如区间求和。(非主流写法勿喷) 1.初始化对于每个元素，我们要处理出它是哪个块的，以便之后快速地找到它所在的块。 对于每个块，我们要统计出之后计算答案所需这个块内的结果（这里就是块内区间和），在区间中的左右端点，以及区间修改的懒标记。 代码： struct cude { int l,r,sum,lazy;//左右端点，区间和，懒标记 }cud[400]; int n,a[100010],bel[100010],each,cnt;//原数组大小及元素，每个元素的块编号，块大小，块数 void build() { each=sqrt(n); for(int i=0;i&lt;n;++i)//注意，我是从0开始存的原数组 { bel[i]=i/each;//预处理元素属于块 cud[bel[i]].sum+=a[i];//区间和 } for(int i=0;i*each&lt;n;++i) { ++cnt;//统计块数 cud[i].l=i*each;//块左端点 cud[i].r=min((i+1)*each-1,n-1);//块右端点，不可能达到n，所以取min，最多到n-1 } } 2.修改修改是很暴力的，我们对这个区间进行扫描。 整块就区间修改，懒标记。 角块就直接暴力扫过去修改。 最多$\\sqrt n$个整块，打懒标记$O(1)$，复杂度为$O(\\sqrt n)$ 最多$2$个角块，一个角块最多$\\sqrt n$个元素，暴力修改$O(\\sqrt n)$ 区间修改总时间复杂度$O(\\sqrt n)$ 代码： void update(int l,int r,int val) { for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i)//注意不要超过块数，我的块是从0开始编号的 { if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r)//整块打懒标记 { cud[i].lazy+=val; cud[i].sum+=(cud[i].r-cud[i].l+1)*val; } else//角块暴力扫 { if(cud[i].l&lt;l)//属于整个区间的最左边的角块，但还可能是最右边的角块，需要判断不要超出修改区间的右端点 { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } else//不是最左边的，那肯定是最右边的。 { for(int j=cud[i].l;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } } } } 3.查询查询也是很暴力的。 同样对这个区间进行扫描。 如果是整块，就直接加上这个块的区间和。 如果是角块，就要先下传懒标记，再暴力查询。 因为我们之前并没有修改元素值，只是加上了懒标记，修改了区间和。 所以我们现在要先修改这些元素的值再查询，否则查询到的值是修改之前的。 时间复杂度与修改相同，都是$O(\\sqrt n)$； 代码： //细节同2.修改 int find(int l,int r) { int res=0; for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i) if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r) res+=cud[i].sum; else { if(cud[i].lazy)//下传懒标记 { for(int j=cud[i].l;j&lt;=cud[i].r;++j) a[j]+=cud[i].lazy; cud[i].lazy=0; } if(cud[i].l&lt;l) { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) res+=a[j]; } else { for(int j=cud[i].l;j&lt;=r;++j) res+=a[j]; } } } return res; } 4.总结你看着这个东西好像很暴力，但它就是跑得过题。 它的总时间复杂度是$O(n\\sqrt n)$的，$500000$及以上就别想啦。 分块的题目很灵活，但一般都很暴力，有时区间修改不能打懒标记，就必须暴力修改，但有时你又可以跳过这个修改，进行“剪枝”。 就像花神游历各国，区间开方必须要在块里去暴力开 但我们想，$1$和$0$开方后都是本身，其它数开方就会变得越来越小，最后到$1$，所以我们可以维护一个块内是否全是$1$或$0$。 如果是，就可以跳过在这个区间里进行开方了，因为这个块里的元素开方之后都还是本身，每个元素和区间和都没有变。 其他的就是普通分块。 $\\ $ 在分块，你甚至可以打表 在区间中选取$\\sqrt n$个特征点，处理出它们间的信息。 对每个查询，选取最近的两个特征点的信息再从这两个特征点暴力跳过去。 这样就可以代替莫队啦。 而且分块没有任何离线操作，可以应对看起来像要用莫队（离线算法，同样$O(n\\sqrt n)$）才能解决，但又强制在线的题目。 以及，整除分块不是数据结构，是数论！！！","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---莫队","slug":"DS100P-MO-ALGORITHM","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:55:49.157Z","comments":true,"path":"2020/02/07/DS100P-MO-ALGORITHM/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-MO-ALGORITHM/","excerpt":"","text":"莫队($n\\sqrt{n}$) 0x01考虑这样一个问题： 对于一个序列$A_1,A_2,\\cdots,A_n$，有如下询问 形如$S\\ \\ l\\ \\ r$的命令表示对区间$[l,r]$求和，并输出 形如$Q\\ \\ l\\ \\ r$表示$\\cdots$ 本题不强制在线 对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改但我太弱不会 现在你有区间$[3,5]$的和，可以求$[3,6]$的区间和吗？显然，将$[3,5]$的区间和加上$A_6$即可。类似的，求$[2,4]$的区间和，我们只需减去$A_5$即可。 可以结合下图感知一下 0x02好，接下来我们想一下如何维护这种询问之间的关系。 很容易想到排序，首先我们对询问的左端点进行排序。再把整个询问序列分为$\\sqrt{n}$块，每块以内再按右端点排序。 所以我们可以得出以下结论： 莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案 0x03来一道简单的例题 小B的询问小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求： 其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。小B请你帮助他回答询问 这道题让我们求 \\sum\\limits_{i=1}^k c_i^2开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int SIZE = 5e4 + 5; struct QueryNode { int l, r; int id; // 储存询问的顺序，方便输出 } Q[SIZE]; int a[SIZE], n, m, k, pos[SIZE]; int cnt[SIZE], ans[SIZE], res; // a:原序列 // pos:每个位置所处的块 // cnt:桶 // ans:询问的答案 // res:每次调整所得到的贡献 inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); } inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); int block = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), pos[i] = i / block; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); // 这四句都是在对当前的区间对于询问的区间进行调整 while (r &lt; Q[i].r) add(++r); // 这三句都是在对当前的区间对于询问的区间进行调整 while (l &lt; Q[i].l) del(l++); // 这二句都是在对当前的区间对于询问的区间进行调整 while (r &gt; Q[i].r) del(r--); // 这一句都是在对当前的区间对于询问的区间进行调整 ans[Q[i].id] = res; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 0x04其实莫队是有套路的，基本上莫队的题都是这样的: for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); while (r &lt; Q[i].r) add(++r); while (l &lt; Q[i].l) del(l++); while (r &gt; Q[i].r) del(r--); ans[Q[i].id] = res; } 我们只需考虑$add$函数以及$del$函数即可","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---KMP","slug":"DS100P-KMP-STRING","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:56:44.103Z","comments":true,"path":"2020/02/07/DS100P-KMP-STRING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-KMP-STRING/","excerpt":"","text":"KMPupd:代码锅已补 0x00 前言本文和某播放软件KMPlayer没有一毛钱关系，并且： 伦家是数据结构！ 0x01 引入问题设想这样一个问题： 给你两个字符串，让你查找在文本串中模式串的位置。 暴力做法是显然的，举例来说： 文本串(text)：$a\\ b\\ c\\ b\\ c\\ g\\ l\\ x$ 模式串(pattern): $b\\ c\\ g\\ l$ 我们直接暴力枚举text中的每一个字符，并且依次与pattern中的字符从头开始匹配。时间复杂度为 $\\Theta(nm)$ 0x02 发现问题这样做其实有很多冗余操作。比如说：$b\\ c\\ g\\ l$ 与text中的 $b\\ c\\ b\\ c$ 不匹配，又从第text的第五个字母 $c$ 开始匹配。这样做是显然不必要的。为什么呢？因为模式串是以 $b$ 开头的，对于text中第五个字母 $c$ 显然我们可以不去匹配。发现了什么吗？每次失配后我们只需要从两个字符串的最长公共部分开始匹配即可。这里看不懂没有什么关系，只要能理解后面的例子就可以了。 0x03 解决一部分问题$\\qquad\\qquad\\quad\\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5\\ \\ 6\\ \\ 7\\ \\ 8\\ \\ 9\\ 10\\ 11$ 文本串(text)： $a\\ \\ b\\ \\ x\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ 模式串(pattern)： $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ 我们有两个指针i和j，分别指向文本串和模式串。在i=0,j=0以及i=1,j=1的时候都匹配上了。但是在i=2,j=2时失配了。如果时朴素算法的话会令i=1,j=0重新开始匹配。然而我们发现我们完全可以令i=3,j=0来重新匹配。一直到i=8,j=5时，它们又失配了。我们令j等于模式串和文本串已经配对完成的部分(即pattern[0]~pattern[4])的最长公共前缀后缀(即pattern[0,1]和pattern[3,4])的前缀末尾部分+1(即1+1=2)的地方，此时的text[6,7]和pattern[0,1]都是ab也就是说我们可以直接从i=8,j=2开始匹配，就可以匹配到模式串了。这就是KMP玄妙的地方。 0x04 解决另一部分问题那么问题来了：我们如何确定模式串最长公共前后缀的前缀末尾+1的位置呢？我们还是通过一个例子来感受。 $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ 模式串(pattern)： $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ (没错就是上面那个我太懒了) 我们可以设数组$next_i$为以 $i$ 为结尾的模式串最长公共前后缀的前缀末尾+1的位置。 $next_0$显然为0。 我们依然设两个指针i和j，i初始化为0，即指向模式串的开头。j初始化1，即i后面一个。 pattern[i]不等于pattern[j]，令next[i]=0，j+=1 pattern[i]依然不等于pattern[j]，令next[i]=0，j+=1 此时pattern[i]等于pattern[j]，令next[i]=j+1=1，i+=1，j+=1 此时pattern[i]等于pettern[j]，令next[i]=j+1=2，i+=1,j+=1 此时pattern[i]不等于patter[j]，并且j不在模式串的开头，令j=next[j-1]=2 此时pattern[i]依然不等于pattern[j]，并且j不在模式串的开头，令j=next[j-1]=0 此时pattern[i]依然不等于pattern[j]，但是j已经跑到开头去了，令i+=1 此时pattern[i]依然不等于pattern[j]，并且i已经跑到了尽头，求解结束。 %出来next数组是这样的:$[0,0,0,1,2,0]$ 0x05 解决所有问题其实就是放一下代码 我自认为讲的还是比较清楚，至少比蓝书好。 代码虽然和网上其他人的不太一样，不太标准，但还算简洁，至少比蓝书好。 总之一句话，学KMP不要看书，不要看书，不要看书！！！会死人的！！！ 对了还有一个坑点，我这份代码用std::string会RE，鬼知道我调了一下午发现是这个原因时心里有多傻逼 /* * P3375【模板】KMP字符串匹配.cpp * Created by boringhacker(c20220233wgy) */ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; namespace MAIN { const int SIZE = 1000000 + 5; int next[SIZE], n, m; char Text[SIZE], Pattern[SIZE]; // string Text, Pattern; 去你的std::string void GetNextVal() { int i = 1, j = 0; *next = 0; while (i &lt; n) { if (Pattern[i] == Pattern[j]) next[i] = j + 1, ++i, ++j; else if (j) j = next[j - 1]; else ++i; } } void GetAnswers() { int st = 0, res = -1; int i = 0, j = 0, flag = 0; while (true) { j = st; if (Text[i] == Pattern[j]) { if (!flag) res = i + 1 - st, flag = 1; // if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = 0, flag = 0; 这里出锅了，j应该赋为next[j-1] if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = next[j - 1], flag = 0; else ++i, ++j; st = j; if (i &gt;= m) return ; } else { if (j) st = next[j - 1]; else ++i; flag = 0; } } } void MAIN() { cin &gt;&gt; Text; cin &gt;&gt; Pattern; m = strlen(Text); n = strlen(Pattern); GetNextVal(); GetAnswers(); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; next[i] &lt;&lt; &#39; &#39;; } } signed main() { MAIN::MAIN(); return 0; } 欢迎捉虫子","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---线段树","slug":"DS100P-SEGMENT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:54:55.012Z","comments":true,"path":"2020/02/07/DS100P-SEGMENT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SEGMENT-TREE/","excerpt":"","text":"线段树 —LYC(ZBing)($nlogn$) 线段树，顾名思义，就是每个树的节点记录一条线段上的一些信息，非常灵活，可以实现很多操作，但常数比树状数组大一点。 就像这样： 线段树的经典应用就是统计区间和，我们这里也用这个来进行线段树的讲解。 1).建树我们先放代码吧，看代码理解。 void build(int l,int r,int x) { if(l==r) { nodes[x]=a[l]; return; } else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=nodes[x&lt;&lt;1]+nodes[(x&lt;&lt;1)+1]; } } 首先，我们遍历到线段树的每一个叶子节点。线段树的每个节点都代表了一个区间，当这个区间的$l=r$时，说明我们到达了叶子节点。这个叶子节点代表的区间只包含了$a[l]$这一个数，所以我们只需要将这个节点的值置为$a[l]$。 然后我们递归回去，每一个非叶子节点都可以把它代表的区间分成两半，对应它的两个子节点（可能没有两个）。它两个子节点的值就是这两个较小区间的元素和。由这两个子节点的值也就是这两个小区间的元素和相加就可以得到当前节点代表区间的元素和。 时间复杂度($nlogn$) 2).单点修改像这种区间和问题的单点修改一般都是给一个点加上一个值。 还是先放代码吧： void update(int l,int r,int x,int pos,int val) { nodes[x]-=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(l,mid,x&lt;&lt;1,pos,val); else update(mid+1,r,(x&lt;&lt;1)+1,pos,val); } 还是先递归找到要修改的叶子节点。先将它的值加上val。 然后再递归回去，因为往下找时找到的每一个节点代表的区间都包含这个叶子节点代表的区间，所以这些节点的值也要加上val。 时间复杂度($logn$) 3).区间查询区间查询的本质就是把要查询的区间拆分成很多小区间，直接利用之前维护的节点的值进行查询。 int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr||r&lt;=ba) return nodes[x]; int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } 我们对于当前递归查找到的节点所代表的区间与要查询的区间进行分类讨论： $1$&gt;.毫无关联 即当前区间的左端点在查询区间右端点的右边或当前区间的右端点在查询区间左端点的左边。 既然他们毫无关联，那么我们就返回一个值0，因为他们对这个区间的和没有任何贡献。 $2$&gt;.被包含 即当前区间的左端点在查询区间的左端点的右边且当前区间的右端点在查询区间的右端点的左边。 既然这个节点代表的区间全部属于查询区间内，那么我们就没有必要再继续递归下去了，直接把这个节点的值加上去。 $3$&gt;.有部分重叠但不被包含 即上两种情况的剩余情况。 对于这种情况，我们没有办法把节点的值直接加上去，因为这个节点代表的区间不全属于查询区间。也不能直接跳过，因为有部分节点属于查询区间。所以我们继续向它的子节点递归，相当于把这个区间分成两半，查询两个子区间中属于查询区间的值加起来。 时间复杂度（$logn$） 4).区间修改面对区间修改，如果我们继续用单点修改，时间复杂度会退回到（$n^2logn$） 所以我们引入人类的本质懒标记。 当我们找到了一个完全是要修改的区间，我们就直接把它的懒标记加上$val$。 对于中途遍历到的其他区间，我们直接计算修改这个区间的和。 代码： void update(int l,int r,int x,int fr,int ba,int val) { if(l&gt;ba||r&lt;fr) return; if(l&gt;=fr&amp;&amp;r&lt;=ba) lazy[x]+=val; else { nodes[x]+=val*max(0,min(r,ba)-max(l,fr)+1); int mid=(l+r)&gt;&gt;1; update(l,mid,x&lt;&lt;1,fr,ba,val); update(mid+1,r,(x&lt;&lt;1)+1,fr,ba,val); } } 长得和区间查询很像对吧 改了修改之后，我们的查询也要进行修改。要把打上的懒标记进行下传，不然查询到下面的节点时，下面的节点没有被修改。 下传时只需要让当前节点加上原来应加而拖延了的值，让它的左右儿子的懒标记加上它的懒标记。因为当初修改时，并没有修改到左右节点。最后再把懒标记清零。 就像这样： void pushdown(int l,int r,int x) { nodes[x]+=(r-l+1)*lazy[x]; lazy[x&lt;&lt;1]+=lazy[x]; lazy[(x&lt;&lt;1)+1]+=lazy[x]; lazy[x]=0; } int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(lazy[x]) pushdown(l,r,x); if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[x]; else { int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } } $\\ $ 线段树的讲解到这里就这么完了，但线段树的运用十分广泛，灵活。要熟练掌握并运用线段树，还要多动脑，想好题。","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---Link-Cut Tree","slug":"DS100P-LINK-CUT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:56:14.822Z","comments":true,"path":"2020/02/07/DS100P-LINK-CUT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-LINK-CUT-TREE/","excerpt":"","text":"Link-Cut Tree0x00本文的图来自Qiuly的博客浅谈link-cut Tree 本文照搬Qiuly的博客浅谈link-cut Tree lct这东西不好写，我这种蒟蒻写不好所以只能照搬Qiuly，跟Qiuly唯一的区别就是我字是自己打的…… 0x01LCT其实可以看做加强版的重链剖分，可以说重链剖分能做的LCT都能做。不仅如此，LCT代码比重链剖分短，常数有时比重链剖分小。 LCT由很多棵Splay组成，其中将Splay森林中的所有Splay连接起来的叫做 虚边 。Splay中边叫做实边。 原来的森林我们叫做原森林，用实边连起来的一棵树叫原树。Splay的关键字是节点在书中的深度。 Splay是LCT的辅助树。fhq-treap其实也可以，但均摊时间复杂度会多出一个\\log 0x02以下是一些LCT常用的基础操作 access(x):将x到root的路径上的边全部变成实边，并断开与自己儿子的联系 findroot(x):找出x所在原树的root makeroot(x):让x变为所在原树的root connect(x,y):连接x和y所在的原树 erase(x,y):拆开x和y所在的原树 split(x,y):将x,y搞在一棵辅助树 Access(x): 换句话来说就是将点x到原树中root之间的链丢到一个splay里 举个例子，现在有一个森林长成这样：&lt;/li&gt;&lt;/ul&gt; 现在x为6。我们access(x)。 那么{1-3，3-6}会变为实边，1-2会变成虚边，假设6有一儿子n，之间用实边连着，那么这条边也将变成虚边。 每次将 x 点 splay 到当前所在辅助树的根节点，将它的右儿子更新为上一个 x ，然后令 x 跳到它的父节点，第一个 x 的右儿子设为0。 为什么是右儿子而不是左儿子呢？ 因为fa[x]的深度小于x，而在Splay里面fa[x]是x的爸爸，所以x在Splay中是fa[x]的右儿子。 我们将 x 旋转到辅助树的根节点，也就是将当前原树这条链上深度小于 x (在 x 上面的点)丢到了 x 的左子树上，将 x 的右子树设为上一个 x 点相当于将 x 原来的右子树丢到了新的 splay 里面(而它们之间用虚边相连)，并且将上一段链连接起来。 现在就可以了。这棵新 Splay 中只有这条链上的结点，没有其他任何的结点。如果我们指定要这三个结点同时进行操作，可以直接下传lazy_tag到这三个结点组成的 Splay 的根结点哦!到后面Splay的时候就可以直接下传跟新结点信息了。 总体过程： 虚边：儿子认父，父不认子 实边：儿子认父，父也认子 用FlashHu的话来说： 1.转到根。 2.换儿子。 3.更新信息。 4.当前操作点切换为轻边所指的父亲，转1。 inline void Access(int x){ for(register int y=0;x;y=x,x=fa[x]){ Splay(x);//转 ch[x][1]=y;//认儿子了 pushup(x);//儿子有变化，更新 } } findroot(x): 首先要明白： 根节点是的深度最小的 我们可以通过x向上找，用 Access 操作可以将x和x的根结点搞到一个 Splay 里。 又因为有BST的性质：x的左子树所有结点的权值 &lt; x &lt; x右子树所有结点的权值。 而我们又知道，在执行完 Access 操作后，这课 Splay 里面的结点权值最大的(深度最大的)就是x。 于是我们可以将x Splay 到这棵 Splay 的根结点，那么现在最左边的节点便是这课树的根结点了。 inline int findroot(int x){ Access(x);//Access将x和根结点搞到同一个Splay中 Splay(x);//转到Splay的根结点 while(ch[x][0])pushdown(x),x=ch[x][0];//不断的找左儿子&amp;更新节点信息 return x;//最左边的就是根结点了。 } makeroot(x): 将x到根结点的路径上的点全部翻转(即x变成了根节点) 具体操作是我们先将x点与原树中的根打通一条链，那么现在它们就在同一棵辅助树里面了，我们发现x一定是在它所在的辅助树的中序遍历的最后一个的(因为它是这条链上最深的点)，我们把x点 splay 到辅助树的根上，那么x显然是没有右子树的，我们要实现将x移到原树的根上，也就是将x到根的这条链的深度全部翻转一遍，在辅助树上的体现就是将整棵树翻转一遍，我们可以写个翻转标记来减少复杂度。 inline void filp(int x){//Splay普通区间翻转 swap(ch[x][0],ch[x][1]);r[x]^=1; } inline void makeroot(int x){ Access(x); Splay(x); filp(x);//lazy_tag&amp;翻转区间 } split(x,y) 这个操作是将x到y之间的那条路径丢到一棵辅助树里，并且这棵辅助树以y节点为根。 Splay 维护的是原树中的一条链，我们不能保证x,y会在同一条链里。 所以我们可以先把x变成原树的根节点(这下子Access(y)就会将x到y之间的所有节点丢到一个 Splay 中了)。 inline void split(int x,int y){ makeroot(x);Access(y);Splay(y); } connect(x,y): 将x和y所在原树合并起来 首先将x点丢到原树的根，然后去找找y的根是不是x，如果不是说明x,y不在一个原树内，我们将x的父节点设为y，也就相当于从y到x连了一条虚边。 inline void connect(int x,int y){ makeroot(x);//转到根 if(findroot(y)!=x)fa[x]=y;//连接一条虚边 / erase(x,y): 首先我们先把x,y之间的那条边用split(x,y)拎出来，因为x,y是相邻的，所以y的左儿子一定是x，将它们的父子关系消灭掉即可。 消灭父子关系时一定满足以下条件： 1.x和y在一个原树里(不在一个树里面往哪儿切啊) 2.split之后x是y的左儿子 3.x的右儿子是空的(保证了中序遍历中y紧跟在x的后面，即深度相邻)(x的权值(深度)只比y小1，而x又正好是直接连着y的，所以我们无法再找到 &gt;x 而又 &lt;y 的整数了) inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1] fa[x]=ch[y][0]=0; }return; } 但是如果我们在findroot中添加了Splay的话，erase中x和y的父子关系就变了，需要改为这样，否则会出现一些奇奇怪怪的错误： inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;! fa[y]=ch[x][1]=0;pushup(x); de> 0X03 Splay的改动： 旋转的改动： 这里需要注意一下，如果x的父亲节点的父亲节点y已经不在当前的这棵辅助树上，只需要连单向边(也就是虚边，认父不认子)，否则正常连就行，这里要和普通的rotate区分开来。 做个对比： 现在的rotate(x): 这里的x可以不更新，因为会在下一次rotate时更新。 inline void rotate(int x){ int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; x;ch[x][!k]=y,ch[y][k]=v; if(v)fa[v]=y;fa[y]=x,fa[x]=z;pushup(y); } Splay的改动 同样要注意一下只能Splay到辅助树的根节点，Splay之前需先下传一下这一条链上需操作的所有的点，用栈来完成即可 inline void Splay(int x){ int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=fa[y]; while(top)pushdown( while(get(x)){//基本普通的Splay y=fa[x],top=fa[y]; rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); }pushup(x);return; } 最后放一下模板题代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---splay","slug":"DS100P-SPLAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:54:29.659Z","comments":true,"path":"2020/02/07/DS100P-SPLAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SPLAY/","excerpt":"","text":"update:增加几道好一点的例题吧 [NOI2004]郁闷的出纳员 [模板]文艺平衡树 [SHOI2013]发牌 [TJOI2010]中位数 [TJOI2007]书架 正文：关于SPLAY其实我更偏向于把splay叫做cosplay 讲平衡树总逃不过BST(Binary Search Tree)，二叉搜索树，以下是BST的性质： 一棵合法的BST每个节点上都带有一个数值，我们将其称为节点的“关键码”。那么对于一棵BST上的任意节点，满足： 该节点的关键码不小于它左子树的任意结点的关键码 该结点的关键码不大于它右子树的任意结点的关键码 显然，BST的中序遍历是一个递增的序列 建立一棵BST因为笔者很懒，不想到处判边界，所以我们一般可以在一棵空的BST中预先插入两个结点，一个正无穷，一个负无穷，如图: const int SIZE = 1e5 + 5; const int INF = 0x7fffffff; struct BSTNode { int l, r; // 左右儿子的编号 int val; // 关键码 } T[SIZE]; int tot, root; int clone(int val) { // 新建节点 T[++tot].val = val; return tot; } void build() { clone(-INF), clone(INF); root = 1, T[1].r = 2; } 以上是建树的代码 那么，BST就讲到这里 平衡树的诞生当BST形成一条链的时候，每次查询会变成$O(n^2)$ 这种深度过深的BST是不平衡的。所以我们需要一种能保持树的深度在$\\log(n)$的数据结构，于是便诞生了平衡树 SPLAYsplay，又称cosplay伸展树，有“序列之王”的美称，常数巨大，跑的没有$fhq-treap$快，但这不在我们的讨论范围以内 想象一下这样一颗BST，我们先把它们的大小关系列出来。 YY, X","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---树套树","slug":"DS100P-TREE-COVER-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:52:32.406Z","comments":true,"path":"2020/02/07/DS100P-TREE-COVER-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-COVER-TREE/","excerpt":"","text":"树套树($nlog^2n$) 树套树也是一种暴力思想，它可以有很多实现：树状数组套平衡树，主席树套树状数组…… 但是最常见的还是线段数套平衡树。 1.思想&amp;&amp;建树标准说法：线段树的每个节点对应平衡树的一个节点。 ??? 其实还是线段树每个节点对应一个区间，但是我们把这个区间建成一棵平衡树就行了，线段树节点记录这个区间建成的平衡树的根节点就行了。 线段树有$logn$层，每层的节点对应的区间能够拼成一个完整的区间，即每层$n$个平衡树节点，平衡树每个节点插入是$logn$的，所以建树的时间复杂度是$nlog^2n$ fhq-treap示例 void build(int l,int r,int x) { for(int i=l;i&lt;=r;++i) { split(root[x],a[i],root1,root2); root[x]=merge(merge(root1,newnode(a[i])),root2); } if(l^r) { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); } } 2.查询区间排名给定一个区间和一个值，查询区间中比他小的元素个数加1。 我们可以像线段树一样，先把这个区间拆分成一些能用我们之前建树建出的平衡树表示的小区间，再查询小区间中比这个值小的元素个数加起来的和。 很明显 f[i,j]=f[i,k]+f[k+1,j]（i\\leq k","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---树链剖分","slug":"DS100P-TREE-CHAIN-SPLITTING","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:52:28.062Z","comments":true,"path":"2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","excerpt":"","text":"树链剖分($nlogn$) 树链剖分准确地说并不是数据结构，它只是数据结构的一种应用。 它用于将一棵树上的节点转换到一个序列中，然后用各种数据结构维护。 所以我只讲如何转换和使用，而维护就因题而异了。 树链剖分有好几种方法：重链剖分，长链剖分… 但我就讲最常用的重链剖分。 重链剖分，顾名思义，就是按照节点的子树大小来剖分这棵树。 一个节点子节点中子树大小最大的子节点叫做这个节点的重儿子。 以一个轻儿子为起点，其余全是重儿子的链叫做重链。 重链上的边叫做重边。 就像这样（红色的边为重边） 可以发现，每个节点都在且仅在一条重链上，我们就可以把这一条链转换到一个连续的区间来进行维护。 dfs1我们采用dfs的形式来进行剖分，记录信息。 第一次dfs我们需要记录每个节点的父亲，子树大小，重儿子和深度。 很简单对吧，就是暴力$dfs$，但要注意不要搜回到父亲节点和一些其他的坑。 代码： void dfs1(int x,int last) { fa[x]=last;//记录父亲节点。 sum[x]=1;//初始化子树大小：该节点本身。 depth[x]=depth[last]+1;//深度：父亲节点深度+1。 int big=0,bi=0;//寻找重儿子 for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^last)//避免重新回到父亲节点 { dfs1(e[x][i],x); sum[x]+=sum[e[x][i]]; if(sum[e[x][i]]&gt;big) { big=sum[e[x][i]]; bi=e[x][i]; } } } son[x]=bi;//记录重儿子。 } //调用:dfs(root,root) dfs2经过刚刚$dfs1$的准备，我们可以进行剖分了，这次记录$dfs$序，转换出的序列上的每一个值，以及每个节点所在重链的起点。 我们在这次$dfs$时应该优先走重儿子，这样才能使一条重链上的值都在序列上连在一起，方便我们操作。 代码: void dfs2(int x,int last,bool heavier) { dfn[x]=++tot;//记录dfs序 turn[tot]=val[x];//记录序列 if(heavier) hb[x]=hb[fa[x]];// else hb[x]=x;//记录所在重链起点 if(b[x].son) build2(b[x].son,1);//优先遍历重儿子 for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^son[x]&amp;&amp;e[x][i]^fa[x]) build2(e[x][i],0);//避免重复遍历 } } 一个节点的$dfs$序就是它在序列中的位置。对吧 使用对于一些子树上的操作，$dfs$序已经能够搞定了，我们只需要用剖出的重链对那些结点间路径的操作进行应对就好了。 对于两个节点间的路径，我们很容易想到$LCA$。而我们记录了重链的起点，可以处理这条重链，然后直接跳到上面一条重链的末端。 注意当两个节点在同一条重链时跳出循环，在最后处理他们之间的路径。 由于他们已经在同一条重链上了，他们及他们之间的节点$dfs$序是连续的，所以再处理这个连续区间就好了。 代码： //设solve(x,y)是对x到y区间的操作(因题而异) ___ LCA(int x,int y) { int fx=hb[x],fy=hb[y];//得到重链起点 while(fx^fy) { if(depth[fx]&lt;depth[fy])//从深度大的往上跳 { swap(fx,fy); swap(x,y); } solve(dfn[fx],dfn[x]);//处理这条重链的区间 x=fa[fx];//跳到上面一条重链 fx=hb[x];//更新重链起点 } solve(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));//最后处理同一条重链上的剩余未处理部分。 //return ans; } 5.主席树($nlogn$) “你是主席树吗？有那么多爷爷！”——$LJS$。 这句话运用打比方的说明方法，生动形象地说明了主席树每个节点可能有很多父亲的特点，体现说明语言的生动性。 也就是说，主席树的几个节点可能共用一个子节点。 就像这样： 主席树可以用来查询静态区间第k小，静态区间前k大的和等等。（用法十分灵活） 我们会创建很多版本的树，一些版本会共用一些节点，以节省空间和时间。 主席树也叫可持久化线段树。但可持久化还有很多东西。我就讲可持久化线段树吧。 1.如何共用节点我们考虑单点修改的线段树。 如果要得到这个序列某个元素$x$加上一个值$val$之后的新版本，我们发现，改变的只有对应元素$x$的节点和他的祖先会加上$val$。那么其他节点我们可以与上一个版本共用。 所以我们每次新建一个节点，继承之前该位置的值和左右儿子，然后更新值，再继续向下寻找元素$x$的位置，最后递归回来更新这个儿子。 我们使用$root$数组来记录每个版本的根节点编号。 代码： void ins(int l,int r,int pre,int &amp;now,int pos,int val)//区间左右端点，上一个版本中对应这个区间的点，当前版本中对应这个区间的点，修改位置，增加的值。 { nodes[++tot]=nodes[pre];//先整个复制 now=tot;//更新上一个节点的儿子。 nodes[now].sum+=val;//更新当前节点的值 if(l==r) return; //向下继续寻找 int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //调用：ins(1,n,root[i-1],root[i],p,v); 最后$root[i]$的引用就相当于记录了这个版本的根节点。 查询其实就和普通的线段树一样，但主席树的用途不止这个。 2.例题【模板】可持久化线段树 1（主席树） 如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。 权值线段树： (线段树的另一种应用，只是每个节点维护整个序列值在$[l,r]$区间内的数的个数) 这道题要求查询静态区间第$k$小。那么对于第$k$小这种问题，我们要使用权值线段树 离散化：$-1e9\\leq a_i \\leq1e9$ 的数据线段树肯定开不下，但这道题只需要求第k小，没有必要开那么大，可以对数据进行离散化。 我们按照序列的顺序插入$a_i$。得到每个$root[i]$代表的权值线段树代表从$a_1$到$a_i$的每个数值的出现次数。 那么根据前缀和的思想，区间$[l,r]$中每个数值的出现个数就是$[1,r]$的减去$[1,l-1]$的。那么数值的区间也具有这个性质。 所有对于每个询问，我们只需要查询一次，用$root[r]$和$root[l-1]$的权值线段树处理出区间$[l,r]$应有的权值线段树，就可以像正常的权值线段树一样查询第k小了。 代码： #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//插入，创建新版本 { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//现场处理，得到[x,y]区间内，值在[l,mid]内的数的个数 if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//如果k&lt;=X.说明第k小的数在左边。 else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//否则在右边。 } int getid(int X)//得到离散化后的数值 { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//离散化 for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//按顺序插入每个值，得到root[i]对应的权值线段树。 for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//查询区间[x,y]；输出原值 } return 0; } 3.缺点及注意事项内存池一般从1开始用，$nodes[0]$作为空白，值为$0$，儿子节点指向自己，值还是为$0$。 当你这个版本的树还没有改过某个节点的某个儿子时，这个节点的这个儿子会指向$nodes[0]$，也就相当于下面都是$0$，正好符合。 数组一定要开大，如果开得不够大可能会出现$MLE$,$TLE$,$RE$,$WA$. 但也不要开太大，不然会$MLE$,$CE$. 主席树是静态的，遇到要动态修改而不是生成一个新版本的问题，就可能要用树套树了。 可持久化可以用在很多数据结构上，平衡树，线段树，$trie$树……可够得写，但它们的思想都是相似的，都是每个版本与之前的版本共用节点以节省时间，空间。","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---后缀全家桶 之 后缀数组","slug":"DS100P-SUFFIX-ARRAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-18T09:53:49.442Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-ARRAY/","excerpt":"","text":"后缀数组0x01 什么是后缀数组(Suffix Array)我们知道，对于一个长度为 $n$ 的字符串有 $n$ 个后缀，譬如对于字符串 $DCBAE$ 来说，它的后缀便是: 那么什么是后缀数组( $SA$ )呢？在我们对字符串的 $n$ 个后缀排序过后，我们定义后缀数组： $SA$ 数组：排在第i位的是第 $SA$ [i]个后缀 即后缀数组。 同时我们定义： RANK数组：排在第RANK[i]位的后缀是第i个后缀 不难看出RANK和 $SA$ 互逆 0x02 如何求出 $SA$ 数组(粗略的)朴素的做法是直接$sort$，$\\Theta(n^2\\log n)$ 爹妈恨铁不成钢。 稍微有点脑子都会想到$hash$但是依然爆炸。 如果深入思考的话很容易想到倍增，时间复杂度 $\\Theta(n\\log n)$ + 大常数碰上毒瘤题当场去世。 $DC3$？常数大，板子难背。 $LUOGU$ 日报曾经有过一片日报给出了一种诱导排序的解决方法，但是我不是很理解。 我在这里给出一种中文互联网上几乎没有任何资料的 $SA$ 数组线性时间复杂度构造方法(我也不知道叫什么名字)。 0x03 如何求出 $SA$ 数组(具体的)首先定义文本串 $text$ 为我们的待求 $SA$ 的字符数组 其次定义 $suffix_i$ 为以 $i$ 起头的 $text$ 的后缀 然后定义 $type_i = \\begin{cases}L, suffix_i &gt; suffix_{i+1} \\\\\\displaystyle S, suffix_i &lt; suffix_{i+1}\\end{cases}$ 参考图片(手写字可能有些看不清楚)： 字符串最后的是什么？你可以认为这是因为作者懒不想到处判边界而加上的比字符串中任意一个字符的ASCLL码都小的字符 再来定义 $dist_i$ 为 $text_i$ 距离上一个 $type_i$ 为 $S$ 的距离 参考图片(手写字可能有些看不清楚)： 再定义一个桶 $bucket$，以 $text$ 中的字符为区别桶之间的“键值”。依然参考图片 我们其实可以发现此时的 $bucket$ 已经和我们要求的 $SA$ 差的不远了。为什么呢？桶排啊！此时的桶外部其实已经是有序的了，只是我们内部还无法确定顺序。比如 $I$ 这个桶里，我们无法确定 $suffix_{2},suffix_{5},suffix_{8},suffix_{11}$ 的排序顺序，因为他们开头的首字母不同。那该怎么办呢？请继续往下看。 我们再定义一个桶 $D_lists$ “键值” 为 $list_i$。参考图片(注意此时我们不考虑键值(即 $dist$ )为0的情况) 以键值为1举一个例子。它的意思就是说 $dist$ 为1的情况有 $suffix_{9},suffix_{3,6}$ 这三种情况。与 $bucket$ 这个桶类似但不同的，我们能分清 $suffix_9$ 和 $sufiix_{3,6}$ 的顺序，但我们无法分清 $suffix_3$ 和 $suffix_6$ 的顺序。为什么呢？我们来看，下标为9的后缀是以 $P$ 开头的，然而下标为3和6的后缀却都是以 $S$ 开头的，所以 $suffix_9$ 一定排在 $suffix_{3,6}$ 的前面。$suffix_{3,6}$ 却因为首字母相同所以无法分清楚顺序。 下一步我们尝试将所有 $type$ 为 $S$ 的 $suffix$ 找出来 我们把 $bucket$ 扫一遍，即可得出： 图中的 $S-Substring$ 即为我们所求的所有 $type$ 为 $S$ 的 $suffix$。 同样，我们不知道 $suffix_{2,5,8}$ 哪个在前哪个在后。一种 $naive$ 的做法就是把 $[2,5,8]$ 依次+1，相当于直接暴力比较下一个字母，然后通过 $D_lists$ 来分析它们的先后关系。 我们发现了一个悲剧的事实：已经加到3了，我们却依然无法分清 $[2,5]$ 的顺序。如果继续加下去或许可以分清它们的顺序，但时间复杂度就难以保持在 $\\Theta(n)$，换句话说，它很容易被卡。 怎么办呢？我们分析一下这种情况出现的原因。 显然此时两个后缀的部分前缀是相同的。即下图的情况：","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---trie树","slug":"DS100P-TRIE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-08T12:28:22.937Z","comments":true,"path":"2020/02/07/DS100P-TRIE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TRIE/","excerpt":"","text":"trie树($\\sum{len}$) $trie$树，不是一种二叉树，它是一种多叉树（其实也可以是二叉树） 可以用来求一堆数中两个（或三个）异或起来的最大值。 可以查找单词。 对于一些有前缀的单词，比如WGY_2333和WGY_AND_LYC_WRITE_BLOG。 它们就可以共用树上的一些节点（即WGY_），查询时就可以从$\\ $2$\\ $和$\\ $L$\\ $来对他们进行区分 所以我们还是看看它是怎么实现的吧。 1&gt;.插入对于$trie$树，树上的每一条边都代表了一个字母或者一个数字。 所以一个节点会有很多儿子，我们就要开一个儿子数组$ch$。 要统计这个节点被经过了多少次，也就是多少单词有这个前缀，就要加一个$sum$。 要统计有多少个单词在这里结束，也就是要查询的单词有多少个已插入的单词作前缀，就要加一个$end$。 插入时，先看这个节点有没有你要走的那个儿子，如果没有，就新建一个，走下去。否则就直接走到这个儿子（共用节点嘛）。 代码：（以小写字母单词为例） struct node { int ch[26],sum,end; }nodes[MAXN]; int root=1,cnt=1; void ins(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].ch[str[i]-&#39;a&#39;]) nodes[x].ch[str[i]-&#39;a&#39;]=++cnt; x=nodes[x].ch[str[i]-&#39;a&#39;]; ++nodes[x].sum; } ++nodes[x].end; } 2&gt;.查询$trie$树的查询有很多种，一般依照题目要求来自己定义。 我们这里又以小写字母单词查询存在性为例。 同样是从最上面的根节点开始。如果当前节点有这个单词现在位置字母的儿子，就走下去。否则就直接返回false，因为之前没有过单词走过这条路径,如果有过这个前缀的单词走过，肯定会创建这个节点。 最后再判断有没有单词在这个地方结束。 代码: bool find(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].str[str[i]-&#39;a&#39;]) return false; x=nodes[x].str[str[i]-&#39;a&#39;]; } return nodes[x].end; } trie树就只有这么点，惊不惊喜，意不意外","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---fhq-treap","slug":"DS100P-FHQ-TREAP","date":"2020-02-05T06:51:05.000Z","updated":"2020-02-18T09:46:46.315Z","comments":true,"path":"2020/02/05/DS100P-FHQ-TREAP/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-FHQ-TREAP/","excerpt":"","text":"fhq-treap($nlogn$) $fhq-treap$是一种二叉搜索树。满足二叉搜索树的性质：中序遍历是一个不降序列。也就是说，一个节点的左儿子小于等于它，右儿子大于等于它。 但它和$treap$一样，都满足堆的性质：任意父节点的键值大于(等于)或小于(等于)子节点的键值。 它可以做普通平衡树（基本操作），文艺平衡树（区间操作），还可以可持久化。 但常数略大。 定义： struct node { int l,r,num,key,cum; //左儿子，右儿子，本节点的值，键值，子树大小 }nodes[MAXN]; 1.权值fhq-treap权值$fhq-treap$的意思是，它这时候既满足二叉搜索树的性质，又满足堆的性质。 先讲讲辅助操作吧： update:用来更新当前节点的子树大小。 代码实现： void update(int x) { nodes[x].cum=nodes[nodes[x].l].cum+nodes[nodes[x].r].cum+1; } 因为一个节点的子树大小等于它左右儿子的子树大小加上它本身嘛。 newnode:新建一个值为指定值的节点并返回它的编号。 代码实现： int newnode(int val) { nodes[++tot].cum=1; nodes[tot].num=val; nodes[tot].key=rand(); return tot; } 主要操作有两个： 1&gt;.分裂split这里的分裂按照权值分裂，即把原树按照权值$val$分成两棵树，一棵$X$中的权值全部小于等于$val$，另一棵y的权值全部大于$val$。而这两棵树都要满足两个性质。 要实现这个操作，我们要从根节点开始遍历，把整棵树分成两半。 我们进行分类讨论：现在遍历到的节点编号为$now$。 1).当$now=0$时 这时，now是一个空节点，没有办法分裂。 2).当$nodes[now].num\\leq val$时 这个节点以及它的左子树的权值都小于等于$val$,那么他们全部都属于$X$。 那么它的右子树可能是$X$的，也可能是$Y$的。 所以我们需要继续分裂右子树，但由于右边的数要比$nodes[now].num$大，接下来分裂出的小于等于$val$的子树需要接在当前分出的$X$树的右子树上。 3).否则 这个时候这个节点和它的右子树的权值都大于$val$，那么他们全部属于$Y$。 但它的左子树可能有一部分属于$X$。 所以我们需要继续分裂左子树。道理同上。 上面操作已经保证了分出的二叉树满足二叉树性质。而堆性质也得到了满足，因为从原树上往下分，分到节点的键值也是有序的。 递归返回前还要记得$update$一下，更新分裂后的子树大小。 是不是还是不懂？还是看代码和代码注释吧： //x,y代表从now这个节点分裂出的两棵树的根节点，使用引用返回值。 void split(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0;//情况1).无法继续分裂，所以两棵树都是空。 else { if(nodes[now].num&lt;=val)//情况2). { x=now;//左子树和这个节点都属于X树，接到之前分裂到的地方。右子树在下面会受到修改，所以右子树并没有被直接包括。 split(nodes[now].r,val,nodes[x].r,y);//继续分裂右子树。接下来分裂出属于X树的根节点位置应该是nodes[x].r，y的位置没有变动。 } else//情况3). { y=now; split(nodes[now].l,val,x,nodes[y].l);//同上 } update(now); //由于无论进入哪个判断，作了改变的节点都等于now,所以可以直接更新now。 } } //调用：split(root,v,root1,root2) 最后传回的值就相当于给$root1$,$root2$赋值。 $root1$,$root2$就是分裂出的$X$树和$Y$树的根节点。 2&gt;.合并merge即把两颗像刚刚上面分裂出来的两颗树合并成一棵满足两个性质的树。 我们又要分类讨论：现在需要合并的节点是$x$,$y$。（示例小根堆） 1).$x=0$|$\\ $|$y=0$ 只有一棵树，直接返回这棵树。 2).$nodes[x].key&lt;nodes[y].key$ $x$节点的键值更小，所以$x$应该在$y$的上面。 $y$的值一定大于$x$,所以把$y$和$x$的右子树进行合并。 3).否则 $y$应该在$x$的上面。 $x$的值一定小于$y$，所以把$y$的左儿子和$x$进行合并。 代码： int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } 学会了这两个操作之后，就可以实现普通平衡树的所有操作了。 3.插入插入的代码只有两行，非常简单。 只需要把原数按要插入的值$val$大小分裂，一边$x$小于等于$val$，另一边$y$大于$val$。 再把$x$与这个值节点合并（得到$z$），最后与$y$合并。 因为$x$的节点全部小于等于$val$,$z$的节点全部小于$y$。满足我们之前合并两棵树的条件。 代码： void ins(int val) { split(root,val,root1,root2); root=merge(merge(root1,newnode(val)),root2); } 4.删除先把要删除的值$val$从原树中分裂出来，删掉一个再合并回去。 怎么在很多的$val$中删掉一个呢。 我们把$val$子树根节点的左右节点合并起来，就相当于抛弃了这个根节点。 这样保证了如果有这个值，一定会被删掉，因为如果有，那么根节点肯定有。 代码： void del(int val) { split(root,val,root1,root2); split(root1,val-1,root1,root3); root3=merge(nodes[root3].l,nodes[root3].r); root=merge(merge(root1,root3),root2); } 5.前驱/后继我们把小于/大于查询值$val$的子树分裂出来，由于分裂出的子树依然满足二叉树性质，所以我们可以直接查询这个子树中的最大值/最小值，查询出的值就是答案。最后记得合并回去。 代码： int pre(int val) { split(root,val-1,root1,root2); int now=root1,res=-INF; if(now) { while(nodes[now].r) now=nodes[now].r; res=nodes[now].num; } root=merge(root1,root2); return res; } int nxt(int val) { split(root,val,root1,root2); int now=root2,res=INF; if(now) { while(nodes[now].l) now=nodes[now].l; res=nodes[now].num; } root=merge(root1,root2); return res; } 6.第k小对于这个问题，$fhq-treap$没有特殊的解决方法。所以和$treap$一样。 由于二叉搜索树中序遍历为不降序列，我们分情况讨论： 1&gt;.左子树大小$+1$等于$k$。 说明当前节点就是第$k$小。 2&gt;.左子树大小小于等于$k$ 说明第$k$大在左边，那么向左边继续寻找第k小。 3&gt;.否则 第$k$小在右边，但左边和当前结点都比第$k$小。所以第k小是在右边的第$k-nodes[nodes[x].l].sum-1$小。 代码： int top(int val) { int x=root; while(x) { if(nodes[nodes[x].l].sum+1==val) break; if(nodes[nodes[x].l].sum&gt;=val) x=nodes[x].l; else { val-=(1+nodes[nodes[x].l].sum); x=nodes[x].r; } } return nodes[x].num; } 7.排名排名的定义是比一个数小的数的个数加$1$。 通过定义就能得出做法： 把比查询值小的子树分离出来，这棵子树的大小就是比这个数小的数的个数。再加$1$就能得到答案了。 代码： int rank(int val) { split(root,val-1,root1,root2); int res=nodes[root1].sum+1; root=merge(root1,root2); return res; } 2.区间fhq-treap区间$fhq-treap$维护了一个区间，中序遍历整个$fhq-treap$就可以得到这个序列。当然，这时候它肯定就不能满足二叉搜索树的性质了。但它还可以满足堆的性质。 为了维护区间，我们的$split$操作需要更改： 每次分裂一个区间出来：把这个序列的前$siz$项分出来为一个子树$X$,剩余另一个子树$Y$。 又分类讨论： 1&gt;.$nodes[nodes[x].l].sum&lt;k$ 这说明当前结点的左子树和自身都属于 $X$，我们再把右子树的前$k-nodes[nodes[x].l].sum-1$项分给$X$就好了。 2&gt;.否则 前$k$项在当前结点的左子树中，那么当前节点和它的右子树属于$Y$。 代码： void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[nodes[now].l].sum&lt;k) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } 但$merge$操作不需要太大变动，只需要加上懒标记下传就行了（如果有的话） 其实区间操作的分裂除了标记下传之外与权值版没有什么差别，只是这里分裂的权值是第k小。 标记下传是个大坑，有标记时，每当你要对一个节点的子节点进行操作（无论是修改还是查询）时，要先下传标记，否则之后能会传错位置，因为你可能更改了它的子节点。 1.区间和我们在每个节点中再加上一个变量记录它和它子树的和。 那么每次子树大小更新时，子树和也要更新。 就在$update$里加一句话更新子树和就好。 查询区间和时就把这个区间分裂出来，直接查询这个区间根节点的子树和就行了。 2.区间翻转区间操作基本靠懒标记来完成。这些标记都会继续下传给子节点。 翻转就用一个$bool$懒标记就好了。 首先说明区间翻转的原理： 先把这个区间分裂出来。 要使区间翻转，就相当于要把这个区间倒着遍历。 左中右$-&gt;$右中左 即我们要对于每个节点遍历时先遍历右边，再遍历本节点，最后遍历左边。 那我们把每个节点的左右儿子交换就行了。 所以我们直接把这个区间剖出来，把它的根节点打上标记，再合并回去就好了。 3.区间加法区间加法就像线段树一样的懒标记就好了。 其实与区间翻转的实现方式类似，我就不讲了。 4.如何剖出区间[l,r]我们把序列$[1,n]$分成3段$[1,l-1]$,$[l,r]$,$[r+1,n]$ 第一段的长度是$l-1$,第二段的长度是$r-l+1$ 我们就挨个把它们$split$出来就好了。 代码: split(root,l-1,root1,root2); split(root2,r-l+1,root2,root3); $root2$即为$[l,r]$区间的根结点。 $\\ $ 由此判断，平衡树比线段树还要万能，但常数巨大。","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题 ---树状数组","slug":"DS100P-BINARY-INDEXED-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-18T09:47:27.516Z","comments":true,"path":"2020/02/05/DS100P-BINARY-INDEXED-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-BINARY-INDEXED-TREE/","excerpt":"","text":"树状数组($nlogn$) 树状数组是一种常数较小的，能够实现区间加法，区间查询的数据结构。 其中最玄妙的操作就是$lowbit$了,它是使树状数组常数进一步缩小的功臣。 1).lowbit这个操作用来找到$x$从右往左数的第一个为1的位。 先看一看这个操作的实现吧：$lowbit(x)=(x$&amp;$(-x))$ ($x$一般为正整数) 说它很玄妙是因为它很短，但很有效；它充分地利用了位运算的高效。 但我们要理解它的原理。 位运算嘛，我们先把x转化成2进制补码。那么x是正整数，它的二进制补码就是他自身，且其中肯定有一个1。 $-x$的二进制表示则是它的二进制表示的反码+1；即把除符号位外的所有位取反，再$+1$。 我们把这两个步骤分开，先把所有位取反，此时x与它与起来等于0。再$+1$，就会使从右往左数第一个为零的位变为1：因为如果第一位是0，那么这位就会变成1；否则就会往前进1位，经过递归，就能使从右往左数第一个为零的位变为1。 从右往左数第一个为零的位的左边的数没有被改变过，所以与起来依然是0；右边的数经过进位都变成了0，不管怎样与都是0。而这一位本身现在是1，原来是0，说明这一位原来是1，与起来就是1。而这一位是第一个为0的位，那么它原来就是第一个为1的位。 2).单点修改首先我们定义一个$nodes$数组。 $nodes[i]$储存$a[i-lowbit(i)+1]$到$a[i]$的和。 那么如果我们给$a[i]$加上了$x$,那么$nodes[i]$肯定包括$a[i]$，也要加上$x$; $lowbit(i+lowbit(i))$的值肯定大于$lowbit(i)$,所以$nodes[i+lowbit(i)]$也要加上$x$; 再继续递归下去，一直到数组的边界为止。 那如何说明$nodes[i+lowbit(i)]$就是第一个包含$nodes[i]$的数呢？ 我们按照$lowbit(i)$把$nodes[MAXN]$分为$log(MAXN)$层，那么不可能有同层及下层节点包含$nodes[i]$，除了它自己。 所以我们向上层节点寻找，就要把$lowbit(i)$这一位消掉且数字要增大，直接加上$lowbit(i)$就可以做到这一点，因为$lowbit(i)$这一位往右都是0，要把这一位消掉，需要加上的数中没有比$lowbit(i)$更小的。 所以$nodes[i+lowbit(i)]$就是第一个包含$nodes[i]$的数。 代码 void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } 3).区间查询（单点修改）如果我们要查询区间$[l,r]$的和，我们可以运用前缀和思想，把它转换成求$[1,r]-[1,l-1]$的值。 那么问题转化成了求区间$[1,x]$的和。 由于定义，$nodes[x]$储存的是$a[x-lowbit(x)+1]$到$a[x]$的和，那么我们可以进一步缩小问题规模：$query[1,x]=query[1,x-lowbit(x)]+nodes[x]$,一直到0为止。 代码 int ask(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int query(int l,int r) { return ask(r)-ask(l-1); } 4).区间修改及查询上面的操作只支持单点修改，那么如何区间修改呢，一个一个地改肯定会炸。我们采用差分的思想，将区间修改转化为单点修改。 我们先思考如何用差分数组$c[n]$求$a[1]+a[2]+\\cdots+a[n-1]+a[n]$。 $c[1]n+c[2](n-1)+\\cdots+c[n-1]*2+c[n]$ 这个式子里的c[i]和i没有什么关系，不太好操作，于是我们把它变个形： $(c[1]+c[2]+\\cdots+c[n-1]+c[n])(n+1)-(c[1]+c[2]2+\\cdots+c[n-1](n-1)+c[n]n)$ 这样就好维护多了：我们只需要开两个树状数组维护$c[1]+c[2]+\\cdots+c[i]$和$c[1]+c[2]2+\\cdots+c[i]i$($nodes[MAXN]$,$exnodes[MAXN]$) 对于一个区间修改——$[l,r]$加$x$。 将所有包含$c[l]$的$nodes$加$x$,$exnodes$加$lx$($(c[l]+x)l==c[l]l+xl$) 将所有包含$c[r+1]$的$nodes$减$x$,$exnodes$减$(r-1)x$($(c[r+1]+x)(r+1)==c[r+1](r+1)+x(r+1)$) 对于一个区间询问——$[l,r]$ 等价于$[1,r]-[1,l-1]$ 对于$[1,x]$ 由上面的式子得出做法:以$nodes$查询$(c[1]+c[2]+\\cdots+c[x-1]+c[x])(x+1)$，以$exnodes$查询$(c[1]+c[2]2+\\cdots+c[x-1](x-1)+c[x]x)$,再将它们相减。 代码 void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } void exupdate(int x,int val) { while(x&lt;=MAXN) { exnodes[x]+=val; x+=lowbit(x); } } int find(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int exfind(int x) { int res=0; while(x) { res+=exnodes[x]; x-=lowbit(x); } return res; } void modify(int l,int r,int x) { update(l,x); exupdate(l,l*x); update(r+1,-x); exupdate(r+1,-(r+1)*x); } int ask(int x) { return find(x)*(x+1)-exfind(x); } int query(int l,int r) { return ask(r)-ask(l-1); } //(下面两个先咕了，我没看到哪道题要用……) 5).二维单点修改，区间查询6).二维区间修改，区间查询","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"数据结构100题系列目录及前言","slug":"DS100P-INDEX-AND-PREWORDS","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-18T09:41:57.937Z","comments":true,"path":"2020/02/05/DS100P-INDEX-AND-PREWORDS/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-INDEX-AND-PREWORDS/","excerpt":"","text":"前言$\\qquad \\qquad \\qquad$ljs搞了一个dp100题，然后lyc告诉我我们搞一个数据结构100题吧 $\\qquad \\qquad \\qquad$于是我就来了，还带来一个网络流(它死了，被lyc杀死的) 由于某WGY硬是把网络流加进去了，所以我只能重开一个……（我为什么要让他建帖子）$\\qquad \\qquad \\qquad$(它死了，被wgy杀死的) 我是不会写网络流的！！！$\\qquad \\qquad \\qquad$(它死了，被wgy杀死的) 前期我会先把各个数据结构的模板先写一遍，先把基础讲清楚。$\\qquad \\qquad \\qquad$咕咕咕 后期再加一些有价值的题目来讲解。$\\qquad \\qquad \\qquad$(我可能会先咕掉部分模板……) $\\qquad \\qquad \\qquad$//先把坑挖好 题解部分$\\qquad \\qquad \\qquad$数据结构100题 1~10题 $\\qquad \\qquad \\qquad$数据结构100题 11~20题 $\\qquad \\qquad \\qquad$数据结构100题 21~30题 数据结构学习笔记部分$\\qquad \\qquad \\qquad$数据结构100题 —-树状数组 $\\qquad \\qquad \\qquad$数据结构100题 —-fhq-treap $\\qquad \\qquad \\qquad$数据结构100题 —-线段树 $\\qquad \\qquad \\qquad$数据结构100题 —-trie树 $\\qquad \\qquad \\qquad$数据结构100题 —-树链剖分 $\\qquad \\qquad \\qquad$数据结构100题 —-主席树 $\\qquad \\qquad \\qquad$数据结构100题 —-树套树 $\\qquad \\qquad \\qquad$数据结构100题 —-分块 $\\qquad \\qquad \\qquad$数据结构100题 —-莫队 $\\qquad \\qquad \\qquad$数据结构100题 —-Link-Cut Tree $\\qquad \\qquad \\qquad$数据结构100题 —-Chtholly-Tree(Old-Driver Tree) $\\qquad \\qquad \\qquad$数据结构100题 —-KMP $\\qquad \\qquad \\qquad$数据结构100题 —-splay $\\qquad \\qquad \\qquad$数据结构100题 —-后缀全家桶 之 后缀数组 $\\qquad \\qquad \\qquad$数据结构100题 —-后缀全家桶 之 后缀树 $\\qquad \\qquad \\qquad$数据结构100题 —-后缀全家桶 之 后缀自动机 $\\qquad \\qquad \\qquad$数据结构100题 —-Sqrt-Tree $\\qquad \\qquad \\qquad$数据结构100题 —-块状数组 $\\qquad \\qquad \\qquad$数据结构100题 —-块状链表 $\\qquad \\qquad \\qquad$数据结构100题 —-树上分块 $\\qquad \\qquad \\qquad$数据结构100题 —-猫树 $\\qquad \\qquad \\qquad$数据结构100题 —-基环树 $\\qquad \\qquad \\qquad$数据结构100题 —-支配树 $\\qquad \\qquad \\qquad$数据结构100题 —-左偏树 $\\qquad \\qquad \\qquad$数据结构100题 —-环套树 $\\qquad \\qquad \\qquad$数据结构100题 —-虚树 $\\qquad \\qquad \\qquad$数据结构100题 —-博弈树 $\\qquad \\qquad \\qquad$数据结构100题 —-圆方树","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]}]}