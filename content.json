{"meta":{"title":"BoringHacker's Blog","subtitle":"Stay Hungry, Stay Foolish","description":null,"author":"BoringHacker","url":"www.orchid-any.cf"},"pages":[{"title":"Comments","date":"2020-01-17T07:04:09.000Z","updated":"2020-01-17T07:05:20.286Z","comments":true,"path":"Comments/index.html","permalink":"www.orchid-any.cf/Comments/index.html","excerpt":"","text":"éšä¾¿è¯´ç‚¹ä»€ä¹ˆå§(è®°å¾—æ”¹æ˜µç§°)233â€¦"},{"title":"Havefun","date":"2019-12-21T13:04:04.000Z","updated":"2020-01-15T08:32:06.232Z","comments":true,"path":"Havefun/index.html","permalink":"www.orchid-any.cf/Havefun/index.html","excerpt":"","text":""},{"title":"Tools","date":"2020-02-15T09:56:00.000Z","updated":"2020-02-20T03:54:56.314Z","comments":true,"path":"Tools/index.html","permalink":"www.orchid-any.cf/Tools/index.html","excerpt":"","text":"For ljes(æ»‘ç¨½)å‡½æ•°æ±‚å¯¼å·¥å…· å‡½æ•°è¾“å…¥æ¡†: è‡ªå˜é‡: é˜¶æ•°: 0 1 2 3 4 5 6 7 8 9 10 ä¸å®šç§¯åˆ†è®¡ç®—å™¨ è¯·è¾“å…¥ä½ éœ€è¦ç§¯åˆ†çš„å‡½æ•°è¡¨è¾¾å¼: è‡ªå˜é‡: å®šç§¯åˆ†è®¡ç®—å™¨ è¯·è¾“å…¥ä½ éœ€è¦ç§¯åˆ†çš„å‡½æ•°è¡¨è¾¾å¼: è‡ªå˜é‡: ä»: åˆ°: æé™è®¡ç®—å™¨ è¯·è¾“å…¥ä¸€ä¸ªå‡½æ•°å¹¶è®¡ç®—æé™: æé™å˜é‡: xè¶‹å‘äº: æé™ç±»å‹ åŒä¾§æé™ å³ä¾§æé™ å·¦ä¾§æé™ å‡½æ•°å›¾åƒç»˜åˆ¶å·¥å…·å‡½æ•°è¾“å…¥æ¡†: X åæ ‡, ä»: åˆ°: Y åæ ‡, ä»: åˆ°: åˆ†æ•°è®¡ç®—å™¨ è¾“å…¥ä¸€ä¸ªåˆ†æ•°è¡¨è¾¾å¼: æ–¹ç¨‹æ±‚è§£ è¾“å…¥é€—å·ä»¥åˆ†éš”å¤šä¸ªæ–¹ç¨‹: è¡¨è¾¾å¼åŒ–ç®€ è¾“å…¥ä¸€ä¸ªè¡¨è¾¾å¼æ¥ç®€åŒ–: å› å¼åˆ†è§£å·¥å…· è¯·è¾“å…¥æ‚¨éœ€è¦åˆ†è§£å› å¼çš„è¡¨è¾¾å¼ï¼š: é˜¶ä¹˜è®¡ç®—å™¨ è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ç»„åˆæ•°è®¡ç®—å™¨ ç»„åˆæ•°è®¡ç®—æ–¹æ³•ï¼Œä»Né¡¹ä¸­é€‰å‡ºMé¡¹. æ˜¯å¦å…·æœ‰é¡ºåº? æ˜¯ å¦ å…ƒç´ æ˜¯å¦å¯ä»¥é€‰æ‹©ä¸€æ¬¡ä»¥ä¸Š? æ˜¯ å¦ N = M = åå‡½æ•°è®¡ç®—å™¨ è¾“å…¥å‡½æ•°æ¥è®¡ç®—å…¶åå‡½æ•°: è¡¨è¾¾å¼è®¡ç®—å™¨ è¾“å…¥è¦è®¡ç®—çš„è¡¨è¾¾å¼: è´¨æ•°å‘ç”Ÿå™¨å’Œæ ¡éªŒå™¨ è¾“å…¥ä¸€ä¸ªè‡ªç„¶æ•°ï¼Œå¹¶é€‰æ‹©ç›¸åº”çš„åŠŸèƒ½: æ£€éªŒæ˜¯å¦ä¸ºè´¨æ•° ä¸‹ä¸€ä¸ªè´¨æ•° ä¸Šä¸€ä¸ªè´¨æ•° æ•´æ•°åˆ†è§£å·¥å…· è¯·è¾“å…¥æ‚¨éœ€è¦åˆ†è§£çš„æ•´æ•°: æ–æ³¢é‚£å¥‘æ•°è®¡ç®—å·¥å…· è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ä¼¯åŠªåˆ©æ•°å‘ç”Ÿå™¨ è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: æ¬§æ‹‰æ•°è®¡ç®—å·¥å…· è¯·è¾“å…¥ä¸€ä¸ªéè´Ÿæ•´æ•°: ç»Ÿè®¡è®¡ç®—å™¨ è¾“å…¥ä¸€ä¸ªç©ºæ ¼ï¼Œé€—å·æˆ–æ–°è¡Œåˆ†éš”çš„æ•°å­—: å¹³å‡æ•° ä¸­ä½æ•° è°ƒå’Œå¹³å‡æ•° å‡ ä½•å¹³å‡æ•° æœ€å° æœ€å¤§ èŒƒå›´ æ–¹å·® æ›´æ­£æ–¹å·® æ ‡å‡†åå·® æ›´æ­£çš„æ ‡å‡†åå·® å˜å¼‚ç³»æ•° å¹³å‡åå·® ä¸­ä½æ•°åå·® ååº¦ çŸ©é˜µè®¡ç®—å™¨ è¾“å…¥çŸ©é˜µ A: çŸ©é˜µçš„è¡Œåˆ—å¼ è½¬ç½®çŸ©é˜µ çŸ©é˜µè¿¹ çŸ©é˜µçš„ç§© é€†çŸ©é˜µ ç‰¹å¾å€¼ ä¸‹ä¸‰è§’çŸ©é˜µ A2 çŸ©é˜µè¿ç®— è¾“å…¥çŸ©é˜µ A:è¾“å…¥çŸ©é˜µ B: åŠ æ³• å‡æ³• ä¹˜æ³•","keywords":null},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"client/index.html","permalink":"www.orchid-any.cf/client/index.html","excerpt":"","text":"ç›´æ¥ä¸‹è½½ or æ‰«ç ä¸‹è½½ï¼š","keywords":"Androidå®¢æˆ·ç«¯"},{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-02-05T10:53:40.037Z","comments":false,"path":"about/index.html","permalink":"www.orchid-any.cf/about/index.html","excerpt":"","text":"BoringHacker ä¸&nbsp; BoringHacker&nbsp; ï¼ˆ BoringHacker ï¼‰ å¯¹è¯ä¸­... bot_ui_ini()","keywords":"å…³äº"},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-02-05T10:46:24.855Z","comments":true,"path":"comment/index.html","permalink":"www.orchid-any.cf/comment/index.html","excerpt":"","text":"å¿µä¸¤å¥è¯ äººæ¸£çš„æœ¬æ„¿ï¼Œè‹è”çš„è§£ä½“ã€‚ ã€ç°ä»£ã€‘noipæ¯’ç˜¤ã€Šæ´›è°·Â·ä¸ªäººä¸»é¡µã€‹","keywords":"ç•™è¨€æ¿"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"donate/index.html","permalink":"www.orchid-any.cf/donate/index.html","excerpt":"","text":"","keywords":"è°¢è°¢é¥²ä¸»äº†å–µ~"},{"title":"Blog","date":"2019-01-05T13:47:59.000Z","updated":"2020-02-08T10:34:13.512Z","comments":false,"path":"lab/index.html","permalink":"www.orchid-any.cf/lab/index.html","excerpt":"","text":"å’•å’•å’•ã€‚ã€‚ã€‚","keywords":"åšå®¢æ˜¯æ€æ ·è¯ç”Ÿçš„"},{"title":"Animes","date":"2019-02-10T13:32:48.000Z","updated":"2020-02-20T03:54:56.300Z","comments":false,"path":"bangumi/index.html","permalink":"www.orchid-any.cf/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"Game","date":"2020-02-05T11:21:36.000Z","updated":"2020-02-20T03:54:56.306Z","comments":false,"path":"game/index.html","permalink":"www.orchid-any.cf/game/index.html","excerpt":"","text":"ä»ctzé‚£é‡Œå‰½æ¥çš„ä¸œè¥¿ 2048 flappy bird äº”å­æ£‹ ç”Ÿç«é—´ æ°´æœå¿è€…","keywords":null},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-02-19T23:50:19.835Z","comments":true,"path":"links/index.html","permalink":"www.orchid-any.cf/links/index.html","excerpt":"","text":"","keywords":"å‹äººå¸"},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"www.orchid-any.cf/theme-sakura/index.html","excerpt":"","text":"Hexoä¸»é¢˜Sakuraä¿®æ”¹è‡ªWordPressä¸»é¢˜Sakuraï¼Œæ„Ÿè°¢åŸä½œè€…Mashiro","keywords":"Hexo ä¸»é¢˜ Sakura ğŸŒ¸"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"music/index.html","permalink":"www.orchid-any.cf/music/index.html","excerpt":"","text":"","keywords":"å–œæ¬¢çš„éŸ³ä¹"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2019-11-15T17:29:48.000Z","comments":true,"path":"rss/index.html","permalink":"www.orchid-any.cf/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-02-08T06:03:27.000Z","updated":"2020-02-20T03:54:56.311Z","comments":true,"path":"tags/index.html","permalink":"www.orchid-any.cf/tags/index.html","excerpt":"","text":"","keywords":null},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2019-11-15T17:29:48.000Z","comments":false,"path":"video/index.html","permalink":"www.orchid-any.cf/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: 'æ”¾é€æ—¶é—´: 2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: 'æœèŠ±å¤•èª“â€”â€”äºç¦»åˆ«ä¹‹æœæŸèµ·çº¦å®šä¹‹èŠ±', status: 'å·²è¿½å®Œ', progress: 100, jp: 'ã•ã‚ˆãªã‚‰ã®æœã«ç´„æŸã®èŠ±ã‚’ã‹ã–ã‚ã†', time: '2018-02-24 SUN.', desc: ' ä½åœ¨è¿œç¦»å°˜åš£çš„åœŸåœ°ï¼Œä¸€è¾¹å°†æ¯å¤©çš„äº‹æƒ…ç¼–ç»‡æˆåä¸ºå¸Œæ¯”æ¬§çš„å¸ƒï¼Œä¸€è¾¹é™é™ç”Ÿæ´»çš„ä¼Šæ¬§å¤«äººæ°‘ã€‚åœ¨15å²å·¦å³å¤–è¡¨å°±åœæ­¢æˆé•¿ï¼Œæ‹¥æœ‰æ•°ç™¾å¹´å¯¿å‘½çš„ä»–ä»¬ï¼Œè¢«ç§°ä¸ºâ€œç¦»åˆ«çš„ä¸€æ—â€ï¼Œå¹¶è¢«è§†ä¸ºæ´»ç€çš„ä¼ è¯´ã€‚æ²¡æœ‰åŒäº²çš„ä¼Šæ¬§å¤«å°‘å¥³ç›å¥‡äºšï¼Œè¿‡ç€è¢«ä¼™ä¼´åŒ…å›´çš„å¹³ç¨³æ—¥å­ï¼Œå´æ€»æ„Ÿè§‰â€œå­¤èº«ä¸€äººâ€ã€‚ä»–ä»¬çš„è¿™ç§æ—¥å¸¸ï¼Œä¸€ç¬é—´å°±å´©æºƒæ¶ˆå¤±ã€‚è¿½æ±‚ä¼Šæ¬§å¤«çš„é•¿å¯¿ä¹‹è¡€ï¼Œæ¢…è¨è’‚å†›ä¹˜åç€åä¸ºé›·çº³ç‰¹çš„å¤ä»£å…½å‘åŠ¨äº†è¿›æ”»ã€‚åœ¨ç»æœ›ä¸æ··ä¹±ä¹‹ä¸­ï¼Œä¼Šæ¬§å¤«çš„ç¬¬ä¸€ç¾å¥³è•¾è‰äºšè¢«æ¢…è¨è’‚å¸¦èµ°ï¼Œè€Œç›å¥‡äºšæš—æ‹çš„å°‘å¹´å…‹é‡Œå§†ä¹Ÿå¤±è¸ªäº†ã€‚ç›å¥‡äºšè™½ç„¶æ€»ç®—é€ƒè„±äº†ï¼Œå´å¤±å»äº†ä¼™ä¼´å’Œå½’å»ä¹‹åœ°â€¦â€¦ã€‚' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} ç•ªç»„è®¡åˆ’ è¿™é‡Œå°†æ˜¯æ°¸è¿œçš„å›å¿† window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} æ”¾é€æ—¶é—´: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"Bç«™"}],"posts":[{"title":"ã€Œé¢˜è§£ã€æ´›è°·P3267ä¾¦å¯Ÿå®ˆå«","slug":"SOL-P3267","date":"2020-02-18T12:02:53.000Z","updated":"2020-02-20T03:02:50.267Z","comments":true,"path":"2020/02/18/SOL-P3267/","link":"","permalink":"www.orchid-any.cf/2020/02/18/SOL-P3267/","excerpt":"","text":"é¢˜æ„ç®€è¿°ç»™ä½ ä¸€æ£µæ ‘ï¼Œæ”¾ç½®å®ˆå«åœ¨æŸä¸ªç‚¹ä¸Šé¢éœ€è¦ä¸€å®šä»£ä»·å’Œä¸€å®šçš„æœ‰æ•ˆèŒƒå›´ã€‚è®©ä½ è¦†ç›–è‹¥å¹²æŒ‡å®šç‚¹ï¼Œæ±‚æœ€å°ä»£ä»· é¢˜è§£ç®—æ³•æ ‡ç­¾ï¼š$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ æ ‘DPDPçŠ¶æ€å®šä¹‰:$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ è¯´å®è¯è¿™é“é¢˜å®šçŠ¶æ€ä¸å¥½å®šã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ é‚£ä¹ˆæˆ‘ä»¬ä»å¤´æ¥çœ‹ï¼Œå½“ $d =0$ çš„æ—¶å€™ï¼Œæˆ‘ä»¬å°±æ˜¯åœ¨æ±‚æ ‘çš„æœ€å¤§ç‹¬ç«‹é›†ï¼Œå®šä¹‰æ˜¾è€Œæ˜“è§ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $d\\neq 0$ æˆ‘ä»¬å¯ä»¥ç…§æ¬åŸæ¥çš„å®šä¹‰ï¼ŒæŠŠå®ƒæ‰©å±•ä¸€ä¸‹ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $f_{i,j}$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘å·²ç»å®Œå…¨è¢«è¦†ç›–è®©ç„¶åè¿˜èƒ½å‘ä¸Šè¦†ç›– $j$ å±‚çš„æœ€å°ä»£ä»· $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ $g_{i,j}=$ è¡¨ç¤ºä»¥ $i$ ä¸ºæ ¹ç»“ç‚¹çš„å­æ ‘è¿˜æœ‰ $j$ å±‚æ²¡æœ‰è¦†ç›–çš„æœ€å°ä»£ä»· $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ éœ€è¦æ³¨æ„çš„æ˜¯ $j$ æœ¬è´¨ä¸Šæ˜¯å¸¦æœ‰æ–¹å‘æ€§çš„ï¼Œå¯ä»¥ç±»æ¯”å‘é‡çš„æ¦‚å¿µã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ è¾¹ç•Œæ¡ä»¶å¾ˆæ˜¾ç„¶ï¼Œ$f_{i,0}=val_{i}$ æ­¤æ—¶å½“å‰ç»“ç‚¹éœ€è¦è¢«è¦†ç›–ã€‚ $\\ \\ \\ \\ \\ \\ \\ \\ \\ $ å…¶ä»–æƒ…å†µï¼š \\begin{cases} f_{i,j}=val_{i},j\\in [1,d] \\\\ \\displaystyle f_{i,j}=\\infty,j=d+1 \\end{cases}$\\ \\ \\ \\ \\ \\ \\ \\ \\ $ çŠ¶æ€è½¬ç§»æ–¹ç¨‹å€’æ˜¯æ¯”è¾ƒå¥½æƒ³ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°ã€‚ #include &lt;cstdio&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf; #ifndef ONLINE_JUDGE #define gc() getchar() #else #define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++) #endif #define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) template &lt; typename Type &gt; void read(Type&amp; a) { a = 0; bool f = 0; char ch; while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1; while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc(); a = (f ? -a : a); } template &lt; typename Type, typename... Args &gt; void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } int val[500005], f[500005][25]; int g[500005][25], vis[500005]; int n, m, d, tot, head[500005]; int nxt[1000005], to[1000005]; std::vector &lt; std::vector &lt; int &gt; &gt; G(500005); void add(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; G[x].push_back(y); G[y].push_back(x); } void DP(int x, int fa) { if (vis[x]) g[x][0] = f[x][0] = val[x]; for (int i = 1; i &lt;= d; ++i) f[x][i] = val[x]; f[x][d + 1] = 0x3f3f3f3f; for (int i = head[x]; i; i = nxt[i]) { int y = to[i]; if (y ^ fa) { DP(y, x); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[y][j + 1] + g[x][j + 1], f[x][j] + g[y][j]); for (int j = d; j &gt;= 0; --j) f[x][j] = std::min(f[x][j + 1], f[x][j]); g[x][0] = f[x][0]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] += g[y][j - 1]; for (int j = 1; j &lt;= d + 1; ++j) g[x][j] = std::min(g[x][j - 1], g[x][j]); } } } signed main() { read(n, d); for (int i = 1; i &lt;= n; ++i) read(val[i]); read(m); for (int i = 0, x; i &lt; m; ++i) read(x), vis[x] = 1; for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); DP(1, 0); printf(&quot;%d\\n&quot;, g[1][0]); }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"åŠ¨æ€è§„åˆ’","slug":"åŠ¨æ€è§„åˆ’","permalink":"www.orchid-any.cf/tags/åŠ¨æ€è§„åˆ’/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"ã€Œç¬”è®°ã€å¿«é€Ÿå‚…é‡Œå¶å˜æ¢","slug":"NOTE-FAST-FOURIER-TRANSFORM","date":"2020-02-17T01:27:53.000Z","updated":"2020-02-20T02:48:47.141Z","comments":true,"path":"2020/02/17/NOTE-FAST-FOURIER-TRANSFORM/","link":"","permalink":"www.orchid-any.cf/2020/02/17/NOTE-FAST-FOURIER-TRANSFORM/","excerpt":"","text":"æœ¬æ–‡æ¬è¿è‡ªC20211013æç°Luogu æ¥”å­ä¸€é“æ¿å­é¢˜ é¢˜æ„ï¼šæ±‚ä¸¤ä¸ªå¤§æ•´æ•°ç›¸ä¹˜çš„ç§¯. é€‰æ‰‹1ï¼šæˆ‘ä¼š$\\mathsf{unsigned\\ long\\ long}$ï¼ é¢„è®¡å¾—åˆ†ï¼š$0\\mathsf{pts}$ é€‰æ‰‹2ï¼šæˆ‘ä¼šé«˜ç²¾ï¼ é¢„è®¡å¾—åˆ†ï¼š$30\\mathsf{pts}$ é€‰æ‰‹3ï¼šæˆ‘ä¼š$\\mathsf{Python}$ï¼ é¢„è®¡å¾—åˆ†ï¼š$\\cdots$ (é€‰æ‰‹3è¢«ä¼—äººå›´æ®´è‡´æ­») å·ç§¯æ€æƒ³å¼•å…¥ 1æ±‚ä¸¤ä¸ªæ— ç¬¦å·æ•´æ•°ç›¸ä¹˜çš„ç§¯. åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å¹¶ä¸æ˜¯æƒ³ç¼–å†™ä¸€ä¸ªç¨‹åºæ¥å®ç°ä¸Šè¿°åŠŸèƒ½ï¼Œè€Œæ˜¯è€è€å®å®ç”¨çº¸ç¬”è®¡ç®—. ä¾‹ï¼š è®¡ç®— $21\\times121$ è§£ï¼š \\quad\\ \\ 21\\times\\ 121 \\quad\\ \\ 21\\ 42\\!\\!\\!\\!21 \\!2541ç­”ï¼š$21\\times121=2541.$ å›é¡¾åˆšæ‰çš„è®¡ç®—è¿‡ç¨‹ï¼Œæˆ‘ä»¬åˆ†æä¸€ä¸‹$2541$çš„æ¯ä¸€ä½æ•°å­—æ˜¯æ€ä¹ˆå¾—å‡ºæ¥çš„. $1=1\\times1$ $4=2\\times1+2\\times2$ $5=2\\times2+1\\times1$ $2=2\\times1$ æˆ‘ä»¬ç”¨æ•°ç»„$A$å­˜å‚¨$21$è¿™ä¸ªæ•°ï¼Œ$B$å­˜å‚¨$121$ï¼Œ$C$å­˜å‚¨ç­”æ¡ˆï¼Œåˆ™ $C_0=A_0\\times B_0$ $C_1=A_1\\times B_0+A_0\\times B_1$ $C_2=A_1\\times B_1+A_0\\times B_2$ $C_3=A_1\\times B_2$ è§‚å¯Ÿä¸‹æ ‡ï¼Œæˆ‘ä»¬å‘ç°ä¸¤ä¸ªæ­£æ•´æ•°ç›¸ä¹˜çš„ç»“æœæ»¡è¶³ä¸‹é¢è§„å¾‹ï¼š C_k=\\sum^k_{i=0}A_i\\times B_{k-i}å¼•å…¥ 2æ±‚ä¸¤ä¸ªå¤šé¡¹å¼ç›¸ä¹˜çš„ç§¯. åŒä¸Šä¾‹ï¼Œæˆ‘ä»¬ä¾ç„¶ç”¨çº¸ç¬”è®¡ç®—ä¹‹. ä¾‹ï¼š è®¡ç®—$(1+2x)(1+2x+x^2)$ è§£ï¼š $(1+2x)(1+2x+x^2)=1+2x+x^2+2x+4x^2+2x^3=1+4x+5x^2+2x^3$ æ ¹æ®è®¡ç®—è¿‡ç¨‹åˆ†æå„é¡¹ç³»æ•°ï¼Œæœ‰ï¼š $1=1\\times1$ $4=2\\times1+2\\times2$ $5=2\\times2+1\\times1$ $2=2\\times1$ è¿™é‡Œæˆ‘ä»¬ç”¨æ•°ç»„$A$å­˜å‚¨$(1+2x)$çš„ç³»æ•°ï¼Œ$B$å­˜å‚¨$(1+2x+x^2)$çš„ç³»æ•°ï¼Œ$C$å­˜å‚¨ç­”æ¡ˆçš„ç³»æ•°ï¼Œåˆ™ï¼š $C_0=A_0\\times B_0$ $C_1=A_1\\times B_0+A_0\\times B_1$ $C_2=A_1\\times B_1+A_0\\times B_2$ $C_3=A_1\\times B_2$ æˆ‘ä»¬å‘ç°ï¼Œä¸¤ä¸ªå¤šé¡¹å¼ä¹˜ç§¯çš„ç³»æ•°æ»¡è¶³ä¸‹é¢çš„è§„å¾‹ï¼š C_k=\\sum^k_{i=0}A_i\\times B_{k-i}å·ç§¯ï¼Ÿï¼æˆ‘ä»¬è§‚å¯Ÿä¸Šé¢ä¸¤ä¸ªå¼å­ï¼Œå¯ä»¥çœ‹å‡ºå®ƒä»¬å…·æœ‰ç›¸åŒçš„å½¢å¼ï¼Œæˆ‘ä»¬ç§°è¿™ç§å½¢å¼ä¸ºå·ç§¯. å½¢è±¡ç†è§£ï¼š â€œå·ç§¯â€ï¼Œâ€œç§¯â€è‡ªç„¶æŒ‡ä¹˜ç§¯ï¼Œè€Œâ€œå·â€çš„å«ä¹‰å¦‚å›¾ï¼š ç¬¬ä¸€æ¬¡å°è¯•#include&lt;cmath&gt; #include&lt;cstdio&gt; const int N = 1000005, mod = 998244353; int A[N], B[N], C[N]; int a, b; void mutiply() { for(int k = 0; k &lt; a + b - 1; ++k) for(int i = 0; i &lt;= k; ++i) C[k] += (A[i]*B[k-i]); } int main() { scanf(&quot;%d%d&quot;,&amp;a,&amp;b); ++a,++b; for(int i=0;i&lt;a;++i)scanf(&quot;%d&quot;,A+i); for(int i=0;i&lt;b;++i)scanf(&quot;%d&quot;,B+i); mutiply(); for(int i=0;i&lt;a+b-1;++i)printf(&quot;%d &quot;,C[i]); return 0; } å¹²å¾—æ¼‚äº®ï¼æˆ‘ä»¬æ”¶è·äº†$44\\mathsf{pts}$çš„ä½³ç»©ï¼ å¦ä¸€ç§æ–¹æ³•ä¹‹å‰æœ‰ç”¨åˆ°è¿™æ ·ä¸€ä¸ªæ€è·¯ï¼Œå¯¹äºä»»æ„å¤šé¡¹å¼$F$ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡ç”¨å°†å…¶å‡å¹‚æ’åˆ—ï¼Œå†å­˜å‚¨å…¶ç³»æ•°çš„åŠæ³•æ¥è¡¨ç¤ºå‡º$F$. è¿™é‡Œè°ˆè°ˆå¦å¤–ä¸€ç§åŠæ³•. ä¼—æ‰€å‘¨çŸ¥ï¼Œä¸¤ç‚¹ç¡®å®šä¸€æ¡ç›´çº¿ï¼Œç”¨è§£æå‡ ä½•çš„è¯­è¨€æè¿°ï¼Œå°±æ˜¯$y=ax+b$ç”±ä¸¤ä¸ªæœ‰åºç‚¹å¯¹${(x_0,y_0),(x_1,y_1)}$å”¯ä¸€åœ°ç¡®å®š. ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºæˆ‘ä»¬çŸ¥é“äº†è¿™ä¸¤ä¸ªç‚¹çš„åæ ‡ï¼Œå°†å…¶å¸¦å…¥è¿›è§£æå¼ï¼Œå¾—åˆ°äºŒå…ƒä¸€æ¬¡æ–¹ç¨‹ç»„ï¼Œå†è§£è¿™ä¸ªæ–¹ç¨‹ç»„ï¼Œå¾—åˆ°$a$å’Œ$b$çš„å€¼. å½“$y=ax^2+bx+c$æ—¶å‘¢ï¼Ÿè¿›ä¸€æ­¥åœ°ï¼Œå½“$y=a_0x^0+a_1x^1+\\cdots+a_nx^n$æ—¶å‘¢ï¼Ÿ æˆ‘ä»¬å¯ä»¥çœ‹å‡ºï¼Œå¼å­$y=a_0x^0+a_1x^1+\\cdots+a_nx^n$æœ‰$(n+1)$ä¸ªç³»æ•°ï¼Œå¦‚æœæˆ‘ä»¬è¦å”¯ä¸€åœ°ç¡®å®šå®ƒï¼Œå°±éœ€è¦$(n+1)$ä¸ªç‚¹çš„åæ ‡è”ç«‹èµ·æ¥è§£å‡ºç³»æ•°. ä¹Ÿå°±æ˜¯è¯´ï¼Œ$(n+1)$ä¸ªæœ‰åºç‚¹å¯¹å¯ä»¥å”¯ä¸€è¡¨ç¤ºä¸€ä¸ªå¤šé¡¹å¼ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºâ€œç‚¹å€¼è¡¨ç¤ºæ³•â€ ä½†æ˜¯å®ƒæœ‰ä»€ä¹ˆç”¨ï¼Ÿæˆ‘ä»¬çŸ¥é“ï¼Œå°†ä¸¤ä¸ªæµ®ç‚¹æ•°ç›¸ä¹˜çš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(1)$çš„ï¼Œé‚£ä¹ˆï¼Œå‡è®¾æˆ‘ä»¬æœ‰ä¸¤ä¸ªå¤šé¡¹å¼$A$å’Œ$B$ï¼Œä¸å¦¨è®¾å®ƒä»¬ä¸º$(1+2x)$å’Œ$(1+2x+x^2)$ï¼Œæ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è®¡ç®—å®ƒä»¬åœ¨ä¸€äº›ç‚¹ä¸Šçš„å€¼ï¼š x\\quad A\\quad B 0\\quad\\ 1\\quad\\ 1 1\\quad\\ 3\\quad\\ 4 2\\quad\\ 5\\quad\\ 9 3\\quad7\\quad16 4\\quad9\\quad25å°†$A$åˆ—å’Œ$B$åˆ—å¯¹åº”çš„æ•°ç›¸ä¹˜ï¼Œè®°ä½œ$C$åˆ—ï¼Œåˆ™ x\\quad C 0\\quad\\ 1 1\\quad12 2\\quad45 3\\ \\ 112 4\\ \\ 225åœ¨ä¸Šé¢æˆ‘ä»¬æ±‚å¾—$A\\times B$ï¼Œæˆ‘ä»¬å°†$x=\\{0,1,2,3,4\\}$ä»£å…¥$A\\times B$ï¼Œ x\\quad A\\times B 0\\quad\\quad\\quad\\ 1 1\\quad\\quad\\quad12 2\\quad\\quad\\quad45 3\\quad\\quad\\ \\ 112 4\\quad\\quad\\ \\ 225ç›¸ç­‰ï¼Ÿï¼æ˜¯çš„ï¼Œå½“æˆ‘ä»¬è½¬æ¢ä¸ºç‚¹å€¼è¡¨ç¤ºæ³•æ—¶ï¼Œä¸¤ä¸ªå¤šé¡¹å¼åœ¨æŸç‚¹ä¸Šçš„å€¼çš„ä¹˜ç§¯ç­‰äºä¸¤ä¸ªå¤šé¡¹å¼çš„ä¹˜ç§¯åœ¨æŸç‚¹ä¸Šçš„å€¼.(æ˜¾ç„¶$F(x)\\times G(x)=F(x)\\times G(x)$ï¼Œç­‰å·å·¦è¾¹æ˜¯ç‚¹å€¼è¡¨ç¤ºæ³•çš„$F$å’Œ$G$åœ¨$x$å¤„çš„å€¼çš„ä¹˜ç§¯ï¼Œç­‰å·å³è¾¹æ˜¯å®ƒä»¬çš„ä¹˜ç§¯åœ¨$x$å¤„çš„å€¼ï¼Œæ…¢æ…¢å“å‘³.) è®¾è¿™ä¸¤ä¸ªå¤šé¡¹å¼æ˜¯$m$å’Œ$n$æ¬¡çš„ï¼Œåˆ™å®ƒä»¬çš„ä¹˜ç§¯æ˜¯$(m+n)$æ¬¡çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬åªè¦è®¡ç®—è¿™ä¸¤ä¸ªå¤šé¡¹å¼åœ¨$(m+n+1)$ä¸ªç‚¹ä¸Šçš„å€¼å¹¶ä¸€ä¸€ç›¸ä¹˜ï¼Œå°±å¯ä»¥ç¡®å®šè¿™ä¸¤ä¸ªå¤šé¡¹å¼çš„ä¹˜ç§¯. æ—¶é—´å¤æ‚åº¦ï¼Ÿ$O(n+m)\\qquad\\mathsf{Good\\ Job!}$ ä¸”æ…¢$1)$å¦‚ä½•å°†ç‚¹å€¼è¡¨ç¤ºæ³•è½¬æ¢ä¸ºç³»æ•°è¡¨ç¤ºæ³•ï¼Ÿ $2)$æˆ‘ä»¬è¯¥å¦‚ä½•é€‰å–é‚£äº›å¾…è®¡ç®—çš„ç‚¹ï¼Ÿæ˜¾ç„¶ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è¿™äº›ç‚¹ä¸Šè®¡ç®—å®ƒçš„å¹³æ–¹ï¼Œç«‹æ–¹ç”šè‡³æ›´é«˜æ¬¡æ–¹ï¼Œè€Œä¸”ï¼Œå¦‚æœæˆ‘ä»¬èƒ½åˆç†åœ°é€‰æ‹©å¾…è®¡ç®—çš„ç‚¹ï¼Œé‚£ä¹ˆè®¡ç®—å°†ä¼šæå¤§åœ°ç®€åŒ–. æ¥ä¸‹æ¥æˆ‘ä»¬å°†ä¼šçœ‹åˆ°ä¸€ç±»åå«å•ä½æ ¹çš„å¤æ•°ï¼Œç»“åˆåˆ†æ²»æ€æƒ³åå¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™ä½åˆ°$O(n\\log n)$. ä½†é¦–å…ˆï¼Œæˆ‘ä»¬è¿˜æ˜¯è¦äº†è§£$\\cdots$ å¤æ•°å¤æ•°æ˜¯å½¢å¦‚$a+bi$çš„æ•°ï¼Œå…¶ä¸­$a,b\\in\\mathrm{R},i=\\sqrt{-1}$. å°†å…¨ä½“å¤æ•°çš„é›†åˆç§°ä½œ$\\mathrm{C}$ å¤æ•°çš„ä¸‰åˆ™è¿ç®—ï¼ˆé™¤æ³•ç°åœ¨è¿˜ç”¨ä¸åˆ°ï¼‰ $(a+bi)+(c+di)=(a+b)+(c+d)i$ $(a+bi)-(c+di)=(a-b)+(c-d)i$ $(a+bi)\\times(c+di)=(ac-bd)+(bc+ad)i$ è¯æ˜ï¼šæ³¨æ„$i^2=-1$ï¼Œåˆ©ç”¨ç»“åˆå¾‹ï¼Œåˆ†é…å¾‹å³è¯. æ³¨ï¼šå¤æ•°ä¹Ÿæ»¡è¶³ç»“åˆå¾‹ï¼Œåˆ†é…å¾‹å’Œå¹‚è¿ç®—è§„åˆ™. æ¬§æ‹‰å…¬å¼å’Œå•ä½æ ¹æ¬§æ‹‰å…¬å¼ï¼š$e^{i\\theta}=\\cos\\theta+i\\sin\\theta$ æ³¨æ„åˆ°$e^{(2a+1)\\pi i}=-1,e^{2a\\pi i}=1,a\\in\\mathrm{N}$ åˆ™æ–¹ç¨‹$x^n=1$çš„æ ¹ï¼ˆç§°ä½œå•ä½æ ¹ï¼Œè®°ä½œ$\\omega^k_n$)ä¸º \\omega^k_n=e^{\\frac{2k\\pi}{n}i}=\\cos\\frac{2k\\pi}{n}+i\\sin\\frac{2k\\pi}{n}è¯æ˜ï¼šç”±$(a^x)^p=a^{xp}$ç»“åˆæ¬§æ‹‰å…¬å¼å³è¯å¾—å…¶ä¸ºæ–¹ç¨‹çš„æ ¹. å•ä½æ ¹çš„æ€§è´¨$1)\\omega^k_n=\\omega^{k\\%n}_n$ è¯ï¼š$\\omega^k_n=\\cos\\dfrac{2k\\pi}{n}+i\\sin\\dfrac{2k\\pi}{n}=\\cos\\dfrac{2(k\\%n)\\pi}{n}+i\\sin\\dfrac{2(k\\%n)\\pi}{n}=\\omega^{k\\%n}_n$ å…¶ä¸­å€’æ•°ç¬¬äºŒæ­¥æ˜¯å½“$k\\ge n$æ—¶ï¼Œå°†$k$çº¦å»å¾—åˆ°$k\\%n$. $2)\\omega^k_n=(\\omega^1_n)^k$ è¯ï¼š$\\omega^k_n=e^{\\frac{2k\\pi}{n}i}=e^{\\frac{2\\pi}{n}i\\times k}=(e^{\\frac{2\\pi}{n}i})^k=(\\omega^1_n)^k$ $3)\\omega^0_n=1$ è¯ï¼š$\\omega^0_n=\\cos0+i\\sin0=1+0i=1$ $4)\\omega^k_n\\times \\omega^j_n=\\omega^{k+j}_n$ è¯ï¼š$\\omega^k_n\\times \\omega^j_n=(\\omega^1_n)^k\\times(\\omega^1_n)^j=(\\omega^1_n)^{k+j}=\\omega^{k+j}_n$ $5)\\omega^{pk}_{pn}=\\omega^k_n$ è¯ï¼š$\\omega^{pk}_{pn}=e^{\\frac{2pk\\pi}{pn}i}=e^{\\frac{2k\\pi}{n}i}=\\omega^k_n$ $6)\\omega^{k+\\frac{n}{2}}_n=-\\omega^k_n$ è¯ï¼š$\\omega^{k+\\frac{n}{2}}_n=\\omega^{\\frac{2k+n}{2}}_n=e^{\\frac{(2k+n)\\pi}{n}i}=e^{\\frac{2k\\pi}{n}i+\\pi i}=e^{\\frac{2k\\pi}{n}i}\\times e^{\\pi i}=-e^{\\frac{2k\\pi}{n}i}=-\\omega^k_n$ å›åˆ°å¤šé¡¹å¼å…³äºå¤æ•°å’Œå•ä½æ ¹çš„æ€§è´¨å·²ç»è¯´å¾—å¤Ÿå¤šäº†ï¼Œç°åœ¨æŠŠæ³¨æ„åŠ›æ”¾åˆ°å¤šé¡¹å¼ä¸­. å‰é¢æœ‰æåˆ°åˆ†æ²»æ€æƒ³ï¼Œç°åœ¨æˆ‘ä»¬æ¥å¥½å¥½ç ”ç©¶ä¸€ä¸‹. è®¾å¤šé¡¹å¼$F(x)=a_0x^0+a_1x^1+\\cdots+a_{n-1}x^{n-1}=\\sum^{n-1}_{i=0}a_ix^i$ï¼Œåˆ™å®ƒå¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºæˆä¸¤ä¸ªå¤šé¡¹å¼çš„å’Œ.å“ªä¸¤ä¸ªï¼Ÿè¯·çœ‹ï¼š F(x)=\\sum^{n-1}_{i=0}a_ix^i=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{2i}+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{2i+1}å³ï¼šæŒ‰ç…§æ¬¡æ•°çš„å¥‡å¶æ€§å°†å¤šé¡¹å¼$F$åˆ†æˆ$L,R$ä¸¤ä¸ªéƒ¨åˆ†. é‚£ä¹ˆï¼Œä¸ºä»€ä¹ˆè¦è¿™ä¹ˆåˆ†ï¼Ÿè¯·ç»§ç»­å‘ä¸‹çœ‹. è®° L(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{i} R(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{i}åˆ™ F(x)=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}x^{2i}+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}x^{2i+1}=\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i}(x^2)^i+\\sum^{\\frac{n}{2}-1}_{i=0}a_{2i+1}(x^2)^i\\times x=L(x^2)+xR(x^2)é‡å¤´æˆè¿™é‡Œ$F$æ˜¯$(n-1)$æ¬¡çš„å¤šé¡¹å¼ï¼Œéœ€è¦$n$ä¸ªç‚¹æ¥ç¡®å®š. å°†å•ä½æ ¹$\\omega^k_n$ä»£å…¥ F(x)=L(x^2)+xR(x^2)å¾— F(\\omega^k_n)=L(\\omega^{2k}_n)+\\omega^k_nR(\\omega^{2k}_n)å³ (1):\\qquad F(\\omega^k_n)=L(\\omega^{k}_{\\frac{n}{2}})+\\omega^k_nR(\\omega^{k}_{\\frac{n}{2}})åˆ™æˆ‘ä»¬å¾—åˆ°äº†$F(x)$åœ¨$\\omega^0_n,\\omega^1_n,\\cdots,\\omega^{\\frac n2-1}_n$è¿™$\\dfrac n2$ä¸ªç‚¹ä¸Šçš„å€¼. é‚£å¦å¤–$\\dfrac n2$ç‚¹ä¸Šçš„å€¼å‘¢ï¼Ÿ å°†å•ä½æ ¹$\\omega^{k+\\frac n2}_n$ä»£å…¥ F(x)=L(x^2)+xR(x^2)å¾— F(\\omega^k_n)=L(\\omega^{2k+n}_n)+\\omega^{k+\\frac n2}_nR(\\omega^{2k+n}_n)å³ F(\\omega^k_n)=L(\\omega^{2k}_n)+\\omega^{k+\\frac n2}_nR(\\omega^{2k}_n)å³ (2):\\qquad F(\\omega^k_n)=L(\\omega^{k}_{\\frac{n}{2}})-\\omega^k_nR(\\omega^{k}_{\\frac{n}{2}})åˆ™æˆ‘ä»¬å¾—åˆ°äº†$F(x)$åœ¨$\\omega^{\\frac n2}_n,\\omega^{\\frac n2+1}_n,\\cdots,\\omega^{n-1}_n$è¿™å¦å¤–$\\dfrac n2$ä¸ªç‚¹ä¸Šçš„å€¼. å¯¹æ¯”$(1)$å’Œ$(2)$ï¼Œå¯ä»¥çœ‹å‡ºå®ƒä»¬ä¹‹é—´åªå·®äº†ä¸€ä¸ªæ­£è´Ÿå·. æ‰€ä»¥åªè¦çŸ¥é“$L$å’Œ$R$åœ¨$\\omega^0_{\\frac n2},\\omega^1_{\\frac n2},\\cdots,\\omega^{\\frac n2-1}_{\\frac n2}$çš„å€¼ï¼Œå°±å¯ä»¥åœ¨$O(n)$çš„æ—¶é—´å¤æ‚åº¦å†…å”¯ä¸€åœ°ç¡®å®š$F$. é‚£ä¹ˆï¼Œå¦‚ä½•æ±‚å¾—$L$å’Œ$R$åœ¨è¿™äº›ç‚¹ä¸Šçš„å€¼å‘¢ï¼Ÿ æ³¨æ„åˆ°ï¼š$L$å’Œ$R$éƒ½æ˜¯$\\dfrac n2$é¡¹çš„å¤šé¡¹å¼ï¼ åˆ†æ²»æ‰€ä»¥ï¼Œæˆ‘ä»¬å°†è§„æ¨¡ä¸º$n$çš„å¤šé¡¹å¼æ±‚å€¼é—®é¢˜åˆ†è§£æˆäº†è§„æ¨¡ä¸º$\\dfrac n2$çš„å­é—®é¢˜ï¼ é€’å½’åœ°æ±‚è§£å³å¯. ä¸€ä¸ªå°ç»†èŠ‚ï¼šä¸ºäº†é¿å…å‡ºç°$2\\nmid n$çš„æƒ…å†µï¼Œæˆ‘ä»¬å¼ºè¡Œå‘é«˜ä½è¡¥é›¶ï¼Œè¡¥æˆä¸€ä¸ªå…·æœ‰$2^k$é¡¹çš„å¤šé¡¹å¼. ç»¼åˆè¿ç”¨è¿™å°±æ˜¯$\\mathsf{DFT}$ï¼šç¦»æ•£å‚…é‡Œå¶å˜æ¢ï¼ ä»£ç å®ç°ï¼š void dft(comp *f,int len) { if(len==1)return ; comp *fL=f,*fR=f+len/2; for(int k=0;k&lt;len;k++)G[k]=f[k]; for(int k=0;k&lt;len/2;k++)L[k]=G[k&lt;&lt;1],R[k]=G[k&lt;&lt;1|1]; dft(L,len/2); dft(R,len/2); comp W(cos(2*pi/len),sin(2*pi/len)),b(1,0); for(int k=0;k&lt;len/2;k++) { G[k]=L[k]+b*R[k]; G[k+len/2]=L[k]-b*R[k]; b*=W; } for(int k=0;k&lt;len;k++)f[k]=G[k]; } åè¿‡æ¥è®¾$G(z)=\\mathcal{F}[F(x)]$ï¼Œåˆ™$F(x)=\\mathcal F^{-1}[G(z)]$. å…¶ä¸­$\\mathcal F$ç§°ä½œï¼ˆç¦»æ•£ï¼‰å‚…é‡Œå¶å˜æ¢ï¼Œ$\\mathcal F^{-1}$ç§°ä½œï¼ˆç¦»æ•£ï¼‰é€†å‚…é‡Œå¶å˜æ¢ï¼Œåˆç§°$\\mathsf{IDFT}$. $\\mathsf{I}:\\mathsf{Inversed}$ IDFTåŸç† ç»“è®ºï¼š ï¼ˆ$f_i,g_i$ä¸º$F,G$ç¬¬$i$é¡¹çš„ç³»æ•°ï¼‰ nf_k=\\sum^{n-1}_{i=0}\\omega^{-ki}_ng_iè´Ÿæ•°æ¬¡å•ä½æ ¹ï¼Ÿ ç”±å®šä¹‰çŸ¥$\\omega^{-k}_n=(\\omega^{-1}_n)^k$ é‚£ä¹ˆ$\\omega^{-1}_n=\\cos-\\dfrac{2\\pi}{n}+i\\sin-\\dfrac{2\\pi}{n}=\\cos\\dfrac{2\\pi}{n}-i\\sin\\dfrac{2\\pi}{n}$ è¯æ˜ï¼Ÿè¯±å¯¼å…¬å¼ï¼ ä¼˜åŒ–å°†é€’å½’è½¬æ¢ä¸ºå¾ªç¯ï¼Œé¿å…æ•°ç»„çš„æ‹·è´ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºä»¥ä¸‹ä»£ç ï¼Œè¿™å°±æ˜¯ç»å…¸çš„å¿«é€Ÿå‚…é‡Œå¶å˜æ¢ï¼ #include&lt;algorithm&gt; #include&lt;cstdio&gt; #include&lt;cmath&gt; using namespace std; const int N = 5100000, mod = 998244353; const double pi=acos(-1); int n,m; struct comp { comp (double _a=0,double _b=0){a=_a,b=_b;} double a,b; comp operator + (comp const &amp;B) const {return comp(a+B.a,b+B.b);} comp operator - (comp const &amp;B) const {return comp(a-B.a,b-B.b);} comp operator * (comp const &amp;B) const {return comp(a*B.a-b*B.b,a*B.b+b*B.a);} }F[N],G[N]; int t[N]; void fft(comp *f,bool flag) { for (int i=0;i&lt;n;i++) if (i&lt;t[i])swap(f[i],f[t[i]]); for(int p=2;p&lt;=n;p&lt;&lt;=1) { int len=p&gt;&gt;1; comp W(cos(2*pi/p),sin(2*pi/p)); if(!flag)W.b*=-1; for(int k=0;k&lt;n;k+=p) { comp b(1,0); for(int l=k;l&lt;k+len;l++) { comp temp=b*f[len+l]; f[len+l]=f[l]-temp; f[l]=f[l]+temp; b=b*W; } } } } int main() { scanf(&quot;%d%d&quot;,&amp;n,&amp;m); for (int i=0;i&lt;=n;i++)scanf(&quot;%lf&quot;,&amp;F[i].a); for (int i=0;i&lt;=m;i++)scanf(&quot;%lf&quot;,&amp;F[i].b); for(m+=n,n=1;n&lt;=m;n&lt;&lt;=1); for(int i=0;i&lt;n;i++)t[i]=(t[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?n&gt;&gt;1:0); fft(F,1); for(int i=0;i&lt;n;++i)F[i]=F[i]*F[i]; fft(F,0); for(int i=0;i&lt;=m;++i)printf(&quot;%d &quot;,(int)(F[i].b/n/2+0.49)); return 0; } ä¸‰æ¬¡å˜ä¸¤æ¬¡ä¼˜åŒ–ä¸Šé¢çš„ä»£ç ä¸­æœ‰ä½“ç° è®¾$P=F+iG$ åˆ™$P^2=F^2-G^2+2iFG$ å³ï¼Œå°†è¾“å…¥å½“ä½œä¸€ä¸ªå¤šé¡¹å¼çš„å®éƒ¨å’Œè™šéƒ¨ï¼Œå°†å…¶$\\mathsf{FFT}$åè‡ªä¹˜ï¼Œå†$\\mathsf{IFFT}$å›æ¥ï¼Œè¾“å‡ºå°±æ˜¯è™šéƒ¨é™¤ä»¥$2$ æœ€ç»ˆå°è¯•$\\mathtt{Accepted!}$ ä¹ é¢˜å’Œæ‹“å±•é˜…è¯»#6393 å¿«é€Ÿæ•°è®ºå˜æ¢ \\mathrm{END.}","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"www.orchid-any.cf/tags/æ•°å­¦/"},{"name":"FFT","slug":"FFT","permalink":"www.orchid-any.cf/tags/FFT/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"ã€Œé¢˜è§£ã€æ´›è°·P2000æ‹¯æ•‘ä¸–ç•Œ","slug":"SOL-P2000","date":"2020-02-16T01:46:20.000Z","updated":"2020-02-20T02:48:47.143Z","comments":true,"path":"2020/02/16/SOL-P2000/","link":"","permalink":"www.orchid-any.cf/2020/02/16/SOL-P2000/","excerpt":"","text":"ç”Ÿæˆå‡½æ•°è£¸é¢˜ã€‚ æŠŠæ‰€æœ‰æƒ…å†µç½—åˆ—å‡ºæ¥: kkk: é‡‘: $1+x^6+x^{12}+\\dots=\\frac{1}{1-x^6}$ æœ¨: $1+x+x^2+\\dots+x^9=\\frac{1-x^{10}}{1-x}$ æ°´å—: $1+x+x^2+\\dots+x^5=\\frac{1-x^6}{1-x}$ ç«: $1+x^4+x^8+\\dots=\\frac{1}{1-x^4}$ åœŸ: $1+x+x^2+\\dots+x^7=\\frac{1-x^8}{1-x}$ lzn: é‡‘: $1+x^2+x^4+\\dots=\\frac{1}{1-x^2}$ æœ¨: $1+x=\\frac{1-x^2}{1-x}$ æ°´: $1+x^8+x^{16}+\\dots=\\frac{1}{1-x^8}$ ç«: $1+x^{10}+x^{20}+\\dots=\\frac{1}{1-x^{10}}$ åœŸ: $1+x+x^2+x^3=\\frac{1-x^4}{1-x}$ å‡‰å¿ƒå‡ºé¢˜äººå‹å¥½çš„å¡äº†ç²¾åº¦å¹¶ä¸”é¡ºä¾¿å¡äº†pypyã€‚æ‰€ä»¥ï¼Œäººç”Ÿè‹¦çŸ­ï¼ŒRubyç”¨æˆ‘ n = gets.to_i print (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"æ•°å­¦","slug":"æ•°å­¦","permalink":"www.orchid-any.cf/tags/æ•°å­¦/"},{"name":"ç”Ÿæˆå‡½æ•°","slug":"ç”Ÿæˆå‡½æ•°","permalink":"www.orchid-any.cf/tags/ç”Ÿæˆå‡½æ•°/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 91~100é¢˜","slug":"DS100P-91-100-P","date":"2020-02-08T06:03:45.000Z","updated":"2020-02-20T02:48:47.103Z","comments":true,"path":"2020/02/08/DS100P-91-100-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-91-100-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 81~90é¢˜","slug":"DS100P-81-90-P","date":"2020-02-08T06:03:43.000Z","updated":"2020-02-20T02:48:47.102Z","comments":true,"path":"2020/02/08/DS100P-81-90-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-81-90-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 71~80é¢˜","slug":"DS100P-71-80-P","date":"2020-02-08T06:03:41.000Z","updated":"2020-02-20T02:48:47.101Z","comments":true,"path":"2020/02/08/DS100P-71-80-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-71-80-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 61~70é¢˜","slug":"DS100P-61-70-P","date":"2020-02-08T06:03:39.000Z","updated":"2020-02-20T02:48:47.100Z","comments":true,"path":"2020/02/08/DS100P-61-70-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-61-70-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ 51~60é¢˜","slug":"DS100P-51-60-P","date":"2020-02-08T06:03:37.000Z","updated":"2020-02-20T02:48:47.099Z","comments":true,"path":"2020/02/08/DS100P-51-60-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-51-60-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"?????100?? 41~50??","slug":"DS100P-41-50-P","date":"2020-02-08T06:03:35.000Z","updated":"2020-02-20T02:39:58.497Z","comments":true,"path":"2020/02/08/DS100P-41-50-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-41-50-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"?????100?? 31~40??","slug":"DS100P-31-40-P","date":"2020-02-08T06:03:33.000Z","updated":"2020-02-20T02:39:58.497Z","comments":true,"path":"2020/02/08/DS100P-31-40-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-31-40-P/","excerpt":"","text":"","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"?????100?? 21~30??","slug":"DS100P-21-30-P","date":"2020-02-08T06:03:31.000Z","updated":"2020-02-20T02:39:58.499Z","comments":true,"path":"2020/02/08/DS100P-21-30-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-21-30-P/","excerpt":"","text":"21.P4172 [WC2006]?????SC ? MY ???????????????????????????? MY ???????????????????????????????????????????????????????????????????????? $x$ ?????? $y$ ?????????????????????????? $A$ ?? $B$ ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? MY ?????????????????????????????????2?????????????????????????? ?????? MY ???????????I?????????????????????????????????????????????????????????????? ????????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????MST, ?????????????????MST???????????????????????????????????????????????LCT?????????MST??Splay????????????(???????????????) ??????????????????????????????????????????MST??????????????????????????MST????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????lct??split???????????????????????????????????????????????????????????????????????? ????????????????????????????????? ??????????????????????????? ?????????????????????? ????????????????????????????? (????????) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace LinkCutTree { const int SIZE = 12e4 + 5; struct SPLAY { int ch[2]; int fa; int key; int maxValue; int lazyTag; } T[SIZE]; stack &lt; int &gt; MemoryWaste; #define ls T[x].ch[0] #define rs T[x].ch[1] #define WhichSon(x) (T[T[x].fa].ch[1] == x) #define IsRoot(x) (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x) void UpdateMessage(int x) { T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue); } void UpdateSons(int x) { if (T[x].lazyTag) { ls ^= rs ^= ls ^= rs; T[x].lazyTag = 0; T[ls].lazyTag ^= 1; T[rs].lazyTag ^= 1; } } void RotateNode(int x) { int y = T[x].fa; if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x; bool k = WhichSon(x); T[x].fa = T[y].fa; T[y].fa = x; T[y].ch[k] = T[x].ch[k ^ 1]; T[T[y].ch[k]].fa = y; T[x].ch[k ^ 1] = y; UpdateMessage(y); UpdateMessage(x); } void LinkSplay(int x) { int u = x; while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa; MemoryWaste.push(u); while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop(); for (; !IsRoot(x); RotateNode(x)) { int y = T[x].fa; if (!IsRoot(y)) RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y); } } void AccessEdge(int x) { for (int u = x, y = 0; u; y = u, u = T[u].fa) { LinkSplay(u); T[u].ch[1] = y; UpdateMessage(u); } } void MakeRoot(int x) { AccessEdge(x); LinkSplay(x); T[x].lazyTag ^= 1; } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); } void LinkTree(int x, int y) { MakeRoot(x); T[x].fa = y; } void CutTree(int x, int y) { MakeRoot(x); AccessEdge(y); LinkSplay(y); T[x].fa = T[y].ch[0] = 0; } int FindByKey(int x, int u) { if (T[x].key == u) return x; else if (T[ls].maxValue == u) return FindByKey(ls, u); else return FindByKey(rs, u); } } // namespace LinkCutTree using namespace LinkCutTree; int F[1005][1005], U[101000], V[101000]; int OP[101000], ans[101000], n, m, QueryNumber; struct EdgeNode { int x, y; int val, key; EdgeNode() { key = 1; } friend bool operator &lt; (EdgeNode X, EdgeNode Y) { return X.val &lt; Y.val; } } e[101000]; struct UnionFindSet { int fa[1010]; int find(int x) { if (x ^ fa[x]) fa[x] = find(fa[x]); return fa[x]; } void merge(int x, int y) { int u = find(x), v = find(y); if (u ^ v) fa[u] = v; } void init(int n, int m) { for (int i = 1; i &lt;= n; ++i) fa[i] = i; for (int i = 1; i &lt;= m; ++i) { if (e[i].key &amp;&amp; find(e[i].x) ^ find(e[i].y)) { merge(e[i].x, e[i].y); LinkTree(e[i].x, n + i); LinkTree(e[i].y, n + i); } } } } ufs; signed main() { read(n, m, QueryNumber); for (int i = 1; i &lt;= m; ++i) read(e[i].x, e[i].y, e[i].val); sort(e + 1, e + 1 + m); for (int i = 1; i &lt;= m; ++i) { F[e[i].x][e[i].y] = i; F[e[i].y][e[i].x] = i; T[n + i].key = e[i].val; } for (int i = 1; i &lt;= QueryNumber; ++i) { read(OP[i], U[i], V[i]); if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0; } ufs.init(n, m); int EdgeCount = 0; for (int i = QueryNumber; i &gt;= 1; --i) { SplitTree(U[i], V[i]); if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue; else { int Temporary = FindByKey(V[i], T[V[i]].maxValue); if (T[F[U[i]][V[i]] + n].key &lt; T[V[i]].maxValue) { CutTree(e[Temporary - n].x, Temporary); CutTree(e[Temporary - n].y, Temporary); LinkTree(U[i], F[U[i]][V[i]] + n); LinkTree(V[i], F[U[i]][V[i]] + n); } } } for (int i = EdgeCount; i &gt;= 1; --i) write(io_l, ans[i]); return 0; } 22.P3302 [SDOI2013]?????Z????????????N??????????????????????????????????????????????????M????? ??Z??????T?????????????????? Q x y k?????x????y????????????????????k??????????????????????x???y??????????????????????????????k???? L x y???x???y??????????????????????????????????????? ???????????????????????????????????????????lastans?????????????????????????????lastans?0?? ????????????????Q x y k,??????????Q x^lastans y^lastans k^lastans?? ????????????????L x y????????????L x^lastans y^lastans??????^??????????????????pascal????xor???????? ???????????????????Z?????????????? ??????????????????????????????????????????????????????lct???????????????+LCT??(????????????????) ?????????? ??????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????????????????????? #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 9e4 + 5; const int LSIZE = SIZE &lt;&lt; 7; const int GSIZE = SIZE &lt;&lt; 1; int n, m, q, waste; int tot, rt[LSIZE], b[SIZE]; int pri_n, edge_tot, a[SIZE]; int Head[GSIZE], Next[GSIZE]; int Vertex[GSIZE], Weight[GSIZE]; int f[SIZE][LSIZE / SIZE &gt;&gt; 2]; int dp[SIZE], fa[SIZE], id[SIZE]; int size[SIZE], vis[SIZE]; struct TreeNode { int l, r; int size; } tr[LSIZE]; void add(int x, int y, int z = 1) { Vertex[++edge_tot] = y, Weight[edge_tot] = z; Next[edge_tot] = Head[x], Head[x] = edge_tot; } int find_set(int x) { return x == fa[x] ? x : fa[x] = find_set(fa[x]); } int make(int l, int r) { int u = ++tot; if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u; else return 0; } void modify(int &amp;u, int pre, int l, int r, int x) { u = ++tot; tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1}; if (l ^ r) if (mid &gt;= x) modify(tr[u].l, tr[pre].l, l, mid, x); else modify(tr[u].r, tr[pre].r, mid + 1, r, x); else return ; } int query(int x, int y, int lca, int fa_lca, int l, int r, int k) { if (l ^ r) if (_size_ &gt;= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k); else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_); else return l; } void dfs(int x, int _rt_) { for (int i = 1; i &lt; 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1]; modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]); #define y Vertex[i] for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_); #undef y } int get_lca(int x, int y) { if (dp[x] &lt; dp[y]) x ^= y ^= x ^= y; for (int i = 16; i &gt;= 0; --i) if (f[x][i] &amp;&amp; dp[f[x][i]] &gt;= dp[y]) x = f[x][i]; if (x == y) return x; for (int i = 16; i &gt;= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0]; } signed main() { read(waste, n, m, q); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); pri_n = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b; for (int i = 1, x, y; i &lt;= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1); *rt = make(1, pri_n); for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i; int ans = 0, lastans = 0; for (int enum_q = 0; enum_q &lt; q; ++enum_q) { char opt[5]; int x, y, k, lca; read(opt), read(x, y); x ^= lastans, y ^= lastans; if (*opt == &#39;Q&#39;) read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]); else { add(x, y, 1); add(y, x, 1); int u = find_set(x); int v = find_set(y); if (size[u] &lt; size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v; f[y][0] = x; fa[y] = x; dp[y] = dp[x] + 1; vis[y] = true; size[u]++; dfs(y, v); } } return 0; } 23.P3250 [HNOI2016]???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ???????????????????????????????????????? ???????????????????? ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ?? $\\Theta(n\\log^3n)$ ???????????? ????????????????+????????????Splay????????????T????fhq-treap????? ???????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????????????????????????????? ??????????O2????????????2.x s ????? xxx ms! #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define CheckSize ((d[top[x]] &lt; d[top[y]]) &amp;&amp; (x ^= y ^= x ^= y)) #define ForGraph int i = Head[x], y = Vertex[i]; i; i = Next[i], y = Vertex[i] #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; namespace HNOI2016_Network { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { namespace IamJustForPlaying { const int SIZE = 2e5 + 5; const int GSIZE = SIZE &lt;&lt; 1; namespace SegmentTree { priority_queue &lt; int &gt; I[SIZE&lt;&lt;1], D[SIZE&lt;&lt;1]; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) void DoModify(int k, int l, int r, int x, int y, int val, int opt) { if (!(l &gt; y || r &lt; x)) if (l &gt;= x &amp;&amp; r &lt;= y) if (opt) I[k].push(val); else D[k].push(val); else DoModify(ls, l, mid, x, y, val, opt), DoModify(rs, mid + 1, r, x, y, val, opt); } int GetAnswer(int k, int l, int r, int x) { while (I[k].size() &amp;&amp; D[k].size() &amp;&amp; I[k].top() == D[k].top()) I[k].pop(), D[k].pop(); int res = I[k].size() ? I[k].top() : -1; if (l ^ r) if (mid &gt;= x) res = max(res, GetAnswer(ls, l, mid, x)); else res = max(res, GetAnswer(rs, mid + 1, r, x)); return res; } } // namespace SegmentTree namespace TreeChainSplitting { int tx[SIZE], ty[SIZE], tk[SIZE]; int Head[SIZE], Vertex[GSIZE]; int Next[GSIZE], EdgeCount; int fa[SIZE], size[SIZE]; int d[SIZE], son[SIZE]; int dfn[SIZE], rnk[SIZE]; int top[SIZE], tot; int edge_tot = 0, n, m; struct Vector2 { int x; int y; friend bool operator &lt; (Vector2 rhs1, Vector2 rhs2) { return rhs1.x &lt; rhs2.x; } } Vec2[SIZE]; void add(int x, int y) { Vertex[++edge_tot] = y; Next[edge_tot] = Head[x]; Head[x] = edge_tot; } void dfs1(int x, int fa) { size[x] = 1, TreeChainSplitting::fa[x] = fa, d[x] = d[fa] + 1; for (ForGraph) if (y ^ fa) dfs1(y, x), size[x] += size[y], ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)); } void dfs2(int x, int tp) { top[x] = tp, dfn[x] = ++tot, rnk[tot] = x; if (son[x]) dfs2(son[x], tp); for (ForGraph) if (y ^ fa[x] &amp;&amp; y ^ son[x]) dfs2(y, y); } void ModifySubTree(int x, int y, int val, int opt, int tp = 0) { while (top[x] ^ top[y]) CheckSize, Vec2[++tp] = {dfn[top[x]], dfn[x]}, x = fa[top[x]]; if (dfn[x] &gt; dfn[y]) x ^= y ^= x ^= y; Vec2[++tp] = {dfn[x], dfn[y]}; sort(Vec2 + 1, Vec2 + 1 + tp); int Sys = 1; for (int i = 1; i &lt;= tp; ++i) ((Sys &lt; Vec2[i].x) &amp;&amp; (SegmentTree::DoModify(1, 1, n, Sys, Vec2[i].x - 1, val, opt), 1)), Sys = Vec2[i].y + 1; if (Sys &lt;= n) SegmentTree::DoModify(1, 1, n, Sys, n, val, opt); } void main() { read(n, m); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x); dfs1(1, 0), dfs2(1, 1); for (int i = 1, x, y, k, t, opt; i &lt;= m; ++i) { read(opt); if (opt == 0) read(x, y, k), ModifySubTree(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k; else if (opt == 1) read(t), ModifySubTree(tx[t], ty[t], tk[t], 0); else if (opt == 2) read(x), write(io_l, SegmentTree::GetAnswer(1, 1, n, dfn[x])); } } } // namespace TreeChainSplittin } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace IamJustForPlaying } // namespace HNOI2016_Network signed main() { HNOI2016_Network::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::TreeChainSplitting::main(); } 24.P4211 [LNOI2014]LCA???????n????????????????????0??n-1????????0?????????????????????????????????+1????dep[i]?????i???????LCA(i,j)???i??j?????????????????q???????????????l r z????$\\sum_{l \\leq i \\leq r}dep[LCA(i,z)]$ ???????????????????????+1?????l??r??????????????? ??????????????????????+1???? ????????????? ???????????????????????????????????????????? $[1,r]-[1,l-1]$ ?????????l-1??r?????????????????????????????????????????? ??????????????????????????????????????n???????Log??n?? (?????????????????????????????????luogu??T?????lojA???????????luoguA?????lojT???) (??????????????????????????????????????) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define IT vector &lt; int &gt;::iterator #define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i] #define CheckSize ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define TCS TreeChainSplitting #define CFS ChainForwardStar #define PS ProblemSolver #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e4 + 5; namespace ChainForwardStar { const int SIZE = ::SIZE; int tot_, Vert[SIZE]; int Head[SIZE], Next[SIZE]; void AddLine(int x, int y) { Vert[++tot_] = y; Next[tot_] = Head[x]; Head[x] = tot_; } } // namespace ChainForwardStar using CFS::Head; using CFS::Vert; using CFS::Next; using CFS::AddLine; namespace TreeChainSplitting { const int SIZE = ::SIZE; const int MOD = 201314; int n, m, tot, d[SIZE]; int fa[SIZE], size[SIZE]; int son[SIZE], top[SIZE]; int dfn[SIZE], rnk[SIZE]; int ask[SIZE], ans[SIZE]; vector &lt; int &gt; GFY[SIZE]; vector &lt; int &gt; FI[SIZE]; int sum[SIZE &lt;&lt; 2], lf[SIZE &lt;&lt; 2]; void Prepare(int x) { size[x] = 1, d[x] = d[fa[x]] + 1; for (ForGraph) Prepare(y), size[x] += size[y], CheckSize; } void Prepare(int x, int tp) { rnk[dfn[x] = ++tot] = x, top[x] = tp; if (son[x]) Prepare(son[x], tp); for (ForGraph) if (y ^ son[x]) Prepare(y, y); } #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define L_RECUR ls, l, mid, x, y #define R_RECUR rs, mid + 1, r, x, y #define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD, \\ sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k], \\ lf[rs] += lf[k], lf[k] = 0 #define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD void ModifyChain(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k]; else { UpdateSons(k, l, r); if (mid &gt;= x) ModifyChain(L_RECUR); if (mid &lt; y) ModifyChain(R_RECUR); UpdateMessages(k); } } void ModifySubTree(int x) { if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]); } int QueryChain(int k, int l, int r, int x, int y, int res = 0) { if (l &gt;= x &amp;&amp; r &lt;= y) return sum[k]; UpdateSons(k, l, r); if (mid &gt;= x) res += QueryChain(L_RECUR, 0); if (mid &lt; y) res += QueryChain(R_RECUR, 0); return res; } int QuerySubTree(int x, int res = 0) { // luogu-only if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res; } // int QuerySubTree(int x, int res = 0) { // loj-only // while (x) { // res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]); // x = fa[top[x]]; // } // return res; // } } // namespace TreeChainSplitting namespace ProblemSolver { void main() { read(TCS::n), read(TCS::m); for (int i = 2; i &lt;= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i); TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1); int L, R; for (int i = 1; i &lt;= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i]; for (int i = 1; i &lt;= TCS::n; ++i) { TCS::ModifySubTree(i); for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]); for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]); } for (int i = 1; i &lt;= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD); } } // namespace ProblemSover signed main() { PS::main(); } 25.??2018 ???????? Day 3??????????????????????????????????????????????????????????????????????????? ?????????????????????? Day1:?????????????????????????????????????????????????????????????? Day2:cow?????????????????????LCT???????????????????????????????????????????????? Day3???????cow????????????????2????(??????)???????????????????? Day4:?????????????????????????????????????????????????(???????????????)????????? Day5???????????5????????????????????????? ????Description ????????????????????????????????? ????????????????? ??????????????????????????????????? LCR ?????????????? ????????????????????????????????????????????????????????????????? ?????????? LCR ???????? ???? ?????????????????????????????????? K ???????????????????????????????????????????? ??????????????????????????????????????????????????????????????????LCR ????????? $1$????????????????????????????????????????????????????LCR ????????????????????????????? $n$ ????????????? ???????????????????????????????????????????????????? $u$ ??????????????????????????? $v$ ?????? $u,v$ ??????????????????????? $u,v$ ???????? $\\min(u,v)$ ????? ???????????????????LCR ???????????????????????????????????? $u,v$?????? $u$ ??????? $v$ ????????????? ?????????????????????????????????????????????????????????????? ???????????????????????????????????? LCR ????????? ???????????????????? ????????????????????????????????????????????? ???????????????LCR ???????????????????????????????? ??????????????????????????????????????????????????????? ???? ??????????????????????????? ????????????????? LCR ????????????????????????????????????????????? ??????????? ?????? ?????????????????????????????????????????????????????????X?m LCA ???????????? ?????????????????????????????? ??????????? ?????????????????????????????LCR ?????????????????????????????????? LCA ??????????????????????????????????????? ?????????????????????????????????????????????????????????????????????LCA??????????? ???? ?????????????????????????????????????? ?????? LCA ???????????????????? ??????????????? ???????????????????????? ????????????? LCR ?????????????? ????????????? $T=(V,E)$??$V$ ??????????????????????????????????????? $i$ ???????? $i$ ??? ???????????????? $G(T)=(V,Eâ€™)$??$G(T)$ ?????????????????? $(u,v)\\in Eâ€™$ ????????? $T$ ????????????????? $u,v$ ??? $x$ ???? $x$ ??? $u$ ?? $v$ ?????????????????????? $\\min(u,v)$?? ??????? $T$??????????????????? $1$?????????? $q$ ??????????????????????? $\\texttt{1 u v}$ ??????????????? $v$ ???????????? $u$ ?????????????????????????????????????????? $\\texttt{2 u v}$ ?????? $G(T)$ ???? $u$ ?? $v$ ???????????????????? $1$???? ???????????????? ???????????????????????????????????????????????????????????????! ?????????????????? ????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????????**??????Splay??????????????????????????????? ????????????????????????????????????????????+??????????????????????????? ????????????????????????????????????????????????????????????????????????????????????????????????Google????????????????????????????Link ???????????????????????(404??????) #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define SIZE_CHECKER ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define pii pair &lt; int , int &gt; #define pll pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; // #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; vector &lt; vector &lt; int &gt; &gt; G(SIZE); int n, m, st[SIZE], tp, F[SIZE]; int _time[SIZE], _down[SIZE]; int OP[SIZE], U[SIZE], V[SIZE]; void init(int n) { for (int i = 1; i &lt;= n; ++i) F[i] = i; } int find(int x) { if (x ^ F[x]) F[x] = find(F[x]); return F[x]; } namespace CartesianTree { vector &lt; vector &lt; int &gt; &gt; GCT(SIZE); int son[SIZE], fa[SIZE]; int top[SIZE], size[SIZE]; int low[SIZE], d[SIZE]; int tot, ls[SIZE], rs[SIZE]; void Prepare1(int x) { while (_time[st[tp]] &gt; _time[x] &amp;&amp; tp) _down[st[tp--]] = x; st[++tp] = x; size[x] = 1; d[x] = d[fa[x]] + 1; for (auto y : GCT[x]) Prepare1((fa[y] = x, y)), size[x] += size[y], SIZE_CHECKER; } void Prepare2(int x) { ls[x] = ++tot; if (!top[x]) top[x] = x; if (!son[x]) return (void)(rs[x] = tot); top[son[x]] = top[x]; for (auto y : GCT[x]) Prepare2(y); rs[x] = tot; } int GetLCA(int x, int y) { while (top[x] ^ top[y]) d[top[x]] &gt; d[top[y]] ? x = fa[top[x]] : y = fa[top[y]]; return d[x] &lt; d[y] ? x : y; } int Behavior(int x, int y) { while (top[x] ^ top[y]) if (fa[x = top[x]] ^ y) x = fa[x]; else return x; return son[y]; } bool FindRule(int x, int y) { return ls[x] &lt; ls[y]; } bool CheckForFun(int x, int y) { int std = *(upper_bound(GCT[y].begin(), GCT[y].end(), x, FindRule) - 1); return !(ls[low[std]] &gt; rs[x] || ls[x] &gt; ls[low[std]]); } void Main() { init(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; find(j)) GCT[i].pub(find(j)), F[find(j)] = i; Prepare1(n), Prepare2(n); for (int i = 1; i &lt;= n; ++i) for (auto j : G[i]) if (i &gt; j) low[Behavior(j, i)] = j; } } // namespace CartesianTree #define CT CartesianTree namespace LinkCutTree { struct SPLAY { int ch[2]; int fa; int sum; int key; } data[SIZE]; int next[SIZE], root[SIZE]; #define WhichSon(x) (data[data[x].fa].ch[1] == x) void UpdateMessages(int x) { data[x].sum = data[data[x].ch[0]].sum + data[data[x].ch[1]].sum + data[x].key; } void RotateNode(int x) { int y = data[x].fa, z = data[y].fa; int k = WhichSon(x); if (root[y]) root[y] = 0, root[x] = root[y] ^ 1; else data[z].ch[data[z].ch[1] == y] = x; data[x].fa = data[y].fa; data[y].ch[k] = data[x].ch[k ^ 1]; if (data[y].ch[k]) data[data[x].ch[k ^ 1]].fa = y; data[x].ch[k ^ 1] = y; data[y].fa = x; UpdateMessages(y), UpdateMessages(x); } void SplayToRoot(int x) { for (int y; !root[x]; RotateNode(x)) if (!root[y = data[x].fa]) RotateNode(data[data[y].fa].ch[0] ^ y ^ data[y].ch[0] ^ x ? x : y); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); if (data[x].ch[1]) root[data[x].ch[1]] = 1; if (data[x].ch[1] = y) root[y] = 0; UpdateMessages(x); } } void Behavior(int u, int v) { if (u &gt; v) { F[v] = u; data[v].fa = u; data[v].key = 1; data[v].sum = 1; return ; } int x = _down[v], rhs = u; SplayToRoot(x); int rsp = 0, cpy = 0, now = data[x].ch[0]; if (now) { while (data[now].ch[1]) now = data[now].ch[1]; SplayToRoot(now); while (data[x].fa ^ now) RotateNode(x); root[x] = 1; data[now].ch[1] = 0; UpdateMessages(now); } now = data[x].fa; if (next[now] == x) next[now] = v; data[v].key = data[v].sum = data[x].key; if (now) next[v] = x; SplayToRoot(x); data[x].fa = v; data[v].fa = now; data[x].key = 0; UpdateMessages(x); while (u) { SplayToRoot(u); if (data[u].ch[1]) root[data[u].ch[1]] = 1; data[u].ch[1] = rsp; if (data[u].ch[1]) root[rsp] = 0; UpdateMessages(u); if (data[u].sum) { x = u; while (233) if (data[x].ch[1] &amp;&amp; data[data[x].ch[1]].sum) x = data[x].ch[1]; else if (!data[x].key) x = data[x].ch[0]; else break; SplayToRoot(x); if (x &gt;= v) break; u = data[x].ch[0]; if (u) { while (data[u].ch[1]) u = data[u].ch[1]; SplayToRoot(u); data[u].ch[1] = 0; root[x] = 1; UpdateMessages(u); } else u = data[x].fa; if (u &gt;= v) break; SplayToRoot(rhs); if (now = data[rhs].ch[1]) root[now] = 1, data[rhs].ch[1] = 0; if (now = next[rhs]) { SplayToRoot(now); data[now].fa = u; data[now].key = 1; UpdateMessages(now); next[rhs] = 0; } u = F[x]; rhs = F[x]; data[x].key = 0; UpdateMessages(x); SplayToRoot(x); while (data[x].ch[1]) x = data[x].ch[1]; SplayToRoot(x); data[x].ch[1] = cpy; if (data[x].ch[1]) { data[cpy].fa = x, root[cpy] = 0, data[x].ch[1] = cpy; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(x); cpy = x; rsp = 0; } else rsp = u, u = data[u].fa; } F[v] = F[_down[v]]; F[_down[v]] = v; if (!F[v]) { SplayToRoot(v); x = v; while (data[x].ch[1]) x = data[x].ch[1]; if (cpy) { data[x].ch[1] = cpy; root[cpy] = 0; data[cpy].fa = x; while (data[cpy].ch[0]) cpy = data[cpy].ch[0]; next[x] = cpy; SplayToRoot(cpy); } SplayToRoot(v); x = data[v].ch[1]; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); } else if (cpy) { x = cpy; while (data[x].ch[0]) x = data[x].ch[0]; data[x].key = 1; UpdateMessages(x); SplayToRoot(x); data[x].fa = v; } } pii GetDis(int x, int t) { if (x ^ t) { AccessEdge(x); SplayToRoot(x); int st = x; int fir = 0, sec = 0; while (x) if (x &lt; t) sec = x, x = data[x].ch[0]; else x = data[x].ch[1]; SplayToRoot(sec); x = data[sec].ch[1]; fir = data[x].sum; if (!fir) return mp(0, st); while (233) { if (data[data[x].ch[0]].sum) x = data[x].ch[0]; else if (!data[x].key) sec = x, x = data[x].ch[1]; else { if (data[x].ch[0]) { x = data[x].ch[0]; while (data[x].ch[1]) x = data[x].ch[1]; sec = x; } break; } } return mp(fir, sec); } else return mp(0, x); } int GetAnswers(int x, int y) { if (x ^ y) { if (x &gt; y) x ^= y ^= x ^= y; int sys = CT::GetLCA(x, y); if (sys ^ y) { pii t1 = GetDis(x, sys); pii t2 = GetDis(y, sys); return t1.fir + t2.fir + ((CT::CheckForFun(t1.sec, sys) &amp;&amp; CT::CheckForFun(t2.sec, sys)) ^ 1) + 2; } else { pii t = GetDis(x, sys); return t.fir + (CT::CheckForFun(t.sec, sys) ^ 1) + 1; } } else return 0; } } // namespace LinkCutTree #define LCT LinkCutTree namespace SOLVER { void Main() { read(m), read(m); n = 1; for (int i = 1; i &lt;= m; ++i) { read(OP[i], U[i], V[i]); if (OP[i] ^ 1) continue; G[U[i]].pub(V[i]); G[V[i]].pub(U[i]); _time[V[i]] = i; n = max(n, V[i]); } for (int i = 1; i &lt;= n; ++i) LCT::root[i] = true; CT::Main(); F[1] = 0; for (int i = 1; i &lt;= m; ++i) { if (OP[i] ^ 2) LCT::Behavior(U[i], V[i]); else write(io_l, LCT::GetAnswers(U[i], V[i])); } } } signed main() { SOLVER::Main(); } 26.P1121 ?????????????????????????????????????$A_1$??$A_N$?????????????????????????????????????????????????? ????????????: ??? ???? ????????? ??????????DP????????????????????????????! ???????????????????????????????????????? ??????????????????????????????????????????????????????? ?????????????????? ????????????????????? ??????????????? ???????????????????????????????????????5?????????????????????????????????????????? ??????????????????????????????????? ?????? ?????????? ??????????? ????????????? ??????????+??? ????????????+??? ??????????+???? ????????????????? ??????????????????????????? ??????????????????? // ???????????????????? const int SIZE = 4e5 + 5; const int INF = ~0U &gt;&gt; 1; struct TreeNode { // ????????????????? int sum; int maxSum; int maxSumDouble; int maxPrefixSum; int maxSuffixSum; int maxPrePlusSuf; int maxPrePlusMid; int maxSufPlusMid; } data[SIZE&lt;&lt;2]; int ints[SIZE&lt;&lt;1], ans = -INF, n; TreeNode UpdateMessages(TreeNode x, TreeNode y) { // ??????? TreeNode res; res.sum = x.sum + y.sum; // ???????????? res.maxSum = max(x.maxSum, y.maxSum); // // ??????????????????? res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // ??????????????????????/????????? res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // ???????????? res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // ??????????????? res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // ???????????????? res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf); res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum); res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum); res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid); res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum); res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum); res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble); res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum); res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid); return res; } void Initialization(int k, int l) { // ?????????????? data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l]; data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF; } void BuildTree(int k, int l, int r) { if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]); else Initialization(k, l); } TreeNode GetAnswers(int k, int l, int r, int x, int y) { if (l ^ x || r ^ y) { if (mid &gt;= y) return GetAnswers(ls, l, mid, x, y); if (mid &lt; x) return GetAnswers(rs, mid + 1, r, x, y); return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y)); } else return data[k]; } signed main() { read(n); for (int i = 1; i &lt;= n; ++i) read(ints[i]), ints[i + n] = ints[i]; BuildTree(1, 1, n &lt;&lt; 1); for (int i = 1; i &lt;= n; ++i) ans = max(ans, GetAnswers(1, 1, n &lt;&lt; 1, i, i + n - 1).maxSumDouble); write(io_l, ans); } 27.???????????????????? Z ?????????????????t????????? $K$ ??????????? Z ??????????????????????????????????????????????????? Z ????? $K$ ????????????????????? Z ???????????????????????? ?? Z ?????????????????????? $N$ ??????????????????? $1\\ldots N$???? $i$ ????????????? $a[i]$ ???????????????????????????????????????????????????????????????????????????? ?????? Z ????? $N$ ?????????????????? $K$ ????? $K$ ????????? Z ???????????????????????????????????????????????????????? ???????????????? ?????????????????????? ??????????check????dp??$dp_i$ ????? $[1,i]$ ?????????????? dp???????? $dp_i=max{dp_j}+1$?? ????????? $\\Theta(n^2)$ ??????T???? ????????????????????????????????????????? ??????? $\\Theta(n\\log^2n)$ #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (k &lt;&lt; 1) #define rs (k &lt;&lt; 1 | 1) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; __int64 , __int64 &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const __int64 SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; __int64 fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register __int64 i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const __int64 SIZE = 1e6 + 5; const __int64 INF = 0x7fffffff; __int64 a[SIZE], bit[SIZE]; __int64 dp[SIZE], n, k, T; vector &lt; __int64 &gt; disc; void add(__int64 x, __int64 y) { for (; x &gt; 0; x -= x &amp; -x) bit[x] = max(bit[x], y); } __int64 ask(__int64 x, __int64 lim, __int64 res = -INF) { for (; x &lt; lim; x += x &amp; -x) res = max(res, bit[x]); return res; } void Discretization(__int64 x) { disc.clear(); disc.pb(0); for (__int64 i = 1; i &lt;= n; ++i) disc.pb(a[i]); sort(disc.begin(), disc.end()); disc.erase(unique(disc.begin(), disc.end()), disc.end()); } bool Check(__int64 x) { Discretization(x); for (__int64 i = 1; i &lt;= (__int64)disc.size(); ++i) { for (__int64 j = i; j &lt; (__int64)disc.size(); j += j &amp; -j) bit[i] = -INF; for (__int64 j = i; j &gt; 0; j -= j &amp; -j) bit[i] = -INF; } *dp = 0; add(lower_bound(disc.begin(), disc.end(), 0) - disc.begin() + 1, *dp); for (__int64 i = 1; i &lt;= n; ++i) { dp[i] = ask(lower_bound(disc.begin(), disc.end(), a[i] - x) - disc.begin() + 1, disc.size() + 1) + 1; add(lower_bound(disc.begin(), disc.end(), a[i]) - disc.begin() + 1, dp[i]); if (k &lt;= dp[i]) return 1; } return 0; } signed main() { for (read(T); T; --T) { read(n, k); for (__int64 i = 1; i &lt;= n; ++i) read(a[i]), a[i] += a[i - 1]; __int64 l = -INF * SIZE, r = SIZE * INF; while (l &lt; r - 1) if (Check(mid)) r = mid; else l = mid; write(io_l, r); } return 0; } 28.P2163 [SHOI2007]??????????????????????????????????????????????????????????????????????????????????????????????????????????? ?????????????????????????????????????????? ??????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????? ??????????????????????????????????????????????? ?????????????????????????????????N?4002??????????????????????????????????? ???????????????????????? ?????????????????????????????????????????OI?????????????????????????????? ???????????????????????????????? ???????????????????????????????????????????????????????????????? ?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????????????????????????????????????????? ????????????????????????? ?????????????????????????? ?????x????????????????????????insert????? ??????????????????????????l??r ??????root[r]-root[l-1]????? #pragma GCC diagnostic error &quot;-std=c++11&quot; #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define ls (data[rt].l) #define rs (data[rt].r) #define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y)) #define PII pair &lt; int , int &gt; #define PLL pair &lt; LL, LL &gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pb push_back #define R register using namespace std; #ifndef __int8 typedef char __int8; #endif #ifndef __uint8 typedef unsigned char __uint8; #endif #ifndef __int16 typedef short __int16; #endif #ifndef __uint16 typedef unsigned short __uint16; #endif #ifndef __int32 typedef int __int32; #endif #ifndef __int64 typedef long long __int64; #endif #ifndef __uint32 typedef unsigned int __uint32; #endif #ifndef __uint64 typedef unsigned long long __uint64; #endif #define io_e &#39;\\0&#39; #define io_s &#39; &#39; #define io_l &#39;\\n&#39; #define _DEBUG_ 1 // debug toggle namespace Fast_IO { #ifndef _DEBUG_ #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++) #else #define gc() getchar() #endif const int SIZ = 1 &lt;&lt; 21 | 1; char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c; int fr; inline void ioout() { fwrite(obuff, 1, oS - obuff, stdout); oS = obuff; } template &lt;class Type&gt; inline void read(Type&amp; x) { x = 0; Type y = 1; for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc()) ; c == &#39;-&#39; ? y = -1 : x = (c &amp; 15); for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15); x *= y; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } inline void read(char* s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char&amp; c) { for (c = gc(); blank(c); c = gc()) ; } template &lt;typename Type, typename... Args&gt; inline void read(Type&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char* t, Args&amp;... args) { read(t), read(args...); } template &lt;typename... Args&gt; inline void read(char&amp; t, Args&amp;... args) { read(t), read(args...); } template &lt;class Type&gt; inline void write(char lastChar, Type x) { if (x &lt; 0) *oS++ = &#39;-&#39;, x = -x; if (x == 0) *oS++ = &#39;0&#39;; while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10; while (fr) *oS++ = fu[fr--]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x[]) { for (register int i = 0; x[i]; ++i) *oS++ = x[i]; *oS++ = lastChar; ioout(); } inline void write(char lastChar, char x) { *oS++ = x; *oS++ = lastChar; ioout(); } template &lt;typename Type, typename... Args&gt; inline void write(char midChar, Type t, Args... args) { write(midChar, t), write(midChar, args...); } } // namespace Fast_IO using Fast_IO::read; using Fast_IO::write; const int SIZE = 5e5 + 5; const int INF = 1e7; int n, m, tot, rt[SIZE]; struct TreeNode { int l, r; int sum; } data[SIZE &lt;&lt; 5]; struct TwoNode { int x, y; } ints[SIZE]; struct BinarySeach { int upper_bound(int x) { int l = 1, r = n + 1; while (l &lt; r - 1) if (ints[mid].x &gt; x) r = mid; else l = mid; return l; } int lower_bound(int x) { int l = 0, r = n; while (l &lt; r - 1) if (ints[mid].x &gt;= x) r = mid; else l = mid; return r; } } BS; bool cmp(const TwoNode&amp; x, const TwoNode&amp; y) { return x.x &lt; y.x; } void update(int &amp;rt, int l, int r, int x) { data[++tot] = data[rt]; ++data[rt = tot].sum; if (l ^ r) if (mid &gt;= x) update(ls, l, mid, x); else update(rs, mid + 1, r, x); else return ; } int queryf(int rt, int l, int r, int x, int y) { if (l &gt; y || r &lt; x || !rt) return 0; else if (l &gt;= x &amp;&amp; r &lt;= y) return data[rt].sum; else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y); } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i].x, ints[i].y); sort(ints + 1, ints + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) update(rt[i] = rt[i - 1], 0, INF, ints[i].y); for (int i = 1, a, b, c, d; i &lt;= m; ++i) { read(a, b, c, d); write(io_l, queryf(rt[BS.upper_bound(c)], 0, INF, b, d) - queryf(rt[BS.lower_bound(a) - 1], 0, INF, b, d)); } return 0; } 29.P5220 ??????????$\\text{TYM}$ ?????????? $n$ ????????????? $1,\\dots,n$???? $n - 1$ ????????????????????????????????????????????????????????????????????????????? $a_i$?? $\\text{TYM}$ ??????? $m_0$ ??????????????????????????? $s,t$????????????????????????????????? $s$ ???????????????????????????????????? $s,t$ ?????????????? $t$??????????????????????????????????????? $a_i$ ??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ???????????????????$s$ ?? $t$ ????????????????????????????? $20924$ ????????? ??????????????????????????????????????????????????????????????? $a_i$ ??????? ???????????????????? $a_i$ ????????? $m$?? WGY??LCT????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????LCT?? ????????????????????,????????????????????????? ?????????????????LCT??????makeroot??access?? ??????????????????????LCT????????makeroot??access?????????????? ??????????????LCT????????????????????????????????? ??????????????Link ??????????????????Link const int SIZE = 1e5 + 5; const int M_SIZE = 2e5 + 5; const int MOD = 20924; int head[M_SIZE], nxt[M_SIZE]; int to[M_SIZE], ints[SIZE]; int waste[SIZE], n, m, top, tot; struct SPLAY { int fa; int ch[2]; int prod; int preprod; int sufprod; int lztg; } data[SIZE]; void AddEdge(int x, int y) { to[++tot] = y; nxt[tot] = head[x]; head[x] = tot; } bool IsRoot(int x) { return ((data[data[x].fa].ch[1] ^ x) &amp;&amp; (data[data[x].fa].ch[0] ^ x)); } bool WhichSon(int x) { return (data[data[x].fa].ch[1] == x); } void UpdateMessages(int x) { data[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD; data[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD; data[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD; } void UpdateSons(int x) { if (data[x].lztg) { swap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]); swap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]); swap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod); swap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod); data[data[x].ch[0]].lztg ^= 1; data[data[x].ch[1]].lztg ^= 1; data[x].lztg = 0; } } void RotateNode(int x) { int y = data[x].fa; int z = data[y].fa; int k = WhichSon(x); if (!IsRoot(y)) data[z].ch[WhichSon(y)] = x; data[y].fa = x; data[data[y].fa].fa = z; if (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y; data[y].ch[k] = data[x].ch[k ^ 1]; data[x].ch[k ^ 1] = y; UpdateMessages(y); } void SplayToRoot(int x) { int y = waste[top = 1] = x; while (!IsRoot(y)) waste[++top] = y = data[y].fa; while (top) UpdateSons(waste[top--]); for (; !IsRoot(x); RotateNode(x)) if (!IsRoot((y = data[x].fa))) RotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y); UpdateMessages(x); } void AccessEdge(int x) { for (int y = 0; x; x = data[y = x].fa) { SplayToRoot(x); data[x].ch[1] = y; UpdateMessages(x); } } void MakeRoot(int x) { AccessEdge(x); SplayToRoot(x); swap(data[x].ch[0], data[x].ch[1]); swap(data[x].preprod, data[x].sufprod); data[x].lztg ^= 1; UpdateMessages(x); } void SplitTree(int x, int y) { MakeRoot(x); AccessEdge(y); SplayToRoot(y); } void Prepare(int x) { data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; for (int i = head[x]; i; i = nxt[i]) if (to[i] ^ data[x].fa) data[to[i]].fa = x, Prepare(to[i]); } int GetAnswers(int x, int y) { SplitTree(x, y); UpdateSons(y); return data[y].sufprod; } void Behavior(int x, int y) { SplitTree(x, x); ints[x] += y; ints[x] %= MOD; data[x].prod = ints[x]; data[x].preprod = ints[x]; data[x].sufprod = ints[x]; } signed main() { read(n, m); for (int i = 1; i &lt;= n; ++i) read(ints[i]); for (int i = 1, x, y; i &lt; n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x); (*data).prod = 1; Prepare(1); for (int i = 0, x, y; i &lt; m; ++i) { char opt[5]; read(opt); read(x, y); if (*opt ^ &#39;C&#39;) write(io_l, GetAnswers(x, y)); else Behavior(x, y); } return 0; } LYC:TCS","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"?????100?? 11~20??","slug":"DS100P-11-20-P","date":"2020-02-08T06:03:29.000Z","updated":"2020-02-20T02:39:58.499Z","comments":true,"path":"2020/02/08/DS100P-11-20-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-11-20-P/","excerpt":"","text":"11.P3203 [HNOI2010]???????????$Lostmonkey$ ???????????????????????????????????????????????????????????????????? ?????????$Lostmonkey$ ?????????????????? $n$ ???????????????????????? $k_i$???????????? $i$ ?????????????????? $k_i$ ???????? $i+k_i$ ??????????????? $i+k_i$ ?????????????????? ???????????????? $i$ ??????????????????????????????????????????????$Lostmonkey$ ??????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????**???? ??????????????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = 2e5 + 5; class LinkCutTree { public: struct SPLAY { int val; int fa; int ch[2]; } T[SIZE]; inline bool isroot(int x) { return !(T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline void push(int x) { T[x].val = T[T[x].ch[0]].val + T[T[x].ch[1]].val + 1; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, k = T[y].ch[1] == x, w = T[x].ch[!k]; (isroot(y)) &amp;&amp; (T[z].ch[T[z].ch[1] == y] = x); T[x].ch[!k] = y, T[y].ch[k] = w; (w) &amp;&amp; (T[w].fa = y); T[y].fa = x; T[x].fa = z; push(y); } inline void splay(int x) { for(; isroot(x); rotate(x)) { int y = T[x].fa, z = T[y].fa; (isroot(y)) &amp;&amp; (rotate(T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? x : y), 1); } push(x); } inline void access(int x) { for(int y = 0; x; x = T[y = x].fa) splay(x), T[x].ch[1] = y, push(x); } } lct_mast; int n, m; signed main() { scanf(&quot;%d&quot;, &amp;n); for(int i = 1, s; i &lt;= n; ++i) { lct_mast.T[i].val = 1; scanf(&quot;%d&quot;, &amp;s); (i + s &lt;= n) &amp;&amp; (lct_mast.T[i].fa = i + s); } for(scanf(&quot;%d&quot;, &amp;m); m; --m) { int opt, x, y; scanf(&quot;%d&quot;, &amp;opt), scanf(&quot;%d&quot;, &amp;x); if (opt ^ 2) { lct_mast.access(x + 1); lct_mast.splay(x + 1); printf(&quot;%d\\n&quot;, lct_mast.T[x + 1].val); } else { scanf(&quot;%d&quot;, &amp;y); lct_mast.access(x + 1); lct_mast.splay(x + 1); lct_mast.T[x + 1].ch[0] = lct_mast.T[lct_mast.T[x + 1].ch[0]].fa = 0; (x + y + 1 &lt;= n) &amp;&amp; (lct_mast.T[x + 1].fa = x + y + 1); lct_mast.push(x + 1); } } return 0; } 12.SP4487 GSS6 - Can you answer these queries VIThe first line of the input contains an integer N.The following line contains N integers, representing the startingsequence A1..AN, _(|Ai| &lt;= 10000)_. The third line contains an integer Q. The next Q lines contains the operations in following form: I x y: insert element y at position x _(between x - 1 and x)_.D x : delete the element at position x.R x y: replace element at position x with y.Q x y: print max{Ai + Ai+1 + .. + Aj | x &lt;= i &lt;= j &lt;= y}. All given positions are valid, and given values are between -10000 and +10000. The sequence will never be empty. ???????????????????????????????????????????????? ?????????????????????????????$lmax$??x??????????????$rmax$??x??????????????$maxsum$????????????$sum$??? ????$Update$??????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;queue&gt; #include &lt;utility&gt; using namespace std; const int SIZE = 2e5 + 5; int n, m, tot, root, a[SIZE]; struct SPLAY { int fa; int ch[2]; int siz; int val; int sum; int lmax; int rmax; int maxsum; } T[SIZE]; vector &lt; int &gt; st; inline int newnode(int v = 0) { int x; if (st.empty()) x = ++tot; else x = st.back(), st.pop_back(); T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].siz = 1; T[x].val = T[x].sum = T[x].maxsum = v; T[x].lmax = T[x].rmax = max(v, 0); return x; } inline void delnode(int x) { T[x].fa = T[x].ch[0] = T[x].ch[1] = 0; T[x].sum = T[x].lmax = T[x].rmax = T[x].maxsum = 0; T[x].siz = 1; st.push_back(x); } inline bool which(int x) { if (T[T[x].fa].ch[0] == x) return 0; if (T[T[x].fa].ch[1] == x) return 1; return -1; } inline void update(int x) { T[x].sum = T[x].val; T[x].siz = 1; if (T[x].ch[0]) T[x].sum += T[T[x].ch[0]].sum, T[x].siz += T[T[x].ch[0]].siz; if (T[x].ch[1]) T[x].sum += T[T[x].ch[1]].sum, T[x].siz += T[T[x].ch[1]].siz; if (T[x].ch[0] &amp;&amp; T[x].ch[1]) { T[x].lmax = max(T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val + T[T[x].ch[1]].lmax); T[x].rmax = max(T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val + T[T[x].ch[0]].rmax); T[x].maxsum = max({T[T[x].ch[0]].maxsum, T[T[x].ch[1]].maxsum, T[T[x].ch[0]].rmax + T[x].val + T[T[x].ch[1]].lmax}); } else if (T[x].ch[0]) { T[x].lmax = max({T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val, 0}); T[x].rmax = max(T[x].val + T[T[x].ch[0]].rmax, 0); T[x].maxsum = max(T[T[x].ch[0]].maxsum, T[T[x].ch[0]].rmax + T[x].val); } else if (T[x].ch[1]) { T[x].lmax = max(T[x].val + T[T[x].ch[1]].lmax, 0); T[x].rmax = max({T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val, 0}); T[x].maxsum = max(T[T[x].ch[1]].maxsum, T[T[x].ch[1]].lmax + T[x].val); } else { T[x].maxsum = T[x].val; T[x].lmax = T[x].rmax = max(T[x].val, 0); } } inline void rotate(int x) { if (!x) return; int w = which(x), y = T[x].fa; if (~which(y)) T[T[y].fa].ch[which(y)] = x; T[x].fa = T[y].fa; T[y].ch[w] = T[x].ch[w ^ 1]; if (T[x].ch[w ^ 1]) T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int &amp;goal) { if (x == goal) return; int p = T[goal].fa; for (int y; T[x].fa ^ p; rotate(x)) y = T[x].fa, (T[y].fa ^ p) &amp;&amp; (rotate(which(y) ^ which(x) ? x : y), 1); goal = x; } inline int kth_element(int x, int k) { while (233) { if (T[x].ch[0] &amp;&amp; k &lt;= T[T[x].ch[0]].siz) x = T[x].ch[0]; else { if (T[x].ch[0]) k -= T[T[x].ch[0]].siz; if (!--k) return x; x = T[x].ch[1]; } } } inline void insert(int &amp;rt, int p, int val) { int x = kth_element(rt, p); splay(x, rt); int y = kth_element(rt, p + 1); splay(y, T[rt].ch[1]); T[y].ch[0] = newnode(val); T[T[y].ch[0]].fa = y; update(T[y].ch[0]); update(y), update(x); } inline void erase(int &amp;rt, int p) { int y = kth_element(rt, p); splay(y, rt); int x = kth_element(rt, p + 1); splay(x, T[rt].ch[1]); int z = T[x].ch[1]; T[z].fa = y; T[y].ch[1] = z; delnode(x); update(y); } inline void modify(int &amp;rt, int p, int val) { int x = kth_element(rt, p + 1); splay(x, rt); T[x].val = val; update(x); } inline int find(int &amp;rt, int l, int r) { int x = kth_element(rt, l); splay(x, rt); int y = kth_element(rt, r + 2); splay(y, T[rt].ch[1]); return T[T[y].ch[0]].maxsum; } inline void make(int p, int l, int r) { int mid = (l + r) &gt;&gt; 1; T[p].val = a[mid]; if (mid - 1 &gt;= l) T[p].ch[0] = newnode(), T[T[p].ch[0]].fa = p, make(T[p].ch[0], l, mid - 1); if (mid + 1 &lt;= r) T[p].ch[1] = newnode(), T[T[p].ch[1]].fa = p, make(T[p].ch[1], mid + 1, r); update(p); } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); int root = newnode(); make(root, 0, n + 1); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { char opt[2]; int x, y; scanf(&quot;%s %d&quot;, opt, &amp;x); if (*opt ^ &#39;D&#39;) scanf(&quot;%d&quot;, &amp;y); if (*opt == &#39;I&#39;) insert(root, x, y); if (*opt == &#39;D&#39;) erase(root, x); if (*opt == &#39;R&#39;) modify(root, x, y); if (*opt == &#39;Q&#39;) printf(&quot;%d\\n&quot;, find(root, x, y)); } return 0; } 13.Count on a tree??????? $n$ ??????????????????????????? $m$ ????????????? $u$,$v$,$k$ ???????? $u \\text{ xor last}$ ?? $v$ ????????????? $k$ ???????? LYC??????????????????????????????? ?????$k$???????????????????????? ?????????????????????????????????????????? ??????????????????????????????$dfs$???????????(???????????????????$root$?????????????????????????????)?????????????$u$,$v$????????????$k$???? ?????I????????????????????????$k$?????????????? ???????????????????? ???????????????????????????????? ?????????????????????????????????????????????????????????????????????????????????????????????????? ?????????????????$LCA$?????????????????????????????????????????????????????????????????????????? ???????????????? ???? #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; int n,m,p,a[100010],last,u,v,w,fa[100010],dep[100010],son[100010],siz[100010],dfn[100010],ton[100010],hb[100010],tot,be[100010],en[100010],cnt,root[100010],cntot; struct node { int l,r,sum; }nodes[4000010]; vector&lt;int&gt; e[100010],pri; int getID(int val) { return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1; }//????? void dfs1(int x,int las) { dep[x]=dep[las]+1; fa[x]=las; siz[x]=1; int b=-1e9,s=0; for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las) { dfs1(y,x); siz[x]+=siz[y]; if(siz[y]&gt;b) { b=siz[y]; s=y; } } } son[x]=s; } void dfs2(int x,int las,int heavy) { if(heavy) hb[x]=hb[las]; else hb[x]=x; dfn[x]=++tot; ton[tot]=a[x]; if(son[x]) dfs2(son[x],x,1); for(int i=0;i&lt;e[x].size();++i) { int y=e[x][i]; if(y^las&amp;&amp;y^son[x]) dfs2(y,x,0); } } void LCA(int x,int y) { int fx=hb[x],fy=hb[y]; while(fx^fy) { if(dep[fx]&lt;dep[fy]) { swap(fx,fy); swap(x,y); } be[++cnt]=root[dfn[fx]-1]; en[cnt]=root[dfn[x]];//??????????????????-1?????????????find(int l,int r,int p1,int p2,int k)????p1,p2?? x=fa[fx]; fx=hb[x]; } be[++cnt]=root[min(dfn[x],dfn[y])-1]; en[cnt]=root[max(dfn[x],dfn[y])]; //???????????????????????????????u??v??????????????????????????LCA????????????????????????????????????????? }//???? void ins(int l,int r,int pre,int &amp;now,int pos) { nodes[++cntot]=nodes[pre]; now=cntot; ++nodes[now].sum; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos); } int find(int l,int r,int k) { if(l==r) return pri[l-1];//?????????k????????????????? int X=0; for(int i=1;i&lt;=cnt;++i) X+=(nodes[nodes[en[i]].l].sum-nodes[nodes[be[i]].l].sum); //??????u??v????????????????????????[l,mid]????????????? int mid=(l+r)&gt;&gt;1; if(k&lt;=X)//k&lt;=X,?????k???????? { for(int i=1;i&lt;=cnt;++i)//?????????????????????????????????????????????[l,mid]??????? { en[i]=nodes[en[i]].l; be[i]=nodes[be[i]].l; } //??????????????????????????[l,mid]??????????? return find(l,mid,k); } else//??????k?????????k-X?? { for(int i=1;i&lt;=cnt;++i)//?????????????????????????? { en[i]=nodes[en[i]].r; be[i]=nodes[be[i]].r; } return find(mid+1,r,k-X);//???????? } }//????? int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } for(int i=1;i&lt;n;++i) { scanf(&quot;%d %d&quot;,&amp;u,&amp;v); e[u].push_back(v); e[v].push_back(u); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); dfs1(1,1); dfs2(1,1,0); p=pri.size(); for(int i=1;i&lt;=n;++i) ins(1,p,root[i-1],root[i],getID(ton[i]));//??dfs?????? for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w); u^=last; cnt=0; LCA(u,v); last=find(1,p,w); printf(&quot;%d\\n&quot;,last); } return 0; } WGY???????????$x$??????$rt_x=rt_{x-1}$???????$rt_x$??????$a_i$???????????????????????????????? ??????????????????$(x,y)$???????????$rt_x+rt_y-rt_{lca_{x,y}}-rt_{fa_{lca_{x,y}}}$????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) const int SIZE = 1e5 + 5; struct TreeNode { int l, r; int size; } fhq[SIZE &lt;&lt; 5]; int n, m, tot, fa[SIZE], rt[SIZE]; int a[SIZE], rnk[SIZE], dp[SIZE], inq[30][SIZE], lastans, Q[SIZE]; std::vector &lt; std::vector &lt; int &gt; &gt; G(SIZE); inline bool cmp(int x, int y) { return a[x] &lt; a[y]; } inline void newnode(int t, int p) { fhq[++tot] = fhq[rt[t]]; rt[t] = tot; int u = rt[t], l = 1, r = n; while (l ^ r) { fhq[u].size++; if (p &lt;= mid) fhq[++tot] = fhq[fhq[u].l], fhq[u].l = tot, u = fhq[u].l, r = mid; else fhq[++tot] = fhq[fhq[u].r], fhq[u].r = tot, u = fhq[u].r, l = mid + 1; } fhq[u].size++; } inline int find(int a, int b, int c, int d, int l, int r, int u) { if (l ^ r) if (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size &gt;= u) return find(fhq[a].l, fhq[b].l, fhq[c].l, fhq[d].l, l, mid, u); else return find(fhq[a].r, fhq[b].r, fhq[c].r, fhq[d].r, mid + 1, r, u - (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size)); else return l; } inline void dfs(int x, int fa) { dp[x] = dp[fa] + 1; rt[x] = rt[fa]; ::fa[x] = fa; newnode(x, a[x]); for (int i = 0; i &lt; (int)G[x].size(); ++i) if (G[x][i] ^ fa) dfs(G[x][i], x); } inline int lca_mast(int x, int y) { if (dp[x] &lt; dp[y]) std::swap(x, y); for (int i = 0; dp[x] - dp[y]; ++i) if ((1 &lt;&lt; i) &amp; (dp[x] - dp[y])) x = inq[i][x]; if (x ^ y) { for (int i = 25; i &gt;= 0; --i) if (inq[i][x] ^ inq[i][y]) x = inq[i][x], y = inq[i][y]; return fa[x]; } else return x; } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), Q[i] = i; std::sort(Q + 1, Q + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) rnk[i] = a[Q[i]], a[Q[i]] = i; for (int i = 1, x, y; i &lt; n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x); dfs(1, 0); for (int i = 1; i &lt;= n; ++i) inq[0][i] = fa[i]; for (int i = 1; i &lt; 26; ++i) for (int j = 1; j &lt;= n; ++j) inq[i][j] = inq[i - 1][inq[i - 1][j]]; for (int i = 1; i &lt;= m; ++i) { int x, y, z; scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z); x ^= lastans; int lca = lca_mast(x, y); printf(&quot;%d\\n&quot;, lastans = rnk[find(rt[x], rt[y], rt[lca], rt[fa[lca]], 1, n, z)]); } return 0; } 14.P2486 [SDOI2011]?? WGY????????????????????????????1?????????9??????????????????????????????????? ?????????????????$LinkCutTree$??$TreeChainSplitting$????????????$LCT$???????? ???????$Splay$??????????????????????????????????????????????????????????????????????????????????????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define lson (fhq[x].ch[0]) #define rson (fhq[x].ch[1]) using namespace std; #define DEBUG 1 // debug toggle struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m; class LinkCutTree { public: struct SPLAY { int w, c; int l, r; int tag, rev; int fa, ch[2]; } fhq[SIZE]; // The fhq-treap replaces the splay // Struct SPLAY int stack[SIZE], tp; inline bool isroot(int x) { return fhq[fhq[x].fa].ch[0] ^ x &amp;&amp; fhq[fhq[x].fa].ch[1] ^ x; } inline void tr_dn1(int x) { if (fhq[x].rev) swap(lson, rson), swap(fhq[lson].l, fhq[lson].r), swap(fhq[rson].l, fhq[rson].r), fhq[lson].rev ^= 1, fhq[rson].rev ^= 1, fhq[x].rev = 0; } inline void tr_dn2(int x) { if (fhq[x].tag) fhq[x].l = fhq[x].r = fhq[x].c = fhq[x].tag, fhq[lson].tag = fhq[rson].tag = fhq[x].tag, fhq[x].w = fhq[x].tag = 0; } inline void tr_dn(int x) { tr_dn1(x), tr_dn2(x); } inline void tr_up_(int x) { tr_dn(lson), tr_dn(rson); fhq[x].w = fhq[lson].w + fhq[rson].w; } inline void tr_up1(int x) { if (lson) fhq[x].l = fhq[lson].l, ((fhq[x].c ^ fhq[lson].r) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].l = fhq[x].c; } inline void tr_up2(int x) { if (rson) fhq[x].r = fhq[rson].r, ((fhq[x].c ^ fhq[rson].l) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].r = fhq[x].c; } inline void tr_up(int x) { tr_up_(x); tr_up1(x); tr_up2(x); } inline void rotate(int x) { int y = fhq[x].fa, z = fhq[y].fa, k = fhq[y].ch[1] == x; if (!isroot(y)) fhq[z].ch[fhq[z].ch[1] == y] = x; fhq[x].fa = z; fhq[y].ch[k] = fhq[x].ch[k ^ 1], fhq[fhq[x].ch[k ^ 1]].fa = y; fhq[x].ch[k ^ 1] = y; fhq[y].fa = x; tr_up(y); } inline void splay1(int x) { stack[tp = 1] = x; for (int i = x; !isroot(i); i = fhq[i].fa) stack[++tp] = fhq[i].fa; while (tp) tr_dn(stack[tp--]); } inline void splay2(int x) { for (; !isroot(x); rotate(x)) { int y = fhq[x].fa, z = fhq[y].fa; if (!isroot(y)) (fhq[y].ch[1] ^ x ^ fhq[z].ch[1] ^ y) ? rotate(x) : rotate(y); } } inline void splay(int x) { splay1(x), splay2(x); tr_up(x); } inline void access(int x) { for (int y = 0; x; y = x, x = fhq[x].fa) splay(x), rson = y, tr_up(x); } inline void makeroot(int x) { access(x), splay(x), fhq[x].rev ^= 1; } inline int findroot(int x) { access(x), splay(x); while (lson) x = lson; return x; } inline void split(int x, int y) { makeroot(x), access(y), splay(y); } inline void connect(int x, int y) { makeroot(x), fhq[x].fa = y; } } lct_mast; // Class LinkCutTree signed main() { io.read(n), io.read(m); for (int i = 1, x; i &lt;= n; ++i) io.read(x), lct_mast.fhq[i].c = lct_mast.fhq[i].l = lct_mast.fhq[i].r = x; for (int i = 1, x, y; i &lt; n; ++i) io.read(x), io.read(y), lct_mast.connect(x, y); for (int i = 1, a, b, c; i &lt;= m; ++i) { char ch = getchar(); while (ch ^ &#39;C&#39; &amp;&amp; ch ^ &#39;Q&#39;) ch = getchar(); if (ch ^ &#39;Q&#39;) io.read(a), io.read(b), io.read(c), lct_mast.split(a, b), lct_mast.fhq[b].tag = c; else io.read(a), io.read(b), lct_mast.split(a, b), io.write(lct_mast.fhq[b].w + 1, &#39;\\n&#39;); } return 0; } LYC15.??ZJOI2017????????????????????????????????????????????????????????????????????????????OI???????????????????????????????? ????????????$n$??????$A$?????????0????????????$m$??????????????????? * 1 x??????? $A_{x}$ ???? $\\left ( A_{x}+ 1 \\right )$ mod 2?? * 2 l r???????? $ \\left ( \\sum_{i=l}^{r} A_{i} \\right )$ mod 2?? ???????????????????? simple??????????????????????????????????????????young ?????????????????? ???? lowbit($x$) ??????? $x$ ??????? 0 ?????????????? lowbit(5) = 1, lowbit(12) = 4????????????????????????? Add($x$)?????????????????????? Query($l$,$r$)?? ????????????????????????????????????????????????? Add ?? Find ?? $x$ ??????????????????????????????????????????? 0 ??? ?????????????????????????????????????????????????????????????????? ???????? ????????????????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? $x$ ???????????????????????? $x$ ???? $\\left [ l_{i},r_{i} \\right ]$ ?????? ????????? ??? ??????????????????????????? $n$ ?????? $A$?????? 0?????????????? $m$ ???????? * 1 $l$ $r$??????????? $\\left [ l, r \\right ]$ ???????????? $x$ ????? Add($x$)?? * 2 $l$ $r$??????????? Query$\\left ( l, r \\right )$???????????????????????? ??????$\\cdots$???????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; typedef long long int ull; const int SIZE = 1e5 + 5; const int MOD = 998244353; struct TreeNode { int l, r; int val; } tr[SIZE * 400]; int rt[SIZE * 20], n, q, tot; inline ull result(ull p, ull q) { ull res = p * q; res %= MOD; return res = (res + (1 - p + MOD) * (1 - q + MOD) % MOD) % MOD; } inline ull fast_pow(ull x, ull y) { ull res = 1; for (; y; y &gt;&gt;= 1, (x *= x) %= MOD) if (y &amp; 1) (res *= x) %= MOD; return res % MOD; } inline void modifies(int l, int r, int &amp;rt, int x, int y, ull p) { if (!rt) rt = ++tot, tr[rt].val = 1; if (l &gt;= x &amp;&amp; r &lt;= y) return (void)(tr[rt].val = result(p, tr[rt].val)); if (mid &gt;= x) modifies(l, mid, tr[rt].l, x, y, p); if (mid &lt; y) modifies(mid + 1, r, tr[rt].r, x, y, p); } inline void modify(int l, int r, int rt, int lx, int rx, int ly, int ry, ull p) { if (l &gt;= lx &amp;&amp; r &lt;= rx) return (void)(modifies(1, n, ::rt[rt], ly, ry, p)); if (mid &gt;= lx) modify(l, mid, rt &lt;&lt; 1, lx, rx, ly, ry, p); if (mid &lt; rx) modify(mid + 1, r, rt &lt;&lt; 1 | 1, lx, rx, ly, ry, p); } inline ull finds(int l, int r, int rt, int x) { if (!rt) return 1; if (l ^ r) if (mid &gt;= x) return result(tr[rt].val, finds(l, mid, tr[rt].l, x)); else return result(tr[rt].val, finds(mid + 1, r, tr[rt].r, x)); else return tr[rt].val; } inline ull find(int l, int r, int rt, int x, int y) { if (l ^ r) if (mid &gt;= x) return result(finds(1, n, ::rt[rt], y), find(l, mid, rt &lt;&lt; 1, x, y)); else return result(finds(1, n, ::rt[rt], y), find(mid + 1, r, rt &lt;&lt; 1 | 1, x, y)); else return finds(1, n, ::rt[rt], y); } signed main() { scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 0; i &lt; q; ++i) { int opt, l, r; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;l, &amp;r); if (opt ^ 1) printf(&quot;%lld\\n&quot;, find(0, n, 1, l - 1, r)); else { ull p = fast_pow(r - l + 1, MOD - 2); if (l &gt; 1) modify(0, n, 1, 1, l - 1, l, r, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, 1, l - 1, 0); if (r &lt; n) modify(0, n, 1, l, r, r + 1, n, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, r + 1, n, 0); modify(0, n, 1, l, r, l, r, (1 - p * 2 % MOD + MOD) % MOD), modify(0, n, 1, 0, 0, l, r, p); } } return 0; } 16.P2161 [SHOI2009]????// ????LJS?2?????????? ????????????????????????BIT????????????????STL?????? ?????????????????????????????????????????set??????????? ???????????????????set????????? // ???????????? struct LaLaLand { int l, r; bool operator &lt; (const LaLaLand&amp; rhs) const { return r &lt; rhs.l; } }; set &lt; LaLaLand &gt; st; int T; signed main() { for (read(T); T; --T) { char opt[5]; read(opt); int l, r, cnt = 0; if (*opt == &#39;A&#39;) { read(l, r); LaLaLand tmp = {l, r}; IT it = st.find(tmp); while (it != st.end()) ++cnt, st.erase(it), it = st.find(tmp); st.insert(tmp); write(io_l, cnt); } else write(io_l, st.size()); } return 0; } 17.SP11470 TTM - To the moon????????n???????4????? ?? C l r d?????? $[l,r]$ ?????????? $d$ ???????????????? $1$?? Q l r????????????????? $[l,r]$ ??????????? ?? H l r t?????????? $t$ ???? $[l,r]$ ??? ?? B t??????????????? $t$ ?? ????????????????????+?????????????????????????(???????1K)??????(???????????????????) ???????????????????????????????????????? ???â€¦??????????????????????????????????????????????? 18.P4168 [Violet]?????????????????????????????????????????????????????????????? ???????????????????????????????????????n?????? $(a_1,a_2..a_n)$?????? $a_i$ ?????????????????i????????????????? ??????????????? [l,r]?????????????????????????????????????????????????????????????????????????????????????????????? ???????????????????? LYC:???????????????????? ?????????????????????????? ???????????????????????????????????????????????????????????????????????????????? ?????????????????????????????????????????????????????????????????????????????? ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ????????????????????? ???????????????????????????????????????????????????? ?????????????????????$n^{2/3}$????$\\sqrt n$?????????? #include&lt;cmath&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; vector&lt;int&gt; pri; int n,m,a[40010],each,cnt[40][40][40010],MAX[40][40],lans,l,r,ans,tmp[40010]; int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); each=pow(n,2.0/3); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); pri.push_back(a[i]); } sort(pri.begin(),pri.end()); pri.erase(unique(pri.begin(),pri.end()),pri.end()); for(int i=1;i&lt;=n;++i) a[i]=lower_bound(pri.begin(),pri.end(),a[i])-pri.begin()+1;//????? for(int i=1,p=1;i&lt;=n;i+=each,++p) { for(int j=i+each-1,q=p;j&lt;=n;j+=each,++q) { for(int k=i;k&lt;=j;++k) { ++cnt[p][q][a[k]]; if(cnt[p][q][a[k]]&gt;cnt[p][q][MAX[p][q]]||(cnt[p][q][a[k]]==cnt[p][q][MAX[p][q]]&amp;&amp;a[k]&lt;MAX[p][q])) MAX[p][q]=a[k]; } } }//????????????? for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d&quot;,&amp;l,&amp;r); l=(l+lans-1)%n+1; r=(r+lans-1)%n+1; if(l&gt;r) swap(l,r);//??????? if(r-l&gt;2*each) { int p=ceil(1.0*(l-1)/each)+1; int q=ceil(1.0*(r+1)/each)-1;//??????????????? ans=MAX[p][q];//??????? for(int i=(p-1)*each;i&gt;=l;--i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } for(int i=q*each+1;i&lt;=r;++i) { ++cnt[p][q][a[i]]; if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1];//?????? printf(&quot;%d\\n&quot;,lans); for(int i=(p-1)*each;i&gt;=l;--i) --cnt[p][q][a[i]]; for(int i=q*each+1;i&lt;=r;++i) --cnt[p][q][a[i]];//???? } else//???????????????????????????????????????????????????????????????? { ans=0; for(int i=l;i&lt;=r;++i) { ++tmp[a[i]]; if(tmp[a[i]]&gt;tmp[ans]||(tmp[a[i]]==tmp[ans]&amp;&amp;a[i]&lt;ans)) ans=a[i]; } lans=pri[ans-1]; printf(&quot;%d\\n&quot;,lans); for(int i=l;i&lt;=r;++i) --tmp[a[i]];//???????? } } return 0; } WGY:??????luogu??????????????â€¦????â€¦????????????+??????????? ???â€¦.????????(?????????????????????????????????â€¦) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 50000 + 5; int a[SIZE], b[SIZE]; int cnt[SIZE], x; int l, r, n, m, l0, r0; signed main() { io.read(n), io.read(m); for (int i = 1; i &lt;= n; ++i) io.read(a[i]), b[i] = a[i]; sort(b + 1, b + 1 + n); int len = unique(b + 1, b + 1 + n) - b - 1; for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b; while (m--) { io.read(l0), io.read(r0); l = (l0 + x - 1) % n + 1; r = (r0 + x - 1) % n + 1; if (l &gt; r) swap(l, r); for (int i = l; i &lt;= r; ++i) cnt[a[i]]++; int MAX = 0, pos = 0; for (int i = 1; i &lt;= len; ++i) if (MAX &lt; cnt[i]) MAX = cnt[i], pos = i; printf(&quot;%d\\n&quot;, b[pos]); x = b[pos]; memset(cnt, 0, sizeof cnt); } } 19.[CQOI2014]???????????????????????????????????????????????????????????????????????????????????????????????????????????????????? $P_1$ ???????????????????? $P_1$ ??????? (?????? $[1,P_1]$ ???????) ??????????????????????????? $P_2$ ????????????????? $P_2$ ??????? (?????? $[2,P_2]$ ???????) ?????????????????????????????? ???????????????????????????????????????????????????? $4$ ?????????????????????????????????????????????????D?????????????????????????? ???????????????????????????????????????????????????? $i$ ?????????????? $P_i$ ???????????????????????????????????????????????????????????????????????????????????? LYC???????????????? ?????????????????????6??????????? ????????????????????????????????????????????????????? ?????? ????????????? ??????????? ?????????update??????????????????????????????????????????????????????????????????? ????????????????????? 1).??????????????????????????????? ????????????????????? ???????????????????????????????????????????? 2).????????????????? ?????????????????????? 3).????????????????? ??????????????? ????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????? ????????????????????????????????????????????????????????? ???? #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,tot,root,root1,root2,root3,c[100010]; struct node { int l,r,num,key,sum; int s,smum;//?????????????????????? bool rev;//??????? }nodes[100010]; struct laji { int v,ID; }a[100010]; bool cmp(laji one,laji two) { if(one.v^two.v) return one.v&lt;two.v; return one.ID&lt;two.ID; }//???????????????????????????????????????????? int newnode(int val) { nodes[++tot].s=val;//????????????????????? nodes[tot].num=val; nodes[tot].key=rand(); nodes[tot].sum=1; return tot; } void pushdown(int x) { swap(nodes[x].l,nodes[x].r);//?????????????? nodes[x].smum=nodes[x].sum-(nodes[x].smum+1);//?????????????????????????????t???????? //????????????????nodes[x].smum //?????: nodes[x].smum+1 //????????nodes[x].sum-(nodes[x].smum+1)+1 //??????????????????nodes[x].sum-(nodes[x].smum+1) nodes[nodes[x].l].rev^=1; nodes[nodes[x].r].rev^=1;//???????? nodes[x].rev=0;//??????? } void update(int x) { nodes[x].sum=nodes[nodes[x].l].sum+nodes[nodes[x].r].sum+1; if(nodes[nodes[x].l].rev) pushdown(nodes[x].l); if(nodes[nodes[x].r].rev) pushdown(nodes[x].r);//??????????????????????????????????3???????? if(nodes[x].num&lt;nodes[nodes[x].l].s&amp;&amp;nodes[x].num&lt;nodes[nodes[x].r].s)//????????????1 { nodes[x].s=nodes[x].num; nodes[x].smum=nodes[nodes[x].l].sum; } else if(nodes[nodes[x].l].s&lt;nodes[nodes[x].r].s)//????2 { nodes[x].s=nodes[nodes[x].l].s; nodes[x].smum=nodes[nodes[x].l].smum; } else//????3 { nodes[x].s=nodes[nodes[x].r].s; nodes[x].smum=nodes[nodes[x].r].smum+nodes[nodes[x].l].sum+1; } } void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[now].rev) pushdown(now);//????????????????????????????????? if(nodes[nodes[now].l].sum&lt;siz) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { if(nodes[x].rev) pushdown(x); nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { if(nodes[y].rev) pushdown(y); nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } int main() { srand(20060515); nodes[0].num=nodes[0].s=1e9;//????????????????????????????????????????????0?????? scanf(&quot;%d&quot;,&amp;n); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i].v); a[i].ID=i; } sort(a+1,a+1+n,cmp); for(int i=1;i&lt;=n;++i) c[a[i].ID]=i;//????? for(int i=1;i&lt;=n;++i) root=merge(root,newnode(c[i]));//??????????????????????????????????? for(int i=1;i&lt;=n;++i) { if(nodes[root].rev) pushdown(root);//????????????????????????????????????????????? printf(&quot;%d &quot;,nodes[root].smum+i);//????????i-1?????????????? split(root,nodes[root].smum,root1,root2); split(root2,1,root2,root3);//????????? nodes[root1].rev^=1;//???????????? root=merge(root1,root3); } return 0; } WGY:SplayNB?????????????????????????(????????????LYC???????????) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; // #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 100000 + 5; struct SPLAY { int fa; int size; int val; int rev; int ch[2]; } t[SIZE]; int n, root, tot, pos[SIZE]; struct InputNode { int id; int val; } a[SIZE]; bool cmp1(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.val ^ rsp.val ? rhs.val &lt; rsp.val : rhs.id &lt; rsp.id; } bool cmp2(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.id &lt; rsp.id; } void update(int x) { t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; } void transf(int x) { if (t[x].rev) { swap(t[x].ch[0], t[x].ch[1]); t[t[x].ch[0]].rev ^= 1; t[t[x].ch[1]].rev ^= 1; t[x].rev = 0; } } int make(int fa, int l, int r) { if (l &gt; r) return 0; int p = ++tot; return(t[p].val = a[mid].val, t[p].fa = fa, pos[a[mid].val] = p, t[p].ch[0] = make(p, l, mid - 1), t[p].ch[1] = make(p, mid + 1, r), update(p), p); } void rotate(int x) { int y = t[x].fa, z = t[y].fa; transf(y), transf(x); int k = t[t[x].fa].ch[1] == x; t[y].ch[k] = t[x].ch[k ^ 1]; t[t[y].ch[k]].fa = y; t[y].fa = x; t[x].ch[k ^ 1] = y; t[x].fa = z; if (z) t[z].ch[y == t[z].ch[1]] = x; update(y), update(x); } void splay(int x, int goal) { for (int y; (y = t[x].fa) ^ goal; rotate(x)) if (t[y].fa ^ goal) rotate(t[t[x].fa].ch[1] ^ x ^ y ^ t[t[y].fa].ch[1] ? x : y); if (!goal) root = x; } int behavior() { transf(root); int x = t[root].ch[1]; while (transf(x), t[x].ch[0]) x = t[x].ch[0]; return x; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i + 1].val), a[i + 1].id = i + 1; a[1].val = 0, a[n + 2].val = n + 1; sort(a + 2, a + 2 + n, cmp1); for (int i = 2; i &lt;= n + 1; ++i) a[i].val = i - 1; sort(a + 2, a + 2 + n, cmp2); root = make(0, 1, n + 2); for (int i = 1; i &lt;= n; ++i) { int x = pos[i]; splay(x, 0); printf(&quot;%d &quot;, t[t[x].ch[0]].size); x = behavior(); int y = pos[i - 1]; splay(y, 0); splay(x, y); t[t[x].ch[0]].rev ^= 1; } return 0; } 20.[SHOI2013]??????????(???????&amp;?????) ???? n ???????????????????????????????? $k$ ????????????? LYC:???????????????????,?????????????? ??????? ???????????????????????????????????? ?????????????????$10^5$??????????????????????????$10^9$?? ????????????????????????????????? ??????????????????????????a??????????????? ?????????????????????????????????????????????????????????????? ????????????????????????????????????????????????? ??????????????????????? ??????????????????????????????????????????????????????????????? ????????????????????? $\\ $ ???????????????????????? ?????????????????????????$k$????????????????? ???????????????????????????? ???????????????????????? ??????????????????????????????????? ?????????$k$???????????????????????$k$?????????????????????$k$???????????????????????????????????????????$k$?? ???????????????????????????????????????????????????????????$k$?????????? ????????????????????????????????????????????????????????? ?????????????????????? ???? #include&lt;cstdio&gt; #include&lt;vector&gt; #include&lt;algorithm&gt; using namespace std; long long n,m,k,nodes[400010],a1,a2,ans,s,now; struct cir { long long r; bool insorex;//1??????2???? }cur; vector&lt;cir&gt; op[2000010];//???????????????????? void ins(long long l,long long r,long long x,long long pos) { ++nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,x&lt;&lt;1,pos); else ins(mid+1,r,x&lt;&lt;1|1,pos); } } void exins(long long l,long long r,long long x,long long pos)//?????????? { --nodes[x]; if(l^r) { long long mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) exins(l,mid,x&lt;&lt;1,pos); else exins(mid+1,r,x&lt;&lt;1|1,pos); } } long long find(long long l,long long r,long long x,long long val)//?????????????????k?? { if(l==r) return l; long long mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1|1]) return find(mid+1,r,x&lt;&lt;1|1,val); else return find(l,mid,x&lt;&lt;1,val-nodes[x&lt;&lt;1|1]); } int main() { scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;k); for(long long i=1;i&lt;=n;++i) { scanf(&quot;%lld %lld %lld&quot;,&amp;cur.r,&amp;a1,&amp;a2); s=max(s,cur.r); a1+=m; a2+=m;//a1,a2????????? //????????????? if(a1&gt;a2)//????????????????????????????? { cur.insorex=1; op[a1+1].push_back(cur); op[1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } else { cur.insorex=1; op[a1+1].push_back(cur); cur.insorex=0; op[a2+1].push_back(cur); } } for(long long i=1;i&lt;=m*2;++i)//??????????(-Pi,Pi] { for(long long j=0;j&lt;op[i].size();++j)//?????????? { cur=op[i][j]; if(cur.insorex) { ins(1,s,1,cur.r); ++now; } else { exins(1,s,1,cur.r); --now;//????????????????? } } if(now&gt;=k)//??k?????????????????? { long long tmp=find(1,s,1,k); ans+=tmp*tmp;//??????????Pi*r*r } } printf(&quot;%lld\\n&quot;,ans); return 0; } WGY?????????+???????????????$O(n\\log^2n)$ ??????????????????????????????????????????????????????? ??????????????????? $k$ ??????????????????????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) #define mp make_pair #define fir first #define sec second #define pub push_back #define pob pop_back using namespace std; typedef long long LL; #define DEBUG 1 struct IO { #define MAXSIZE (1 &lt;&lt; 20) #define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;) char buf[MAXSIZE], *p1, *p2; char pbuf[MAXSIZE], *pp; #if DEBUG #else IO() : p1(buf), p2(buf), pp(pbuf) {} ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); } #endif inline char gc() { #if DEBUG return getchar(); #endif if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin); return p1 == p2 ? &#39; &#39; : *p1++; } inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\\n&#39; || ch == &#39;\\r&#39; || ch == &#39;\\t&#39;; } template &lt;class T&gt; inline void read(T &amp;x) { register double tmp = 1; register bool sign = 0; x = 0; register char ch = gc(); for (; !isdigit(ch); ch = gc()) if (ch == &#39;-&#39;) sign = 1; for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;); if (ch == &#39;.&#39;) for (ch = gc(); isdigit(ch); ch = gc()) tmp /= 10.0, x += tmp * (ch - &#39;0&#39;); if (sign) x = -x; } inline void read(char *s) { register char ch = gc(); for (; blank(ch); ch = gc()) ; for (; !blank(ch); ch = gc()) *s++ = ch; *s = 0; } inline void read(char &amp;c) { for (c = gc(); blank(c); c = gc()) ; } inline void push(const char &amp;c) { #if DEBUG putchar(c); #else if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf; *pp++ = c; #endif } template &lt;class T&gt; inline void write(T x) { if (x &lt; 0) x = -x, push(&#39;-&#39;); static T sta[35]; T top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + &#39;0&#39;); } template &lt;class T&gt; inline void write(T x, char lastChar) { write(x), push(lastChar); } } io; const int SIZE = 1e6 + 5; int n, m, k, a[SIZE]; LL tree[SIZE], ans; vector &lt; int &gt; In[SIZE&lt;&lt;1], Out[SIZE&lt;&lt;1]; void Add(int x, int y) { for (; x &lt; SIZE; x += x &amp; -x) tree[x] += y; } int Ask(int x, int res = 0) { for (; x; x -= x &amp; -x) res += tree[x]; return res; } int KthElement(int k) { int l = 1, r = SIZE - 5; while (l &lt; r) if (Ask(mid) &lt; k) l = mid + 1; else r = mid; return l; } signed main() { io.read(m), io.read(n), io.read(k); int L, R; for (int i = 1; i &lt;= m; ++i) { io.read(a[i]); io.read(L); io.read(R); if (L &lt; R) L += n + 1, R += n, In[L].pub(i), Out[R + 1].pub(i); else L ^= R ^= L ^= R, L += n, R += n + 1, In[1].pub(i), Out[L + 1].pub(i), In[R].pub(i); } int now = 0, x; for (int i = 1; i &lt;= (n&lt;&lt;1); ++i) { for (int j = 0; j &lt; In[i].size(); ++j) Add(a[In[i][j]], 1); for (int j = 0; j &lt; Out[i].size(); ++j) Add(a[Out[i][j]], -1); now += In[i].size() - Out[i].size(); if (now &gt;= k) x = KthElement(now - k + 1), ans += (LL)x * x; } printf(&quot;%lld\\n&quot;, ans); return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"?????100?? 1~10??","slug":"DS100P-1-10-P","date":"2020-02-08T06:03:27.000Z","updated":"2020-02-20T02:39:58.498Z","comments":true,"path":"2020/02/08/DS100P-1-10-P/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-1-10-P/","excerpt":"","text":"1.?????? 4.6 ?? 1?????????????????HNOI 2002 Tiger ????????????????????????????????????????????????????????????????????????????????????? Tiger ???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????????? $a_i$??????????? $b$??????????????????? $\\delta=\\min |a_i-b|$???????????????????????????????????????????????????????????????????????????????????????????????????????????????? ?????????????????????????? Tiger ??????????????????????????????????????????? ??????????????? $n$ ?????????? $\\{a_n\\}$??????? $i$ ????? $a_i$?????? $f_i=\\min |a_i-a_j|$?????? $1\\le j\\lt i,f_1=a_1$???? $\\sum f_i$?? ???????????????????????????????????splay????????????????????????????? ?????????????? ???????????????????????????????x??????????????????????????x????????????????????????????????????insert???????? #include &lt;cstdio&gt; #include &lt;algorithm&gt; #define mid (l + r &gt;&gt; 1) #define int long long using namespace std; const int SIZE = (1 &lt;&lt; 15) + 5; const int INF = 0x7fffffff; struct SplayNode { SplayNode *son[2], *fa; int val, siz; SplayNode(SplayNode *fa = NULL, int val = 0) : fa(fa), val(val) { *son = *(son + 1) = NULL; siz = 1; } inline bool islyczbing() { return this == fa-&gt;son[1]; } inline int rnk() { return 1 + (*son ? (*son)-&gt;siz : 0); } inline void up() { siz = 1 + (*son ? (*son)-&gt;siz : 0) + ((*(son + 1)) ? (*(son + 1))-&gt;siz : 0); } } * root; inline void rotate(SplayNode *x) { bool k = x-&gt;islyczbing(); SplayNode *y = x-&gt;fa, *z = y-&gt;fa, *w = x-&gt;son[!k]; if (root == y) root = x; else z-&gt;son[y-&gt;islyczbing()] = x; x-&gt;fa = z; y-&gt;fa = x; x-&gt;son[!k] = y; y-&gt;son[k] = w; if (w) w-&gt;fa = y; y-&gt;up(); x-&gt;up(); } inline void cosplay(SplayNode *x) { while (x != root) { if (x-&gt;fa != root) rotate(x-&gt;islyczbing() ^ x-&gt;fa-&gt;islyczbing() ? x : x-&gt;fa); rotate(x); } } inline void insert(int val) { if (!root) return (void)(root = new SplayNode(NULL, val)); SplayNode *p = root, *fa = NULL; while (p) { fa = p; p = p-&gt;son[val &gt; p-&gt;val]; } p = new SplayNode(fa, val); fa-&gt;son[val &gt; fa-&gt;val] = p; cosplay(p); } inline int getpre(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &gt; p-&gt;val) lst = p, p = p-&gt;son[1]; else p = p-&gt;son[0]; } if (lst) return cosplay(lst), lst-&gt;val; return -INF; } inline int getnext(int val) { SplayNode *p = root, *lst = NULL; while (p) { if (val &lt; p-&gt;val) lst = p, p = p-&gt;son[0]; else p = p-&gt;son[1]; } if (lst) return cosplay(lst), lst-&gt;val; return INF; } signed main() { root = NULL; int n; scanf(&quot;%lld&quot;, &amp;n); int ans = 0; for (int i = 1, x; i &lt;= n; ++i) { scanf(&quot;%lld&quot;, &amp;x); if (i == 1) ans += x; else ans += min(x - getpre(x + 1), getnext(x - 1) - x); insert(x); } printf(&quot;%lld\\n&quot;, ans); return 0; } 2.[SHOI2013]?????????????????????????????????????????????????????????????????????????????????burn card?????????????????????????????????????????????????????????????????????? ?????????????????????????????????N ??????????????????1??N???????????????????????????????????????????????1, 2,???????N??N ???????????????????????????????????N ??????????????i ??????????????????????Ri??????????? Ri???????????????????????????????????????????? ????????????N = 4??????????????????????????????{1, 2, 3, 4}?? ????R1=2???????????????????????1 ??2 ?????????????3 ????????????????????????{4, 1, 2}?? ????R2=0??????????????????4 ????????????????????????{1,2}?? ????R3=3????????????????1, 2, 1?????2 ??????????????????????????1?? ????R4=2?????????????????1 ????????1 ??????????????????1 ?????????????????? splay???? by wgy???????????????splay???1-x???????????????????????????????????????? ?????? #pragma GCC optimize(2) #pragma GCC optimize(3) #pragma GCC optimize(&quot;Ofast&quot;) #pragma GCC optimize(&quot;inline&quot;) #pragma GCC optimize(&quot;-fgcse&quot;) #pragma GCC optimize(&quot;-fgcse-lm&quot;) #pragma GCC optimize(&quot;-fipa-sra&quot;) #pragma GCC optimize(&quot;-ftree-pre&quot;) #pragma GCC optimize(&quot;-ftree-vrp&quot;) #pragma GCC optimize(&quot;-fpeephole2&quot;) #pragma GCC optimize(&quot;-ffast-math&quot;) #pragma GCC optimize(&quot;-fsched-spec&quot;) #pragma GCC optimize(&quot;unroll-loops&quot;) #pragma GCC optimize(&quot;-falign-jumps&quot;) #pragma GCC optimize(&quot;-falign-loops&quot;) #pragma GCC optimize(&quot;-falign-labels&quot;) #pragma GCC optimize(&quot;-fdevirtualize&quot;) #pragma GCC optimize(&quot;-fcaller-saves&quot;) #pragma GCC optimize(&quot;-fcrossjumping&quot;) #pragma GCC optimize(&quot;-fthread-jumps&quot;) #pragma GCC optimize(&quot;-funroll-loops&quot;) #pragma GCC optimize(&quot;-fwhole-program&quot;) #pragma GCC optimize(&quot;-freorder-blocks&quot;) #pragma GCC optimize(&quot;-fschedule-insns&quot;) #pragma GCC optimize(&quot;inline-functions&quot;) #pragma GCC optimize(&quot;-ftree-tail-merge&quot;) #pragma GCC optimize(&quot;-fschedule-insns2&quot;) #pragma GCC optimize(&quot;-fstrict-aliasing&quot;) #pragma GCC optimize(&quot;-fstrict-overflow&quot;) #pragma GCC optimize(&quot;-falign-functions&quot;) #pragma GCC optimize(&quot;-fcse-skip-blocks&quot;) #pragma GCC optimize(&quot;-fcse-follow-jumps&quot;) #pragma GCC optimize(&quot;-fsched-interblock&quot;) #pragma GCC optimize(&quot;-fpartial-inlining&quot;) #pragma GCC optimize(&quot;no-stack-protector&quot;) #pragma GCC optimize(&quot;-freorder-functions&quot;) #pragma GCC optimize(&quot;-findirect-inlining&quot;) #pragma GCC optimize(&quot;-fhoist-adjacent-loads&quot;) #pragma GCC optimize(&quot;-frerun-cse-after-loop&quot;) #pragma GCC optimize(&quot;inline-small-functions&quot;) #pragma GCC optimize(&quot;-finline-small-functions&quot;) #pragma GCC optimize(&quot;-ftree-switch-conversion&quot;) #pragma GCC optimize(&quot;-foptimize-sibling-calls&quot;) #pragma GCC optimize(&quot;-fexpensive-optimizations&quot;) #pragma GCC optimize(&quot;-funsafe-loop-optimizations&quot;) #pragma GCC optimize(&quot;inline-functions-called-once&quot;) #pragma GCC optimize(&quot;-fdelete-null-pointer-checks&quot;) #pragma GCC optimize(2) #pragma GCC optimize(3) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #include &lt;cctype&gt; #define mid (l + r &gt;&gt; 1) using namespace std; const int SIZE = 7e5 + 5; struct SPLAY { int siz; int val; int ch[2]; int fa; } T[SIZE]; int root, n, R[SIZE], tot; template &lt; typename T &gt; inline void read ( T &amp;a ) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T &gt; inline T read ( T _checkType, bool _Typeflag ) { T f = 1, a = 0; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } template &lt; typename T &gt; inline void write ( T x, char end_, int st = 0 ) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10, end_, st + 1); putchar(x % 10 + &#39;0&#39;); if (!st) putchar(end_); } inline void update(int u) { T[u].siz = T[T[u].ch[0]].siz + T[T[u].ch[1]].siz + 1; } inline int make(int l, int r, int fa) { int u = ++tot; T[u].siz = 1; T[u].val = mid; T[u].ch[0] = T[u].ch[1] = 0; T[u].fa = fa; if (mid &gt; l) T[u].ch[0] = make(l, mid - 1, u); if (mid &lt; r) T[u].ch[1] = make(mid + 1, r, u); update(u); return u; } inline void rotate(int x) { int y = T[x].fa; int z = T[y].fa; int w = T[y].ch[1] == x; T[z].ch[T[z].ch[1] == y] = x; T[x].fa = z; T[y].ch[w] = T[x].ch[w ^ 1]; T[T[x].ch[w ^ 1]].fa = y; T[x].ch[w ^ 1] = y; T[y].fa = x; update(y), update(x); } inline void splay(int x, int goal) { for (; T[x].fa ^ goal; rotate(x)) { int y = T[x].fa; int z = T[y].fa; if (z ^ goal) T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y); } if (!goal) root = x; } inline int getRank(int x) { int u = root; while (233) { if (x &lt;= T[T[u].ch[0]].siz) u = T[u].ch[0]; else { x -= T[T[u].ch[0]].siz + 1; if (!x) return u; u = T[u].ch[1]; } } } inline int getcard(int x) { if (x) { splay(getRank(x), 0); int u = root; root = T[u].ch[1]; T[root].fa = 0; T[u].ch[1] = 0; update(u); splay(getRank(T[root].siz), 0); if (u) T[u].fa = root; if (root) T[root].ch[1] = u, update(root); } int ranker = getRank(1); int res = T[ranker].val; splay(ranker, 0); if (T[ranker].ch[1]) T[root = T[ranker].ch[1]].fa = 0; return res; } signed main() { read(n); root = make(1, n, 0); for (int i = 1; i &lt;= n; ++i) { read(R[i]); write(getcard(R[i] % T[root].siz), &#39;\\n&#39;); } return 0; } ??????????? by lyc:??????????????? ??????? ????O2??????????? ???????????????????????????????????????? ?????????????7e5??????????????????????????????????????????????????????????????????????????????? ???????????????????????????????????????????????????????1??2??3??4 -&gt;1??3??4????????????????now?????????????????????????????????????????????????0??n%n???????????a???????????now??????a???????????????????????????????????now??????????????????????????????????????????????????????????now???????????????????????????????????????????e??????????????????????????now???????????????????????????????? ???? #include&lt;cstdio&gt; int n,nodes[80000010],now,a; void writing(int x) { if(!x) return; writing(x/10); putchar((x%10)+&#39;0&#39;); } void read(int &amp;hhh) { int x=0; char c=getchar(); while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)) c=getchar(); x=c^&#39;0&#39;; c=getchar(); while((c&lt;=&#39;9&#39;)&amp;(c&gt;=&#39;0&#39;)) { x=(x&lt;&lt;1)+(x&lt;&lt;3)+(c^&#39;0&#39;); c=getchar(); } hhh=x; } void build(int l,int r,int x) { if(l==r) nodes[x]=1; else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=r-l+1; } } int kth(int l,int r,int x,int val) { if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=nodes[x&lt;&lt;1]) return kth(l,mid,x&lt;&lt;1,val); else return kth(mid+1,r,(x&lt;&lt;1)+1,val-nodes[x&lt;&lt;1]); } else return l; } void del(int l,int r,int x,int val) { --nodes[x]; if(l^r) { int mid=(l+r)&gt;&gt;1; if(val&lt;=mid) del(l,mid,x&lt;&lt;1,val); else del(mid+1,r,(x&lt;&lt;1)+1,val); } } int main() { read(n); build(1,n,1); for(int i=n;i;--i) { read(a); now=(now+a)%i+1; int cur=kth(1,n,1,now); writing(cur); putchar(&#39;\\n&#39;); del(1,n,1,cur); --now; } return 0; } 3.??????????? 8?????????? $n$ ??????????? $n$ ??????????????p??????????????? $c$ ????????????????????????????? $c$?? ????????????????????????????????????c ????????????? ???????????????????????????????????|????? ODT???????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;cctype&gt; #include &lt;utility&gt; #include &lt;set&gt; #define IT set&lt;TreeNode&gt;::iterator using namespace std; inline int getInt() { int a = 0, f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); return a * f; } inline void outInt(int x) { char buffer[20]; int length = 0; bool minus = x &lt; 0; if (minus) x = -x; do { buffer[length++] = x % 10 + &#39;0&#39;; x /= 10; } while (x); if (minus) buffer[length++] = &#39;-&#39;; do { putchar(buffer[--length]); } while (length); } struct TreeNode { int lef; int rig; mutable int val; TreeNode(int l, int r = -1, int v = 0) : lef(l), rig(r), val(v) {} friend bool operator &lt; (const TreeNode &amp;rhs) const { return lef &lt; rhs.lef; } } ; set&lt;TreeNode&gt; st; int n = getInt(); inline IT split(int pos) { IT it = st.lower_bound(TreeNode(pos)); if (it != st.end() &amp;&amp; it-&gt;lef == pos) return it; it--; int l = it-&gt;lef, r = it-&gt;rig; int v = it-&gt;val; st.erase(it); st.insert(TreeNode(l, pos - 1, v)); return st.insert(TreeNode(pos, r, v)).first; } inline void assign(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); st.erase(itl, itr); st.insert(TreeNode(l, r, v)); } inline int query(int l, int r, int v) { IT itr = split(r + 1), itl = split(l); int res = 0; for (; itl != itr; ++itl) res += (itl-&gt;rig - itl-&gt;lef + 1) * (itl-&gt;val == v); return res; } signed main() { for (int i = 1; i &lt;= n; ++i) { int x = getInt(); st.insert(TreeNode(i, i, x)); } for (int i = 1; i &lt;= n; ++i) { int l = getInt(); int r = getInt(); int v = getInt(); printf(&quot;%d\\n&quot;, query(l, r, v)); assign(l, r, v); } return 0; } 4.SP3267 DQUERY - D-query$Given$ $a$ $sequence$ $of$ $n$ $numbers$ $and$ $a$ $number$ $of$ $d-queries.$ $A$ $d-query$ $is$ $a$ $pair$ $(i,$ $j)$ $(1$ $??$ $i$ $??$ $j$ $??$ $n).$ $For$ $each$ $d-query$ $(i,$ $j),$ $you$ $have$ $to$ $return$ $the$ $number$ $of$ $distinct$ $elements$ $in$ $the$ $subsequence$ $a_i$,$a_{i+1},\\cdots,a_j$ ????????????????????????????? ??????????????????????????????????????????????????????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #define mid ((l + r) &gt;&gt; 1) using namespace std; const int SIZE = 1e6 + 5; int n, m, tree[SIZE], ans[SIZE]; int list[SIZE], tag[SIZE]; pair &lt; pair &lt; int , int &gt; , int &gt; st[SIZE]; inline bool _rule(pair &lt; pair &lt; int , int &gt; , int &gt; x, pair &lt; pair &lt; int , int &gt; , int &gt; y) { return x.first.second &lt; y.first.second; } signed main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;list[i]); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;st[i].first.first, &amp;st[i].first.second), st[i].second = i; sort(st + 1, st + 1 + m, _rule); int zblyc = 1; for (int i = 1; i &lt;= m; ++i) { for (int j = zblyc; j &lt;= st[i].first.second; ++j) { if (tag[list[j]]) for (int x = tag[list[j]]; x &lt;= n; x += x &amp; -x) tree[x]--; tag[list[j]] = j; for (int x = j; x &lt;= n; x += x &amp; -x) tree[x]++; } zblyc = st[i].first.second + 1; int lef = 0, rig = 0; for (int x = st[i].first.second; x; x -= x &amp; -x) rig += tree[x]; for (int x = st[i].first.first - 1; x; x -= x &amp; -x) lef += tree[x]; ans[st[i].second] = rig - lef; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 5.P1231 ????????????????????????OJ?????????????????????????????????????????????????????????? Link ?X?mHansBug???????????????M???????????????????????????????????????????? ?????????????????????????????????????????????????????????????????????????e???????????????????????????????????????????????????? ?????????????????????????????HansBug??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ????????HansBug?????????????????????????????????????????????????? ????????????????????????e??????????????????????????????? ??????????????????RE????????Siyuan???????????????add_edge?????????????????????????RE ????????????????????? ?????????????????????????????????????????? ?????? ??????????????? ????????????????? ???????????????????????????????????????????????????????? Siyuan????????????? ?????????????????????????????????????????????????????????????????????????????? 1????????????????????????????????????????????????????????????????????????????????????????????? 1 ??? ?????????????????????????????????! #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE_N = 4e6 + 5; const int SIZE_M = 1e6 + 5; const int INF = 1 &lt;&lt; 30; int n1, n2, n3, m, tot = 1, s, t; int path[SIZE_N], ter[SIZE_M]; int head[SIZE_N], edge[SIZE_M]; int _next[SIZE_N], ver[SIZE_M]; int depth[SIZE_N], cur[SIZE_N]; inline int getid(int p, int x) { switch (p) { case 1: return x; case 2: return n2 + x; case 3: return n2 + n1 + x; case 4: return n2 + (n1 &lt;&lt; 1) + x; } } inline void add_edge(int from, int to, int dis) { ver[++tot] = to, edge[tot] = dis, _next[tot] = head[from], head[from] = tot; } inline int bfs() { memset(depth, 0, sizeof depth); memcpy(cur, head, sizeof head); queue &lt; int &gt; Q; Q.push(s), depth[s] = 1; while (!Q.empty()) { int x = Q.front(); Q.pop(); for (int i = head[x]; i; i = _next[i]) { if (!depth[ver[i]] &amp;&amp; edge[i]) depth[ver[i]] = depth[x] + 1, Q.push(ver[i]); } } return depth[t]; } inline int dfs(int x, int flow) { if (x == t) return flow; int res = 0; for (int i = cur[x]; i &amp;&amp; res &lt; flow; i = _next[i]) { cur[x] = i; if (depth[ver[i]] == depth[x] + 1 &amp;&amp; edge[i]) { int tmp = dfs(ver[i], min(edge[i], flow - res)); if (tmp) edge[i] -= tmp, edge[i ^ 1] += tmp, res += tmp; } } if (res &lt; flow) depth[x] = -1; return res; } inline int dinic() { int res = 0; for (int x; bfs(); ) while (x = dfs(s, INF)) res += x; return res; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n1, &amp;n2, &amp;n3); scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(1, to), getid(2, from), 1); add_edge(getid(2, from), getid(1, to), 0); } scanf(&quot;%d&quot;, &amp;m); for (int i = 1; i &lt;= m; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); add_edge(getid(3, from), getid(4, to), 1); add_edge(getid(4, to), getid(3, from), 0); } for (int i = 1; i &lt;= n1; ++i) add_edge(getid(2, i), getid(3, i), 1), add_edge(getid(3, i), getid(2, i), 0); s = 0, t = (n1 &lt;&lt; 1) + n2 + n3 + 1; for (int i = 1; i &lt;= n2; ++i) add_edge(s, getid(1, i), 1), add_edge(getid(1, i), s, 0); for (int i = 1; i &lt;= n3; ++i) add_edge(getid(4, i), t, 1), add_edge(t, getid(4, i), 0); printf(&quot;%d\\n&quot;, dinic()); return 0; } 6.[USACO12OPEN]????Bookshelf????????????????????????????????????????????????????????? N ???? (1 &lt;= N &lt;= 100,000)?? ??????????????????????????? ????? i ???????? W(i) ???? H(i)?????????????????????????????????????????????e??????1 â€¦ k?????????????????k + 1??????????????????????????????????L??1??L??1,000,000,000??????????????????????????????????????????????????????????????????????????????? ???????????????????????????????????? ??N(1 &lt;= N &lt;= 100000)???????????????????W(i)?????H(i)??(1 &lt;= H(i) &lt;= 1,000,000; 1 &lt;= W(i) &lt;= L)?? ??????????????????????????????L (1 &lt;= L &lt;= 1,000,000,000)???????????????1?????2â€¦..??????????????????????????????????????????????? ????????????????????????????????????????? ???????$O(N^2)$?????DP?????????????????????? F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))???????? W_{j+1},W_{j+2},\\cdots,W_i\\le L???????$W$??????????????????????????????????? ?????? F_i=\\min(F_j+\\max(H_{j+1},H_{j+2},\\cdots,H_i))???? left_i\\le j??????????????????????????????P??????????????????????????????? ??????????????????????????????????????????????????(????????) ??????????????????????????$H_i$??????$lef$????$[lef+1,i]$??????????????$H_i$ ?????????????????????????????$H$?????????????????????????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; #define mid ((l + r) &gt;&gt; 1) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) using namespace std; typedef long long ull; const int SIZE = 100000 + 5; const ull INF = 1e18; stack &lt; ull &gt; S; ull n, limit, W[SIZE], H[SIZE], pre[SIZE]; ull list[SIZE], dp[SIZE], val[SIZE &lt;&lt; 2]; ull minval[SIZE &lt;&lt; 2], flag[SIZE &lt;&lt; 2]; inline void make(int k, int l, int r) { minval[k] = val[k] = flag[k] = INF; if (l ^ r) make(lson, l, mid), make(rson, mid + 1, r); } inline void push(int k) { if (flag[k] ^ INF) { minval[lson] = val[lson] + flag[k]; minval[rson] = val[rson] + flag[k]; flag[lson] = flag[rson] = flag[k]; flag[k] = INF; } } inline int update(int k, int l, int r, int x, int y, int v) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k] = val[k] + v, flag[k] = v, 0; push(k); if (mid &gt;= x) update(lson, l, mid, x, y, v); if (mid &lt; y) update(rson, mid + 1, r, x, y, v); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); return 0; } inline void modify(int k, int l, int r, int x) { if (l ^ r) { push(k); if (mid &gt;= x) modify(lson, l, mid, x); else modify(rson, mid + 1, r, x); minval[k] = min(minval[lson], minval[rson]); val[k] = min(val[lson], val[rson]); } else minval[k] = INF, val[k] = dp[l - 1]; } inline ull query(int k, int l, int r, int x, int y) { if (l &gt;= x &amp;&amp; r &lt;= y) return minval[k]; push(k); ull res = INF; if (mid &gt;= x) res = min(res, query(lson, l, mid, x, y)); if (mid &lt; y) res = min(res, query(rson, mid + 1, r, x, y)); return res; } signed main() { scanf(&quot;%lld %lld&quot;, &amp;n, &amp;limit); make(1, 1, n); S.push(1); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%lld %lld&quot;, &amp;H[i], &amp;W[i]), list[i] = list[i - 1] + W[i]; for (int i = 2; i &lt;= n; ++i) { while (S.size() &amp;&amp; H[i] &gt; H[S.top()]) S.pop(); if (S.size()) pre[i] = S.top(); S.push(i); } for (int i = 1; i &lt;= n; ++i) { modify(1, 1, n, i); if (pre[i] + 1 &lt;= i) update(1, 1, n, pre[i] + 1, i, H[i]); int lef = lower_bound(list, list + 1 + i, list[i] - limit) - list; if (lef &lt; i) dp[i] = query(1, 1, n, lef + 1, i); } printf(&quot;%lld\\n&quot;, dp[n]); return 0; } 7.P1110 [ZJOI2007]???????Q????????????????????????????????????????????????????????????Q??????????????????????????????????????????? ????????????Q?????????????????????????????????????????????????????????? ??????????????????????N??????????????????????????????? INSERT i k????????????i????????????????????kk??????????????ii???????????????????????????????????????????????????????MIN_GAP???????????????????????????????????????MIN_SORT_GAP???????????????????????????????????????????????????????5, 3, 15,3,1?? ???????INSERT 2 9???????5, 3, 9, 15,3,9,1?????MIN_GAP?22??MIN_SORT_GAP?22?? ?????????INSERT 2 6???????5, 3, 9, 6, 15,3,9,6,1 ??????????????????22????????????????????99??????????66?????99?????????????MIN_GAP?22??MIN_SORT_GAP?11?? ??????Q????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????? #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;utility&gt; #define sgt_mid ((SGT[k].l + SGT[k].r) &gt;&gt; 1) #define mid ((l + r) &gt;&gt; 1) #define U int k, int l, int r #define H int k, int x, int val #define transfer SGT[k].val = min(SGT[lson].val, SGT[rson].val) #define lson (k &lt;&lt; 1) #define rson (k &lt;&lt; 1 | 1) #define LRE lson, l, mid #define RRE rson, mid + 1, r #define LWA lson, x, val #define RWA rson, x, val #define int long long using namespace std; const int SIZE = 500000 + 5; const int INF = 0x7fffffff; int a[SIZE], b[SIZE], root; int n, m, tot, MIN_GAP, MIN_SORT_GAP; struct SPLAY { int ch[2]; int val; int fa; } SBT[SIZE]; struct TREE { int l; int r; int val; } SGT[SIZE]; template &lt; typename T &gt; inline T ads(T x) { return x &gt; 0 ? x : -x; } /*****************SplayArea*****************/ inline void rotate(int x) { int y = SBT[x].fa; int z = SBT[y].fa; int w = SBT[y].ch[1] == x; SBT[z].ch[SBT[z].ch[1] == y] = x; SBT[x].fa = z; SBT[y].ch[w] = SBT[x].ch[w ^ 1]; SBT[SBT[x].ch[w ^ 1]].fa = y; SBT[x].ch[w ^ 1] = y; SBT[y].fa = x; } inline void splay(int x, int goal) { for (; SBT[x].fa ^ goal; rotate(x)) { int y = SBT[x].fa; int z = SBT[y].fa; if (z ^ goal) SBT[z].ch[1] ^ y ^ SBT[y].ch[1] ^ x ? rotate(x) : rotate(y); } if (!goal) root = x; } inline void insert(int x) { int u = root, fa = 0; while (u &amp;&amp; SBT[u].val ^ x) fa = u, u = SBT[u].ch[x &gt; SBT[u].val]; if (u) return ; u = ++tot; SBT[u].fa = fa; if (fa) SBT[fa].ch[x &gt; SBT[fa].val] = u; SBT[u].val = x; splay(u, 0); } inline void find(int x) { int u = root; if (!u) return ; while (SBT[u].ch[x &gt; SBT[u].val] &amp;&amp; SBT[u].val ^ x) u = SBT[u].ch[x &gt; SBT[u].val]; splay(u, 0); } inline int next_(int x, int f) { find(x); int u = root; if (SBT[u].val == x) return SBT[u].val; if (SBT[u].val &lt; x &amp;&amp; !f) return SBT[u].val; if (SBT[u].val &gt; x &amp;&amp; f) return SBT[u].val; u = SBT[u].ch[f]; while (SBT[u].ch[f ^ 1]) u = SBT[u].ch[f ^ 1]; return SBT[u].val; } /*****************EndSplay*****************/ /*****************SegmentTreeArea*****************/ inline void make(U) { SGT[k].l = l, SGT[k].r = r; if (l ^ r) make(LRE), make(RRE), transfer; else SGT[k].val = ads(a[l] - a[l - 1]); } inline void modify(H) { if (SGT[k].l ^ SGT[k].r) if (sgt_mid &gt;= x) modify(LWA), transfer; else modify(RWA), transfer; else SGT[k].val = val; } /*****************EndSegmentTree*****************/ inline void Initialize() { MIN_GAP = INF, MIN_SORT_GAP = INF; scanf(&quot;%d %d&quot;, &amp;n, &amp;m); insert(INF), insert(-INF); a[0] = INF, a[n + 1] = INF; for (int i = 1; i &lt;= n; ++i) { scanf(&quot;%d&quot;, &amp;a[i]); if (i ^ 1) { int l_limit = next_(a[i], false), r_limit = next_(a[i], true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(l_limit - a[i]), ads(r_limit - a[i]))); } insert(a[i]); b[i] = a[i]; } make(1, 1, n); for (int i = 1; i &lt;= m; ++i) { char S[SIZE]; scanf(&quot;%s&quot;, S); if (*S == &#39;I&#39;) { int x, y; scanf(&quot;%d %d&quot;, &amp;x, &amp;y); int l_limit = next_(y, false); int r_limit = next_(y, true); MIN_SORT_GAP = min(MIN_SORT_GAP, min(ads(y - l_limit), ads(y - r_limit))); insert(y); MIN_GAP = min(MIN_GAP, ads(b[x] - y)); modify(1, x + 1, ads(a[x + 1] - y)); b[x] = y; } else if (S[4] == &#39;G&#39;) printf(&quot;%d\\n&quot;, min(MIN_GAP, SGT[1].val)); else printf(&quot;%d\\n&quot;, MIN_SORT_GAP); } } signed main() { Initialize(); return 0; } 8.Link Cut Tree ????????????? n ??????????????????????????????? m ????????????????????????? 0 ?? 3 ????????? 1 ?? n ????? 0 x y ???????? x ?? y ???????????????? xor ?????? x ?? y ???????? 1 x y ???????? x ?? y???? x ?? y ????????????????? 2 x y ????????? (x,y)????????? (x,y) ????? 3 x y ???????? x ????????? y?? ???????????????????????????????????LCT?????????????(??????splay(not fhq-treap)) #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; } // ???233.cpp 9.P5227 [AHOI2013]???????????????????????????????????????????????????????????????????????????????????????????????????????????????????? ??????????????????????????????????????????????????????????? ????LCT?????????????????????????? ??????????????????????????????????????????? ?????????????????????? %:include &lt;cstdio&gt; %:include &lt;iostream&gt; %:include &lt;algorithm&gt; %:include &lt;cstring&gt; %:include &lt;queue&gt; using namespace std; const int SIZE = 1e7 + 5; const int INF = 0x7fffffff; struct ReadNode &lt;% template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) &lt;% a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; %&gt; template &lt; typename T&gt; void write(T x) &lt;% if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); %&gt; template &lt; typename T&gt; void operator &lt;&lt; (T x) &lt;% write(x); %&gt; %&gt; win; int n, m; /******************LinkCutTree******************/ class LinkCutTree &lt;% public: struct TreeNode &lt;% int ch&lt;:2:&gt;; int fa; int val; int siz; int cnt; int miv; bool rev; %&gt; T&lt;:SIZE:&gt;; inline void exch(int &amp;x, int &amp;y) &lt;% x ^= y ^= x ^= y; %&gt; inline void push1(int x) &lt;% T&lt;:x:&gt;.siz = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.siz + T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz +T&lt;:x:&gt;.cnt + (x &lt;= n); x &gt; n &amp;&amp; (T&lt;:x:&gt;.miv = x); %&gt; inline void push2(int x) &lt;% (T&lt;:x:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:0:&gt;:&gt;.miv); (T&lt;:T&lt;:x:&gt;.miv:&gt;.val &gt;= T&lt;:T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv:&gt;.val) &amp;&amp; (T&lt;:x:&gt;.miv = T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.miv); %&gt; inline void transfer(int x) &lt;% push1(x); push2(x); %&gt; inline bool which(int x) &lt;% return T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; == x; %&gt; inline bool isroot(int x) &lt;% return (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:0:&gt; ^ x) &amp;&amp; (T&lt;:T&lt;:x:&gt;.fa:&gt;.ch&lt;:1:&gt; ^ x); %&gt; inline void rotate(int x) &lt;% int y = T&lt;:x:&gt;.fa, z = T&lt;:y:&gt;.fa, w = which(x), test = which(y), s = T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt;; (!isroot(y)) &amp;&amp; (T&lt;:z:&gt;.ch&lt;:test:&gt; = x); T&lt;:y:&gt;.ch&lt;:w:&gt; = s, T&lt;:x:&gt;.ch&lt;:w ^ 1:&gt; = y; (s) &amp;&amp; (T&lt;:s:&gt;.fa = y); T&lt;:x:&gt;.fa = z, T&lt;:y:&gt;.fa = x; transfer(y); %&gt; inline void reverse(int x) &lt;% exch(T&lt;:x:&gt;.ch&lt;:0:&gt;, T&lt;:x:&gt;.ch&lt;:1:&gt;), T&lt;:x:&gt;.rev ^= 1; %&gt; inline void push_down(int x) &lt;% if (T&lt;:x:&gt;.rev) &lt;% if (T&lt;:x:&gt;.ch&lt;:0:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:0:&gt;); if (T&lt;:x:&gt;.ch&lt;:1:&gt;) reverse(T&lt;:x:&gt;.ch&lt;:1:&gt;); T&lt;:x:&gt;.rev = 0; %&gt; %&gt; inline void push_up(int x) &lt;% (!isroot(x)) &amp;&amp; (push_up(T&lt;:x:&gt;.fa), 1); push_down(x); %&gt; inline void splay(int x) &lt;% push_up(x); for (; !isroot(x); rotate(x)) (!isroot(T&lt;:x:&gt;.fa)) &amp;&amp; ((which(x) == which(T&lt;:x:&gt;.fa) ? rotate(T&lt;:x:&gt;.fa) : rotate(x)), 1); transfer(x); %&gt; inline void access(int x) &lt;% for (int i = 0; x; x = T&lt;:i = x:&gt;.fa) splay(x), T&lt;:x:&gt;.cnt += T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt;:&gt;.siz, T&lt;:x:&gt;.cnt -= T&lt;:T&lt;:x:&gt;.ch&lt;:1:&gt; = i:&gt;.siz, transfer(x); %&gt; inline void makeroot(int x) &lt;% access(x), splay(x), reverse(x); %&gt; inline void split(int x, int y) &lt;% makeroot(y), access(x), splay(x); %&gt; inline int getroot(int x) &lt;% access(x), splay(x), push_down(x); for (; T&lt;:x:&gt;.ch&lt;:0:&gt;; push_down(x = T&lt;:x:&gt;.ch&lt;:0:&gt;)); return splay(x), x; %&gt; inline void init(int length, int data) &lt;% for (int i = 0; i &lt;= length; ++i) T&lt;:i:&gt;.val = data; %&gt; inline void connect(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = x, T&lt;:x:&gt;.cnt += T&lt;:y:&gt;.siz, transfer(x); %&gt; inline void erase(int x, int y) &lt;% split(x, y), T&lt;:y:&gt;.fa = T&lt;:x:&gt;.ch&lt;:0:&gt; = 0, transfer(x); %&gt; inline bool find() &lt;% return access(1), splay(1), (T&lt;:1:&gt;.siz == n); %&gt; %&gt; lct_mast; /*****************EndLinkCutTree*****************/ int now&lt;:SIZE:&gt;, num, ans&lt;:SIZE:&gt;, st&lt;:SIZE:&gt;, top; struct EdgeNode &lt;% int from; int to; int dis; %&gt; edge&lt;:SIZE:&gt;; struct LycNode &lt;% bool opt, tag; int idx; %&gt; H&lt;:SIZE:&gt;; signed main() &lt;% win &gt;&gt; n; win &gt;&gt; m; lct_mast.init(n, INF); for (int i = 1; i &lt;= m; ++i) &lt;% int x, y; win &gt;&gt; x; win &gt;&gt; y; edge&lt;:i:&gt; = &lt;%x, y%&gt;; now&lt;:i:&gt; = i; H&lt;:++num:&gt; = &lt;%1, 0, i%&gt;; %&gt; int k, tot = m; win &gt;&gt; k; for (int i = 1; i &lt;= k; ++i) &lt;% int x; win &gt;&gt; x; for (int j = 1; j &lt;= x; ++j) &lt;% int y; win &gt;&gt; y; edge&lt;:now&lt;:y:&gt;:&gt;.dis = i - 1; lct_mast.T&lt;:now&lt;:y:&gt; + n:&gt;.val = i - 1; H&lt;:++num:&gt; = &lt;%0, 0, now&lt;:y:&gt;%&gt;; edge&lt;:++tot:&gt;.from = edge&lt;:now&lt;:y:&gt;:&gt;.from; edge&lt;:tot:&gt;.to = edge&lt;:now&lt;:y:&gt;:&gt;.to; now&lt;:y:&gt; = tot; st&lt;:++top:&gt; = now&lt;:y:&gt;; %&gt; H&lt;:++num:&gt;.tag = true; if (i ^ k) while (top) H&lt;:++num:&gt; = &lt;%1, 0, st&lt;:top--:&gt;%&gt;; %&gt; for (int i = 1; i &lt;= m; ++i) if (!edge&lt;:now&lt;:i:&gt;:&gt;.dis) edge&lt;:now&lt;:i:&gt;:&gt;.dis = k, lct_mast.T&lt;:now&lt;:i:&gt; + n:&gt;.val = k; tot += n; for (int i = 1; i &lt;= tot; ++i) lct_mast.T&lt;:i:&gt;.siz = 1; for (int i = 1; i &lt;= num; ++i) &lt;% if (H&lt;:i:&gt;.tag) puts(lct_mast.find() ? &quot;Connected&quot; : &quot;Disconnected&quot;); else &lt;% int j = H&lt;:i:&gt;.idx, from = edge&lt;:j:&gt;.from; int to = edge&lt;:j:&gt;.to, dis = edge&lt;:j:&gt;.dis; lct_mast.makeroot(from); if (H&lt;:i:&gt;.opt) &lt;% if (lct_mast.getroot(to) == from) &lt;% int mix = lct_mast.T&lt;:from:&gt;.miv; if (lct_mast.T&lt;:mix:&gt;.val &gt;= dis) continue; lct_mast.erase(edge&lt;:mix - n:&gt;.from, mix); lct_mast.erase(edge&lt;:mix - n:&gt;.to, mix); %&gt; lct_mast.connect(from, j + n); lct_mast.connect(to, j + n); %&gt; else &lt;% if (lct_mast.getroot(to) == from) &lt;% lct_mast.transfer(j + n); if (!lct_mast.T&lt;:j + n:&gt;.fa &amp;&amp; !lct_mast.T&lt;:j + n:&gt;.siz) continue; lct_mast.erase(edge&lt;:j:&gt;.from, j + n); lct_mast.erase(edge&lt;:j:&gt;.to, j + n); %&gt; %&gt; %&gt; %&gt; return 0; %&gt; 10.[TJOI2018]???????????????$1$??????????$n$??????????????????????????????????$v_i$????????$Q$?????????????????? $1\\;x\\;y$????????$x$??????????$y$??????????????? $2\\;x\\;y\\;z$?????????$x$??$y$?????$z$????????????? ????????????$01Trie$??+??????????? ????????????????????????????????????????$DFS$??????????????? ???????????????????$DFS$?????$sub_tree$????????? ???????????????????????$DFS$???????????????????? ???????????$LCA$ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; const int SIZE = (100000 + 5) &lt;&lt; 1; int head[SIZE], ver[SIZE]; int nxt[SIZE], edge[SIZE]; int n, q, fuck, a[SIZE]; inline void pushEdge(int x, int y, int z) { ver[++fuck] = y, edge[fuck] = z; nxt[fuck] = head[x], head[x] = fuck; } struct ZeroOneTrie { int root[SIZE], cnt; int trie[SIZE &lt;&lt; 6][2]; int frie[SIZE &lt;&lt; 6]; ZeroOneTrie() { root[0] = cnt = 1; } inline void insert(int last, int &amp;lyc, int x) { int rt = lyc = ++cnt; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; trie[rt][!now] = trie[last][!now]; trie[rt][now] = ++cnt; rt = trie[rt][now]; last = trie[last][now]; frie[rt] = frie[last] + 1; } } inline int find(int l, int r, int x) { int res = 0; for (int i = 30; ~i; --i) { int now = (x &gt;&gt; i) &amp; 1; if (frie[trie[r][!now]] - frie[trie[l][!now]]) { r = trie[r][!now]; l = trie[l][!now]; res |= 1 &lt;&lt; i; } else { r = trie[r][now]; l = trie[l][now]; } } return res; } } t0, t1; int dfn[SIZE], L[SIZE], R[SIZE]; int num, fa[SIZE][30], depth[SIZE]; inline void dfs(int x, int pre) { t1.insert(t1.root[pre], t1.root[x], a[x]); fa[x][0] = pre; depth[x] = depth[pre] + 1; L[x] = ++num; dfn[num] = a[x]; for (int i = head[x]; ~i; i = nxt[i]) if (ver[i] ^ pre) dfs(ver[i], x); R[x] = num; } inline int lca_mast(int x, int y) { if (depth[x] &lt; depth[y]) swap(x, y); for (int i = 25; ~i; --i) if (depth[fa[x][i]] &gt;= depth[y]) x = fa[x][i]; if (x ^ y) { for (int i = 25; ~i; --i) if (fa[x][i] ^ fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0]; } else return x; } signed main() { memset(head, -1, sizeof head); scanf(&quot;%d %d&quot;, &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt; n; ++i) { int from, to; scanf(&quot;%d %d&quot;, &amp;from, &amp;to); pushEdge(from, to, 1); pushEdge(to, from, 1); } dfs(1, 0); for (int j = 1; j &lt;= 25; ++j) for (int i = 1; i &lt;= n; ++i) fa[i][j] = fa[fa[i][j - 1]][j - 1]; for (int i = 1; i &lt;= n; ++i) t0.insert(t0.root[i - 1], t0.root[i], dfn[i]); for (int i = 1; i &lt;= q; ++i) { int opt, x, y, z; scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y); if (opt ^ 1) { scanf(&quot;%d&quot;, &amp;z); int ans = lca_mast(x, y); printf(&quot;%d\\n&quot;, max(t1.find(t1.root[fa[ans][0]], t1.root[x], z), t1.find(t1.root[fa[ans][0]], t1.root[y], z))); } else { printf(&quot;%d\\n&quot;, t0.find(t0.root[L[x] - 1], t0.root[R[x]], y)); } } return 0; }","categories":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Solution","slug":"Solution","permalink":"www.orchid-any.cf/categories/Solution/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åœ†æ–¹æ ‘","slug":"DS100P-ROUND-SQUARE-TREE","date":"2020-02-08T05:44:40.000Z","updated":"2020-02-20T02:48:47.130Z","comments":true,"path":"2020/02/08/DS100P-ROUND-SQUARE-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-ROUND-SQUARE-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åšå¼ˆæ ‘","slug":"DS100P-GAME-TREE","date":"2020-02-08T05:41:27.000Z","updated":"2020-02-20T02:48:47.114Z","comments":true,"path":"2020/02/08/DS100P-GAME-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-GAME-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---è™šæ ‘","slug":"DS100P-VIRTUAL-TREE","date":"2020-02-08T05:40:33.000Z","updated":"2020-02-20T02:48:47.139Z","comments":true,"path":"2020/02/08/DS100P-VIRTUAL-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-VIRTUAL-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---ç¯å¥—æ ‘","slug":"DS100P-RING-TREE","date":"2020-02-08T05:39:43.000Z","updated":"2020-02-20T02:48:47.129Z","comments":true,"path":"2020/02/08/DS100P-RING-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-RING-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å·¦åæ ‘","slug":"DS100P-LEFT-SIDE-TREE","date":"2020-02-08T05:39:04.000Z","updated":"2020-02-20T02:48:47.126Z","comments":true,"path":"2020/02/08/DS100P-LEFT-SIDE-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-LEFT-SIDE-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ”¯é…æ ‘","slug":"DS100P-DOMINATION-TREE","date":"2020-02-08T05:38:18.000Z","updated":"2020-02-20T02:48:47.111Z","comments":true,"path":"2020/02/08/DS100P-DOMINATION-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-DOMINATION-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åŸºç¯æ ‘","slug":"DS100P-BASE-RING-TREE","date":"2020-02-08T05:37:33.000Z","updated":"2020-02-20T02:48:47.104Z","comments":true,"path":"2020/02/08/DS100P-BASE-RING-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-BASE-RING-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---çŒ«æ ‘","slug":"DS100P-CAT-TREE","date":"2020-02-08T05:37:14.000Z","updated":"2020-02-20T02:48:47.108Z","comments":true,"path":"2020/02/08/DS100P-CAT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/08/DS100P-CAT-TREE/","excerpt":"","text":"0x01 å¼•å­é¦–å…ˆå¼•å…¥è¿™æ ·ä¸€ç§é—®é¢˜ï¼šç»™å®š $n$ çš„èŒƒå›´ï¼Œå†ç»™å‡ºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„åºåˆ—ï¼Œç„¶åç»™å‡ºå„ç§è¯¢é—®ï¼Œè¯¢é—®çš„æ•°é‡å¤§äº $n$ã€‚æ¯”å¦‚è¯´ $n=10^{6},q=10^{7}$ã€‚ è€ƒè™‘çº¿æ®µæ ‘ï¼Œ$\\log n$ çš„æŸ¥è¯¢å½“åœºæ­»äº¡ã€‚ é‚£ä¹ˆæ€ä¹ˆåŠå‘¢ï¼ŸçŒ«é”Ÿå¤§å¤§å°±ç»™å‡ºäº†ä¸€ç§ ä¸æ”¯æŒä¿®æ”¹ä½†æ˜¯å¯ä»¥åšåˆ° $\\Theta(n\\log n)$ é¢„å¤„ç† $\\Theta(1)$ æŸ¥è¯¢çš„æ•°æ®ç»“æ„â€”â€”çŒ«æ ‘ ï¼Œç»™å¤§å®¶åˆ†äº«ä¸€ä¸‹åŸæ–‡ç« Linkã€‚ 0x02 é¢„å¤„ç†éƒ¨åˆ†å…·ä½“è¿‡ç¨‹æŒ‰æˆ‘çš„ç†è§£ï¼ŒçŒ«æ ‘å…¶å®å¯ä»¥çœ‹åšåƒ $DP$ ä¸€æ · æŠŠåˆ†æ²»çš„è¿‡ç¨‹è®°å½•ä¸‹æ¥ çš„ä¸œè¥¿ã€‚ ä¸¾ä¾‹æ¥è¯´ï¼Œæˆ‘ä»¬ç°åœ¨éœ€è¦ä½ æŸ¥è¯¢åºåˆ—çš„åŒºé—´æœ€å¤§å€¼å’ŒåŒºé—´å’Œä¹‹ç±»çš„ å…·æœ‰åŒºé—´å¯åŠ æ€§ çš„ä¿¡æ¯ï¼ŒæŸ¥è¯¢åŒºé—´ä¸º $[l,r]$ã€‚ é€’å½’çš„æ¥æƒ³ï¼ŒåŒºé—´ $[l,r]$ æ˜¯ç”±åŒºé—´ $[l,mid]$ å’Œ $[mid+1,r]$ ä¸¤ä¸ªåŒºé—´åˆå¹¶è€Œæ¥çš„ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ˜¯å¦èƒ½å¤Ÿä½¿ç”¨é¢„å¤„ç†çš„æ‰‹æ®µä½¿å¾—æ‰€æœ‰å¯èƒ½çš„è¯¢é—®åŒºé—´éƒ½å¯ä»¥é€šè¿‡åˆå¹¶æ¥ $\\Theta(1)$ å¾—å‡ºç­”æ¡ˆå‘¢ï¼Ÿç­”æ¡ˆæ˜¯æ²¡é—®é¢˜ã€‚ æ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹å…·ä½“çš„æ­¥éª¤ï¼š step1:æˆ‘ä»¬å°†æ•´ä¸ªåºåˆ—åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå³ $[1,mid]$ å’Œ $[mid+1,n]$step2:åˆ†åˆ«ä» $mid$ å‘å·¦ä» $mid+1$ å‘å³ï¼Œéå†æ•´ä¸ªåŒºé—´step3:ç»´æŠ¤ä¿¡æ¯ã€‚æ¯”å¦‚è¯´åŒºé—´æœ€å¤§å€¼ï¼Œé‚£ä¹ˆå¯¹äºä» $mid$ å¼€å§‹å‘å·¦çš„åŒºé—´ï¼Œ$maxvalue_{i}=max\\{max_{i+1},a_{i}\\}$ï¼Œå¯¹äºä» $mid+1$ å¼€å§‹å‘å³çš„åŒºé—´åŒç†step4:å¤è¯»æœº æ—¶é—´å¤æ‚åº¦å°±åƒçº¿æ®µæ ‘ä¸€æ ·ï¼ŒçŒ«æ ‘æ˜¯ä¸€é¢—äºŒå‰æ ‘ï¼Œæ·±åº¦æœ€å¤šä¸º $\\log_{2}n$ å±‚ï¼Œæ¯ä¸€å±‚æˆ‘ä»¬éœ€è¦ $\\Theta(n)$ çš„æ—¶é—´è¿›è¡Œç»´æŠ¤ä¿¡æ¯çš„å·¥ä½œï¼Œæ‰€ä»¥é¢„å¤„ç†çš„æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(n\\log n)$ã€‚ å•Šå¯¹äº†ï¼Œç©ºé—´å¤æ‚åº¦ä¹Ÿæ˜¯ $\\Theta(n\\log n)$ï¼Œæƒ³æƒ³å°±æ˜ç™½äº†ï¼Œè¿™é‡Œä¸ºäº†èŠ‚çœç¯‡å¹…å°±ç•¥æ‰äº†ã€‚ 0x03 å¤„ç†è¯¢é—®éƒ¨åˆ†å…·ä½“è¿‡ç¨‹å¯¹äºä¸€ä¸ª è¯¢é—® åŒºé—´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå®ƒæ”¾åœ¨æŸä¸ª å·²ç»ç»è¿‡é¢„å¤„ç†çš„ å¹¶ä¸” è¯¢é—® åŒºé—´ç»è¿‡ å·²ç»ç»è¿‡é¢„å¤„ç†çš„ çš„åŒºé—´çš„ ä¸­ç‚¹ çš„åŒºé—´é‡Œã€‚ç®€è€Œè¨€ä¹‹ï¼Œæˆ‘ä»¬è®¾è¯¢é—®åŒºé—´ä¸º $q$ï¼Œæˆ‘ä»¬æŠŠ $q$ æ”¾åœ¨ä¸€ä¸ªåŒºé—´ $t$ é‡Œé¢ï¼Œ$t$ çš„å®šä¹‰æ˜¯å·²ç»ç»è¿‡é¢„å¤„ç†ï¼Œå¹¶ä¸”è¯¢é—®åŒºé—´ $q$ è·¨è¿‡åŒºé—´ $t$ çš„ä¸­ç‚¹ã€‚ ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå…¶å®å¾ˆç®€å•ï¼Œæ—¢ç„¶ $t$ å·²ç»ç»è¿‡äº†é¢„å¤„ç†ï¼Œé‚£ä¹ˆ $t$ çš„ä¸­ç‚¹æŠŠ $q$ åˆ†æˆçš„ä¸¤éƒ¨åˆ†ä¹Ÿä¸€å®šç»è¿‡äº†é¢„å¤„ç†ï¼Œæˆ‘ä»¬å°±å¯ä»¥ $\\Theta(1)$ çš„åˆå¹¶äº†ã€‚ æ²¡æœ‰å›¾å§‹ç»ˆæ²¡æœ‰æ„Ÿè§‰å¯¹å§ï¼Ÿé‚£ä¹ˆä¸Šå›¾æ¥ç†è§£å§ã€‚ è¿™æ˜¯ä¸€æ£µç‰›é€¼çš„æ ‘ï¼Œæˆ‘ä»¬ç»™ä»–å–åå«ç‰›é€¼æ ‘ å“¦ï¼ç°åœ¨ç‰›é€¼æ ‘ä¸Šæœ‰äº†ä¸€ä¸ªè¯¢é—®ï¼ å“ˆï¼ç‰›é€¼æ ‘ä¸Šçš„è¯¢é—®æˆåŠŸçš„è¢«ç¬¬ä¸‰å±‚çš„æŸä¸ªåŒºé—´åˆ†å‰²å•¦ï¼è€¶ï¼ å¹³ç”Ÿæ²¡æœ‰è¿™ä¹ˆå‚»è¿‡ æ—¶é—´å¤æ‚åº¦æŸ¥è¯¢çš„å¤æ‚åº¦è²Œä¼¼æ˜¯ $\\Theta(\\log n)$ï¼Ÿä¸ä¸ä¸ï¼Œæ—¢ç„¶å‰é¢è¯´äº†æŸ¥è¯¢æ˜¯ $\\Theta(1)$ çš„ï¼Œé‚£å°±ä¸€å®šæ˜¯ã€‚æ¥ä¸‹æ¥æˆ‘ä»¬è°ˆä¸€è°ˆä¼˜åŒ–çš„å†…å®¹ã€‚ æ—¶é—´å¤æ‚åº¦ä¼˜åŒ–ä»”ç»†æƒ³æƒ³å¦‚æœæˆ‘ä»¬ä¸ä»æ ¹ç»“ç‚¹å‡ºå‘ï¼Œè€Œæ˜¯ä»å¶å­ç»“ç‚¹æ¥çš„è¯ï¼Œè¿™å°±æ˜¯åœ¨æ±‚ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ å˜›ï¼ä½†æ˜¯æœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿä»”ç»†æƒ³æƒ³ï¼Œæˆ‘ä»¬çš„ç‰›é€¼çŒ«æ ‘æ˜¯ä¸€é¢—äºŒå‰æ ‘ï¼Œè€ŒäºŒå‰æ ‘çš„ $LCA$ æ˜¯ä»€ä¹ˆï¼Ÿ è¿™é‡Œæœ‰ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼ŒäºŒå‰æ ‘ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ å°±æ˜¯äºŒè¿›åˆ¶ä¸‹çš„å®ƒä»¬çš„ç¼–å·çš„ æœ€é•¿å…¬å…±å‰ç¼€ ã€‚ æ¯”å¦‚è¯´ $7$ å·ç»“ç‚¹å’Œ $5$ å·ç»“ç‚¹çš„ $LCA$ å°±æ˜¯ï¼š $(0111)_{2}\\ \\ \\ (0101)_{2}$ ä¹Ÿå°±æ˜¯ $(01)_{2}$ ä¹Ÿå°±æ˜¯ $1$ å·ç»“ç‚¹ã€‚ é‚£ä¹ˆæˆ‘ä»¬å¦‚ä½•æ‰¾å‡ºä¸¤ä¸ªæ•°çš„äºŒè¿›åˆ¶æœ€é•¿å…¬å…±å‰ç¼€å‘¢ï¼Ÿ æˆ‘ä»¬å¯ä»¥å‘ç°ï¼Œæˆ‘ä»¬å°†ä¸¤ä¸ªèŠ‚ç‚¹ $xor$ èµ·æ¥ï¼Œå°±èƒ½å¤Ÿå»æ‰å®ƒä»¬çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚äºæ˜¯æˆ‘ä»¬å°±å¯ä»¥ä½¿ç”¨x&gt;&gt;log2[x^y]æ¥è·å¾—ä¸¤ä¸ªç»“ç‚¹çš„ $LCA$ã€‚ 0x03 ä¾‹é¢˜ä¸ä»£ç # SP1043 GSS1 - Can you answer these queries Iç»™å‡ºäº†åºåˆ— $A[1],A[2],â€¦,A[N]$ ã€‚ ($a[i]â‰¤15007,1â‰¤Nâ‰¤50000$ )ã€‚æŸ¥è¯¢å®šä¹‰å¦‚ä¸‹ï¼š æŸ¥è¯¢ $(x,y)=\\max\\{a[i]+a[i+1]+â€¦+a[j];xâ‰¤iâ‰¤jâ‰¤y\\}$ã€‚ ç»™å®š$M$ä¸ªæŸ¥è¯¢ï¼Œç¨‹åºå¿…é¡»è¾“å‡ºè¿™äº›æŸ¥è¯¢çš„ç»“æœã€‚ é¢˜ç›®è®©æˆ‘ä»¬æŸ¥è¯¢æœ€å¤§å­æ®µå’Œï¼Œå¹¶ä¸”æ²¡æœ‰ä¿®æ”¹æ“ä½œï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡çŒ«æ ‘æ¥ç©è¿™é“é¢˜ã€‚ å…·ä½“æ­¥éª¤ä¸Šæ–‡å·²ç»å†™äº†ï¼Œå¯¹äºè¿™é“ æ¿ é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥è®°å½•æœ€å¤§å­æ®µå’Œä»¥åŠæœ€å¤§å‰ç¼€å’Œå³å¯ã€‚ ä»£ç ï¼š // çœç•¥äº†ä¸€äº›å¤´æ–‡ä»¶ã€å¿«è¯»ã€é¢„å¤„ç†å‘½ä»¤ç­‰ä¸œè¥¿ï¼Œå®Œæ•´ä»£ç è¯·ç§»æ­¥è‡³https://vjudge.net/solution/24123955 const int SIZE = 2e5 + 5; const int LOG_SIZE = 20; int n, m, real = 2, ints[SIZE]; // real:æŠŠnæ˜ å°„ä¸º2çš„å¹‚å½¢å¼ // ints:åŸåºåˆ— namespace CatsTree { int log2[SIZE]; // é¢„å¤„ç†log2 int nodes[SIZE]; // ç»“ç‚¹ int ans[LOG_SIZE][SIZE]; // æœ€å¤§å­æ®µå’Œ int preans[LOG_SIZE][SIZE]; // æœ€å¤§å‰ç¼€å’Œ void MakeLog() { for (int i = 2, lim = real &lt;&lt; 1; i &lt;= lim; ++i) log2[i] = log2[i &gt;&gt; 1] + 1; } void BuildTree(int k, int l, int r, int s) { if (l ^ r) { ans[s][mid] = preans[s][mid] = ints[mid]; int pre, sum; pre = sum = ints[mid]; sum = sum &gt; 0 ? sum : 0; for (int i = mid - 1; i &gt;= l; --i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i + 1]); preans[s][i] = max(sum, preans[s][i + 1]); sum = sum &gt; 0 ? sum : 0; } ans[s][mid + 1] = preans[s][mid + 1] = ints[mid + 1]; pre = sum = ints[mid + 1]; sum = sum &gt; 0 ? sum : 0; for (int i = mid + 2; i &lt;= r; ++i) { pre += ints[i]; sum += ints[i]; ans[s][i] = max(pre, ans[s][i - 1]); preans[s][i] = max(sum, preans[s][i - 1]); sum = sum &gt; 0 ? sum : 0; } BuildTree(ls, l, mid, s + 1); BuildTree(rs, mid + 1, r, s + 1); } else nodes[l] = k; } int GetAnswers(int l, int r) { if (l ^ r) { int s = log2[nodes[l]] - log2[nodes[l] ^ nodes[r]]; return max(ans[s][l] + ans[s][r], max(preans[s][l], preans[s][r])); } else return ints[l]; } } #define CT CatsTree void init() { read(n); while (real &lt; n) real &lt;&lt;= 1; for (int i = 1; i &lt;= n; ++i) read(ints[i]); CT::BuildTree(1, 1, real, 1); CT::MakeLog(); } void solving() { read(m); for (int i = 0, l, r; i &lt; m; ++i) read(l, r), write(io_l, CT::GetAnswers(l, r)); } signed main() { init(); solving(); }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---K-D Tree","slug":"DS100P-K-D-TREE","date":"2020-02-07T12:03:42.000Z","updated":"2020-02-20T02:48:47.124Z","comments":true,"path":"2020/02/07/DS100P-K-D-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-K-D-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Sqrt-Tree","slug":"DS100P-SQRT-TREE","date":"2020-02-07T10:49:19.000Z","updated":"2020-02-20T02:48:47.133Z","comments":true,"path":"2020/02/07/DS100P-SQRT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SQRT-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å—çŠ¶æ•°ç»„","slug":"DS100P-BLOCK-ARRAY","date":"2020-02-07T10:48:41.000Z","updated":"2020-02-20T02:48:47.106Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-ARRAY/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---å—çŠ¶é“¾è¡¨","slug":"DS100P-BLOCK-LIST","date":"2020-02-07T10:48:26.000Z","updated":"2020-02-20T02:48:47.107Z","comments":true,"path":"2020/02/07/DS100P-BLOCK-LIST/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-BLOCK-LIST/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘ä¸Šåˆ†å—","slug":"DS100P-TREE-FENKUAI","date":"2020-02-07T10:43:01.000Z","updated":"2020-02-20T02:48:47.138Z","comments":true,"path":"2020/02/07/DS100P-TREE-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-FENKUAI/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€è‡ªåŠ¨æœº","slug":"DS100P-SUFFIX-AUTOMATON","date":"2020-02-07T10:14:33.000Z","updated":"2020-02-20T02:48:47.134Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-AUTOMATON/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-AUTOMATON/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ ‘","slug":"DS100P-SUFFIX-TREE","date":"2020-02-07T10:14:14.000Z","updated":"2020-02-20T02:48:47.135Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-TREE/","excerpt":"","text":"","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---ä¸»å¸­æ ‘","slug":"DS100P-CHAIRMAN-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.109Z","comments":true,"path":"2020/02/07/DS100P-CHAIRMAN-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHAIRMAN-TREE/","excerpt":"","text":"ä¸»å¸­æ ‘($nlogn$) â€œä½ æ˜¯ä¸»å¸­æ ‘å—ï¼Ÿæœ‰é‚£ä¹ˆå¤šçˆ·çˆ·ï¼â€â€”â€”$LJS$ã€‚ è¿™å¥è¯è¿ç”¨æ‰“æ¯”æ–¹çš„è¯´æ˜æ–¹æ³•ï¼Œç”ŸåŠ¨å½¢è±¡åœ°è¯´æ˜äº†ä¸»å¸­æ ‘æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¾ˆå¤šçˆ¶äº²çš„ç‰¹ç‚¹ï¼Œä½“ç°è¯´æ˜è¯­è¨€çš„ç”ŸåŠ¨æ€§ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸»å¸­æ ‘çš„å‡ ä¸ªèŠ‚ç‚¹å¯èƒ½å…±ç”¨ä¸€ä¸ªå­èŠ‚ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š ä¸»å¸­æ ‘å¯ä»¥ç”¨æ¥æŸ¥è¯¢é™æ€åŒºé—´ç¬¬kå°ï¼Œé™æ€åŒºé—´å‰kå¤§çš„å’Œç­‰ç­‰ã€‚ï¼ˆç”¨æ³•ååˆ†çµæ´»ï¼‰ æˆ‘ä»¬ä¼šåˆ›å»ºå¾ˆå¤šç‰ˆæœ¬çš„æ ‘ï¼Œä¸€äº›ç‰ˆæœ¬ä¼šå…±ç”¨ä¸€äº›èŠ‚ç‚¹ï¼Œä»¥èŠ‚çœç©ºé—´å’Œæ—¶é—´ã€‚ ä¸»å¸­æ ‘ä¹Ÿå«å¯æŒä¹…åŒ–çº¿æ®µæ ‘ã€‚ä½†å¯æŒä¹…åŒ–è¿˜æœ‰å¾ˆå¤šä¸œè¥¿ã€‚æˆ‘å°±è®²å¯æŒä¹…åŒ–çº¿æ®µæ ‘å§ã€‚ 1.å¦‚ä½•å…±ç”¨èŠ‚ç‚¹æˆ‘ä»¬è€ƒè™‘å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ã€‚ å¦‚æœè¦å¾—åˆ°è¿™ä¸ªåºåˆ—æŸä¸ªå…ƒç´ $x$åŠ ä¸Šä¸€ä¸ªå€¼$val$ä¹‹åçš„æ–°ç‰ˆæœ¬ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæ”¹å˜çš„åªæœ‰å¯¹åº”å…ƒç´ $x$çš„èŠ‚ç‚¹å’Œä»–çš„ç¥–å…ˆä¼šåŠ ä¸Š$val$ã€‚é‚£ä¹ˆå…¶ä»–èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥ä¸ä¸Šä¸€ä¸ªç‰ˆæœ¬å…±ç”¨ã€‚ æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§æ‰¿ä¹‹å‰è¯¥ä½ç½®çš„å€¼å’Œå·¦å³å„¿å­ï¼Œç„¶åæ›´æ–°å€¼ï¼Œå†ç»§ç»­å‘ä¸‹å¯»æ‰¾å…ƒç´ $x$çš„ä½ç½®ï¼Œæœ€åé€’å½’å›æ¥æ›´æ–°è¿™ä¸ªå„¿å­ã€‚ æˆ‘ä»¬ä½¿ç”¨$root$æ•°ç»„æ¥è®°å½•æ¯ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ç¼–å·ã€‚ ä»£ç ï¼š void ins(int l,int r,int pre,int &amp;now,int pos,int val)//åŒºé—´å·¦å³ç«¯ç‚¹ï¼Œä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œå½“å‰ç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œä¿®æ”¹ä½ç½®ï¼Œå¢åŠ çš„å€¼ã€‚ { nodes[++tot]=nodes[pre];//å…ˆæ•´ä¸ªå¤åˆ¶ now=tot;//æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å„¿å­ã€‚ nodes[now].sum+=val;//æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å€¼ if(l==r) return; //å‘ä¸‹ç»§ç»­å¯»æ‰¾ int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //è°ƒç”¨ï¼šins(1,n,root[i-1],root[i],p,v); æœ€å$root[i]$çš„å¼•ç”¨å°±ç›¸å½“äºè®°å½•äº†è¿™ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ã€‚ æŸ¥è¯¢å…¶å®å°±å’Œæ™®é€šçš„çº¿æ®µæ ‘ä¸€æ ·ï¼Œä½†ä¸»å¸­æ ‘çš„ç”¨é€”ä¸æ­¢è¿™ä¸ªã€‚ 2.ä¾‹é¢˜ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ 1ï¼ˆä¸»å¸­æ ‘ï¼‰ å¦‚é¢˜ï¼Œç»™å®š $n$ ä¸ªæ•´æ•°æ„æˆçš„åºåˆ—ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬ $k$ å°å€¼ã€‚ æƒå€¼çº¿æ®µæ ‘ï¼š (çº¿æ®µæ ‘çš„å¦ä¸€ç§åº”ç”¨ï¼Œåªæ˜¯æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æ•´ä¸ªåºåˆ—å€¼åœ¨$[l,r]$åŒºé—´å†…çš„æ•°çš„ä¸ªæ•°) è¿™é“é¢˜è¦æ±‚æŸ¥è¯¢é™æ€åŒºé—´ç¬¬$k$å°ã€‚é‚£ä¹ˆå¯¹äºç¬¬$k$å°è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ ç¦»æ•£åŒ–ï¼š$-1e9\\leq a_i \\leq1e9$ çš„æ•°æ®çº¿æ®µæ ‘è‚¯å®šå¼€ä¸ä¸‹ï¼Œä½†è¿™é“é¢˜åªéœ€è¦æ±‚ç¬¬kå°ï¼Œæ²¡æœ‰å¿…è¦å¼€é‚£ä¹ˆå¤§ï¼Œå¯ä»¥å¯¹æ•°æ®è¿›è¡Œç¦»æ•£åŒ–ã€‚ æˆ‘ä»¬æŒ‰ç…§åºåˆ—çš„é¡ºåºæ’å…¥$a_i$ã€‚å¾—åˆ°æ¯ä¸ª$root[i]$ä»£è¡¨çš„æƒå€¼çº¿æ®µæ ‘ä»£è¡¨ä»$a_1$åˆ°$a_i$çš„æ¯ä¸ªæ•°å€¼çš„å‡ºç°æ¬¡æ•°ã€‚ é‚£ä¹ˆæ ¹æ®å‰ç¼€å’Œçš„æ€æƒ³ï¼ŒåŒºé—´$[l,r]$ä¸­æ¯ä¸ªæ•°å€¼çš„å‡ºç°ä¸ªæ•°å°±æ˜¯$[1,r]$çš„å‡å»$[1,l-1]$çš„ã€‚é‚£ä¹ˆæ•°å€¼çš„åŒºé—´ä¹Ÿå…·æœ‰è¿™ä¸ªæ€§è´¨ã€‚ æ‰€æœ‰å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæˆ‘ä»¬åªéœ€è¦æŸ¥è¯¢ä¸€æ¬¡ï¼Œç”¨$root[r]$å’Œ$root[l-1]$çš„æƒå€¼çº¿æ®µæ ‘å¤„ç†å‡ºåŒºé—´$[l,r]$åº”æœ‰çš„æƒå€¼çº¿æ®µæ ‘ï¼Œå°±å¯ä»¥åƒæ­£å¸¸çš„æƒå€¼çº¿æ®µæ ‘ä¸€æ ·æŸ¥è¯¢ç¬¬kå°äº†ã€‚ ä»£ç ï¼š #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//æ’å…¥ï¼Œåˆ›å»ºæ–°ç‰ˆæœ¬ { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//ç°åœºå¤„ç†ï¼Œå¾—åˆ°[x,y]åŒºé—´å†…ï¼Œå€¼åœ¨[l,mid]å†…çš„æ•°çš„ä¸ªæ•° if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//å¦‚æœk&lt;=X.è¯´æ˜ç¬¬kå°çš„æ•°åœ¨å·¦è¾¹ã€‚ else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//å¦åˆ™åœ¨å³è¾¹ã€‚ } int getid(int X)//å¾—åˆ°ç¦»æ•£åŒ–åçš„æ•°å€¼ { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//ç¦»æ•£åŒ– for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//æŒ‰é¡ºåºæ’å…¥æ¯ä¸ªå€¼ï¼Œå¾—åˆ°root[i]å¯¹åº”çš„æƒå€¼çº¿æ®µæ ‘ã€‚ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//æŸ¥è¯¢åŒºé—´[x,y]ï¼›è¾“å‡ºåŸå€¼ } return 0; } 3.ç¼ºç‚¹åŠæ³¨æ„äº‹é¡¹å†…å­˜æ± ä¸€èˆ¬ä»1å¼€å§‹ç”¨ï¼Œ$nodes[0]$ä½œä¸ºç©ºç™½ï¼Œå€¼ä¸º$0$ï¼Œå„¿å­èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼Œå€¼è¿˜æ˜¯ä¸º$0$ã€‚ å½“ä½ è¿™ä¸ªç‰ˆæœ¬çš„æ ‘è¿˜æ²¡æœ‰æ”¹è¿‡æŸä¸ªèŠ‚ç‚¹çš„æŸä¸ªå„¿å­æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹çš„è¿™ä¸ªå„¿å­ä¼šæŒ‡å‘$nodes[0]$ï¼Œä¹Ÿå°±ç›¸å½“äºä¸‹é¢éƒ½æ˜¯$0$ï¼Œæ­£å¥½ç¬¦åˆã€‚ æ•°ç»„ä¸€å®šè¦å¼€å¤§ï¼Œå¦‚æœå¼€å¾—ä¸å¤Ÿå¤§å¯èƒ½ä¼šå‡ºç°$MLE$,$TLE$,$RE$,$WA$. ä½†ä¹Ÿä¸è¦å¼€å¤ªå¤§ï¼Œä¸ç„¶ä¼š$MLE$,$CE$. ä¸»å¸­æ ‘æ˜¯é™æ€çš„ï¼Œé‡åˆ°è¦åŠ¨æ€ä¿®æ”¹è€Œä¸æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°ç‰ˆæœ¬çš„é—®é¢˜ï¼Œå°±å¯èƒ½è¦ç”¨æ ‘å¥—æ ‘äº†ã€‚ å¯æŒä¹…åŒ–å¯ä»¥ç”¨åœ¨å¾ˆå¤šæ•°æ®ç»“æ„ä¸Šï¼Œå¹³è¡¡æ ‘ï¼Œçº¿æ®µæ ‘ï¼Œ$trie$æ ‘â€¦â€¦å¯å¤Ÿå¾—å†™ï¼Œä½†å®ƒä»¬çš„æ€æƒ³éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œéƒ½æ˜¯æ¯ä¸ªç‰ˆæœ¬ä¸ä¹‹å‰çš„ç‰ˆæœ¬å…±ç”¨èŠ‚ç‚¹ä»¥èŠ‚çœæ—¶é—´ï¼Œç©ºé—´ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åˆ†å—","slug":"DS100P-FENKUAI","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.112Z","comments":true,"path":"2020/02/07/DS100P-FENKUAI/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-FENKUAI/","excerpt":"","text":"åˆ†å—($n\\sqrt n$) åˆ†å—å…¶å®ä¹Ÿæ˜¯ä¸€ç§æš´åŠ›ï¼Œä½†å®ƒæ˜¯ä¸€ç§å·§å¦™çš„æš´åŠ› å®ƒç”¨æ¥å¤„ç†åŒºé—´çš„é—®é¢˜ã€‚ æŠŠè¿™ä¸ªåŒºé—´å¤§æ¦‚åˆ†æˆ$\\sqrt n$å— ç„¶åå†å¤„ç†ï¼šå¯¹äºä¸€ä¸ªæ•´å—ï¼Œå°±æ•´ä¸ªå¤„ç†æ‰ï¼›å¯¹äºä¸€ä¸ªè§’å—ï¼ˆä¸å®Œæ•´çš„å—ï¼‰ï¼Œå°±æš´åŠ›å¤„ç†ã€‚ æ¯”å¦‚åŒºé—´æ±‚å’Œã€‚(éä¸»æµå†™æ³•å‹¿å–·) 1.åˆå§‹åŒ–å¯¹äºæ¯ä¸ªå…ƒç´ ï¼Œæˆ‘ä»¬è¦å¤„ç†å‡ºå®ƒæ˜¯å“ªä¸ªå—çš„ï¼Œä»¥ä¾¿ä¹‹åå¿«é€Ÿåœ°æ‰¾åˆ°å®ƒæ‰€åœ¨çš„å—ã€‚ å¯¹äºæ¯ä¸ªå—ï¼Œæˆ‘ä»¬è¦ç»Ÿè®¡å‡ºä¹‹åè®¡ç®—ç­”æ¡ˆæ‰€éœ€è¿™ä¸ªå—å†…çš„ç»“æœï¼ˆè¿™é‡Œå°±æ˜¯å—å†…åŒºé—´å’Œï¼‰ï¼Œåœ¨åŒºé—´ä¸­çš„å·¦å³ç«¯ç‚¹ï¼Œä»¥åŠåŒºé—´ä¿®æ”¹çš„æ‡’æ ‡è®°ã€‚ ä»£ç ï¼š struct cude { int l,r,sum,lazy;//å·¦å³ç«¯ç‚¹ï¼ŒåŒºé—´å’Œï¼Œæ‡’æ ‡è®° }cud[400]; int n,a[100010],bel[100010],each,cnt;//åŸæ•°ç»„å¤§å°åŠå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ çš„å—ç¼–å·ï¼Œå—å¤§å°ï¼Œå—æ•° void build() { each=sqrt(n); for(int i=0;i&lt;n;++i)//æ³¨æ„ï¼Œæˆ‘æ˜¯ä»0å¼€å§‹å­˜çš„åŸæ•°ç»„ { bel[i]=i/each;//é¢„å¤„ç†å…ƒç´ å±äºå— cud[bel[i]].sum+=a[i];//åŒºé—´å’Œ } for(int i=0;i*each&lt;n;++i) { ++cnt;//ç»Ÿè®¡å—æ•° cud[i].l=i*each;//å—å·¦ç«¯ç‚¹ cud[i].r=min((i+1)*each-1,n-1);//å—å³ç«¯ç‚¹ï¼Œä¸å¯èƒ½è¾¾åˆ°nï¼Œæ‰€ä»¥å–minï¼Œæœ€å¤šåˆ°n-1 } } 2.ä¿®æ”¹ä¿®æ”¹æ˜¯å¾ˆæš´åŠ›çš„ï¼Œæˆ‘ä»¬å¯¹è¿™ä¸ªåŒºé—´è¿›è¡Œæ‰«æã€‚ æ•´å—å°±åŒºé—´ä¿®æ”¹ï¼Œæ‡’æ ‡è®°ã€‚ è§’å—å°±ç›´æ¥æš´åŠ›æ‰«è¿‡å»ä¿®æ”¹ã€‚ æœ€å¤š$\\sqrt n$ä¸ªæ•´å—ï¼Œæ‰“æ‡’æ ‡è®°$O(1)$ï¼Œå¤æ‚åº¦ä¸º$O(\\sqrt n)$ æœ€å¤š$2$ä¸ªè§’å—ï¼Œä¸€ä¸ªè§’å—æœ€å¤š$\\sqrt n$ä¸ªå…ƒç´ ï¼Œæš´åŠ›ä¿®æ”¹$O(\\sqrt n)$ åŒºé—´ä¿®æ”¹æ€»æ—¶é—´å¤æ‚åº¦$O(\\sqrt n)$ ä»£ç ï¼š void update(int l,int r,int val) { for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i)//æ³¨æ„ä¸è¦è¶…è¿‡å—æ•°ï¼Œæˆ‘çš„å—æ˜¯ä»0å¼€å§‹ç¼–å·çš„ { if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r)//æ•´å—æ‰“æ‡’æ ‡è®° { cud[i].lazy+=val; cud[i].sum+=(cud[i].r-cud[i].l+1)*val; } else//è§’å—æš´åŠ›æ‰« { if(cud[i].l&lt;l)//å±äºæ•´ä¸ªåŒºé—´çš„æœ€å·¦è¾¹çš„è§’å—ï¼Œä½†è¿˜å¯èƒ½æ˜¯æœ€å³è¾¹çš„è§’å—ï¼Œéœ€è¦åˆ¤æ–­ä¸è¦è¶…å‡ºä¿®æ”¹åŒºé—´çš„å³ç«¯ç‚¹ { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } else//ä¸æ˜¯æœ€å·¦è¾¹çš„ï¼Œé‚£è‚¯å®šæ˜¯æœ€å³è¾¹çš„ã€‚ { for(int j=cud[i].l;j&lt;=r;++j) { a[j]+=val; cud[i].sum+=val; } } } } } 3.æŸ¥è¯¢æŸ¥è¯¢ä¹Ÿæ˜¯å¾ˆæš´åŠ›çš„ã€‚ åŒæ ·å¯¹è¿™ä¸ªåŒºé—´è¿›è¡Œæ‰«æã€‚ å¦‚æœæ˜¯æ•´å—ï¼Œå°±ç›´æ¥åŠ ä¸Šè¿™ä¸ªå—çš„åŒºé—´å’Œã€‚ å¦‚æœæ˜¯è§’å—ï¼Œå°±è¦å…ˆä¸‹ä¼ æ‡’æ ‡è®°ï¼Œå†æš´åŠ›æŸ¥è¯¢ã€‚ å› ä¸ºæˆ‘ä»¬ä¹‹å‰å¹¶æ²¡æœ‰ä¿®æ”¹å…ƒç´ å€¼ï¼Œåªæ˜¯åŠ ä¸Šäº†æ‡’æ ‡è®°ï¼Œä¿®æ”¹äº†åŒºé—´å’Œã€‚ æ‰€ä»¥æˆ‘ä»¬ç°åœ¨è¦å…ˆä¿®æ”¹è¿™äº›å…ƒç´ çš„å€¼å†æŸ¥è¯¢ï¼Œå¦åˆ™æŸ¥è¯¢åˆ°çš„å€¼æ˜¯ä¿®æ”¹ä¹‹å‰çš„ã€‚ æ—¶é—´å¤æ‚åº¦ä¸ä¿®æ”¹ç›¸åŒï¼Œéƒ½æ˜¯$O(\\sqrt n)$ï¼› ä»£ç ï¼š //ç»†èŠ‚åŒ2.ä¿®æ”¹ int find(int l,int r) { int res=0; for(int i=bel[l];cud[i].l&lt;=r&amp;&amp;i&lt;cnt;++i) if(cud[i].l&gt;=l&amp;&amp;cud[i].r&lt;=r) res+=cud[i].sum; else { if(cud[i].lazy)//ä¸‹ä¼ æ‡’æ ‡è®° { for(int j=cud[i].l;j&lt;=cud[i].r;++j) a[j]+=cud[i].lazy; cud[i].lazy=0; } if(cud[i].l&lt;l) { for(int j=l;j&lt;=cud[i].r&amp;&amp;j&lt;=r;++j) res+=a[j]; } else { for(int j=cud[i].l;j&lt;=r;++j) res+=a[j]; } } } return res; } 4.æ€»ç»“ä½ çœ‹ç€è¿™ä¸ªä¸œè¥¿å¥½åƒå¾ˆæš´åŠ›ï¼Œä½†å®ƒå°±æ˜¯è·‘å¾—è¿‡é¢˜ã€‚ å®ƒçš„æ€»æ—¶é—´å¤æ‚åº¦æ˜¯$O(n\\sqrt n)$çš„ï¼Œ$500000$åŠä»¥ä¸Šå°±åˆ«æƒ³å•¦ã€‚ åˆ†å—çš„é¢˜ç›®å¾ˆçµæ´»ï¼Œä½†ä¸€èˆ¬éƒ½å¾ˆæš´åŠ›ï¼Œæœ‰æ—¶åŒºé—´ä¿®æ”¹ä¸èƒ½æ‰“æ‡’æ ‡è®°ï¼Œå°±å¿…é¡»æš´åŠ›ä¿®æ”¹ï¼Œä½†æœ‰æ—¶ä½ åˆå¯ä»¥è·³è¿‡è¿™ä¸ªä¿®æ”¹ï¼Œè¿›è¡Œâ€œå‰ªæâ€ã€‚ å°±åƒèŠ±ç¥æ¸¸å†å„å›½ï¼ŒåŒºé—´å¼€æ–¹å¿…é¡»è¦åœ¨å—é‡Œå»æš´åŠ›å¼€ ä½†æˆ‘ä»¬æƒ³ï¼Œ$1$å’Œ$0$å¼€æ–¹åéƒ½æ˜¯æœ¬èº«ï¼Œå…¶å®ƒæ•°å¼€æ–¹å°±ä¼šå˜å¾—è¶Šæ¥è¶Šå°ï¼Œæœ€ååˆ°$1$ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç»´æŠ¤ä¸€ä¸ªå—å†…æ˜¯å¦å…¨æ˜¯$1$æˆ–$0$ã€‚ å¦‚æœæ˜¯ï¼Œå°±å¯ä»¥è·³è¿‡åœ¨è¿™ä¸ªåŒºé—´é‡Œè¿›è¡Œå¼€æ–¹äº†ï¼Œå› ä¸ºè¿™ä¸ªå—é‡Œçš„å…ƒç´ å¼€æ–¹ä¹‹åéƒ½è¿˜æ˜¯æœ¬èº«ï¼Œæ¯ä¸ªå…ƒç´ å’ŒåŒºé—´å’Œéƒ½æ²¡æœ‰å˜ã€‚ å…¶ä»–çš„å°±æ˜¯æ™®é€šåˆ†å—ã€‚ $\\ $ åœ¨åˆ†å—ï¼Œä½ ç”šè‡³å¯ä»¥æ‰“è¡¨ åœ¨åŒºé—´ä¸­é€‰å–$\\sqrt n$ä¸ªç‰¹å¾ç‚¹ï¼Œå¤„ç†å‡ºå®ƒä»¬é—´çš„ä¿¡æ¯ã€‚ å¯¹æ¯ä¸ªæŸ¥è¯¢ï¼Œé€‰å–æœ€è¿‘çš„ä¸¤ä¸ªç‰¹å¾ç‚¹çš„ä¿¡æ¯å†ä»è¿™ä¸¤ä¸ªç‰¹å¾ç‚¹æš´åŠ›è·³è¿‡å»ã€‚ è¿™æ ·å°±å¯ä»¥ä»£æ›¿è«é˜Ÿå•¦ã€‚ è€Œä¸”åˆ†å—æ²¡æœ‰ä»»ä½•ç¦»çº¿æ“ä½œï¼Œå¯ä»¥åº”å¯¹çœ‹èµ·æ¥åƒè¦ç”¨è«é˜Ÿï¼ˆç¦»çº¿ç®—æ³•ï¼ŒåŒæ ·$O(n\\sqrt n)$ï¼‰æ‰èƒ½è§£å†³ï¼Œä½†åˆå¼ºåˆ¶åœ¨çº¿çš„é¢˜ç›®ã€‚ ä»¥åŠï¼Œæ•´é™¤åˆ†å—ä¸æ˜¯æ•°æ®ç»“æ„ï¼Œæ˜¯æ•°è®ºï¼ï¼ï¼","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Chtholly-Tree(Old-Driver Tree)","slug":"DS100P-CHTHOLLY-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.110Z","comments":true,"path":"2020/02/07/DS100P-CHTHOLLY-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-CHTHOLLY-TREE/","excerpt":"","text":"Chtholly-Treeä¼—æ‰€å‘¨çŸ¥ï¼Œæ•°æ®ç»“æ„+ç®—æ³•=ç¨‹åºï¼Œå¯è§æ•°æ®ç»“æ„çš„é‡è¦æ€§æ•°æ®ç»“æ„å äº†æˆ‘ä»¬ç¼–ç¨‹çš„ä¸€å¤§éƒ¨åˆ†ã€‚æ•°æ®ç»“æ„çš„å¤§å®¶æ—ä¸­ï¼Œæœ‰ä¼˜ç¾çš„çº¿æ®µæ ‘ã€æ ‘çŠ¶æ•°ç»„ç­‰ã€‚ä½†æˆ‘ä»¬ä»Šå¤©çš„ä¸»è§’å´ååˆ†æš´åŠ›ã€‚å¥¹çš„åå­—å«ç‚æœµè‰æ ‘ ç‚æœµè‰æ ‘æ˜¯åŸºäºC++STLåº“ä¸­çš„setçš„æ•°æ®ç»“æ„ã€‚ä¸çº¿æ®µæ ‘ã€å¹³è¡¡æ ‘ç­‰æ ‘å½¢ç»“æ„ç±»ä¼¼ï¼Œç‚æœµè‰æ ‘æ˜¯ç”¨æ¥è§£å†³åŒºé—´é—®é¢˜çš„å¾ˆæš´åŠ›çš„æ ‘å½¢ç»“æ„ã€‚ å¥¹çš„ç‰¹ç‚¹æ˜¯èƒ½å¤Ÿè¿›è¡ŒåŒºé—´æ¨å¹³æ“ä½œï¼Œå¹¶ä¸”æ—¶é—´å¤æ‚åº¦æ¥è¿‘O(n log m) ã€‚ä½†å‰ææ˜¯æ•°æ®éšæœºã€‚ä½†ä¸€èˆ¬ä¸ä¼šæœ‰å“ªä¸ªå‡ºé¢˜äººå»å¡è¿™æ ·ä¸€ä¸ªå¹¶ä¸å‡ºåçš„æ•°æ®ç»“æ„ã€‚å¹¶ä¸”è¦æœ‰åŒºé—´æ¨å¹³æ“ä½œï¼Œå¦åˆ™å…‰æ˜¯ä¸€ä¸ªsplitæ—¶é—´å¤æ‚åº¦ä¼šç‚¸ã€‚ ç‚æœµè‰æ ‘çš„æ„é€ é•¿æˆè¿™ä¸ªäºšå­: struct Chtholly { LL L; LL R; //åŒºé—´ mutable LL _val; //å€¼ï¼Œæ³¨æ„ï¼Œå…³é”®å­—mutableæ˜¯å¿…éœ€çš„ï¼Œå¦åˆ™ä¼šåœ¨addå‡½æ•°é‡ŒCE node(LL l, LL r = -1, LL V = 0) : L(l), R(r), _val(V) {} bool operator&lt;(const node &amp;rhs) const { return L &lt; rhs.L; } } Splitæ“ä½œ: inline IT split(int k) { IT it = st.lower_bound(node(k)); if (it != st.end() &amp;&amp; it-&gt;L == k) return it; --it; LL l = it-&gt;L, r = it-&gt;R; LL v = it-&gt;_val; st.erase(it); st.insert(node(l, k - 1, v)); return st.insert(node(k, r, v)).first; } ä¸ºäº†æ“ä½œæ–¹ä¾¿æˆ‘ä»¬è¿™é‡Œæœ‰ä¸€ä¸ªdefine: #define IT set&lt;Chtholly&gt;::iterator assignåŒºé—´æ¨å¹³æ“ä½œï¼Œè¿™ä¹Ÿæ˜¯ç‚æœµè‰æ ‘çš„æ—¶é—´å¤æ‚åº¦ä¿è¯ inline void assign(LL ll, LL rr, LL val) { IT itr = split(rr + 1), itl = split(ll); st.erase(itl, itr); st.insert(node(ll, rr, val)); } ä¸¾å‡ ä¸ªä¾‹å­å§ åŒºé—´æ±‚å’Œ:inline LL Qsum(LL ll, LL rr) { LL res = 0; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) res += (itl-&gt;R - itl-&gt;L + 1) * itl-&gt;_val; return res; } åŒºé—´ç¬¬Kå°:inline LL kth(LL ll, LL rr, LL k) { vector&lt;pair&lt;LL, LL&gt; &gt; vec; IT itr = split(rr + 1), itl = split(ll); for (; itl != itr; ++itl) vec.push_back(pair&lt;LL, LL&gt;(itl-&gt;_val, itl-&gt;R - itl-&gt;L + 1)); sort(vec.begin(), vec.end()); for (auto it = vec.begin(); it != vec.end(); ++it) { k -= it-&gt;second; if (k &lt;= 0) return it-&gt;first; } return -1; } åŒºé—´åŠ inline void add(LL ll, LL rr, LL ad) { IT itr = split(rr + 1), itl = split(ll); for (; itr != itl; ++itl) itl-&gt;_val += ad; } å¹³æ—¶å¤§å®¶è¿˜æ˜¯å°½é‡å°‘ç”¨Â·Â·Â·Â·Â·Â·","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---KMP","slug":"DS100P-KMP-STRING","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.125Z","comments":true,"path":"2020/02/07/DS100P-KMP-STRING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-KMP-STRING/","excerpt":"","text":"KMPupd:ä»£ç é”…å·²è¡¥ 0x00 å‰è¨€æœ¬æ–‡å’ŒæŸæ’­æ”¾è½¯ä»¶KMPlayeræ²¡æœ‰ä¸€æ¯›é’±å…³ç³»ï¼Œå¹¶ä¸”ï¼š ä¼¦å®¶æ˜¯æ•°æ®ç»“æ„ï¼ 0x01 å¼•å…¥é—®é¢˜è®¾æƒ³è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š ç»™ä½ ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œè®©ä½ æŸ¥æ‰¾åœ¨æ–‡æœ¬ä¸²ä¸­æ¨¡å¼ä¸²çš„ä½ç½®ã€‚ æš´åŠ›åšæ³•æ˜¯æ˜¾ç„¶çš„ï¼Œä¸¾ä¾‹æ¥è¯´ï¼š æ–‡æœ¬ä¸²(text)ï¼š$a\\ b\\ c\\ b\\ c\\ g\\ l\\ x$ æ¨¡å¼ä¸²(pattern): $b\\ c\\ g\\ l$ æˆ‘ä»¬ç›´æ¥æš´åŠ›æšä¸¾textä¸­çš„æ¯ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”ä¾æ¬¡ä¸patternä¸­çš„å­—ç¬¦ä»å¤´å¼€å§‹åŒ¹é…ã€‚æ—¶é—´å¤æ‚åº¦ä¸º $\\Theta(nm)$ 0x02 å‘ç°é—®é¢˜è¿™æ ·åšå…¶å®æœ‰å¾ˆå¤šå†—ä½™æ“ä½œã€‚æ¯”å¦‚è¯´ï¼š$b\\ c\\ g\\ l$ ä¸textä¸­çš„ $b\\ c\\ b\\ c$ ä¸åŒ¹é…ï¼Œåˆä»ç¬¬textçš„ç¬¬äº”ä¸ªå­—æ¯ $c$ å¼€å§‹åŒ¹é…ã€‚è¿™æ ·åšæ˜¯æ˜¾ç„¶ä¸å¿…è¦çš„ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºæ¨¡å¼ä¸²æ˜¯ä»¥ $b$ å¼€å¤´çš„ï¼Œå¯¹äºtextä¸­ç¬¬äº”ä¸ªå­—æ¯ $c$ æ˜¾ç„¶æˆ‘ä»¬å¯ä»¥ä¸å»åŒ¹é…ã€‚å‘ç°äº†ä»€ä¹ˆå—ï¼Ÿæ¯æ¬¡å¤±é…åæˆ‘ä»¬åªéœ€è¦ä»ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æœ€é•¿å…¬å…±éƒ¨åˆ†å¼€å§‹åŒ¹é…å³å¯ã€‚è¿™é‡Œçœ‹ä¸æ‡‚æ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œåªè¦èƒ½ç†è§£åé¢çš„ä¾‹å­å°±å¯ä»¥äº†ã€‚ 0x03 è§£å†³ä¸€éƒ¨åˆ†é—®é¢˜$\\qquad\\qquad\\quad\\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5\\ \\ 6\\ \\ 7\\ \\ 8\\ \\ 9\\ 10\\ 11$ æ–‡æœ¬ä¸²(text)ï¼š $a\\ \\ b\\ \\ x\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ æ¨¡å¼ä¸²(pattern)ï¼š $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ æˆ‘ä»¬æœ‰ä¸¤ä¸ªæŒ‡é’ˆiå’Œjï¼Œåˆ†åˆ«æŒ‡å‘æ–‡æœ¬ä¸²å’Œæ¨¡å¼ä¸²ã€‚åœ¨i=0,j=0ä»¥åŠi=1,j=1çš„æ—¶å€™éƒ½åŒ¹é…ä¸Šäº†ã€‚ä½†æ˜¯åœ¨i=2,j=2æ—¶å¤±é…äº†ã€‚å¦‚æœæ—¶æœ´ç´ ç®—æ³•çš„è¯ä¼šä»¤i=1,j=0é‡æ–°å¼€å§‹åŒ¹é…ã€‚ç„¶è€Œæˆ‘ä»¬å‘ç°æˆ‘ä»¬å®Œå…¨å¯ä»¥ä»¤i=3,j=0æ¥é‡æ–°åŒ¹é…ã€‚ä¸€ç›´åˆ°i=8,j=5æ—¶ï¼Œå®ƒä»¬åˆå¤±é…äº†ã€‚æˆ‘ä»¬ä»¤jç­‰äºæ¨¡å¼ä¸²å’Œæ–‡æœ¬ä¸²å·²ç»é…å¯¹å®Œæˆçš„éƒ¨åˆ†(å³pattern[0]~pattern[4])çš„æœ€é•¿å…¬å…±å‰ç¼€åç¼€(å³pattern[0,1]å’Œpattern[3,4])çš„å‰ç¼€æœ«å°¾éƒ¨åˆ†+1(å³1+1=2)çš„åœ°æ–¹ï¼Œæ­¤æ—¶çš„text[6,7]å’Œpattern[0,1]éƒ½æ˜¯abä¹Ÿå°±æ˜¯è¯´æˆ‘ä»¬å¯ä»¥ç›´æ¥ä»i=8,j=2å¼€å§‹åŒ¹é…ï¼Œå°±å¯ä»¥åŒ¹é…åˆ°æ¨¡å¼ä¸²äº†ã€‚è¿™å°±æ˜¯KMPç„å¦™çš„åœ°æ–¹ã€‚ 0x04 è§£å†³å¦ä¸€éƒ¨åˆ†é—®é¢˜é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼šæˆ‘ä»¬å¦‚ä½•ç¡®å®šæ¨¡å¼ä¸²æœ€é•¿å…¬å…±å‰åç¼€çš„å‰ç¼€æœ«å°¾+1çš„ä½ç½®å‘¢ï¼Ÿæˆ‘ä»¬è¿˜æ˜¯é€šè¿‡ä¸€ä¸ªä¾‹å­æ¥æ„Ÿå—ã€‚ $\\qquad\\qquad\\qquad\\ \\ \\ 0\\ \\ 1\\ \\ 2\\ \\ 3\\ \\ 4\\ \\ 5$ æ¨¡å¼ä¸²(pattern)ï¼š $a\\ \\ b\\ \\ c\\ \\ a\\ \\ b\\ \\ y$ (æ²¡é”™å°±æ˜¯ä¸Šé¢é‚£ä¸ªæˆ‘å¤ªæ‡’äº†) æˆ‘ä»¬å¯ä»¥è®¾æ•°ç»„$next_i$ä¸ºä»¥ $i$ ä¸ºç»“å°¾çš„æ¨¡å¼ä¸²æœ€é•¿å…¬å…±å‰åç¼€çš„å‰ç¼€æœ«å°¾+1çš„ä½ç½®ã€‚ $next_0$æ˜¾ç„¶ä¸º0ã€‚ æˆ‘ä»¬ä¾ç„¶è®¾ä¸¤ä¸ªæŒ‡é’ˆiå’Œjï¼Œiåˆå§‹åŒ–ä¸º0ï¼Œå³æŒ‡å‘æ¨¡å¼ä¸²çš„å¼€å¤´ã€‚jåˆå§‹åŒ–1ï¼Œå³iåé¢ä¸€ä¸ªã€‚ pattern[i]ä¸ç­‰äºpattern[j]ï¼Œä»¤next[i]=0ï¼Œj+=1 pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œä»¤next[i]=0ï¼Œj+=1 æ­¤æ—¶pattern[i]ç­‰äºpattern[j]ï¼Œä»¤next[i]=j+1=1ï¼Œi+=1ï¼Œj+=1 æ­¤æ—¶pattern[i]ç­‰äºpettern[j]ï¼Œä»¤next[i]=j+1=2ï¼Œi+=1,j+=1 æ­¤æ—¶pattern[i]ä¸ç­‰äºpatter[j]ï¼Œå¹¶ä¸”jä¸åœ¨æ¨¡å¼ä¸²çš„å¼€å¤´ï¼Œä»¤j=next[j-1]=2 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œå¹¶ä¸”jä¸åœ¨æ¨¡å¼ä¸²çš„å¼€å¤´ï¼Œä»¤j=next[j-1]=0 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œä½†æ˜¯jå·²ç»è·‘åˆ°å¼€å¤´å»äº†ï¼Œä»¤i+=1 æ­¤æ—¶pattern[i]ä¾ç„¶ä¸ç­‰äºpattern[j]ï¼Œå¹¶ä¸”iå·²ç»è·‘åˆ°äº†å°½å¤´ï¼Œæ±‚è§£ç»“æŸã€‚ %å‡ºæ¥nextæ•°ç»„æ˜¯è¿™æ ·çš„:$[0,0,0,1,2,0]$ 0x05 è§£å†³æ‰€æœ‰é—®é¢˜å…¶å®å°±æ˜¯æ”¾ä¸€ä¸‹ä»£ç  æˆ‘è‡ªè®¤ä¸ºè®²çš„è¿˜æ˜¯æ¯”è¾ƒæ¸…æ¥šï¼Œè‡³å°‘æ¯”è“ä¹¦å¥½ã€‚ ä»£ç è™½ç„¶å’Œç½‘ä¸Šå…¶ä»–äººçš„ä¸å¤ªä¸€æ ·ï¼Œä¸å¤ªæ ‡å‡†ï¼Œä½†è¿˜ç®—ç®€æ´ï¼Œè‡³å°‘æ¯”è“ä¹¦å¥½ã€‚ æ€»ä¹‹ä¸€å¥è¯ï¼Œå­¦KMPä¸è¦çœ‹ä¹¦ï¼Œä¸è¦çœ‹ä¹¦ï¼Œä¸è¦çœ‹ä¹¦ï¼ï¼ï¼ä¼šæ­»äººçš„ï¼ï¼ï¼ å¯¹äº†è¿˜æœ‰ä¸€ä¸ªå‘ç‚¹ï¼Œæˆ‘è¿™ä»½ä»£ç ç”¨std::stringä¼šREï¼Œé¬¼çŸ¥é“æˆ‘è°ƒäº†ä¸€ä¸‹åˆå‘ç°æ˜¯è¿™ä¸ªåŸå› æ—¶å¿ƒé‡Œæœ‰å¤šå‚»é€¼ /* * P3375ã€æ¨¡æ¿ã€‘KMPå­—ç¬¦ä¸²åŒ¹é….cpp * Created by boringhacker(c20220233wgy) */ #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; using namespace std; namespace MAIN { const int SIZE = 1000000 + 5; int next[SIZE], n, m; char Text[SIZE], Pattern[SIZE]; // string Text, Pattern; å»ä½ çš„std::string void GetNextVal() { int i = 1, j = 0; *next = 0; while (i &lt; n) { if (Pattern[i] == Pattern[j]) next[i] = j + 1, ++i, ++j; else if (j) j = next[j - 1]; else ++i; } } void GetAnswers() { int st = 0, res = -1; int i = 0, j = 0, flag = 0; while (true) { j = st; if (Text[i] == Pattern[j]) { if (!flag) res = i + 1 - st, flag = 1; // if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = 0, flag = 0; è¿™é‡Œå‡ºé”…äº†ï¼Œjåº”è¯¥èµ‹ä¸ºnext[j-1] if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = next[j - 1], flag = 0; else ++i, ++j; st = j; if (i &gt;= m) return ; } else { if (j) st = next[j - 1]; else ++i; flag = 0; } } } void MAIN() { cin &gt;&gt; Text; cin &gt;&gt; Pattern; m = strlen(Text); n = strlen(Pattern); GetNextVal(); GetAnswers(); for (int i = 0; i &lt; n; ++i) cout &lt;&lt; next[i] &lt;&lt; &#39; &#39;; } } signed main() { MAIN::MAIN(); return 0; } æ¬¢è¿æ‰è™«å­","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---Link-Cut Tree","slug":"DS100P-LINK-CUT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.127Z","comments":true,"path":"2020/02/07/DS100P-LINK-CUT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-LINK-CUT-TREE/","excerpt":"","text":"Link-Cut Tree0x00æœ¬æ–‡çš„å›¾æ¥è‡ªQiulyçš„åšå®¢æµ…è°ˆlink-cut Tree æœ¬æ–‡ç…§æ¬Qiulyçš„åšå®¢æµ…è°ˆlink-cut Tree lctè¿™ä¸œè¥¿ä¸å¥½å†™ï¼Œæˆ‘è¿™ç§è’Ÿè’»å†™ä¸å¥½æ‰€ä»¥åªèƒ½ç…§æ¬Qiulyï¼Œè·ŸQiulyå”¯ä¸€çš„åŒºåˆ«å°±æ˜¯æˆ‘å­—æ˜¯è‡ªå·±æ‰“çš„â€¦â€¦ 0x01LCTå…¶å®å¯ä»¥çœ‹åšåŠ å¼ºç‰ˆçš„é‡é“¾å‰–åˆ†ï¼Œå¯ä»¥è¯´é‡é“¾å‰–åˆ†èƒ½åšçš„LCTéƒ½èƒ½åšã€‚ä¸ä»…å¦‚æ­¤ï¼ŒLCTä»£ç æ¯”é‡é“¾å‰–åˆ†çŸ­ï¼Œå¸¸æ•°æœ‰æ—¶æ¯”é‡é“¾å‰–åˆ†å°ã€‚ LCTç”±å¾ˆå¤šæ£µSplayç»„æˆï¼Œå…¶ä¸­å°†Splayæ£®æ—ä¸­çš„æ‰€æœ‰Splayè¿æ¥èµ·æ¥çš„å«åš è™šè¾¹ ã€‚Splayä¸­è¾¹å«åšå®è¾¹ã€‚ åŸæ¥çš„æ£®æ—æˆ‘ä»¬å«åšåŸæ£®æ—ï¼Œç”¨å®è¾¹è¿èµ·æ¥çš„ä¸€æ£µæ ‘å«åŸæ ‘ã€‚Splayçš„å…³é”®å­—æ˜¯èŠ‚ç‚¹åœ¨ä¹¦ä¸­çš„æ·±åº¦ã€‚ Splayæ˜¯LCTçš„è¾…åŠ©æ ‘ã€‚fhq-treapå…¶å®ä¹Ÿå¯ä»¥ï¼Œä½†å‡æ‘Šæ—¶é—´å¤æ‚åº¦ä¼šå¤šå‡ºä¸€ä¸ª\\log 0x02ä»¥ä¸‹æ˜¯ä¸€äº›LCTå¸¸ç”¨çš„åŸºç¡€æ“ä½œ access(x):å°†xåˆ°rootçš„è·¯å¾„ä¸Šçš„è¾¹å…¨éƒ¨å˜æˆå®è¾¹ï¼Œå¹¶æ–­å¼€ä¸è‡ªå·±å„¿å­çš„è”ç³» findroot(x):æ‰¾å‡ºxæ‰€åœ¨åŸæ ‘çš„root makeroot(x):è®©xå˜ä¸ºæ‰€åœ¨åŸæ ‘çš„root connect(x,y):è¿æ¥xå’Œyæ‰€åœ¨çš„åŸæ ‘ erase(x,y):æ‹†å¼€xå’Œyæ‰€åœ¨çš„åŸæ ‘ split(x,y):å°†x,yæåœ¨ä¸€æ£µè¾…åŠ©æ ‘ Access(x): æ¢å¥è¯æ¥è¯´å°±æ˜¯å°†ç‚¹xåˆ°åŸæ ‘ä¸­rootä¹‹é—´çš„é“¾ä¸¢åˆ°ä¸€ä¸ªsplayé‡Œ ä¸¾ä¸ªä¾‹å­ï¼Œç°åœ¨æœ‰ä¸€ä¸ªæ£®æ—é•¿æˆè¿™æ ·ï¼š&lt;/li&gt;&lt;/ul&gt; ç°åœ¨xä¸º6ã€‚æˆ‘ä»¬access(x)ã€‚ é‚£ä¹ˆ{1-3ï¼Œ3-6}ä¼šå˜ä¸ºå®è¾¹ï¼Œ1-2ä¼šå˜æˆè™šè¾¹ï¼Œå‡è®¾6æœ‰ä¸€å„¿å­nï¼Œä¹‹é—´ç”¨å®è¾¹è¿ç€ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹ä¹Ÿå°†å˜æˆè™šè¾¹ã€‚ æ¯æ¬¡å°† x ç‚¹ splay åˆ°å½“å‰æ‰€åœ¨è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œå°†å®ƒçš„å³å„¿å­æ›´æ–°ä¸ºä¸Šä¸€ä¸ª x ï¼Œç„¶åä»¤ x è·³åˆ°å®ƒçš„çˆ¶èŠ‚ç‚¹ï¼Œç¬¬ä¸€ä¸ª x çš„å³å„¿å­è®¾ä¸º0ã€‚ ä¸ºä»€ä¹ˆæ˜¯å³å„¿å­è€Œä¸æ˜¯å·¦å„¿å­å‘¢ï¼Ÿ å› ä¸ºfa[x]çš„æ·±åº¦å°äºxï¼Œè€Œåœ¨Splayé‡Œé¢fa[x]æ˜¯xçš„çˆ¸çˆ¸ï¼Œæ‰€ä»¥xåœ¨Splayä¸­æ˜¯fa[x]çš„å³å„¿å­ã€‚ æˆ‘ä»¬å°† x æ—‹è½¬åˆ°è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯å°†å½“å‰åŸæ ‘è¿™æ¡é“¾ä¸Šæ·±åº¦å°äº x (åœ¨ x ä¸Šé¢çš„ç‚¹)ä¸¢åˆ°äº† x çš„å·¦å­æ ‘ä¸Šï¼Œå°† x çš„å³å­æ ‘è®¾ä¸ºä¸Šä¸€ä¸ª x ç‚¹ç›¸å½“äºå°† x åŸæ¥çš„å³å­æ ‘ä¸¢åˆ°äº†æ–°çš„ splay é‡Œé¢(è€Œå®ƒä»¬ä¹‹é—´ç”¨è™šè¾¹ç›¸è¿)ï¼Œå¹¶ä¸”å°†ä¸Šä¸€æ®µé“¾è¿æ¥èµ·æ¥ã€‚ ç°åœ¨å°±å¯ä»¥äº†ã€‚è¿™æ£µæ–° Splay ä¸­åªæœ‰è¿™æ¡é“¾ä¸Šçš„ç»“ç‚¹ï¼Œæ²¡æœ‰å…¶ä»–ä»»ä½•çš„ç»“ç‚¹ã€‚å¦‚æœæˆ‘ä»¬æŒ‡å®šè¦è¿™ä¸‰ä¸ªç»“ç‚¹åŒæ—¶è¿›è¡Œæ“ä½œï¼Œå¯ä»¥ç›´æ¥ä¸‹ä¼ lazy_tagåˆ°è¿™ä¸‰ä¸ªç»“ç‚¹ç»„æˆçš„ Splay çš„æ ¹ç»“ç‚¹å“¦!åˆ°åé¢Splayçš„æ—¶å€™å°±å¯ä»¥ç›´æ¥ä¸‹ä¼ è·Ÿæ–°ç»“ç‚¹ä¿¡æ¯äº†ã€‚ æ€»ä½“è¿‡ç¨‹ï¼š è™šè¾¹ï¼šå„¿å­è®¤çˆ¶ï¼Œçˆ¶ä¸è®¤å­ å®è¾¹ï¼šå„¿å­è®¤çˆ¶ï¼Œçˆ¶ä¹Ÿè®¤å­ ç”¨FlashHuçš„è¯æ¥è¯´ï¼š 1.è½¬åˆ°æ ¹ã€‚ 2.æ¢å„¿å­ã€‚ 3.æ›´æ–°ä¿¡æ¯ã€‚ 4.å½“å‰æ“ä½œç‚¹åˆ‡æ¢ä¸ºè½»è¾¹æ‰€æŒ‡çš„çˆ¶äº²ï¼Œè½¬1ã€‚ inline void Access(int x){ for(register int y=0;x;y=x,x=fa[x]){ Splay(x);//è½¬ ch[x][1]=y;//è®¤å„¿å­äº† pushup(x);//å„¿å­æœ‰å˜åŒ–ï¼Œæ›´æ–° } } findroot(x): é¦–å…ˆè¦æ˜ç™½ï¼š æ ¹èŠ‚ç‚¹æ˜¯çš„æ·±åº¦æœ€å°çš„ æˆ‘ä»¬å¯ä»¥é€šè¿‡xå‘ä¸Šæ‰¾ï¼Œç”¨ Access æ“ä½œå¯ä»¥å°†xå’Œxçš„æ ¹ç»“ç‚¹æåˆ°ä¸€ä¸ª Splay é‡Œã€‚ åˆå› ä¸ºæœ‰BSTçš„æ€§è´¨ï¼šxçš„å·¦å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æƒå€¼ &lt; x &lt; xå³å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æƒå€¼ã€‚ è€Œæˆ‘ä»¬åˆçŸ¥é“ï¼Œåœ¨æ‰§è¡Œå®Œ Access æ“ä½œåï¼Œè¿™è¯¾ Splay é‡Œé¢çš„ç»“ç‚¹æƒå€¼æœ€å¤§çš„(æ·±åº¦æœ€å¤§çš„)å°±æ˜¯xã€‚ äºæ˜¯æˆ‘ä»¬å¯ä»¥å°†x Splay åˆ°è¿™æ£µ Splay çš„æ ¹ç»“ç‚¹ï¼Œé‚£ä¹ˆç°åœ¨æœ€å·¦è¾¹çš„èŠ‚ç‚¹ä¾¿æ˜¯è¿™è¯¾æ ‘çš„æ ¹ç»“ç‚¹äº†ã€‚ inline int findroot(int x){ Access(x);//Accesså°†xå’Œæ ¹ç»“ç‚¹æåˆ°åŒä¸€ä¸ªSplayä¸­ Splay(x);//è½¬åˆ°Splayçš„æ ¹ç»“ç‚¹ while(ch[x][0])pushdown(x),x=ch[x][0];//ä¸æ–­çš„æ‰¾å·¦å„¿å­&amp;æ›´æ–°èŠ‚ç‚¹ä¿¡æ¯ return x;//æœ€å·¦è¾¹çš„å°±æ˜¯æ ¹ç»“ç‚¹äº†ã€‚ } makeroot(x): å°†xåˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„ä¸Šçš„ç‚¹å…¨éƒ¨ç¿»è½¬(å³xå˜æˆäº†æ ¹èŠ‚ç‚¹) å…·ä½“æ“ä½œæ˜¯æˆ‘ä»¬å…ˆå°†xç‚¹ä¸åŸæ ‘ä¸­çš„æ ¹æ‰“é€šä¸€æ¡é“¾ï¼Œé‚£ä¹ˆç°åœ¨å®ƒä»¬å°±åœ¨åŒä¸€æ£µè¾…åŠ©æ ‘é‡Œé¢äº†ï¼Œæˆ‘ä»¬å‘ç°xä¸€å®šæ˜¯åœ¨å®ƒæ‰€åœ¨çš„è¾…åŠ©æ ‘çš„ä¸­åºéå†çš„æœ€åä¸€ä¸ªçš„(å› ä¸ºå®ƒæ˜¯è¿™æ¡é“¾ä¸Šæœ€æ·±çš„ç‚¹)ï¼Œæˆ‘ä»¬æŠŠxç‚¹ splay åˆ°è¾…åŠ©æ ‘çš„æ ¹ä¸Šï¼Œé‚£ä¹ˆxæ˜¾ç„¶æ˜¯æ²¡æœ‰å³å­æ ‘çš„ï¼Œæˆ‘ä»¬è¦å®ç°å°†xç§»åˆ°åŸæ ‘çš„æ ¹ä¸Šï¼Œä¹Ÿå°±æ˜¯å°†xåˆ°æ ¹çš„è¿™æ¡é“¾çš„æ·±åº¦å…¨éƒ¨ç¿»è½¬ä¸€éï¼Œåœ¨è¾…åŠ©æ ‘ä¸Šçš„ä½“ç°å°±æ˜¯å°†æ•´æ£µæ ‘ç¿»è½¬ä¸€éï¼Œæˆ‘ä»¬å¯ä»¥å†™ä¸ªç¿»è½¬æ ‡è®°æ¥å‡å°‘å¤æ‚åº¦ã€‚ inline void filp(int x){//Splayæ™®é€šåŒºé—´ç¿»è½¬ swap(ch[x][0],ch[x][1]);r[x]^=1; } inline void makeroot(int x){ Access(x); Splay(x); filp(x);//lazy_tag&amp;ç¿»è½¬åŒºé—´ } split(x,y) è¿™ä¸ªæ“ä½œæ˜¯å°†xåˆ°yä¹‹é—´çš„é‚£æ¡è·¯å¾„ä¸¢åˆ°ä¸€æ£µè¾…åŠ©æ ‘é‡Œï¼Œå¹¶ä¸”è¿™æ£µè¾…åŠ©æ ‘ä»¥yèŠ‚ç‚¹ä¸ºæ ¹ã€‚ Splay ç»´æŠ¤çš„æ˜¯åŸæ ‘ä¸­çš„ä¸€æ¡é“¾ï¼Œæˆ‘ä»¬ä¸èƒ½ä¿è¯x,yä¼šåœ¨åŒä¸€æ¡é“¾é‡Œã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å…ˆæŠŠxå˜æˆåŸæ ‘çš„æ ¹èŠ‚ç‚¹(è¿™ä¸‹å­Access(y)å°±ä¼šå°†xåˆ°yä¹‹é—´çš„æ‰€æœ‰èŠ‚ç‚¹ä¸¢åˆ°ä¸€ä¸ª Splay ä¸­äº†)ã€‚ inline void split(int x,int y){ makeroot(x);Access(y);Splay(y); } connect(x,y): å°†xå’Œyæ‰€åœ¨åŸæ ‘åˆå¹¶èµ·æ¥ é¦–å…ˆå°†xç‚¹ä¸¢åˆ°åŸæ ‘çš„æ ¹ï¼Œç„¶åå»æ‰¾æ‰¾yçš„æ ¹æ˜¯ä¸æ˜¯xï¼Œå¦‚æœä¸æ˜¯è¯´æ˜x,yä¸åœ¨ä¸€ä¸ªåŸæ ‘å†…ï¼Œæˆ‘ä»¬å°†xçš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºyï¼Œä¹Ÿå°±ç›¸å½“äºä»yåˆ°xè¿äº†ä¸€æ¡è™šè¾¹ã€‚ inline void connect(int x,int y){ makeroot(x);//è½¬åˆ°æ ¹ if(findroot(y)!=x)fa[x]=y;//è¿æ¥ä¸€æ¡è™šè¾¹ / erase(x,y): é¦–å…ˆæˆ‘ä»¬å…ˆæŠŠx,yä¹‹é—´çš„é‚£æ¡è¾¹ç”¨split(x,y)æ‹å‡ºæ¥ï¼Œå› ä¸ºx,yæ˜¯ç›¸é‚»çš„ï¼Œæ‰€ä»¥yçš„å·¦å„¿å­ä¸€å®šæ˜¯xï¼Œå°†å®ƒä»¬çš„çˆ¶å­å…³ç³»æ¶ˆç­æ‰å³å¯ã€‚ æ¶ˆç­çˆ¶å­å…³ç³»æ—¶ä¸€å®šæ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼š 1.xå’Œyåœ¨ä¸€ä¸ªåŸæ ‘é‡Œ(ä¸åœ¨ä¸€ä¸ªæ ‘é‡Œé¢å¾€å“ªå„¿åˆ‡å•Š) 2.splitä¹‹åxæ˜¯yçš„å·¦å„¿å­ 3.xçš„å³å„¿å­æ˜¯ç©ºçš„(ä¿è¯äº†ä¸­åºéå†ä¸­yç´§è·Ÿåœ¨xçš„åé¢ï¼Œå³æ·±åº¦ç›¸é‚»)(xçš„æƒå€¼(æ·±åº¦)åªæ¯”yå°1ï¼Œè€Œxåˆæ­£å¥½æ˜¯ç›´æ¥è¿ç€yçš„ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— æ³•å†æ‰¾åˆ° &gt;x è€Œåˆ &lt;y çš„æ•´æ•°äº†) inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1] fa[x]=ch[y][0]=0; }return; } ä½†æ˜¯å¦‚æœæˆ‘ä»¬åœ¨findrootä¸­æ·»åŠ äº†Splayçš„è¯ï¼Œeraseä¸­xå’Œyçš„çˆ¶å­å…³ç³»å°±å˜äº†ï¼Œéœ€è¦æ”¹ä¸ºè¿™æ ·ï¼Œå¦åˆ™ä¼šå‡ºç°ä¸€äº›å¥‡å¥‡æ€ªæ€ªçš„é”™è¯¯ï¼š inline void erase(int x,int y){ split(x,y); if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;! fa[y]=ch[x][1]=0;pushup(x); de> 0X03 Splayçš„æ”¹åŠ¨ï¼š æ—‹è½¬çš„æ”¹åŠ¨ï¼š è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸‹ï¼Œå¦‚æœxçš„çˆ¶äº²èŠ‚ç‚¹çš„çˆ¶äº²èŠ‚ç‚¹yå·²ç»ä¸åœ¨å½“å‰çš„è¿™æ£µè¾…åŠ©æ ‘ä¸Šï¼Œåªéœ€è¦è¿å•å‘è¾¹(ä¹Ÿå°±æ˜¯è™šè¾¹ï¼Œè®¤çˆ¶ä¸è®¤å­)ï¼Œå¦åˆ™æ­£å¸¸è¿å°±è¡Œï¼Œè¿™é‡Œè¦å’Œæ™®é€šçš„rotateåŒºåˆ†å¼€æ¥ã€‚ åšä¸ªå¯¹æ¯”ï¼š ç°åœ¨çš„rotate(x): è¿™é‡Œçš„xå¯ä»¥ä¸æ›´æ–°ï¼Œå› ä¸ºä¼šåœ¨ä¸‹ä¸€æ¬¡rotateæ—¶æ›´æ–°ã€‚ inline void rotate(int x){ int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; x;ch[x][!k]=y,ch[y][k]=v; if(v)fa[v]=y;fa[y]=x,fa[x]=z;pushup(y); } Splayçš„æ”¹åŠ¨ åŒæ ·è¦æ³¨æ„ä¸€ä¸‹åªèƒ½Splayåˆ°è¾…åŠ©æ ‘çš„æ ¹èŠ‚ç‚¹ï¼ŒSplayä¹‹å‰éœ€å…ˆä¸‹ä¼ ä¸€ä¸‹è¿™ä¸€æ¡é“¾ä¸Šéœ€æ“ä½œçš„æ‰€æœ‰çš„ç‚¹ï¼Œç”¨æ ˆæ¥å®Œæˆå³å¯ inline void Splay(int x){ int y=x,top=0;hep[++top]=y; while(get(y))hep[++top]=y=fa[y]; while(top)pushdown( while(get(x)){//åŸºæœ¬æ™®é€šçš„Splay y=fa[x],top=fa[y]; rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y); rotate(x); }pushup(x);return; } æœ€åæ”¾ä¸€ä¸‹æ¨¡æ¿é¢˜ä»£ç  #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;stack&gt; using namespace std; const int SIZE = 3e5 + 5; struct ReadNode { template &lt; typename T&gt; void operator &gt;&gt; (T &amp;a) { a = 0; T f = 1; char ch; while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1; while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar(); a *= f; } template &lt; typename T&gt; void write(T x) { if (x &lt; 0) x = -x, putchar(&#39;-&#39;); if (x &gt; 9) write(x / 10); putchar(x % 10 + &#39;0&#39;); } template &lt; typename T&gt; void operator &lt;&lt; (T x) { write(x); } } win; int n, q, dis[SIZE]; /******************LinkCutTree******************/ class LinkCutTree { private: struct TreeNode { int ch[2]; int val; int sum; int rev; int fa; } T[SIZE + 5]; int st[SIZE + 5]; inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; } inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; } inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; } inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; } inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); } inline void makeroot(int x) { access(x); splay(x); reverse(x); } inline void split(int x, int y) { makeroot(x); access(y); splay(y); } inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); } inline bool which(int x) { return T[T[x].fa].ch[1] == x; } inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); } inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); } inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); } inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; } public: inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; } inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); } inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); } inline void insert(int x, int v) { splay(x), T[x].val = v; } inline int find(int x, int y) { return split(x, y), T[y].sum; } } lct_mast; /*****************EndLinkCutTree*****************/ signed main() { win &gt;&gt; n; win &gt;&gt; q; for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i]; lct_mast.init(n, dis); for (int i = 1; i &lt;= q; ++i) { int opt, x, y; win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y; switch(opt) { case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break; case 1: lct_mast.connect(x, y); break; case 2: lct_mast.erase(x, y); break; case 3: lct_mast.insert(x, y); break; } } return 0; }","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---è«é˜Ÿ","slug":"DS100P-MO-ALGORITHM","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.128Z","comments":true,"path":"2020/02/07/DS100P-MO-ALGORITHM/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-MO-ALGORITHM/","excerpt":"","text":"è«é˜Ÿ($n\\sqrt{n}$) 0x01è€ƒè™‘è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼š å¯¹äºä¸€ä¸ªåºåˆ—$A_1,A_2,\\cdots,A_n$ï¼Œæœ‰å¦‚ä¸‹è¯¢é—® å½¢å¦‚$S\\ \\ l\\ \\ r$çš„å‘½ä»¤è¡¨ç¤ºå¯¹åŒºé—´$[l,r]$æ±‚å’Œï¼Œå¹¶è¾“å‡º å½¢å¦‚$Q\\ \\ l\\ \\ r$è¡¨ç¤º$\\cdots$ æœ¬é¢˜ä¸å¼ºåˆ¶åœ¨çº¿ å¯¹äºè¿™æ ·çš„é™æ€é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥è€ƒè™‘ç”¨è«é˜Ÿæ¥è§£å†³ã€‚æ®è¯´è«é˜Ÿæ”¯æŒä¿®æ”¹ä½†æˆ‘å¤ªå¼±ä¸ä¼š ç°åœ¨ä½ æœ‰åŒºé—´$[3,5]$çš„å’Œï¼Œå¯ä»¥æ±‚$[3,6]$çš„åŒºé—´å’Œå—ï¼Ÿæ˜¾ç„¶ï¼Œå°†$[3,5]$çš„åŒºé—´å’ŒåŠ ä¸Š$A_6$å³å¯ã€‚ç±»ä¼¼çš„ï¼Œæ±‚$[2,4]$çš„åŒºé—´å’Œï¼Œæˆ‘ä»¬åªéœ€å‡å»$A_5$å³å¯ã€‚ å¯ä»¥ç»“åˆä¸‹å›¾æ„ŸçŸ¥ä¸€ä¸‹ 0x02å¥½ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬æƒ³ä¸€ä¸‹å¦‚ä½•ç»´æŠ¤è¿™ç§è¯¢é—®ä¹‹é—´çš„å…³ç³»ã€‚ å¾ˆå®¹æ˜“æƒ³åˆ°æ’åºï¼Œé¦–å…ˆæˆ‘ä»¬å¯¹è¯¢é—®çš„å·¦ç«¯ç‚¹è¿›è¡Œæ’åºã€‚å†æŠŠæ•´ä¸ªè¯¢é—®åºåˆ—åˆ†ä¸º$\\sqrt{n}$å—ï¼Œæ¯å—ä»¥å†…å†æŒ‰å³ç«¯ç‚¹æ’åºã€‚ æ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¾—å‡ºä»¥ä¸‹ç»“è®ºï¼š è«é˜Ÿå°±æ˜¯å¯¹äºä¸€ç³»åˆ—çš„è¯¢é—®ï¼Œé€šè¿‡æ’åºå‡å°è¯¢é—®çš„ä¹‹é—´çš„å·®è·ï¼Œç„¶åä»¥è®¡ç®—è´¡çŒ®çš„æ–¹æ³•ç¦»çº¿çš„å¾—å‡ºç­”æ¡ˆ 0x03æ¥ä¸€é“ç®€å•çš„ä¾‹é¢˜ å°Bçš„è¯¢é—®å°B æœ‰ä¸€ä¸ªé•¿ä¸º $n$ çš„æ•´æ•°åºåˆ— $a$ï¼Œå€¼åŸŸä¸º $[1,k]$ã€‚ä»–ä¸€å…±æœ‰ $m$ ä¸ªè¯¢é—®ï¼Œæ¯ä¸ªè¯¢é—®ç»™å®šä¸€ä¸ªåŒºé—´ $[l,r]$ï¼Œæ±‚ï¼š å…¶ä¸­ $c_i$ è¡¨ç¤ºæ•°å­— $i$ åœ¨ $[l,r]$ ä¸­çš„å‡ºç°æ¬¡æ•°ã€‚å°Bè¯·ä½ å¸®åŠ©ä»–å›ç­”è¯¢é—® è¿™é“é¢˜è®©æˆ‘ä»¬æ±‚ \\sum\\limits_{i=1}^k c_i^2å¼€ä¸€ä¸ªæ¡¶ï¼Œè®¡ç®—æ¯ä¸ªæ•°å‡ºç°çš„æ¬¡æ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç”±æ­¤è®¡ç®—ç­”æ¡ˆçš„è´¡çŒ®ï¼Œå°±å¯ä»¥å†™å‡ºä»¥ä¸‹çš„ä»£ç  #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;cmath&gt; using namespace std; const int SIZE = 5e4 + 5; struct QueryNode { int l, r; int id; // å‚¨å­˜è¯¢é—®çš„é¡ºåºï¼Œæ–¹ä¾¿è¾“å‡º } Q[SIZE]; int a[SIZE], n, m, k, pos[SIZE]; int cnt[SIZE], ans[SIZE], res; // a:åŸåºåˆ— // pos:æ¯ä¸ªä½ç½®æ‰€å¤„çš„å— // cnt:æ¡¶ // ans:è¯¢é—®çš„ç­”æ¡ˆ // res:æ¯æ¬¡è°ƒæ•´æ‰€å¾—åˆ°çš„è´¡çŒ® inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); } inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; } signed main() { scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k); int block = sqrt(n); for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), pos[i] = i / block; for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; }); int l = 1, r = 0; for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); // è¿™å››å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (r &lt; Q[i].r) add(++r); // è¿™ä¸‰å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (l &lt; Q[i].l) del(l++); // è¿™äºŒå¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ while (r &gt; Q[i].r) del(r--); // è¿™ä¸€å¥éƒ½æ˜¯åœ¨å¯¹å½“å‰çš„åŒºé—´å¯¹äºè¯¢é—®çš„åŒºé—´è¿›è¡Œè°ƒæ•´ ans[Q[i].id] = res; } for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\\n&quot;, ans[i]); return 0; } 0x04å…¶å®è«é˜Ÿæ˜¯æœ‰å¥—è·¯çš„ï¼ŒåŸºæœ¬ä¸Šè«é˜Ÿçš„é¢˜éƒ½æ˜¯è¿™æ ·çš„: for (int i = 1; i &lt;= m; ++i) { while (l &gt; Q[i].l) add(--l); while (r &lt; Q[i].r) add(++r); while (l &lt; Q[i].l) del(l++); while (r &gt; Q[i].r) del(r--); ans[Q[i].id] = res; } æˆ‘ä»¬åªéœ€è€ƒè™‘$add$å‡½æ•°ä»¥åŠ$del$å‡½æ•°å³å¯","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---çº¿æ®µæ ‘","slug":"DS100P-SEGMENT-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.131Z","comments":true,"path":"2020/02/07/DS100P-SEGMENT-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SEGMENT-TREE/","excerpt":"","text":"çº¿æ®µæ ‘ â€”LYC(ZBing)($nlogn$) çº¿æ®µæ ‘ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯æ¯ä¸ªæ ‘çš„èŠ‚ç‚¹è®°å½•ä¸€æ¡çº¿æ®µä¸Šçš„ä¸€äº›ä¿¡æ¯ï¼Œéå¸¸çµæ´»ï¼Œå¯ä»¥å®ç°å¾ˆå¤šæ“ä½œï¼Œä½†å¸¸æ•°æ¯”æ ‘çŠ¶æ•°ç»„å¤§ä¸€ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š çº¿æ®µæ ‘çš„ç»å…¸åº”ç”¨å°±æ˜¯ç»Ÿè®¡åŒºé—´å’Œï¼Œæˆ‘ä»¬è¿™é‡Œä¹Ÿç”¨è¿™ä¸ªæ¥è¿›è¡Œçº¿æ®µæ ‘çš„è®²è§£ã€‚ 1).å»ºæ ‘æˆ‘ä»¬å…ˆæ”¾ä»£ç å§ï¼Œçœ‹ä»£ç ç†è§£ã€‚ void build(int l,int r,int x) { if(l==r) { nodes[x]=a[l]; return; } else { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,(x&lt;&lt;1)+1); nodes[x]=nodes[x&lt;&lt;1]+nodes[(x&lt;&lt;1)+1]; } } é¦–å…ˆï¼Œæˆ‘ä»¬éå†åˆ°çº¿æ®µæ ‘çš„æ¯ä¸€ä¸ªå¶å­èŠ‚ç‚¹ã€‚çº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½ä»£è¡¨äº†ä¸€ä¸ªåŒºé—´ï¼Œå½“è¿™ä¸ªåŒºé—´çš„$l=r$æ—¶ï¼Œè¯´æ˜æˆ‘ä»¬åˆ°è¾¾äº†å¶å­èŠ‚ç‚¹ã€‚è¿™ä¸ªå¶å­èŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´åªåŒ…å«äº†$a[l]$è¿™ä¸€ä¸ªæ•°ï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å°†è¿™ä¸ªèŠ‚ç‚¹çš„å€¼ç½®ä¸º$a[l]$ã€‚ ç„¶åæˆ‘ä»¬é€’å½’å›å»ï¼Œæ¯ä¸€ä¸ªéå¶å­èŠ‚ç‚¹éƒ½å¯ä»¥æŠŠå®ƒä»£è¡¨çš„åŒºé—´åˆ†æˆä¸¤åŠï¼Œå¯¹åº”å®ƒçš„ä¸¤ä¸ªå­èŠ‚ç‚¹ï¼ˆå¯èƒ½æ²¡æœ‰ä¸¤ä¸ªï¼‰ã€‚å®ƒä¸¤ä¸ªå­èŠ‚ç‚¹çš„å€¼å°±æ˜¯è¿™ä¸¤ä¸ªè¾ƒå°åŒºé—´çš„å…ƒç´ å’Œã€‚ç”±è¿™ä¸¤ä¸ªå­èŠ‚ç‚¹çš„å€¼ä¹Ÿå°±æ˜¯è¿™ä¸¤ä¸ªå°åŒºé—´çš„å…ƒç´ å’Œç›¸åŠ å°±å¯ä»¥å¾—åˆ°å½“å‰èŠ‚ç‚¹ä»£è¡¨åŒºé—´çš„å…ƒç´ å’Œã€‚ æ—¶é—´å¤æ‚åº¦($nlogn$) 2).å•ç‚¹ä¿®æ”¹åƒè¿™ç§åŒºé—´å’Œé—®é¢˜çš„å•ç‚¹ä¿®æ”¹ä¸€èˆ¬éƒ½æ˜¯ç»™ä¸€ä¸ªç‚¹åŠ ä¸Šä¸€ä¸ªå€¼ã€‚ è¿˜æ˜¯å…ˆæ”¾ä»£ç å§ï¼š void update(int l,int r,int x,int pos,int val) { nodes[x]-=val; if(l==r) return; int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) update(l,mid,x&lt;&lt;1,pos,val); else update(mid+1,r,(x&lt;&lt;1)+1,pos,val); } è¿˜æ˜¯å…ˆé€’å½’æ‰¾åˆ°è¦ä¿®æ”¹çš„å¶å­èŠ‚ç‚¹ã€‚å…ˆå°†å®ƒçš„å€¼åŠ ä¸Švalã€‚ ç„¶åå†é€’å½’å›å»ï¼Œå› ä¸ºå¾€ä¸‹æ‰¾æ—¶æ‰¾åˆ°çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´éƒ½åŒ…å«è¿™ä¸ªå¶å­èŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´ï¼Œæ‰€ä»¥è¿™äº›èŠ‚ç‚¹çš„å€¼ä¹Ÿè¦åŠ ä¸Švalã€‚ æ—¶é—´å¤æ‚åº¦($logn$) 3).åŒºé—´æŸ¥è¯¢åŒºé—´æŸ¥è¯¢çš„æœ¬è´¨å°±æ˜¯æŠŠè¦æŸ¥è¯¢çš„åŒºé—´æ‹†åˆ†æˆå¾ˆå¤šå°åŒºé—´ï¼Œç›´æ¥åˆ©ç”¨ä¹‹å‰ç»´æŠ¤çš„èŠ‚ç‚¹çš„å€¼è¿›è¡ŒæŸ¥è¯¢ã€‚ int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(l&gt;=fr||r&lt;=ba) return nodes[x]; int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } æˆ‘ä»¬å¯¹äºå½“å‰é€’å½’æŸ¥æ‰¾åˆ°çš„èŠ‚ç‚¹æ‰€ä»£è¡¨çš„åŒºé—´ä¸è¦æŸ¥è¯¢çš„åŒºé—´è¿›è¡Œåˆ†ç±»è®¨è®ºï¼š $1$&gt;.æ¯«æ— å…³è” å³å½“å‰åŒºé—´çš„å·¦ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´å³ç«¯ç‚¹çš„å³è¾¹æˆ–å½“å‰åŒºé—´çš„å³ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´å·¦ç«¯ç‚¹çš„å·¦è¾¹ã€‚ æ—¢ç„¶ä»–ä»¬æ¯«æ— å…³è”ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¿”å›ä¸€ä¸ªå€¼0ï¼Œå› ä¸ºä»–ä»¬å¯¹è¿™ä¸ªåŒºé—´çš„å’Œæ²¡æœ‰ä»»ä½•è´¡çŒ®ã€‚ $2$&gt;.è¢«åŒ…å« å³å½“å‰åŒºé—´çš„å·¦ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´çš„å·¦ç«¯ç‚¹çš„å³è¾¹ä¸”å½“å‰åŒºé—´çš„å³ç«¯ç‚¹åœ¨æŸ¥è¯¢åŒºé—´çš„å³ç«¯ç‚¹çš„å·¦è¾¹ã€‚ æ—¢ç„¶è¿™ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´å…¨éƒ¨å±äºæŸ¥è¯¢åŒºé—´å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±æ²¡æœ‰å¿…è¦å†ç»§ç»­é€’å½’ä¸‹å»äº†ï¼Œç›´æ¥æŠŠè¿™ä¸ªèŠ‚ç‚¹çš„å€¼åŠ ä¸Šå»ã€‚ $3$&gt;.æœ‰éƒ¨åˆ†é‡å ä½†ä¸è¢«åŒ…å« å³ä¸Šä¸¤ç§æƒ…å†µçš„å‰©ä½™æƒ…å†µã€‚ å¯¹äºè¿™ç§æƒ…å†µï¼Œæˆ‘ä»¬æ²¡æœ‰åŠæ³•æŠŠèŠ‚ç‚¹çš„å€¼ç›´æ¥åŠ ä¸Šå»ï¼Œå› ä¸ºè¿™ä¸ªèŠ‚ç‚¹ä»£è¡¨çš„åŒºé—´ä¸å…¨å±äºæŸ¥è¯¢åŒºé—´ã€‚ä¹Ÿä¸èƒ½ç›´æ¥è·³è¿‡ï¼Œå› ä¸ºæœ‰éƒ¨åˆ†èŠ‚ç‚¹å±äºæŸ¥è¯¢åŒºé—´ã€‚æ‰€ä»¥æˆ‘ä»¬ç»§ç»­å‘å®ƒçš„å­èŠ‚ç‚¹é€’å½’ï¼Œç›¸å½“äºæŠŠè¿™ä¸ªåŒºé—´åˆ†æˆä¸¤åŠï¼ŒæŸ¥è¯¢ä¸¤ä¸ªå­åŒºé—´ä¸­å±äºæŸ¥è¯¢åŒºé—´çš„å€¼åŠ èµ·æ¥ã€‚ æ—¶é—´å¤æ‚åº¦ï¼ˆ$logn$ï¼‰ 4).åŒºé—´ä¿®æ”¹é¢å¯¹åŒºé—´ä¿®æ”¹ï¼Œå¦‚æœæˆ‘ä»¬ç»§ç»­ç”¨å•ç‚¹ä¿®æ”¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¼šé€€å›åˆ°ï¼ˆ$n^2logn$ï¼‰ æ‰€ä»¥æˆ‘ä»¬å¼•å…¥äººç±»çš„æœ¬è´¨æ‡’æ ‡è®°ã€‚ å½“æˆ‘ä»¬æ‰¾åˆ°äº†ä¸€ä¸ªå®Œå…¨æ˜¯è¦ä¿®æ”¹çš„åŒºé—´ï¼Œæˆ‘ä»¬å°±ç›´æ¥æŠŠå®ƒçš„æ‡’æ ‡è®°åŠ ä¸Š$val$ã€‚ å¯¹äºä¸­é€”éå†åˆ°çš„å…¶ä»–åŒºé—´ï¼Œæˆ‘ä»¬ç›´æ¥è®¡ç®—ä¿®æ”¹è¿™ä¸ªåŒºé—´çš„å’Œã€‚ ä»£ç ï¼š void update(int l,int r,int x,int fr,int ba,int val) { if(l&gt;ba||r&lt;fr) return; if(l&gt;=fr&amp;&amp;r&lt;=ba) lazy[x]+=val; else { nodes[x]+=val*max(0,min(r,ba)-max(l,fr)+1); int mid=(l+r)&gt;&gt;1; update(l,mid,x&lt;&lt;1,fr,ba,val); update(mid+1,r,(x&lt;&lt;1)+1,fr,ba,val); } } é•¿å¾—å’ŒåŒºé—´æŸ¥è¯¢å¾ˆåƒå¯¹å§ æ”¹äº†ä¿®æ”¹ä¹‹åï¼Œæˆ‘ä»¬çš„æŸ¥è¯¢ä¹Ÿè¦è¿›è¡Œä¿®æ”¹ã€‚è¦æŠŠæ‰“ä¸Šçš„æ‡’æ ‡è®°è¿›è¡Œä¸‹ä¼ ï¼Œä¸ç„¶æŸ¥è¯¢åˆ°ä¸‹é¢çš„èŠ‚ç‚¹æ—¶ï¼Œä¸‹é¢çš„èŠ‚ç‚¹æ²¡æœ‰è¢«ä¿®æ”¹ã€‚ ä¸‹ä¼ æ—¶åªéœ€è¦è®©å½“å‰èŠ‚ç‚¹åŠ ä¸ŠåŸæ¥åº”åŠ è€Œæ‹–å»¶äº†çš„å€¼ï¼Œè®©å®ƒçš„å·¦å³å„¿å­çš„æ‡’æ ‡è®°åŠ ä¸Šå®ƒçš„æ‡’æ ‡è®°ã€‚å› ä¸ºå½“åˆä¿®æ”¹æ—¶ï¼Œå¹¶æ²¡æœ‰ä¿®æ”¹åˆ°å·¦å³èŠ‚ç‚¹ã€‚æœ€åå†æŠŠæ‡’æ ‡è®°æ¸…é›¶ã€‚ å°±åƒè¿™æ ·ï¼š void pushdown(int l,int r,int x) { nodes[x]+=(r-l+1)*lazy[x]; lazy[x&lt;&lt;1]+=lazy[x]; lazy[(x&lt;&lt;1)+1]+=lazy[x]; lazy[x]=0; } int find(int l,int r,int x,int fr,int ba) { if(l&gt;ba||r&lt;fr) return 0; if(lazy[x]) pushdown(l,r,x); if(l&gt;=fr&amp;&amp;r&lt;=ba) return nodes[x]; else { int mid=(l+r)&gt;&gt;1; return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba); } } $\\ $ çº¿æ®µæ ‘çš„è®²è§£åˆ°è¿™é‡Œå°±è¿™ä¹ˆå®Œäº†ï¼Œä½†çº¿æ®µæ ‘çš„è¿ç”¨ååˆ†å¹¿æ³›ï¼Œçµæ´»ã€‚è¦ç†Ÿç»ƒæŒæ¡å¹¶è¿ç”¨çº¿æ®µæ ‘ï¼Œè¿˜è¦å¤šåŠ¨è„‘ï¼Œæƒ³å¥½é¢˜ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---splay","slug":"DS100P-SPLAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.132Z","comments":true,"path":"2020/02/07/DS100P-SPLAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SPLAY/","excerpt":"","text":"update:å¢åŠ å‡ é“å¥½ä¸€ç‚¹çš„ä¾‹é¢˜å§ [NOI2004]éƒé—·çš„å‡ºçº³å‘˜ [æ¨¡æ¿]æ–‡è‰ºå¹³è¡¡æ ‘ [SHOI2013]å‘ç‰Œ [TJOI2010]ä¸­ä½æ•° [TJOI2007]ä¹¦æ¶ æ­£æ–‡ï¼šå…³äºSPLAYå…¶å®æˆ‘æ›´åå‘äºæŠŠsplayå«åšcosplay è®²å¹³è¡¡æ ‘æ€»é€ƒä¸è¿‡BST(Binary Search Tree)ï¼ŒäºŒå‰æœç´¢æ ‘ï¼Œä»¥ä¸‹æ˜¯BSTçš„æ€§è´¨ï¼š ä¸€æ£µåˆæ³•çš„BSTæ¯ä¸ªèŠ‚ç‚¹ä¸Šéƒ½å¸¦æœ‰ä¸€ä¸ªæ•°å€¼ï¼Œæˆ‘ä»¬å°†å…¶ç§°ä¸ºèŠ‚ç‚¹çš„â€œå…³é”®ç â€ã€‚é‚£ä¹ˆå¯¹äºä¸€æ£µBSTä¸Šçš„ä»»æ„èŠ‚ç‚¹ï¼Œæ»¡è¶³ï¼š è¯¥èŠ‚ç‚¹çš„å…³é”®ç ä¸å°äºå®ƒå·¦å­æ ‘çš„ä»»æ„ç»“ç‚¹çš„å…³é”®ç  è¯¥ç»“ç‚¹çš„å…³é”®ç ä¸å¤§äºå®ƒå³å­æ ‘çš„ä»»æ„ç»“ç‚¹çš„å…³é”®ç  æ˜¾ç„¶ï¼ŒBSTçš„ä¸­åºéå†æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ— å»ºç«‹ä¸€æ£µBSTå› ä¸ºç¬”è€…å¾ˆæ‡’ï¼Œä¸æƒ³åˆ°å¤„åˆ¤è¾¹ç•Œï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸€èˆ¬å¯ä»¥åœ¨ä¸€æ£µç©ºçš„BSTä¸­é¢„å…ˆæ’å…¥ä¸¤ä¸ªç»“ç‚¹ï¼Œä¸€ä¸ªæ­£æ— ç©·ï¼Œä¸€ä¸ªè´Ÿæ— ç©·ï¼Œå¦‚å›¾: const int SIZE = 1e5 + 5; const int INF = 0x7fffffff; struct BSTNode { int l, r; // å·¦å³å„¿å­çš„ç¼–å· int val; // å…³é”®ç  } T[SIZE]; int tot, root; int clone(int val) { // æ–°å»ºèŠ‚ç‚¹ T[++tot].val = val; return tot; } void build() { clone(-INF), clone(INF); root = 1, T[1].r = 2; } ä»¥ä¸Šæ˜¯å»ºæ ‘çš„ä»£ç  é‚£ä¹ˆï¼ŒBSTå°±è®²åˆ°è¿™é‡Œ å¹³è¡¡æ ‘çš„è¯ç”Ÿå½“BSTå½¢æˆä¸€æ¡é“¾çš„æ—¶å€™ï¼Œæ¯æ¬¡æŸ¥è¯¢ä¼šå˜æˆ$O(n^2)$ è¿™ç§æ·±åº¦è¿‡æ·±çš„BSTæ˜¯ä¸å¹³è¡¡çš„ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä¸€ç§èƒ½ä¿æŒæ ‘çš„æ·±åº¦åœ¨$\\log(n)$çš„æ•°æ®ç»“æ„ï¼Œäºæ˜¯ä¾¿è¯ç”Ÿäº†å¹³è¡¡æ ‘ SPLAYsplayï¼Œåˆç§°cosplayä¼¸å±•æ ‘ï¼Œæœ‰â€œåºåˆ—ä¹‹ç‹â€çš„ç¾ç§°ï¼Œå¸¸æ•°å·¨å¤§ï¼Œè·‘çš„æ²¡æœ‰$fhq-treap$å¿«ï¼Œä½†è¿™ä¸åœ¨æˆ‘ä»¬çš„è®¨è®ºèŒƒå›´ä»¥å†… æƒ³è±¡ä¸€ä¸‹è¿™æ ·ä¸€é¢—BSTï¼Œæˆ‘ä»¬å…ˆæŠŠå®ƒä»¬çš„å¤§å°å…³ç³»åˆ—å‡ºæ¥ã€‚ YY, X","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ•°ç»„","slug":"DS100P-SUFFIX-ARRAY","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.134Z","comments":true,"path":"2020/02/07/DS100P-SUFFIX-ARRAY/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-ARRAY/","excerpt":"","text":"åç¼€æ•°ç»„0x01 ä»€ä¹ˆæ˜¯åç¼€æ•°ç»„(Suffix Array)æˆ‘ä»¬çŸ¥é“ï¼Œå¯¹äºä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„å­—ç¬¦ä¸²æœ‰ $n$ ä¸ªåç¼€ï¼Œè­¬å¦‚å¯¹äºå­—ç¬¦ä¸² $DCBAE$ æ¥è¯´ï¼Œå®ƒçš„åç¼€ä¾¿æ˜¯: é‚£ä¹ˆä»€ä¹ˆæ˜¯åç¼€æ•°ç»„( $SA$ )å‘¢ï¼Ÿåœ¨æˆ‘ä»¬å¯¹å­—ç¬¦ä¸²çš„ $n$ ä¸ªåç¼€æ’åºè¿‡åï¼Œæˆ‘ä»¬å®šä¹‰åç¼€æ•°ç»„ï¼š $SA$ æ•°ç»„ï¼šæ’åœ¨ç¬¬iä½çš„æ˜¯ç¬¬ $SA$ [i]ä¸ªåç¼€ å³åç¼€æ•°ç»„ã€‚ åŒæ—¶æˆ‘ä»¬å®šä¹‰ï¼š RANKæ•°ç»„ï¼šæ’åœ¨ç¬¬RANK[i]ä½çš„åç¼€æ˜¯ç¬¬iä¸ªåç¼€ ä¸éš¾çœ‹å‡ºRANKå’Œ $SA$ äº’é€† 0x02 å¦‚ä½•æ±‚å‡º $SA$ æ•°ç»„(ç²—ç•¥çš„)æœ´ç´ çš„åšæ³•æ˜¯ç›´æ¥$sort$ï¼Œ$\\Theta(n^2\\log n)$ çˆ¹å¦ˆæ¨é“ä¸æˆé’¢ã€‚ ç¨å¾®æœ‰ç‚¹è„‘å­éƒ½ä¼šæƒ³åˆ°$hash$ä½†æ˜¯ä¾ç„¶çˆ†ç‚¸ã€‚ å¦‚æœæ·±å…¥æ€è€ƒçš„è¯å¾ˆå®¹æ˜“æƒ³åˆ°å€å¢ï¼Œæ—¶é—´å¤æ‚åº¦ $\\Theta(n\\log n)$ + å¤§å¸¸æ•°ç¢°ä¸Šæ¯’ç˜¤é¢˜å½“åœºå»ä¸–ã€‚ $DC3$ï¼Ÿå¸¸æ•°å¤§ï¼Œæ¿å­éš¾èƒŒã€‚ $LUOGU$ æ—¥æŠ¥æ›¾ç»æœ‰è¿‡ä¸€ç‰‡æ—¥æŠ¥ç»™å‡ºäº†ä¸€ç§è¯±å¯¼æ’åºçš„è§£å†³æ–¹æ³•ï¼Œä½†æ˜¯æˆ‘ä¸æ˜¯å¾ˆç†è§£ã€‚ æˆ‘åœ¨è¿™é‡Œç»™å‡ºä¸€ç§ä¸­æ–‡äº’è”ç½‘ä¸Šå‡ ä¹æ²¡æœ‰ä»»ä½•èµ„æ–™çš„ $SA$ æ•°ç»„çº¿æ€§æ—¶é—´å¤æ‚åº¦æ„é€ æ–¹æ³•(æˆ‘ä¹Ÿä¸çŸ¥é“å«ä»€ä¹ˆåå­—)ã€‚ 0x03 å¦‚ä½•æ±‚å‡º $SA$ æ•°ç»„(å…·ä½“çš„)é¦–å…ˆå®šä¹‰æ–‡æœ¬ä¸² $text$ ä¸ºæˆ‘ä»¬çš„å¾…æ±‚ $SA$ çš„å­—ç¬¦æ•°ç»„ å…¶æ¬¡å®šä¹‰ $suffix_i$ ä¸ºä»¥ $i$ èµ·å¤´çš„ $text$ çš„åç¼€ ç„¶åå®šä¹‰ $type_i = \\begin{cases}L, suffix_i &gt; suffix_{i+1} \\\\\\displaystyle S, suffix_i &lt; suffix_{i+1}\\end{cases}$ å‚è€ƒå›¾ç‰‡(æ‰‹å†™å­—å¯èƒ½æœ‰äº›çœ‹ä¸æ¸…æ¥š)ï¼š å­—ç¬¦ä¸²æœ€åçš„æ˜¯ä»€ä¹ˆï¼Ÿä½ å¯ä»¥è®¤ä¸ºè¿™æ˜¯å› ä¸ºä½œè€…æ‡’ä¸æƒ³åˆ°å¤„åˆ¤è¾¹ç•Œè€ŒåŠ ä¸Šçš„æ¯”å­—ç¬¦ä¸²ä¸­ä»»æ„ä¸€ä¸ªå­—ç¬¦çš„ASCLLç éƒ½å°çš„å­—ç¬¦ å†æ¥å®šä¹‰ $dist_i$ ä¸º $text_i$ è·ç¦»ä¸Šä¸€ä¸ª $type_i$ ä¸º $S$ çš„è·ç¦» å‚è€ƒå›¾ç‰‡(æ‰‹å†™å­—å¯èƒ½æœ‰äº›çœ‹ä¸æ¸…æ¥š)ï¼š å†å®šä¹‰ä¸€ä¸ªæ¡¶ $bucket$ï¼Œä»¥ $text$ ä¸­çš„å­—ç¬¦ä¸ºåŒºåˆ«æ¡¶ä¹‹é—´çš„â€œé”®å€¼â€ã€‚ä¾ç„¶å‚è€ƒå›¾ç‰‡ æˆ‘ä»¬å…¶å®å¯ä»¥å‘ç°æ­¤æ—¶çš„ $bucket$ å·²ç»å’Œæˆ‘ä»¬è¦æ±‚çš„ $SA$ å·®çš„ä¸è¿œäº†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæ¡¶æ’å•Šï¼æ­¤æ—¶çš„æ¡¶å¤–éƒ¨å…¶å®å·²ç»æ˜¯æœ‰åºçš„äº†ï¼Œåªæ˜¯æˆ‘ä»¬å†…éƒ¨è¿˜æ— æ³•ç¡®å®šé¡ºåºã€‚æ¯”å¦‚ $I$ è¿™ä¸ªæ¡¶é‡Œï¼Œæˆ‘ä»¬æ— æ³•ç¡®å®š $suffix_{2},suffix_{5},suffix_{8},suffix_{11}$ çš„æ’åºé¡ºåºï¼Œå› ä¸ºä»–ä»¬å¼€å¤´çš„é¦–å­—æ¯ä¸åŒã€‚é‚£è¯¥æ€ä¹ˆåŠå‘¢ï¼Ÿè¯·ç»§ç»­å¾€ä¸‹çœ‹ã€‚ æˆ‘ä»¬å†å®šä¹‰ä¸€ä¸ªæ¡¶ $D_lists$ â€œé”®å€¼â€ ä¸º $list_i$ã€‚å‚è€ƒå›¾ç‰‡(æ³¨æ„æ­¤æ—¶æˆ‘ä»¬ä¸è€ƒè™‘é”®å€¼(å³ $dist$ )ä¸º0çš„æƒ…å†µ) ä»¥é”®å€¼ä¸º1ä¸¾ä¸€ä¸ªä¾‹å­ã€‚å®ƒçš„æ„æ€å°±æ˜¯è¯´ $dist$ ä¸º1çš„æƒ…å†µæœ‰ $suffix_{9},suffix_{3,6}$ è¿™ä¸‰ç§æƒ…å†µã€‚ä¸ $bucket$ è¿™ä¸ªæ¡¶ç±»ä¼¼ä½†ä¸åŒçš„ï¼Œæˆ‘ä»¬èƒ½åˆ†æ¸… $suffix_9$ å’Œ $sufiix_{3,6}$ çš„é¡ºåºï¼Œä½†æˆ‘ä»¬æ— æ³•åˆ†æ¸… $suffix_3$ å’Œ $suffix_6$ çš„é¡ºåºã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿæˆ‘ä»¬æ¥çœ‹ï¼Œä¸‹æ ‡ä¸º9çš„åç¼€æ˜¯ä»¥ $P$ å¼€å¤´çš„ï¼Œç„¶è€Œä¸‹æ ‡ä¸º3å’Œ6çš„åç¼€å´éƒ½æ˜¯ä»¥ $S$ å¼€å¤´çš„ï¼Œæ‰€ä»¥ $suffix_9$ ä¸€å®šæ’åœ¨ $suffix_{3,6}$ çš„å‰é¢ã€‚$suffix_{3,6}$ å´å› ä¸ºé¦–å­—æ¯ç›¸åŒæ‰€ä»¥æ— æ³•åˆ†æ¸…æ¥šé¡ºåºã€‚ ä¸‹ä¸€æ­¥æˆ‘ä»¬å°è¯•å°†æ‰€æœ‰ $type$ ä¸º $S$ çš„ $suffix$ æ‰¾å‡ºæ¥ æˆ‘ä»¬æŠŠ $bucket$ æ‰«ä¸€éï¼Œå³å¯å¾—å‡ºï¼š å›¾ä¸­çš„ $S-Substring$ å³ä¸ºæˆ‘ä»¬æ‰€æ±‚çš„æ‰€æœ‰ $type$ ä¸º $S$ çš„ $suffix$ã€‚ åŒæ ·ï¼Œæˆ‘ä»¬ä¸çŸ¥é“ $suffix_{2,5,8}$ å“ªä¸ªåœ¨å‰å“ªä¸ªåœ¨åã€‚ä¸€ç§ $naive$ çš„åšæ³•å°±æ˜¯æŠŠ $[2,5,8]$ ä¾æ¬¡+1ï¼Œç›¸å½“äºç›´æ¥æš´åŠ›æ¯”è¾ƒä¸‹ä¸€ä¸ªå­—æ¯ï¼Œç„¶åé€šè¿‡ $D_lists$ æ¥åˆ†æå®ƒä»¬çš„å…ˆåå…³ç³»ã€‚ æˆ‘ä»¬å‘ç°äº†ä¸€ä¸ªæ‚²å‰§çš„äº‹å®ï¼šå·²ç»åŠ åˆ°3äº†ï¼Œæˆ‘ä»¬å´ä¾ç„¶æ— æ³•åˆ†æ¸… $[2,5]$ çš„é¡ºåºã€‚å¦‚æœç»§ç»­åŠ ä¸‹å»æˆ–è®¸å¯ä»¥åˆ†æ¸…å®ƒä»¬çš„é¡ºåºï¼Œä½†æ—¶é—´å¤æ‚åº¦å°±éš¾ä»¥ä¿æŒåœ¨ $\\Theta(n)$ï¼Œæ¢å¥è¯è¯´ï¼Œå®ƒå¾ˆå®¹æ˜“è¢«å¡ã€‚ æ€ä¹ˆåŠå‘¢ï¼Ÿæˆ‘ä»¬åˆ†æä¸€ä¸‹è¿™ç§æƒ…å†µå‡ºç°çš„åŸå› ã€‚ æ˜¾ç„¶æ­¤æ—¶ä¸¤ä¸ªåç¼€çš„éƒ¨åˆ†å‰ç¼€æ˜¯ç›¸åŒçš„ã€‚å³ä¸‹å›¾çš„æƒ…å†µï¼š","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘é“¾å‰–åˆ†","slug":"DS100P-TREE-CHAIN-SPLITTING","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.136Z","comments":true,"path":"2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-CHAIN-SPLITTING/","excerpt":"","text":"æ ‘é“¾å‰–åˆ†($nlogn$) æ ‘é“¾å‰–åˆ†å‡†ç¡®åœ°è¯´å¹¶ä¸æ˜¯æ•°æ®ç»“æ„ï¼Œå®ƒåªæ˜¯æ•°æ®ç»“æ„çš„ä¸€ç§åº”ç”¨ã€‚ å®ƒç”¨äºå°†ä¸€æ£µæ ‘ä¸Šçš„èŠ‚ç‚¹è½¬æ¢åˆ°ä¸€ä¸ªåºåˆ—ä¸­ï¼Œç„¶åç”¨å„ç§æ•°æ®ç»“æ„ç»´æŠ¤ã€‚ æ‰€ä»¥æˆ‘åªè®²å¦‚ä½•è½¬æ¢å’Œä½¿ç”¨ï¼Œè€Œç»´æŠ¤å°±å› é¢˜è€Œå¼‚äº†ã€‚ æ ‘é“¾å‰–åˆ†æœ‰å¥½å‡ ç§æ–¹æ³•ï¼šé‡é“¾å‰–åˆ†ï¼Œé•¿é“¾å‰–åˆ†â€¦ ä½†æˆ‘å°±è®²æœ€å¸¸ç”¨çš„é‡é“¾å‰–åˆ†ã€‚ é‡é“¾å‰–åˆ†ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯æŒ‰ç…§èŠ‚ç‚¹çš„å­æ ‘å¤§å°æ¥å‰–åˆ†è¿™æ£µæ ‘ã€‚ ä¸€ä¸ªèŠ‚ç‚¹å­èŠ‚ç‚¹ä¸­å­æ ‘å¤§å°æœ€å¤§çš„å­èŠ‚ç‚¹å«åšè¿™ä¸ªèŠ‚ç‚¹çš„é‡å„¿å­ã€‚ ä»¥ä¸€ä¸ªè½»å„¿å­ä¸ºèµ·ç‚¹ï¼Œå…¶ä½™å…¨æ˜¯é‡å„¿å­çš„é“¾å«åšé‡é“¾ã€‚ é‡é“¾ä¸Šçš„è¾¹å«åšé‡è¾¹ã€‚ å°±åƒè¿™æ ·ï¼ˆçº¢è‰²çš„è¾¹ä¸ºé‡è¾¹ï¼‰ å¯ä»¥å‘ç°ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½åœ¨ä¸”ä»…åœ¨ä¸€æ¡é‡é“¾ä¸Šï¼Œæˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™ä¸€æ¡é“¾è½¬æ¢åˆ°ä¸€ä¸ªè¿ç»­çš„åŒºé—´æ¥è¿›è¡Œç»´æŠ¤ã€‚ dfs1æˆ‘ä»¬é‡‡ç”¨dfsçš„å½¢å¼æ¥è¿›è¡Œå‰–åˆ†ï¼Œè®°å½•ä¿¡æ¯ã€‚ ç¬¬ä¸€æ¬¡dfsæˆ‘ä»¬éœ€è¦è®°å½•æ¯ä¸ªèŠ‚ç‚¹çš„çˆ¶äº²ï¼Œå­æ ‘å¤§å°ï¼Œé‡å„¿å­å’Œæ·±åº¦ã€‚ å¾ˆç®€å•å¯¹å§ï¼Œå°±æ˜¯æš´åŠ›$dfs$ï¼Œä½†è¦æ³¨æ„ä¸è¦æœå›åˆ°çˆ¶äº²èŠ‚ç‚¹å’Œä¸€äº›å…¶ä»–çš„å‘ã€‚ ä»£ç ï¼š void dfs1(int x,int last) { fa[x]=last;//è®°å½•çˆ¶äº²èŠ‚ç‚¹ã€‚ sum[x]=1;//åˆå§‹åŒ–å­æ ‘å¤§å°ï¼šè¯¥èŠ‚ç‚¹æœ¬èº«ã€‚ depth[x]=depth[last]+1;//æ·±åº¦ï¼šçˆ¶äº²èŠ‚ç‚¹æ·±åº¦+1ã€‚ int big=0,bi=0;//å¯»æ‰¾é‡å„¿å­ for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^last)//é¿å…é‡æ–°å›åˆ°çˆ¶äº²èŠ‚ç‚¹ { dfs1(e[x][i],x); sum[x]+=sum[e[x][i]]; if(sum[e[x][i]]&gt;big) { big=sum[e[x][i]]; bi=e[x][i]; } } } son[x]=bi;//è®°å½•é‡å„¿å­ã€‚ } //è°ƒç”¨:dfs(root,root) dfs2ç»è¿‡åˆšåˆš$dfs1$çš„å‡†å¤‡ï¼Œæˆ‘ä»¬å¯ä»¥è¿›è¡Œå‰–åˆ†äº†ï¼Œè¿™æ¬¡è®°å½•$dfs$åºï¼Œè½¬æ¢å‡ºçš„åºåˆ—ä¸Šçš„æ¯ä¸€ä¸ªå€¼ï¼Œä»¥åŠæ¯ä¸ªèŠ‚ç‚¹æ‰€åœ¨é‡é“¾çš„èµ·ç‚¹ã€‚ æˆ‘ä»¬åœ¨è¿™æ¬¡$dfs$æ—¶åº”è¯¥ä¼˜å…ˆèµ°é‡å„¿å­ï¼Œè¿™æ ·æ‰èƒ½ä½¿ä¸€æ¡é‡é“¾ä¸Šçš„å€¼éƒ½åœ¨åºåˆ—ä¸Šè¿åœ¨ä¸€èµ·ï¼Œæ–¹ä¾¿æˆ‘ä»¬æ“ä½œã€‚ ä»£ç : void dfs2(int x,int last,bool heavier) { dfn[x]=++tot;//è®°å½•dfsåº turn[tot]=val[x];//è®°å½•åºåˆ— if(heavier) hb[x]=hb[fa[x]];// else hb[x]=x;//è®°å½•æ‰€åœ¨é‡é“¾èµ·ç‚¹ if(b[x].son) build2(b[x].son,1);//ä¼˜å…ˆéå†é‡å„¿å­ for(int i=0;i&lt;e[x].size();++i) { if(e[x][i]^son[x]&amp;&amp;e[x][i]^fa[x]) build2(e[x][i],0);//é¿å…é‡å¤éå† } } ä¸€ä¸ªèŠ‚ç‚¹çš„$dfs$åºå°±æ˜¯å®ƒåœ¨åºåˆ—ä¸­çš„ä½ç½®ã€‚å¯¹å§ ä½¿ç”¨å¯¹äºä¸€äº›å­æ ‘ä¸Šçš„æ“ä½œï¼Œ$dfs$åºå·²ç»èƒ½å¤Ÿæå®šäº†ï¼Œæˆ‘ä»¬åªéœ€è¦ç”¨å‰–å‡ºçš„é‡é“¾å¯¹é‚£äº›ç»“ç‚¹é—´è·¯å¾„çš„æ“ä½œè¿›è¡Œåº”å¯¹å°±å¥½äº†ã€‚ å¯¹äºä¸¤ä¸ªèŠ‚ç‚¹é—´çš„è·¯å¾„ï¼Œæˆ‘ä»¬å¾ˆå®¹æ˜“æƒ³åˆ°$LCA$ã€‚è€Œæˆ‘ä»¬è®°å½•äº†é‡é“¾çš„èµ·ç‚¹ï¼Œå¯ä»¥å¤„ç†è¿™æ¡é‡é“¾ï¼Œç„¶åç›´æ¥è·³åˆ°ä¸Šé¢ä¸€æ¡é‡é“¾çš„æœ«ç«¯ã€‚ æ³¨æ„å½“ä¸¤ä¸ªèŠ‚ç‚¹åœ¨åŒä¸€æ¡é‡é“¾æ—¶è·³å‡ºå¾ªç¯ï¼Œåœ¨æœ€åå¤„ç†ä»–ä»¬ä¹‹é—´çš„è·¯å¾„ã€‚ ç”±äºä»–ä»¬å·²ç»åœ¨åŒä¸€æ¡é‡é“¾ä¸Šäº†ï¼Œä»–ä»¬åŠä»–ä»¬ä¹‹é—´çš„èŠ‚ç‚¹$dfs$åºæ˜¯è¿ç»­çš„ï¼Œæ‰€ä»¥å†å¤„ç†è¿™ä¸ªè¿ç»­åŒºé—´å°±å¥½äº†ã€‚ ä»£ç ï¼š //è®¾solve(x,y)æ˜¯å¯¹xåˆ°yåŒºé—´çš„æ“ä½œ(å› é¢˜è€Œå¼‚) ___ LCA(int x,int y) { int fx=hb[x],fy=hb[y];//å¾—åˆ°é‡é“¾èµ·ç‚¹ while(fx^fy) { if(depth[fx]&lt;depth[fy])//ä»æ·±åº¦å¤§çš„å¾€ä¸Šè·³ { swap(fx,fy); swap(x,y); } solve(dfn[fx],dfn[x]);//å¤„ç†è¿™æ¡é‡é“¾çš„åŒºé—´ x=fa[fx];//è·³åˆ°ä¸Šé¢ä¸€æ¡é‡é“¾ fx=hb[x];//æ›´æ–°é‡é“¾èµ·ç‚¹ } solve(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));//æœ€åå¤„ç†åŒä¸€æ¡é‡é“¾ä¸Šçš„å‰©ä½™æœªå¤„ç†éƒ¨åˆ†ã€‚ //return ans; } 5.ä¸»å¸­æ ‘($nlogn$) â€œä½ æ˜¯ä¸»å¸­æ ‘å—ï¼Ÿæœ‰é‚£ä¹ˆå¤šçˆ·çˆ·ï¼â€â€”â€”$LJS$ã€‚ è¿™å¥è¯è¿ç”¨æ‰“æ¯”æ–¹çš„è¯´æ˜æ–¹æ³•ï¼Œç”ŸåŠ¨å½¢è±¡åœ°è¯´æ˜äº†ä¸»å¸­æ ‘æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½æœ‰å¾ˆå¤šçˆ¶äº²çš„ç‰¹ç‚¹ï¼Œä½“ç°è¯´æ˜è¯­è¨€çš„ç”ŸåŠ¨æ€§ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸»å¸­æ ‘çš„å‡ ä¸ªèŠ‚ç‚¹å¯èƒ½å…±ç”¨ä¸€ä¸ªå­èŠ‚ç‚¹ã€‚ å°±åƒè¿™æ ·ï¼š ä¸»å¸­æ ‘å¯ä»¥ç”¨æ¥æŸ¥è¯¢é™æ€åŒºé—´ç¬¬kå°ï¼Œé™æ€åŒºé—´å‰kå¤§çš„å’Œç­‰ç­‰ã€‚ï¼ˆç”¨æ³•ååˆ†çµæ´»ï¼‰ æˆ‘ä»¬ä¼šåˆ›å»ºå¾ˆå¤šç‰ˆæœ¬çš„æ ‘ï¼Œä¸€äº›ç‰ˆæœ¬ä¼šå…±ç”¨ä¸€äº›èŠ‚ç‚¹ï¼Œä»¥èŠ‚çœç©ºé—´å’Œæ—¶é—´ã€‚ ä¸»å¸­æ ‘ä¹Ÿå«å¯æŒä¹…åŒ–çº¿æ®µæ ‘ã€‚ä½†å¯æŒä¹…åŒ–è¿˜æœ‰å¾ˆå¤šä¸œè¥¿ã€‚æˆ‘å°±è®²å¯æŒä¹…åŒ–çº¿æ®µæ ‘å§ã€‚ 1.å¦‚ä½•å…±ç”¨èŠ‚ç‚¹æˆ‘ä»¬è€ƒè™‘å•ç‚¹ä¿®æ”¹çš„çº¿æ®µæ ‘ã€‚ å¦‚æœè¦å¾—åˆ°è¿™ä¸ªåºåˆ—æŸä¸ªå…ƒç´ $x$åŠ ä¸Šä¸€ä¸ªå€¼$val$ä¹‹åçš„æ–°ç‰ˆæœ¬ï¼Œæˆ‘ä»¬å‘ç°ï¼Œæ”¹å˜çš„åªæœ‰å¯¹åº”å…ƒç´ $x$çš„èŠ‚ç‚¹å’Œä»–çš„ç¥–å…ˆä¼šåŠ ä¸Š$val$ã€‚é‚£ä¹ˆå…¶ä»–èŠ‚ç‚¹æˆ‘ä»¬å¯ä»¥ä¸ä¸Šä¸€ä¸ªç‰ˆæœ¬å…±ç”¨ã€‚ æ‰€ä»¥æˆ‘ä»¬æ¯æ¬¡æ–°å»ºä¸€ä¸ªèŠ‚ç‚¹ï¼Œç»§æ‰¿ä¹‹å‰è¯¥ä½ç½®çš„å€¼å’Œå·¦å³å„¿å­ï¼Œç„¶åæ›´æ–°å€¼ï¼Œå†ç»§ç»­å‘ä¸‹å¯»æ‰¾å…ƒç´ $x$çš„ä½ç½®ï¼Œæœ€åé€’å½’å›æ¥æ›´æ–°è¿™ä¸ªå„¿å­ã€‚ æˆ‘ä»¬ä½¿ç”¨$root$æ•°ç»„æ¥è®°å½•æ¯ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ç¼–å·ã€‚ ä»£ç ï¼š void ins(int l,int r,int pre,int &amp;now,int pos,int val)//åŒºé—´å·¦å³ç«¯ç‚¹ï¼Œä¸Šä¸€ä¸ªç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œå½“å‰ç‰ˆæœ¬ä¸­å¯¹åº”è¿™ä¸ªåŒºé—´çš„ç‚¹ï¼Œä¿®æ”¹ä½ç½®ï¼Œå¢åŠ çš„å€¼ã€‚ { nodes[++tot]=nodes[pre];//å…ˆæ•´ä¸ªå¤åˆ¶ now=tot;//æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å„¿å­ã€‚ nodes[now].sum+=val;//æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å€¼ if(l==r) return; //å‘ä¸‹ç»§ç»­å¯»æ‰¾ int mid=(l+r)&gt;&gt;1; if(pos&lt;=mid) ins(l,mid,nodes[pre].l,nodes[now].l,pos,val); else ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val); } //è°ƒç”¨ï¼šins(1,n,root[i-1],root[i],p,v); æœ€å$root[i]$çš„å¼•ç”¨å°±ç›¸å½“äºè®°å½•äº†è¿™ä¸ªç‰ˆæœ¬çš„æ ¹èŠ‚ç‚¹ã€‚ æŸ¥è¯¢å…¶å®å°±å’Œæ™®é€šçš„çº¿æ®µæ ‘ä¸€æ ·ï¼Œä½†ä¸»å¸­æ ‘çš„ç”¨é€”ä¸æ­¢è¿™ä¸ªã€‚ 2.ä¾‹é¢˜ã€æ¨¡æ¿ã€‘å¯æŒä¹…åŒ–çº¿æ®µæ ‘ 1ï¼ˆä¸»å¸­æ ‘ï¼‰ å¦‚é¢˜ï¼Œç»™å®š $n$ ä¸ªæ•´æ•°æ„æˆçš„åºåˆ—ï¼Œå°†å¯¹äºæŒ‡å®šçš„é—­åŒºé—´æŸ¥è¯¢å…¶åŒºé—´å†…çš„ç¬¬ $k$ å°å€¼ã€‚ æƒå€¼çº¿æ®µæ ‘ï¼š (çº¿æ®µæ ‘çš„å¦ä¸€ç§åº”ç”¨ï¼Œåªæ˜¯æ¯ä¸ªèŠ‚ç‚¹ç»´æŠ¤æ•´ä¸ªåºåˆ—å€¼åœ¨$[l,r]$åŒºé—´å†…çš„æ•°çš„ä¸ªæ•°) è¿™é“é¢˜è¦æ±‚æŸ¥è¯¢é™æ€åŒºé—´ç¬¬$k$å°ã€‚é‚£ä¹ˆå¯¹äºç¬¬$k$å°è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬è¦ä½¿ç”¨æƒå€¼çº¿æ®µæ ‘ ç¦»æ•£åŒ–ï¼š$-1e9\\leq a_i \\leq1e9$ çš„æ•°æ®çº¿æ®µæ ‘è‚¯å®šå¼€ä¸ä¸‹ï¼Œä½†è¿™é“é¢˜åªéœ€è¦æ±‚ç¬¬kå°ï¼Œæ²¡æœ‰å¿…è¦å¼€é‚£ä¹ˆå¤§ï¼Œå¯ä»¥å¯¹æ•°æ®è¿›è¡Œç¦»æ•£åŒ–ã€‚ æˆ‘ä»¬æŒ‰ç…§åºåˆ—çš„é¡ºåºæ’å…¥$a_i$ã€‚å¾—åˆ°æ¯ä¸ª$root[i]$ä»£è¡¨çš„æƒå€¼çº¿æ®µæ ‘ä»£è¡¨ä»$a_1$åˆ°$a_i$çš„æ¯ä¸ªæ•°å€¼çš„å‡ºç°æ¬¡æ•°ã€‚ é‚£ä¹ˆæ ¹æ®å‰ç¼€å’Œçš„æ€æƒ³ï¼ŒåŒºé—´$[l,r]$ä¸­æ¯ä¸ªæ•°å€¼çš„å‡ºç°ä¸ªæ•°å°±æ˜¯$[1,r]$çš„å‡å»$[1,l-1]$çš„ã€‚é‚£ä¹ˆæ•°å€¼çš„åŒºé—´ä¹Ÿå…·æœ‰è¿™ä¸ªæ€§è´¨ã€‚ æ‰€æœ‰å¯¹äºæ¯ä¸ªè¯¢é—®ï¼Œæˆ‘ä»¬åªéœ€è¦æŸ¥è¯¢ä¸€æ¬¡ï¼Œç”¨$root[r]$å’Œ$root[l-1]$çš„æƒå€¼çº¿æ®µæ ‘å¤„ç†å‡ºåŒºé—´$[l,r]$åº”æœ‰çš„æƒå€¼çº¿æ®µæ ‘ï¼Œå°±å¯ä»¥åƒæ­£å¸¸çš„æƒå€¼çº¿æ®µæ ‘ä¸€æ ·æŸ¥è¯¢ç¬¬kå°äº†ã€‚ ä»£ç ï¼š #include&lt;vector&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; using namespace std; int n,m,a[200010],x,y,z,cnt,root[200010]; struct node { int l,r,sum; }nodes[8000010];//40*n vector&lt;int&gt; v; void ins(int l,int r,int pre,int &amp;now,int p)//æ’å…¥ï¼Œåˆ›å»ºæ–°ç‰ˆæœ¬ { nodes[++cnt]=nodes[pre]; now=cnt; ++nodes[cnt].sum; if(l==r) return; int m=(l+r)&gt;&gt;1; if(p&lt;=m) ins(l,m,nodes[pre].l,nodes[cnt].l,p); else ins(m+1,r,nodes[pre].r,nodes[cnt].r,p); } int find(int l,int r,int p1,int p2,int k) { if(l==r) return l; int m=(l+r)&gt;&gt;1; int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//ç°åœºå¤„ç†ï¼Œå¾—åˆ°[x,y]åŒºé—´å†…ï¼Œå€¼åœ¨[l,mid]å†…çš„æ•°çš„ä¸ªæ•° if(k&lt;=X) return find(l,m,nodes[p1].l,nodes[p2].l,k);//å¦‚æœk&lt;=X.è¯´æ˜ç¬¬kå°çš„æ•°åœ¨å·¦è¾¹ã€‚ else return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//å¦åˆ™åœ¨å³è¾¹ã€‚ } int getid(int X)//å¾—åˆ°ç¦»æ•£åŒ–åçš„æ•°å€¼ { return lower_bound(v.begin(),v.end(),X)-v.begin()+1; } int main() { scanf(&quot;%d %d&quot;,&amp;n,&amp;m); for(int i=1;i&lt;=n;++i) { scanf(&quot;%d&quot;,&amp;a[i]); v.push_back(a[i]); } sort(v.begin(),v.end()); v.erase(unique(v.begin(),v.end()),v.end());//ç¦»æ•£åŒ– for(int i=1;i&lt;=n;++i) ins(1,n,root[i-1],root[i],getid(a[i]));//æŒ‰é¡ºåºæ’å…¥æ¯ä¸ªå€¼ï¼Œå¾—åˆ°root[i]å¯¹åº”çš„æƒå€¼çº¿æ®µæ ‘ã€‚ for(int i=1;i&lt;=m;++i) { scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z); printf(&quot;%d\\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//æŸ¥è¯¢åŒºé—´[x,y]ï¼›è¾“å‡ºåŸå€¼ } return 0; } 3.ç¼ºç‚¹åŠæ³¨æ„äº‹é¡¹å†…å­˜æ± ä¸€èˆ¬ä»1å¼€å§‹ç”¨ï¼Œ$nodes[0]$ä½œä¸ºç©ºç™½ï¼Œå€¼ä¸º$0$ï¼Œå„¿å­èŠ‚ç‚¹æŒ‡å‘è‡ªå·±ï¼Œå€¼è¿˜æ˜¯ä¸º$0$ã€‚ å½“ä½ è¿™ä¸ªç‰ˆæœ¬çš„æ ‘è¿˜æ²¡æœ‰æ”¹è¿‡æŸä¸ªèŠ‚ç‚¹çš„æŸä¸ªå„¿å­æ—¶ï¼Œè¿™ä¸ªèŠ‚ç‚¹çš„è¿™ä¸ªå„¿å­ä¼šæŒ‡å‘$nodes[0]$ï¼Œä¹Ÿå°±ç›¸å½“äºä¸‹é¢éƒ½æ˜¯$0$ï¼Œæ­£å¥½ç¬¦åˆã€‚ æ•°ç»„ä¸€å®šè¦å¼€å¤§ï¼Œå¦‚æœå¼€å¾—ä¸å¤Ÿå¤§å¯èƒ½ä¼šå‡ºç°$MLE$,$TLE$,$RE$,$WA$. ä½†ä¹Ÿä¸è¦å¼€å¤ªå¤§ï¼Œä¸ç„¶ä¼š$MLE$,$CE$. ä¸»å¸­æ ‘æ˜¯é™æ€çš„ï¼Œé‡åˆ°è¦åŠ¨æ€ä¿®æ”¹è€Œä¸æ˜¯ç”Ÿæˆä¸€ä¸ªæ–°ç‰ˆæœ¬çš„é—®é¢˜ï¼Œå°±å¯èƒ½è¦ç”¨æ ‘å¥—æ ‘äº†ã€‚ å¯æŒä¹…åŒ–å¯ä»¥ç”¨åœ¨å¾ˆå¤šæ•°æ®ç»“æ„ä¸Šï¼Œå¹³è¡¡æ ‘ï¼Œçº¿æ®µæ ‘ï¼Œ$trie$æ ‘â€¦â€¦å¯å¤Ÿå¾—å†™ï¼Œä½†å®ƒä»¬çš„æ€æƒ³éƒ½æ˜¯ç›¸ä¼¼çš„ï¼Œéƒ½æ˜¯æ¯ä¸ªç‰ˆæœ¬ä¸ä¹‹å‰çš„ç‰ˆæœ¬å…±ç”¨èŠ‚ç‚¹ä»¥èŠ‚çœæ—¶é—´ï¼Œç©ºé—´ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---trieæ ‘","slug":"DS100P-TRIE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-08T12:28:22.937Z","comments":true,"path":"2020/02/07/DS100P-TRIE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TRIE/","excerpt":"","text":"trieæ ‘($\\sum{len}$) $trie$æ ‘ï¼Œä¸æ˜¯ä¸€ç§äºŒå‰æ ‘ï¼Œå®ƒæ˜¯ä¸€ç§å¤šå‰æ ‘ï¼ˆå…¶å®ä¹Ÿå¯ä»¥æ˜¯äºŒå‰æ ‘ï¼‰ å¯ä»¥ç”¨æ¥æ±‚ä¸€å †æ•°ä¸­ä¸¤ä¸ªï¼ˆæˆ–ä¸‰ä¸ªï¼‰å¼‚æˆ–èµ·æ¥çš„æœ€å¤§å€¼ã€‚ å¯ä»¥æŸ¥æ‰¾å•è¯ã€‚ å¯¹äºä¸€äº›æœ‰å‰ç¼€çš„å•è¯ï¼Œæ¯”å¦‚WGY_2333å’ŒWGY_AND_LYC_WRITE_BLOGã€‚ å®ƒä»¬å°±å¯ä»¥å…±ç”¨æ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹ï¼ˆå³WGY_ï¼‰ï¼ŒæŸ¥è¯¢æ—¶å°±å¯ä»¥ä»$\\ $2$\\ $å’Œ$\\ $L$\\ $æ¥å¯¹ä»–ä»¬è¿›è¡ŒåŒºåˆ† æ‰€ä»¥æˆ‘ä»¬è¿˜æ˜¯çœ‹çœ‹å®ƒæ˜¯æ€ä¹ˆå®ç°çš„å§ã€‚ 1&gt;.æ’å…¥å¯¹äº$trie$æ ‘ï¼Œæ ‘ä¸Šçš„æ¯ä¸€æ¡è¾¹éƒ½ä»£è¡¨äº†ä¸€ä¸ªå­—æ¯æˆ–è€…ä¸€ä¸ªæ•°å­—ã€‚ æ‰€ä»¥ä¸€ä¸ªèŠ‚ç‚¹ä¼šæœ‰å¾ˆå¤šå„¿å­ï¼Œæˆ‘ä»¬å°±è¦å¼€ä¸€ä¸ªå„¿å­æ•°ç»„$ch$ã€‚ è¦ç»Ÿè®¡è¿™ä¸ªèŠ‚ç‚¹è¢«ç»è¿‡äº†å¤šå°‘æ¬¡ï¼Œä¹Ÿå°±æ˜¯å¤šå°‘å•è¯æœ‰è¿™ä¸ªå‰ç¼€ï¼Œå°±è¦åŠ ä¸€ä¸ª$sum$ã€‚ è¦ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªå•è¯åœ¨è¿™é‡Œç»“æŸï¼Œä¹Ÿå°±æ˜¯è¦æŸ¥è¯¢çš„å•è¯æœ‰å¤šå°‘ä¸ªå·²æ’å…¥çš„å•è¯ä½œå‰ç¼€ï¼Œå°±è¦åŠ ä¸€ä¸ª$end$ã€‚ æ’å…¥æ—¶ï¼Œå…ˆçœ‹è¿™ä¸ªèŠ‚ç‚¹æœ‰æ²¡æœ‰ä½ è¦èµ°çš„é‚£ä¸ªå„¿å­ï¼Œå¦‚æœæ²¡æœ‰ï¼Œå°±æ–°å»ºä¸€ä¸ªï¼Œèµ°ä¸‹å»ã€‚å¦åˆ™å°±ç›´æ¥èµ°åˆ°è¿™ä¸ªå„¿å­ï¼ˆå…±ç”¨èŠ‚ç‚¹å˜›ï¼‰ã€‚ ä»£ç ï¼šï¼ˆä»¥å°å†™å­—æ¯å•è¯ä¸ºä¾‹ï¼‰ struct node { int ch[26],sum,end; }nodes[MAXN]; int root=1,cnt=1; void ins(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].ch[str[i]-&#39;a&#39;]) nodes[x].ch[str[i]-&#39;a&#39;]=++cnt; x=nodes[x].ch[str[i]-&#39;a&#39;]; ++nodes[x].sum; } ++nodes[x].end; } 2&gt;.æŸ¥è¯¢$trie$æ ‘çš„æŸ¥è¯¢æœ‰å¾ˆå¤šç§ï¼Œä¸€èˆ¬ä¾ç…§é¢˜ç›®è¦æ±‚æ¥è‡ªå·±å®šä¹‰ã€‚ æˆ‘ä»¬è¿™é‡Œåˆä»¥å°å†™å­—æ¯å•è¯æŸ¥è¯¢å­˜åœ¨æ€§ä¸ºä¾‹ã€‚ åŒæ ·æ˜¯ä»æœ€ä¸Šé¢çš„æ ¹èŠ‚ç‚¹å¼€å§‹ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹æœ‰è¿™ä¸ªå•è¯ç°åœ¨ä½ç½®å­—æ¯çš„å„¿å­ï¼Œå°±èµ°ä¸‹å»ã€‚å¦åˆ™å°±ç›´æ¥è¿”å›falseï¼Œå› ä¸ºä¹‹å‰æ²¡æœ‰è¿‡å•è¯èµ°è¿‡è¿™æ¡è·¯å¾„,å¦‚æœæœ‰è¿‡è¿™ä¸ªå‰ç¼€çš„å•è¯èµ°è¿‡ï¼Œè‚¯å®šä¼šåˆ›å»ºè¿™ä¸ªèŠ‚ç‚¹ã€‚ æœ€åå†åˆ¤æ–­æœ‰æ²¡æœ‰å•è¯åœ¨è¿™ä¸ªåœ°æ–¹ç»“æŸã€‚ ä»£ç : bool find(int len) { int x=root; for(int i=0;i&lt;len;++i) { if(!nodes[x].str[str[i]-&#39;a&#39;]) return false; x=nodes[x].str[str[i]-&#39;a&#39;]; } return nodes[x].end; } trieæ ‘å°±åªæœ‰è¿™ä¹ˆç‚¹ï¼ŒæƒŠä¸æƒŠå–œï¼Œæ„ä¸æ„å¤–","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘å¥—æ ‘","slug":"DS100P-TREE-COVER-TREE","date":"2020-02-07T06:51:04.000Z","updated":"2020-02-20T02:48:47.137Z","comments":true,"path":"2020/02/07/DS100P-TREE-COVER-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/07/DS100P-TREE-COVER-TREE/","excerpt":"","text":"æ ‘å¥—æ ‘($nlog^2n$) æ ‘å¥—æ ‘ä¹Ÿæ˜¯ä¸€ç§æš´åŠ›æ€æƒ³ï¼Œå®ƒå¯ä»¥æœ‰å¾ˆå¤šå®ç°ï¼šæ ‘çŠ¶æ•°ç»„å¥—å¹³è¡¡æ ‘ï¼Œä¸»å¸­æ ‘å¥—æ ‘çŠ¶æ•°ç»„â€¦â€¦ ä½†æ˜¯æœ€å¸¸è§çš„è¿˜æ˜¯çº¿æ®µæ•°å¥—å¹³è¡¡æ ‘ã€‚ 1.æ€æƒ³&amp;&amp;å»ºæ ‘æ ‡å‡†è¯´æ³•ï¼šçº¿æ®µæ ‘çš„æ¯ä¸ªèŠ‚ç‚¹å¯¹åº”å¹³è¡¡æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚ ??? å…¶å®è¿˜æ˜¯çº¿æ®µæ ‘æ¯ä¸ªèŠ‚ç‚¹å¯¹åº”ä¸€ä¸ªåŒºé—´ï¼Œä½†æ˜¯æˆ‘ä»¬æŠŠè¿™ä¸ªåŒºé—´å»ºæˆä¸€æ£µå¹³è¡¡æ ‘å°±è¡Œäº†ï¼Œçº¿æ®µæ ‘èŠ‚ç‚¹è®°å½•è¿™ä¸ªåŒºé—´å»ºæˆçš„å¹³è¡¡æ ‘çš„æ ¹èŠ‚ç‚¹å°±è¡Œäº†ã€‚ çº¿æ®µæ ‘æœ‰$logn$å±‚ï¼Œæ¯å±‚çš„èŠ‚ç‚¹å¯¹åº”çš„åŒºé—´èƒ½å¤Ÿæ‹¼æˆä¸€ä¸ªå®Œæ•´çš„åŒºé—´ï¼Œå³æ¯å±‚$n$ä¸ªå¹³è¡¡æ ‘èŠ‚ç‚¹ï¼Œå¹³è¡¡æ ‘æ¯ä¸ªèŠ‚ç‚¹æ’å…¥æ˜¯$logn$çš„ï¼Œæ‰€ä»¥å»ºæ ‘çš„æ—¶é—´å¤æ‚åº¦æ˜¯$nlog^2n$ fhq-treapç¤ºä¾‹ void build(int l,int r,int x) { for(int i=l;i&lt;=r;++i) { split(root[x],a[i],root1,root2); root[x]=merge(merge(root1,newnode(a[i])),root2); } if(l^r) { int mid=(l+r)&gt;&gt;1; build(l,mid,x&lt;&lt;1); build(mid+1,r,x&lt;&lt;1|1); } } 2.æŸ¥è¯¢åŒºé—´æ’åç»™å®šä¸€ä¸ªåŒºé—´å’Œä¸€ä¸ªå€¼ï¼ŒæŸ¥è¯¢åŒºé—´ä¸­æ¯”ä»–å°çš„å…ƒç´ ä¸ªæ•°åŠ 1ã€‚ æˆ‘ä»¬å¯ä»¥åƒçº¿æ®µæ ‘ä¸€æ ·ï¼Œå…ˆæŠŠè¿™ä¸ªåŒºé—´æ‹†åˆ†æˆä¸€äº›èƒ½ç”¨æˆ‘ä»¬ä¹‹å‰å»ºæ ‘å»ºå‡ºçš„å¹³è¡¡æ ‘è¡¨ç¤ºçš„å°åŒºé—´ï¼Œå†æŸ¥è¯¢å°åŒºé—´ä¸­æ¯”è¿™ä¸ªå€¼å°çš„å…ƒç´ ä¸ªæ•°åŠ èµ·æ¥çš„å’Œã€‚ å¾ˆæ˜æ˜¾ f[i,j]=f[i,k]+f[k+1,j]ï¼ˆi\\leq k","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---fhq-treap","slug":"DS100P-FHQ-TREAP","date":"2020-02-05T06:51:05.000Z","updated":"2020-02-20T02:48:47.113Z","comments":true,"path":"2020/02/05/DS100P-FHQ-TREAP/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-FHQ-TREAP/","excerpt":"","text":"fhq-treap($nlogn$) $fhq-treap$æ˜¯ä¸€ç§äºŒå‰æœç´¢æ ‘ã€‚æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼šä¸­åºéå†æ˜¯ä¸€ä¸ªä¸é™åºåˆ—ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€ä¸ªèŠ‚ç‚¹çš„å·¦å„¿å­å°äºç­‰äºå®ƒï¼Œå³å„¿å­å¤§äºç­‰äºå®ƒã€‚ ä½†å®ƒå’Œ$treap$ä¸€æ ·ï¼Œéƒ½æ»¡è¶³å †çš„æ€§è´¨ï¼šä»»æ„çˆ¶èŠ‚ç‚¹çš„é”®å€¼å¤§äº(ç­‰äº)æˆ–å°äº(ç­‰äº)å­èŠ‚ç‚¹çš„é”®å€¼ã€‚ å®ƒå¯ä»¥åšæ™®é€šå¹³è¡¡æ ‘ï¼ˆåŸºæœ¬æ“ä½œï¼‰ï¼Œæ–‡è‰ºå¹³è¡¡æ ‘ï¼ˆåŒºé—´æ“ä½œï¼‰ï¼Œè¿˜å¯ä»¥å¯æŒä¹…åŒ–ã€‚ ä½†å¸¸æ•°ç•¥å¤§ã€‚ å®šä¹‰ï¼š struct node { int l,r,num,key,cum; //å·¦å„¿å­ï¼Œå³å„¿å­ï¼Œæœ¬èŠ‚ç‚¹çš„å€¼ï¼Œé”®å€¼ï¼Œå­æ ‘å¤§å° }nodes[MAXN]; 1.æƒå€¼fhq-treapæƒå€¼$fhq-treap$çš„æ„æ€æ˜¯ï¼Œå®ƒè¿™æ—¶å€™æ—¢æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œåˆæ»¡è¶³å †çš„æ€§è´¨ã€‚ å…ˆè®²è®²è¾…åŠ©æ“ä½œå§ï¼š update:ç”¨æ¥æ›´æ–°å½“å‰èŠ‚ç‚¹çš„å­æ ‘å¤§å°ã€‚ ä»£ç å®ç°ï¼š void update(int x) { nodes[x].cum=nodes[nodes[x].l].cum+nodes[nodes[x].r].cum+1; } å› ä¸ºä¸€ä¸ªèŠ‚ç‚¹çš„å­æ ‘å¤§å°ç­‰äºå®ƒå·¦å³å„¿å­çš„å­æ ‘å¤§å°åŠ ä¸Šå®ƒæœ¬èº«å˜›ã€‚ newnode:æ–°å»ºä¸€ä¸ªå€¼ä¸ºæŒ‡å®šå€¼çš„èŠ‚ç‚¹å¹¶è¿”å›å®ƒçš„ç¼–å·ã€‚ ä»£ç å®ç°ï¼š int newnode(int val) { nodes[++tot].cum=1; nodes[tot].num=val; nodes[tot].key=rand(); return tot; } ä¸»è¦æ“ä½œæœ‰ä¸¤ä¸ªï¼š 1&gt;.åˆ†è£‚splitè¿™é‡Œçš„åˆ†è£‚æŒ‰ç…§æƒå€¼åˆ†è£‚ï¼Œå³æŠŠåŸæ ‘æŒ‰ç…§æƒå€¼$val$åˆ†æˆä¸¤æ£µæ ‘ï¼Œä¸€æ£µ$X$ä¸­çš„æƒå€¼å…¨éƒ¨å°äºç­‰äº$val$ï¼Œå¦ä¸€æ£µyçš„æƒå€¼å…¨éƒ¨å¤§äº$val$ã€‚è€Œè¿™ä¸¤æ£µæ ‘éƒ½è¦æ»¡è¶³ä¸¤ä¸ªæ€§è´¨ã€‚ è¦å®ç°è¿™ä¸ªæ“ä½œï¼Œæˆ‘ä»¬è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹éå†ï¼ŒæŠŠæ•´æ£µæ ‘åˆ†æˆä¸¤åŠã€‚ æˆ‘ä»¬è¿›è¡Œåˆ†ç±»è®¨è®ºï¼šç°åœ¨éå†åˆ°çš„èŠ‚ç‚¹ç¼–å·ä¸º$now$ã€‚ 1).å½“$now=0$æ—¶ è¿™æ—¶ï¼Œnowæ˜¯ä¸€ä¸ªç©ºèŠ‚ç‚¹ï¼Œæ²¡æœ‰åŠæ³•åˆ†è£‚ã€‚ 2).å½“$nodes[now].num\\leq val$æ—¶ è¿™ä¸ªèŠ‚ç‚¹ä»¥åŠå®ƒçš„å·¦å­æ ‘çš„æƒå€¼éƒ½å°äºç­‰äº$val$,é‚£ä¹ˆä»–ä»¬å…¨éƒ¨éƒ½å±äº$X$ã€‚ é‚£ä¹ˆå®ƒçš„å³å­æ ‘å¯èƒ½æ˜¯$X$çš„ï¼Œä¹Ÿå¯èƒ½æ˜¯$Y$çš„ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­åˆ†è£‚å³å­æ ‘ï¼Œä½†ç”±äºå³è¾¹çš„æ•°è¦æ¯”$nodes[now].num$å¤§ï¼Œæ¥ä¸‹æ¥åˆ†è£‚å‡ºçš„å°äºç­‰äº$val$çš„å­æ ‘éœ€è¦æ¥åœ¨å½“å‰åˆ†å‡ºçš„$X$æ ‘çš„å³å­æ ‘ä¸Šã€‚ 3).å¦åˆ™ è¿™ä¸ªæ—¶å€™è¿™ä¸ªèŠ‚ç‚¹å’Œå®ƒçš„å³å­æ ‘çš„æƒå€¼éƒ½å¤§äº$val$ï¼Œé‚£ä¹ˆä»–ä»¬å…¨éƒ¨å±äº$Y$ã€‚ ä½†å®ƒçš„å·¦å­æ ‘å¯èƒ½æœ‰ä¸€éƒ¨åˆ†å±äº$X$ã€‚ æ‰€ä»¥æˆ‘ä»¬éœ€è¦ç»§ç»­åˆ†è£‚å·¦å­æ ‘ã€‚é“ç†åŒä¸Šã€‚ ä¸Šé¢æ“ä½œå·²ç»ä¿è¯äº†åˆ†å‡ºçš„äºŒå‰æ ‘æ»¡è¶³äºŒå‰æ ‘æ€§è´¨ã€‚è€Œå †æ€§è´¨ä¹Ÿå¾—åˆ°äº†æ»¡è¶³ï¼Œå› ä¸ºä»åŸæ ‘ä¸Šå¾€ä¸‹åˆ†ï¼Œåˆ†åˆ°èŠ‚ç‚¹çš„é”®å€¼ä¹Ÿæ˜¯æœ‰åºçš„ã€‚ é€’å½’è¿”å›å‰è¿˜è¦è®°å¾—$update$ä¸€ä¸‹ï¼Œæ›´æ–°åˆ†è£‚åçš„å­æ ‘å¤§å°ã€‚ æ˜¯ä¸æ˜¯è¿˜æ˜¯ä¸æ‡‚ï¼Ÿè¿˜æ˜¯çœ‹ä»£ç å’Œä»£ç æ³¨é‡Šå§ï¼š //x,yä»£è¡¨ä»nowè¿™ä¸ªèŠ‚ç‚¹åˆ†è£‚å‡ºçš„ä¸¤æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä½¿ç”¨å¼•ç”¨è¿”å›å€¼ã€‚ void split(int now,int val,int &amp;x,int &amp;y) { if(!now) x=y=0;//æƒ…å†µ1).æ— æ³•ç»§ç»­åˆ†è£‚ï¼Œæ‰€ä»¥ä¸¤æ£µæ ‘éƒ½æ˜¯ç©ºã€‚ else { if(nodes[now].num&lt;=val)//æƒ…å†µ2). { x=now;//å·¦å­æ ‘å’Œè¿™ä¸ªèŠ‚ç‚¹éƒ½å±äºXæ ‘ï¼Œæ¥åˆ°ä¹‹å‰åˆ†è£‚åˆ°çš„åœ°æ–¹ã€‚å³å­æ ‘åœ¨ä¸‹é¢ä¼šå—åˆ°ä¿®æ”¹ï¼Œæ‰€ä»¥å³å­æ ‘å¹¶æ²¡æœ‰è¢«ç›´æ¥åŒ…æ‹¬ã€‚ split(nodes[now].r,val,nodes[x].r,y);//ç»§ç»­åˆ†è£‚å³å­æ ‘ã€‚æ¥ä¸‹æ¥åˆ†è£‚å‡ºå±äºXæ ‘çš„æ ¹èŠ‚ç‚¹ä½ç½®åº”è¯¥æ˜¯nodes[x].rï¼Œyçš„ä½ç½®æ²¡æœ‰å˜åŠ¨ã€‚ } else//æƒ…å†µ3). { y=now; split(nodes[now].l,val,x,nodes[y].l);//åŒä¸Š } update(now); //ç”±äºæ— è®ºè¿›å…¥å“ªä¸ªåˆ¤æ–­ï¼Œä½œäº†æ”¹å˜çš„èŠ‚ç‚¹éƒ½ç­‰äºnow,æ‰€ä»¥å¯ä»¥ç›´æ¥æ›´æ–°nowã€‚ } } //è°ƒç”¨ï¼šsplit(root,v,root1,root2) æœ€åä¼ å›çš„å€¼å°±ç›¸å½“äºç»™$root1$,$root2$èµ‹å€¼ã€‚ $root1$,$root2$å°±æ˜¯åˆ†è£‚å‡ºçš„$X$æ ‘å’Œ$Y$æ ‘çš„æ ¹èŠ‚ç‚¹ã€‚ 2&gt;.åˆå¹¶mergeå³æŠŠä¸¤é¢—åƒåˆšåˆšä¸Šé¢åˆ†è£‚å‡ºæ¥çš„ä¸¤é¢—æ ‘åˆå¹¶æˆä¸€æ£µæ»¡è¶³ä¸¤ä¸ªæ€§è´¨çš„æ ‘ã€‚ æˆ‘ä»¬åˆè¦åˆ†ç±»è®¨è®ºï¼šç°åœ¨éœ€è¦åˆå¹¶çš„èŠ‚ç‚¹æ˜¯$x$,$y$ã€‚ï¼ˆç¤ºä¾‹å°æ ¹å †ï¼‰ 1).$x=0$|$\\ $|$y=0$ åªæœ‰ä¸€æ£µæ ‘ï¼Œç›´æ¥è¿”å›è¿™æ£µæ ‘ã€‚ 2).$nodes[x].key&lt;nodes[y].key$ $x$èŠ‚ç‚¹çš„é”®å€¼æ›´å°ï¼Œæ‰€ä»¥$x$åº”è¯¥åœ¨$y$çš„ä¸Šé¢ã€‚ $y$çš„å€¼ä¸€å®šå¤§äº$x$,æ‰€ä»¥æŠŠ$y$å’Œ$x$çš„å³å­æ ‘è¿›è¡Œåˆå¹¶ã€‚ 3).å¦åˆ™ $y$åº”è¯¥åœ¨$x$çš„ä¸Šé¢ã€‚ $x$çš„å€¼ä¸€å®šå°äº$y$ï¼Œæ‰€ä»¥æŠŠ$y$çš„å·¦å„¿å­å’Œ$x$è¿›è¡Œåˆå¹¶ã€‚ ä»£ç ï¼š int merge(int x,int y) { if(!x||!y) return x+y; if(nodes[x].key&lt;nodes[y].key) { nodes[x].r=merge(nodes[x].r,y); update(x); return x; } else { nodes[y].l=merge(x,nodes[y].l); update(y); return y; } } å­¦ä¼šäº†è¿™ä¸¤ä¸ªæ“ä½œä¹‹åï¼Œå°±å¯ä»¥å®ç°æ™®é€šå¹³è¡¡æ ‘çš„æ‰€æœ‰æ“ä½œäº†ã€‚ 3.æ’å…¥æ’å…¥çš„ä»£ç åªæœ‰ä¸¤è¡Œï¼Œéå¸¸ç®€å•ã€‚ åªéœ€è¦æŠŠåŸæ•°æŒ‰è¦æ’å…¥çš„å€¼$val$å¤§å°åˆ†è£‚ï¼Œä¸€è¾¹$x$å°äºç­‰äº$val$ï¼Œå¦ä¸€è¾¹$y$å¤§äº$val$ã€‚ å†æŠŠ$x$ä¸è¿™ä¸ªå€¼èŠ‚ç‚¹åˆå¹¶ï¼ˆå¾—åˆ°$z$ï¼‰ï¼Œæœ€åä¸$y$åˆå¹¶ã€‚ å› ä¸º$x$çš„èŠ‚ç‚¹å…¨éƒ¨å°äºç­‰äº$val$,$z$çš„èŠ‚ç‚¹å…¨éƒ¨å°äº$y$ã€‚æ»¡è¶³æˆ‘ä»¬ä¹‹å‰åˆå¹¶ä¸¤æ£µæ ‘çš„æ¡ä»¶ã€‚ ä»£ç ï¼š void ins(int val) { split(root,val,root1,root2); root=merge(merge(root1,newnode(val)),root2); } 4.åˆ é™¤å…ˆæŠŠè¦åˆ é™¤çš„å€¼$val$ä»åŸæ ‘ä¸­åˆ†è£‚å‡ºæ¥ï¼Œåˆ æ‰ä¸€ä¸ªå†åˆå¹¶å›å»ã€‚ æ€ä¹ˆåœ¨å¾ˆå¤šçš„$val$ä¸­åˆ æ‰ä¸€ä¸ªå‘¢ã€‚ æˆ‘ä»¬æŠŠ$val$å­æ ‘æ ¹èŠ‚ç‚¹çš„å·¦å³èŠ‚ç‚¹åˆå¹¶èµ·æ¥ï¼Œå°±ç›¸å½“äºæŠ›å¼ƒäº†è¿™ä¸ªæ ¹èŠ‚ç‚¹ã€‚ è¿™æ ·ä¿è¯äº†å¦‚æœæœ‰è¿™ä¸ªå€¼ï¼Œä¸€å®šä¼šè¢«åˆ æ‰ï¼Œå› ä¸ºå¦‚æœæœ‰ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹è‚¯å®šæœ‰ã€‚ ä»£ç ï¼š void del(int val) { split(root,val,root1,root2); split(root1,val-1,root1,root3); root3=merge(nodes[root3].l,nodes[root3].r); root=merge(merge(root1,root3),root2); } 5.å‰é©±/åç»§æˆ‘ä»¬æŠŠå°äº/å¤§äºæŸ¥è¯¢å€¼$val$çš„å­æ ‘åˆ†è£‚å‡ºæ¥ï¼Œç”±äºåˆ†è£‚å‡ºçš„å­æ ‘ä¾ç„¶æ»¡è¶³äºŒå‰æ ‘æ€§è´¨ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥æŸ¥è¯¢è¿™ä¸ªå­æ ‘ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼ï¼ŒæŸ¥è¯¢å‡ºçš„å€¼å°±æ˜¯ç­”æ¡ˆã€‚æœ€åè®°å¾—åˆå¹¶å›å»ã€‚ ä»£ç ï¼š int pre(int val) { split(root,val-1,root1,root2); int now=root1,res=-INF; if(now) { while(nodes[now].r) now=nodes[now].r; res=nodes[now].num; } root=merge(root1,root2); return res; } int nxt(int val) { split(root,val,root1,root2); int now=root2,res=INF; if(now) { while(nodes[now].l) now=nodes[now].l; res=nodes[now].num; } root=merge(root1,root2); return res; } 6.ç¬¬kå°å¯¹äºè¿™ä¸ªé—®é¢˜ï¼Œ$fhq-treap$æ²¡æœ‰ç‰¹æ®Šçš„è§£å†³æ–¹æ³•ã€‚æ‰€ä»¥å’Œ$treap$ä¸€æ ·ã€‚ ç”±äºäºŒå‰æœç´¢æ ‘ä¸­åºéå†ä¸ºä¸é™åºåˆ—ï¼Œæˆ‘ä»¬åˆ†æƒ…å†µè®¨è®ºï¼š 1&gt;.å·¦å­æ ‘å¤§å°$+1$ç­‰äº$k$ã€‚ è¯´æ˜å½“å‰èŠ‚ç‚¹å°±æ˜¯ç¬¬$k$å°ã€‚ 2&gt;.å·¦å­æ ‘å¤§å°å°äºç­‰äº$k$ è¯´æ˜ç¬¬$k$å¤§åœ¨å·¦è¾¹ï¼Œé‚£ä¹ˆå‘å·¦è¾¹ç»§ç»­å¯»æ‰¾ç¬¬kå°ã€‚ 3&gt;.å¦åˆ™ ç¬¬$k$å°åœ¨å³è¾¹ï¼Œä½†å·¦è¾¹å’Œå½“å‰ç»“ç‚¹éƒ½æ¯”ç¬¬$k$å°ã€‚æ‰€ä»¥ç¬¬kå°æ˜¯åœ¨å³è¾¹çš„ç¬¬$k-nodes[nodes[x].l].sum-1$å°ã€‚ ä»£ç ï¼š int top(int val) { int x=root; while(x) { if(nodes[nodes[x].l].sum+1==val) break; if(nodes[nodes[x].l].sum&gt;=val) x=nodes[x].l; else { val-=(1+nodes[nodes[x].l].sum); x=nodes[x].r; } } return nodes[x].num; } 7.æ’åæ’åçš„å®šä¹‰æ˜¯æ¯”ä¸€ä¸ªæ•°å°çš„æ•°çš„ä¸ªæ•°åŠ $1$ã€‚ é€šè¿‡å®šä¹‰å°±èƒ½å¾—å‡ºåšæ³•ï¼š æŠŠæ¯”æŸ¥è¯¢å€¼å°çš„å­æ ‘åˆ†ç¦»å‡ºæ¥ï¼Œè¿™æ£µå­æ ‘çš„å¤§å°å°±æ˜¯æ¯”è¿™ä¸ªæ•°å°çš„æ•°çš„ä¸ªæ•°ã€‚å†åŠ $1$å°±èƒ½å¾—åˆ°ç­”æ¡ˆäº†ã€‚ ä»£ç ï¼š int rank(int val) { split(root,val-1,root1,root2); int res=nodes[root1].sum+1; root=merge(root1,root2); return res; } 2.åŒºé—´fhq-treapåŒºé—´$fhq-treap$ç»´æŠ¤äº†ä¸€ä¸ªåŒºé—´ï¼Œä¸­åºéå†æ•´ä¸ª$fhq-treap$å°±å¯ä»¥å¾—åˆ°è¿™ä¸ªåºåˆ—ã€‚å½“ç„¶ï¼Œè¿™æ—¶å€™å®ƒè‚¯å®šå°±ä¸èƒ½æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„æ€§è´¨äº†ã€‚ä½†å®ƒè¿˜å¯ä»¥æ»¡è¶³å †çš„æ€§è´¨ã€‚ ä¸ºäº†ç»´æŠ¤åŒºé—´ï¼Œæˆ‘ä»¬çš„$split$æ“ä½œéœ€è¦æ›´æ”¹ï¼š æ¯æ¬¡åˆ†è£‚ä¸€ä¸ªåŒºé—´å‡ºæ¥ï¼šæŠŠè¿™ä¸ªåºåˆ—çš„å‰$siz$é¡¹åˆ†å‡ºæ¥ä¸ºä¸€ä¸ªå­æ ‘$X$,å‰©ä½™å¦ä¸€ä¸ªå­æ ‘$Y$ã€‚ åˆåˆ†ç±»è®¨è®ºï¼š 1&gt;.$nodes[nodes[x].l].sum&lt;k$ è¿™è¯´æ˜å½“å‰ç»“ç‚¹çš„å·¦å­æ ‘å’Œè‡ªèº«éƒ½å±äº $X$ï¼Œæˆ‘ä»¬å†æŠŠå³å­æ ‘çš„å‰$k-nodes[nodes[x].l].sum-1$é¡¹åˆ†ç»™$X$å°±å¥½äº†ã€‚ 2&gt;.å¦åˆ™ å‰$k$é¡¹åœ¨å½“å‰ç»“ç‚¹çš„å·¦å­æ ‘ä¸­ï¼Œé‚£ä¹ˆå½“å‰èŠ‚ç‚¹å’Œå®ƒçš„å³å­æ ‘å±äº$Y$ã€‚ ä»£ç ï¼š void split(int now,int siz,int &amp;x,int &amp;y) { if(!now) x=y=0; else { if(nodes[nodes[now].l].sum&lt;k) { x=now; split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y); } else { y=now; split(nodes[now].l,siz,x,nodes[y].l); } update(now); } } ä½†$merge$æ“ä½œä¸éœ€è¦å¤ªå¤§å˜åŠ¨ï¼Œåªéœ€è¦åŠ ä¸Šæ‡’æ ‡è®°ä¸‹ä¼ å°±è¡Œäº†ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ å…¶å®åŒºé—´æ“ä½œçš„åˆ†è£‚é™¤äº†æ ‡è®°ä¸‹ä¼ ä¹‹å¤–ä¸æƒå€¼ç‰ˆæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ï¼Œåªæ˜¯è¿™é‡Œåˆ†è£‚çš„æƒå€¼æ˜¯ç¬¬kå°ã€‚ æ ‡è®°ä¸‹ä¼ æ˜¯ä¸ªå¤§å‘ï¼Œæœ‰æ ‡è®°æ—¶ï¼Œæ¯å½“ä½ è¦å¯¹ä¸€ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹è¿›è¡Œæ“ä½œï¼ˆæ— è®ºæ˜¯ä¿®æ”¹è¿˜æ˜¯æŸ¥è¯¢ï¼‰æ—¶ï¼Œè¦å…ˆä¸‹ä¼ æ ‡è®°ï¼Œå¦åˆ™ä¹‹åèƒ½ä¼šä¼ é”™ä½ç½®ï¼Œå› ä¸ºä½ å¯èƒ½æ›´æ”¹äº†å®ƒçš„å­èŠ‚ç‚¹ã€‚ 1.åŒºé—´å’Œæˆ‘ä»¬åœ¨æ¯ä¸ªèŠ‚ç‚¹ä¸­å†åŠ ä¸Šä¸€ä¸ªå˜é‡è®°å½•å®ƒå’Œå®ƒå­æ ‘çš„å’Œã€‚ é‚£ä¹ˆæ¯æ¬¡å­æ ‘å¤§å°æ›´æ–°æ—¶ï¼Œå­æ ‘å’Œä¹Ÿè¦æ›´æ–°ã€‚ å°±åœ¨$update$é‡ŒåŠ ä¸€å¥è¯æ›´æ–°å­æ ‘å’Œå°±å¥½ã€‚ æŸ¥è¯¢åŒºé—´å’Œæ—¶å°±æŠŠè¿™ä¸ªåŒºé—´åˆ†è£‚å‡ºæ¥ï¼Œç›´æ¥æŸ¥è¯¢è¿™ä¸ªåŒºé—´æ ¹èŠ‚ç‚¹çš„å­æ ‘å’Œå°±è¡Œäº†ã€‚ 2.åŒºé—´ç¿»è½¬åŒºé—´æ“ä½œåŸºæœ¬é æ‡’æ ‡è®°æ¥å®Œæˆã€‚è¿™äº›æ ‡è®°éƒ½ä¼šç»§ç»­ä¸‹ä¼ ç»™å­èŠ‚ç‚¹ã€‚ ç¿»è½¬å°±ç”¨ä¸€ä¸ª$bool$æ‡’æ ‡è®°å°±å¥½äº†ã€‚ é¦–å…ˆè¯´æ˜åŒºé—´ç¿»è½¬çš„åŸç†ï¼š å…ˆæŠŠè¿™ä¸ªåŒºé—´åˆ†è£‚å‡ºæ¥ã€‚ è¦ä½¿åŒºé—´ç¿»è½¬ï¼Œå°±ç›¸å½“äºè¦æŠŠè¿™ä¸ªåŒºé—´å€’ç€éå†ã€‚ å·¦ä¸­å³$-&gt;$å³ä¸­å·¦ å³æˆ‘ä»¬è¦å¯¹äºæ¯ä¸ªèŠ‚ç‚¹éå†æ—¶å…ˆéå†å³è¾¹ï¼Œå†éå†æœ¬èŠ‚ç‚¹ï¼Œæœ€åéå†å·¦è¾¹ã€‚ é‚£æˆ‘ä»¬æŠŠæ¯ä¸ªèŠ‚ç‚¹çš„å·¦å³å„¿å­äº¤æ¢å°±è¡Œäº†ã€‚ æ‰€ä»¥æˆ‘ä»¬ç›´æ¥æŠŠè¿™ä¸ªåŒºé—´å‰–å‡ºæ¥ï¼ŒæŠŠå®ƒçš„æ ¹èŠ‚ç‚¹æ‰“ä¸Šæ ‡è®°ï¼Œå†åˆå¹¶å›å»å°±å¥½äº†ã€‚ 3.åŒºé—´åŠ æ³•åŒºé—´åŠ æ³•å°±åƒçº¿æ®µæ ‘ä¸€æ ·çš„æ‡’æ ‡è®°å°±å¥½äº†ã€‚ å…¶å®ä¸åŒºé—´ç¿»è½¬çš„å®ç°æ–¹å¼ç±»ä¼¼ï¼Œæˆ‘å°±ä¸è®²äº†ã€‚ 4.å¦‚ä½•å‰–å‡ºåŒºé—´[l,r]æˆ‘ä»¬æŠŠåºåˆ—$[1,n]$åˆ†æˆ3æ®µ$[1,l-1]$,$[l,r]$,$[r+1,n]$ ç¬¬ä¸€æ®µçš„é•¿åº¦æ˜¯$l-1$,ç¬¬äºŒæ®µçš„é•¿åº¦æ˜¯$r-l+1$ æˆ‘ä»¬å°±æŒ¨ä¸ªæŠŠå®ƒä»¬$split$å‡ºæ¥å°±å¥½äº†ã€‚ ä»£ç : split(root,l-1,root1,root2); split(root2,r-l+1,root2,root3); $root2$å³ä¸º$[l,r]$åŒºé—´çš„æ ¹ç»“ç‚¹ã€‚ $\\ $ ç”±æ­¤åˆ¤æ–­ï¼Œå¹³è¡¡æ ‘æ¯”çº¿æ®µæ ‘è¿˜è¦ä¸‡èƒ½ï¼Œä½†å¸¸æ•°å·¨å¤§ã€‚","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ ---æ ‘çŠ¶æ•°ç»„","slug":"DS100P-BINARY-INDEXED-TREE","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-20T02:48:47.106Z","comments":true,"path":"2020/02/05/DS100P-BINARY-INDEXED-TREE/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-BINARY-INDEXED-TREE/","excerpt":"","text":"æ ‘çŠ¶æ•°ç»„($nlogn$) æ ‘çŠ¶æ•°ç»„æ˜¯ä¸€ç§å¸¸æ•°è¾ƒå°çš„ï¼Œèƒ½å¤Ÿå®ç°åŒºé—´åŠ æ³•ï¼ŒåŒºé—´æŸ¥è¯¢çš„æ•°æ®ç»“æ„ã€‚ å…¶ä¸­æœ€ç„å¦™çš„æ“ä½œå°±æ˜¯$lowbit$äº†,å®ƒæ˜¯ä½¿æ ‘çŠ¶æ•°ç»„å¸¸æ•°è¿›ä¸€æ­¥ç¼©å°çš„åŠŸè‡£ã€‚ 1).lowbitè¿™ä¸ªæ“ä½œç”¨æ¥æ‰¾åˆ°$x$ä»å³å¾€å·¦æ•°çš„ç¬¬ä¸€ä¸ªä¸º1çš„ä½ã€‚ å…ˆçœ‹ä¸€çœ‹è¿™ä¸ªæ“ä½œçš„å®ç°å§ï¼š$lowbit(x)=(x$&amp;$(-x))$ ($x$ä¸€èˆ¬ä¸ºæ­£æ•´æ•°) è¯´å®ƒå¾ˆç„å¦™æ˜¯å› ä¸ºå®ƒå¾ˆçŸ­ï¼Œä½†å¾ˆæœ‰æ•ˆï¼›å®ƒå……åˆ†åœ°åˆ©ç”¨äº†ä½è¿ç®—çš„é«˜æ•ˆã€‚ ä½†æˆ‘ä»¬è¦ç†è§£å®ƒçš„åŸç†ã€‚ ä½è¿ç®—å˜›ï¼Œæˆ‘ä»¬å…ˆæŠŠxè½¬åŒ–æˆ2è¿›åˆ¶è¡¥ç ã€‚é‚£ä¹ˆxæ˜¯æ­£æ•´æ•°ï¼Œå®ƒçš„äºŒè¿›åˆ¶è¡¥ç å°±æ˜¯ä»–è‡ªèº«ï¼Œä¸”å…¶ä¸­è‚¯å®šæœ‰ä¸€ä¸ª1ã€‚ $-x$çš„äºŒè¿›åˆ¶è¡¨ç¤ºåˆ™æ˜¯å®ƒçš„äºŒè¿›åˆ¶è¡¨ç¤ºçš„åç +1ï¼›å³æŠŠé™¤ç¬¦å·ä½å¤–çš„æ‰€æœ‰ä½å–åï¼Œå†$+1$ã€‚ æˆ‘ä»¬æŠŠè¿™ä¸¤ä¸ªæ­¥éª¤åˆ†å¼€ï¼Œå…ˆæŠŠæ‰€æœ‰ä½å–åï¼Œæ­¤æ—¶xä¸å®ƒä¸èµ·æ¥ç­‰äº0ã€‚å†$+1$ï¼Œå°±ä¼šä½¿ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½å˜ä¸º1ï¼šå› ä¸ºå¦‚æœç¬¬ä¸€ä½æ˜¯0ï¼Œé‚£ä¹ˆè¿™ä½å°±ä¼šå˜æˆ1ï¼›å¦åˆ™å°±ä¼šå¾€å‰è¿›1ä½ï¼Œç»è¿‡é€’å½’ï¼Œå°±èƒ½ä½¿ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½å˜ä¸º1ã€‚ ä»å³å¾€å·¦æ•°ç¬¬ä¸€ä¸ªä¸ºé›¶çš„ä½çš„å·¦è¾¹çš„æ•°æ²¡æœ‰è¢«æ”¹å˜è¿‡ï¼Œæ‰€ä»¥ä¸èµ·æ¥ä¾ç„¶æ˜¯0ï¼›å³è¾¹çš„æ•°ç»è¿‡è¿›ä½éƒ½å˜æˆäº†0ï¼Œä¸ç®¡æ€æ ·ä¸éƒ½æ˜¯0ã€‚è€Œè¿™ä¸€ä½æœ¬èº«ç°åœ¨æ˜¯1ï¼ŒåŸæ¥æ˜¯0ï¼Œè¯´æ˜è¿™ä¸€ä½åŸæ¥æ˜¯1ï¼Œä¸èµ·æ¥å°±æ˜¯1ã€‚è€Œè¿™ä¸€ä½æ˜¯ç¬¬ä¸€ä¸ªä¸º0çš„ä½ï¼Œé‚£ä¹ˆå®ƒåŸæ¥å°±æ˜¯ç¬¬ä¸€ä¸ªä¸º1çš„ä½ã€‚ 2).å•ç‚¹ä¿®æ”¹é¦–å…ˆæˆ‘ä»¬å®šä¹‰ä¸€ä¸ª$nodes$æ•°ç»„ã€‚ $nodes[i]$å‚¨å­˜$a[i-lowbit(i)+1]$åˆ°$a[i]$çš„å’Œã€‚ é‚£ä¹ˆå¦‚æœæˆ‘ä»¬ç»™$a[i]$åŠ ä¸Šäº†$x$,é‚£ä¹ˆ$nodes[i]$è‚¯å®šåŒ…æ‹¬$a[i]$ï¼Œä¹Ÿè¦åŠ ä¸Š$x$; $lowbit(i+lowbit(i))$çš„å€¼è‚¯å®šå¤§äº$lowbit(i)$,æ‰€ä»¥$nodes[i+lowbit(i)]$ä¹Ÿè¦åŠ ä¸Š$x$; å†ç»§ç»­é€’å½’ä¸‹å»ï¼Œä¸€ç›´åˆ°æ•°ç»„çš„è¾¹ç•Œä¸ºæ­¢ã€‚ é‚£å¦‚ä½•è¯´æ˜$nodes[i+lowbit(i)]$å°±æ˜¯ç¬¬ä¸€ä¸ªåŒ…å«$nodes[i]$çš„æ•°å‘¢ï¼Ÿ æˆ‘ä»¬æŒ‰ç…§$lowbit(i)$æŠŠ$nodes[MAXN]$åˆ†ä¸º$log(MAXN)$å±‚ï¼Œé‚£ä¹ˆä¸å¯èƒ½æœ‰åŒå±‚åŠä¸‹å±‚èŠ‚ç‚¹åŒ…å«$nodes[i]$ï¼Œé™¤äº†å®ƒè‡ªå·±ã€‚ æ‰€ä»¥æˆ‘ä»¬å‘ä¸Šå±‚èŠ‚ç‚¹å¯»æ‰¾ï¼Œå°±è¦æŠŠ$lowbit(i)$è¿™ä¸€ä½æ¶ˆæ‰ä¸”æ•°å­—è¦å¢å¤§ï¼Œç›´æ¥åŠ ä¸Š$lowbit(i)$å°±å¯ä»¥åšåˆ°è¿™ä¸€ç‚¹ï¼Œå› ä¸º$lowbit(i)$è¿™ä¸€ä½å¾€å³éƒ½æ˜¯0ï¼Œè¦æŠŠè¿™ä¸€ä½æ¶ˆæ‰ï¼Œéœ€è¦åŠ ä¸Šçš„æ•°ä¸­æ²¡æœ‰æ¯”$lowbit(i)$æ›´å°çš„ã€‚ æ‰€ä»¥$nodes[i+lowbit(i)]$å°±æ˜¯ç¬¬ä¸€ä¸ªåŒ…å«$nodes[i]$çš„æ•°ã€‚ ä»£ç  void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } 3).åŒºé—´æŸ¥è¯¢ï¼ˆå•ç‚¹ä¿®æ”¹ï¼‰å¦‚æœæˆ‘ä»¬è¦æŸ¥è¯¢åŒºé—´$[l,r]$çš„å’Œï¼Œæˆ‘ä»¬å¯ä»¥è¿ç”¨å‰ç¼€å’Œæ€æƒ³ï¼ŒæŠŠå®ƒè½¬æ¢æˆæ±‚$[1,r]-[1,l-1]$çš„å€¼ã€‚ é‚£ä¹ˆé—®é¢˜è½¬åŒ–æˆäº†æ±‚åŒºé—´$[1,x]$çš„å’Œã€‚ ç”±äºå®šä¹‰ï¼Œ$nodes[x]$å‚¨å­˜çš„æ˜¯$a[x-lowbit(x)+1]$åˆ°$a[x]$çš„å’Œï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥ç¼©å°é—®é¢˜è§„æ¨¡ï¼š$query[1,x]=query[1,x-lowbit(x)]+nodes[x]$,ä¸€ç›´åˆ°0ä¸ºæ­¢ã€‚ ä»£ç  int ask(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int query(int l,int r) { return ask(r)-ask(l-1); } 4).åŒºé—´ä¿®æ”¹åŠæŸ¥è¯¢ä¸Šé¢çš„æ“ä½œåªæ”¯æŒå•ç‚¹ä¿®æ”¹ï¼Œé‚£ä¹ˆå¦‚ä½•åŒºé—´ä¿®æ”¹å‘¢ï¼Œä¸€ä¸ªä¸€ä¸ªåœ°æ”¹è‚¯å®šä¼šç‚¸ã€‚æˆ‘ä»¬é‡‡ç”¨å·®åˆ†çš„æ€æƒ³ï¼Œå°†åŒºé—´ä¿®æ”¹è½¬åŒ–ä¸ºå•ç‚¹ä¿®æ”¹ã€‚ æˆ‘ä»¬å…ˆæ€è€ƒå¦‚ä½•ç”¨å·®åˆ†æ•°ç»„$c[n]$æ±‚$a[1]+a[2]+\\cdots+a[n-1]+a[n]$ã€‚ $c[1]n+c[2](n-1)+\\cdots+c[n-1]*2+c[n]$ è¿™ä¸ªå¼å­é‡Œçš„c[i]å’Œiæ²¡æœ‰ä»€ä¹ˆå…³ç³»ï¼Œä¸å¤ªå¥½æ“ä½œï¼Œäºæ˜¯æˆ‘ä»¬æŠŠå®ƒå˜ä¸ªå½¢ï¼š $(c[1]+c[2]+\\cdots+c[n-1]+c[n])(n+1)-(c[1]+c[2]2+\\cdots+c[n-1](n-1)+c[n]n)$ è¿™æ ·å°±å¥½ç»´æŠ¤å¤šäº†ï¼šæˆ‘ä»¬åªéœ€è¦å¼€ä¸¤ä¸ªæ ‘çŠ¶æ•°ç»„ç»´æŠ¤$c[1]+c[2]+\\cdots+c[i]$å’Œ$c[1]+c[2]2+\\cdots+c[i]i$($nodes[MAXN]$,$exnodes[MAXN]$) å¯¹äºä¸€ä¸ªåŒºé—´ä¿®æ”¹â€”â€”$[l,r]$åŠ $x$ã€‚ å°†æ‰€æœ‰åŒ…å«$c[l]$çš„$nodes$åŠ $x$,$exnodes$åŠ $lx$($(c[l]+x)l==c[l]l+xl$) å°†æ‰€æœ‰åŒ…å«$c[r+1]$çš„$nodes$å‡$x$,$exnodes$å‡$(r-1)x$($(c[r+1]+x)(r+1)==c[r+1](r+1)+x(r+1)$) å¯¹äºä¸€ä¸ªåŒºé—´è¯¢é—®â€”â€”$[l,r]$ ç­‰ä»·äº$[1,r]-[1,l-1]$ å¯¹äº$[1,x]$ ç”±ä¸Šé¢çš„å¼å­å¾—å‡ºåšæ³•:ä»¥$nodes$æŸ¥è¯¢$(c[1]+c[2]+\\cdots+c[x-1]+c[x])(x+1)$ï¼Œä»¥$exnodes$æŸ¥è¯¢$(c[1]+c[2]2+\\cdots+c[x-1](x-1)+c[x]x)$,å†å°†å®ƒä»¬ç›¸å‡ã€‚ ä»£ç  void update(int x,int val) { while(x&lt;=MAXN) { nodes[x]+=val; x+=lowbit(x); } } void exupdate(int x,int val) { while(x&lt;=MAXN) { exnodes[x]+=val; x+=lowbit(x); } } int find(int x) { int res=0; while(x) { res+=nodes[x]; x-=lowbit(x); } return res; } int exfind(int x) { int res=0; while(x) { res+=exnodes[x]; x-=lowbit(x); } return res; } void modify(int l,int r,int x) { update(l,x); exupdate(l,l*x); update(r+1,-x); exupdate(r+1,-(r+1)*x); } int ask(int x) { return find(x)*(x+1)-exfind(x); } int query(int l,int r) { return ask(r)-ask(l-1); } //(ä¸‹é¢ä¸¤ä¸ªå…ˆå’•äº†ï¼Œæˆ‘æ²¡çœ‹åˆ°å“ªé“é¢˜è¦ç”¨â€¦â€¦) 5).äºŒç»´å•ç‚¹ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢6).äºŒç»´åŒºé—´ä¿®æ”¹ï¼ŒåŒºé—´æŸ¥è¯¢","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]},{"title":"æ•°æ®ç»“æ„100é¢˜ç³»åˆ—ç›®å½•åŠå‰è¨€","slug":"DS100P-INDEX-AND-PREWORDS","date":"2020-02-05T06:51:04.000Z","updated":"2020-02-20T02:48:47.116Z","comments":true,"path":"2020/02/05/DS100P-INDEX-AND-PREWORDS/","link":"","permalink":"www.orchid-any.cf/2020/02/05/DS100P-INDEX-AND-PREWORDS/","excerpt":"","text":"å‰è¨€$\\qquad \\qquad \\qquad$ljsæäº†ä¸€ä¸ªdp100é¢˜ï¼Œç„¶ålycå‘Šè¯‰æˆ‘æˆ‘ä»¬æä¸€ä¸ªæ•°æ®ç»“æ„100é¢˜å§ $\\qquad \\qquad \\qquad$äºæ˜¯æˆ‘å°±æ¥äº†ï¼Œè¿˜å¸¦æ¥ä¸€ä¸ªç½‘ç»œæµ(å®ƒæ­»äº†ï¼Œè¢«lycæ€æ­»çš„) ç”±äºæŸWGYç¡¬æ˜¯æŠŠç½‘ç»œæµåŠ è¿›å»äº†ï¼Œæ‰€ä»¥æˆ‘åªèƒ½é‡å¼€ä¸€ä¸ªâ€¦â€¦ï¼ˆæˆ‘ä¸ºä»€ä¹ˆè¦è®©ä»–å»ºå¸–å­ï¼‰$\\qquad \\qquad \\qquad$(å®ƒæ­»äº†ï¼Œè¢«wgyæ€æ­»çš„) æˆ‘æ˜¯ä¸ä¼šå†™ç½‘ç»œæµçš„ï¼ï¼ï¼$\\qquad \\qquad \\qquad$(å®ƒæ­»äº†ï¼Œè¢«wgyæ€æ­»çš„) å‰æœŸæˆ‘ä¼šå…ˆæŠŠå„ä¸ªæ•°æ®ç»“æ„çš„æ¨¡æ¿å…ˆå†™ä¸€éï¼Œå…ˆæŠŠåŸºç¡€è®²æ¸…æ¥šã€‚$\\qquad \\qquad \\qquad$å’•å’•å’• åæœŸå†åŠ ä¸€äº›æœ‰ä»·å€¼çš„é¢˜ç›®æ¥è®²è§£ã€‚$\\qquad \\qquad \\qquad$(æˆ‘å¯èƒ½ä¼šå…ˆå’•æ‰éƒ¨åˆ†æ¨¡æ¿â€¦â€¦) $\\qquad \\qquad \\qquad$//å…ˆæŠŠå‘æŒ–å¥½ é¢˜è§£éƒ¨åˆ†$\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 1~10é¢˜ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 11~20é¢˜ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ 21~30é¢˜ æ•°æ®ç»“æ„å­¦ä¹ ç¬”è®°éƒ¨åˆ†$\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘çŠ¶æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-fhq-treap $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-çº¿æ®µæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-trieæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘é“¾å‰–åˆ† $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-ä¸»å¸­æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘å¥—æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åˆ†å— $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-è«é˜Ÿ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Link-Cut Tree $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Chtholly-Tree(Old-Driver Tree) $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-KMP $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-splay $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åç¼€å…¨å®¶æ¡¶ ä¹‹ åç¼€è‡ªåŠ¨æœº $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-Sqrt-Tree $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å—çŠ¶æ•°ç»„ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å—çŠ¶é“¾è¡¨ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ ‘ä¸Šåˆ†å— $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-çŒ«æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åŸºç¯æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-æ”¯é…æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-å·¦åæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-ç¯å¥—æ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-è™šæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åšå¼ˆæ ‘ $\\qquad \\qquad \\qquad$æ•°æ®ç»“æ„100é¢˜ â€”-åœ†æ–¹æ ‘","categories":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}],"tags":[{"name":"DS100P","slug":"DS100P","permalink":"www.orchid-any.cf/tags/DS100P/"}],"keywords":[{"name":"Note","slug":"Note","permalink":"www.orchid-any.cf/categories/Note/"}]}]}