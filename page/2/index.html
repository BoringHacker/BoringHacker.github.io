<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta property="og:type" content="website">
<meta property="og:title" content="BoringHacker&#39;s Blog">
<meta property="og:url" content="www.orchid-any.cf/page/2/index.html">
<meta property="og:site_name" content="BoringHacker&#39;s Blog">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BoringHacker&#39;s Blog">



  <link rel="alternate" href="/atom.xml" title="BoringHacker's Blog" type="application/atom+xml">




  <link rel="canonical" href="www.orchid-any.cf/page/2/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>BoringHacker's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BoringHacker's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/16/SOL-P2000/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/16/SOL-P2000/" itemprop="url">「题解」洛谷P2000拯救世界</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-16T09:46:20+08:00">2020-02-16</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-41.png" rel="gallery_ck8wtuwx60041xgvrg2mlyp8k" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-41.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <p>生成函数裸题。</p>
<p>把所有情况罗列出来: </p>
<p>kkk:</p>
<p>金: $1+x^6+x^{12}+\dots=\frac{1}{1-x^6}$</p>
<p>木: $1+x+x^2+\dots+x^9=\frac{1-x^{10}}{1-x}$</p>
<p>水块: $1+x+x^2+\dots+x^5=\frac{1-x^6}{1-x}$</p>
<p>火: $1+x^4+x^8+\dots=\frac{1}{1-x^4}$</p>
<p>土: $1+x+x^2+\dots+x^7=\frac{1-x^8}{1-x}$</p>
<p>lzn:</p>
<p>金: $1+x^2+x^4+\dots=\frac{1}{1-x^2}$</p>
<p>木: $1+x=\frac{1-x^2}{1-x}$</p>
<p>水: $1+x^8+x^{16}+\dots=\frac{1}{1-x^8}$</p>
<p>火: $1+x^{10}+x^{20}+\dots=\frac{1}{1-x^{10}}$</p>
<p>土: $1+x+x^2+x^3=\frac{1-x^4}{1-x}$</p>
<p>凉心出题人友好的卡了精度并且顺便卡了pypy。所以，人生苦短，Ruby用我</p>
<pre><code class="lang-ruby">n = gets.to_i
print (n + 1) * (n + 2) * (n + 3) * (n + 4) / 24
</code></pre>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-91-100-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-91-100-P/" itemprop="url">数据结构100题 91~100题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:45+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-40.png" rel="gallery_ck8wtuwu7000sxgvrqd43iwyn" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-40.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-81-90-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-81-90-P/" itemprop="url">数据结构100题 81~90题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:43+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-39.png" rel="gallery_ck8wtuwtt000gxgvrtynzs9hn" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-39.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-71-80-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-71-80-P/" itemprop="url">数据结构100题 71~80题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:41+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-38.png" rel="gallery_ck8wtuwtk000bxgvr96ibhomr" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-38.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-61-70-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-61-70-P/" itemprop="url">数据结构100题 61~70题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:39+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-37.png" rel="gallery_ck8wtuwtc0009xgvr5o5zw3ye" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-37.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-51-60-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-51-60-P/" itemprop="url">数据结构100题 51~60题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:37+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-36.png" rel="gallery_ck8wtuwt80007xgvreav380ey" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-36.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-41-50-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-41-50-P/" itemprop="url">数据结构100题 41~50题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:35+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-35.png" rel="gallery_ck8wtuwsu0003xgvrapf4cz9y" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-35.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-31-40-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-31-40-P/" itemprop="url">数据结构100题 31~40题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:33+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png" rel="gallery_ck8wtuwuh0012xgvrsusaw6gk" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-34.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="31-P2163-SHOI2007-园丁的烦恼"><a href="#31-P2163-SHOI2007-园丁的烦恼" class="headerlink" title="31.P2163 [SHOI2007]园丁的烦恼]"></a>31.P2163 [SHOI2007]园丁的烦恼]</h1><p>很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。</p>
<p>有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”</p>
<p>“那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。</p>
<p>“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”</p>
<p>“是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。</p>
<p>“该死的，你究竟是什么来头？”</p>
<p>“陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。</p>
<p>看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。</p>
<p>这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。</p>
<hr>
<p>这道题拿到一看，第一个想法是二维树状数组。</p>
<p>单点修改，区间查询。</p>
<p><del>很标准的模板题嘛</del></p>
<p>这个数据范围可不模板……</p>
<p>就算离散化之后还剩$500000*500000$</p>
<p>连数组都开不下。</p>
<p>所以我们要寻找新的做法。</p>
<p>我们可以看到，所有的询问都会在修改的后面。</p>
<p>所以整个问题是静态的。</p>
<p>那么我们可以使用主席树来解决这个问题。</p>
<p>主席树第$i$个版本统计横坐标为$1-i$的所有树木的纵坐标在权值线段树上的体现。</p>
<p>这个权值线段树维护每个值域有多少个元素。</p>
<p>那么我们就可以在离散化后按照横坐标顺序插入。</p>
<p>查询时利用查分。只需要查询第$xr$个版本时和第$xl-1$个版本时$yl$到$yr$这个区间里有的元素个数，再相减就能得到答案了。</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,root[1500010],s,e,tot;
struct tree
{
    int x,y;
}tre[500010];
struct query
{
    int X1,X2,Y1,Y2;
}q[500010];
struct node
{
    int l,r,num;
}nodes[50000010];
vector&lt;int&gt; pril,prih,inslist[1500010];
void ins(int l,int r,int pre,int &amp;now,int pos)
{
    now=++tot;
    nodes[now]=nodes[pre];
    ++nodes[now].num;
    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    ins(l,mid,nodes[pre].l,nodes[now].l,pos);
        else    ins(mid+1,r,nodes[pre].r,nodes[now].r,pos);
    }
}
int find(int l,int r,int v1,int v2,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[v2].num-nodes[v1].num;
    int mid=(l+r)&gt;&gt;1;
    return find(l,mid,nodes[v1].l,nodes[v2].l,fr,ba)+find(mid+1,r,nodes[v1].r,nodes[v2].r,fr,ba);
}
void read(int &amp;hhh)
{
    int x=0;
    char c=getchar();
    while((c&lt;&#39;0&#39;)|(c&gt;&#39;9&#39;)&amp;&amp;c^&#39;-&#39;)    c=getchar();
    if(c^&#39;-&#39;)    x=c^&#39;0&#39;;
    char d=getchar();
    while((d&lt;=&#39;9&#39;)&amp;(d&gt;=&#39;0&#39;))
    {
        x=(x&lt;&lt;1)+(x&lt;&lt;3)+(d^&#39;0&#39;);
        d=getchar();
    }
    if(c^&#39;-&#39;)    hhh=x;
    else    hhh=-x;
}
void writing(int x)
{
    if(!x)    return;
    writing(x/10);
    putchar((x%10)+&#39;0&#39;);
}
void write(int x)
{
    if(x&lt;0)
    {
        putchar(&#39;-&#39;);
        x=-x;
    }
    else if(!x)
    {
        putchar(&#39;0&#39;);
        putchar(&#39;\n&#39;);
        return;
    }
    writing(x);
    putchar(&#39;\n&#39;);
}
int main()
{
    read(n);
    read(m);
    for(int i=1;i&lt;=n;++i)
    {
        read(tre[i].x);
        read(tre[i].y);
        pril.push_back(tre[i].x);
        prih.push_back(tre[i].y);
    }
    for(int i=1;i&lt;=m;++i)
    {
        read(q[i].X1);
        read(q[i].Y1);
        read(q[i].X2);
        read(q[i].Y2);
        --q[i].X1;
        pril.push_back(q[i].X1);
        prih.push_back(q[i].Y1);
        pril.push_back(q[i].X2);
        prih.push_back(q[i].Y2);
    }
    sort(pril.begin(),pril.end());
    sort(prih.begin(),prih.end());
    pril.erase(unique(pril.begin(),pril.end()),pril.end());
    prih.erase(unique(prih.begin(),prih.end()),prih.end());
    s=prih.size();
    e=pril.size();
    for(int i=1;i&lt;=n;++i)
    {
        tre[i].x=lower_bound(pril.begin(),pril.end(),tre[i].x)-pril.begin()+1;
        tre[i].y=lower_bound(prih.begin(),prih.end(),tre[i].y)-prih.begin()+1;
        inslist[tre[i].x].push_back(tre[i].y);
    }
    for(int i=1;i&lt;=m;++i)
    {
        q[i].X1=lower_bound(pril.begin(),pril.end(),q[i].X1)-pril.begin()+1;
        q[i].Y1=lower_bound(prih.begin(),prih.end(),q[i].Y1)-prih.begin()+1;
        q[i].X2=lower_bound(pril.begin(),pril.end(),q[i].X2)-pril.begin()+1;
        q[i].Y2=lower_bound(prih.begin(),prih.end(),q[i].Y2)-prih.begin()+1;
    }
    for(int i=1;i&lt;=e;++i)
    {
        root[i]=root[i-1];
        int WHILEMAX=inslist[i].size();
        for(int j=0;j^WHILEMAX;++j)    ins(1,s,root[i],root[i],inslist[i][j]);
    }
    for(int i=1;i&lt;=m;++i)    write(find(1,s,root[q[i].X1],root[q[i].X2],q[i].Y1,q[i].Y2));
    return 0;
}
</code></pre>
<h1 id="32-P2471-SCOI2007-降雨量"><a href="#32-P2471-SCOI2007-降雨量" class="headerlink" title="32.P2471 [SCOI2007]降雨量"></a>32.P2471 [SCOI2007]降雨量</h1><p>我们常常会说这样的话：“X年是自Y年以来降雨量最多的”。它的含义是X年的降雨量不超过Y年，且对于任意Y&lt;Z&lt;X，Z年的降雨量严格小于X年。例如2002，2003，2004和2005年的降雨量分别为4920，5901，2832和3890，则可以说“2005年是自2003年以来最多的”，但不能说“2005年是自2002年以来最多的”由于有些年份的降雨量未知，有的说法是可能正确也可以不正确的。</p>
<hr>
<p>这道题要求查询一个数是否是继另一个数后的最大值。</p>
<p>然而中间有很多数是未知的。</p>
<p>要判断这个结论一定成立，我们要知道中间的数是不是都知道。</p>
<p>那我们是不是要把所有的数都放进线段树里呢？</p>
<p>肯定不行，因为年份的范围是$1e9$。</p>
<p>那我们怎么离散化呢？</p>
<p>这里我们只用把与每个年份相邻的两个年份也加进来就好了，再顺便把查询的端点和往内一个数也加进来，不然找端点的时候容易锅……</p>
<p>因为如果查询时这里没有数，那么肯定就被查到了。</p>
<p>如果这里有，那么这里的这个数就会又把它两边的数加进来。一直到要查询到的那个数为止。</p>
<p>那么我们应该怎么判断呢？</p>
<p>这里就要分类讨论了：查询为$(p,q)$</p>
<p>$1.p &gt; q$：肯定不成立，他们的位置都不对，$p$根本不在$q$前面。</p>
<p>$2.p=q$：<del>显然</del>成立。</p>
<p>$3.$继续分类。</p>
<p>$\ \ \ \ \ $$1).$两个端点都已知。</p>
<p>$\ \ \ \ \ \ \ \ \ \ <script type="math/tex">1>.</script>p$的降雨量小于$q$：肯定不对，不符合定义。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$如果$p,q$中间有数比$q$的降雨量大或等于：也不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$3&gt;.$如果$p,q$中间有数未知:那么我们无法确定这些未知的数是否小于$q$的降雨量，输出也许。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$4&gt;.$以上条件均不满足：说明满足了所有条件，是对的。</p>
<p>$\ \ \ \ \ $$2).$知道$p$的降雨量。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$1&gt;.$如果$p,q$中间有数大于$p$的降雨量或等于：不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$否则无论中间是否全部已知，由于$q$未知，都不能确定。</p>
<p>$\ \ \ \ \ $$3).$知道$q$的降雨量。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$1&gt;.$如果$p,q$中间有数大于$q$的降雨量或等于：不符合定义，不对。</p>
<p>$\ \ \ \ \ \ \ \ \ \ $$2&gt;.$否则无论中间是否全部已知，由于$p$未知，都不能确定。</p>
<p>$\ \ \ \ \ $$4).$两个都未知：无论中间是否全部已知，由于不能确定中间的数是否小于他们，所以输出也许。</p>
<p>关于判断中间是否有数大于某数，我们需要查询中间的最大值。</p>
<p>关于判断中间是否有数未知，我们需要查询区间里有多少数。</p>
<p>所以我们要开两棵线段树，一棵记录区间最大值，一棵记录区间里的元素个数。</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;map&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; pri;
map&lt;int,int&gt; mp;
int n,m,s,y[50010],r[50010],p[10010],q[10010],siz[1000010],nodes[1000010];
int getID(int val)
{
    return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1;
}
void ins(int l,int r,int x,int pos,int val)
{
    ++siz[x];
    if(l==r)    nodes[x]=val;
    else
    {
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    ins(l,mid,x&lt;&lt;1,pos,val);
        else    ins(mid+1,r,x&lt;&lt;1|1,pos,val);
        nodes[x]=max(nodes[x&lt;&lt;1],nodes[x&lt;&lt;1|1]);
    }
}
int findsiz(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return siz[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return findsiz(l,mid,x&lt;&lt;1,fr,ba)+findsiz(mid+1,r,x&lt;&lt;1|1,fr,ba);
    }
}
int findmax(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return max(findmax(l,mid,x&lt;&lt;1,fr,ba),findmax(mid+1,r,x&lt;&lt;1|1,fr,ba));
    }
}
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;y[i],&amp;r[i]);
        pri.push_back(y[i]-1);
        pri.push_back(y[i]);
        pri.push_back(y[i]+1);
        mp[y[i]]=r[i];
    }
    scanf(&quot;%d&quot;,&amp;m);
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;p[i],&amp;q[i]);
        pri.push_back(p[i]);
        pri.push_back(p[i]+1);
        pri.push_back(q[i]);
        pri.push_back(q[i]-1);
    }
    sort(pri.begin(),pri.end());
    pri.erase(unique(pri.begin(),pri.end()),pri.end());
    s=pri.size();
    for(int i=1;i&lt;=n;++i)    ins(1,s,1,getID(y[i]),r[i]);
    for(int i=1;i&lt;=m;++i)
    {
        int L=getID(p[i]);
        int R=getID(q[i]);
        if(p[i]&gt;q[i])    printf(&quot;false\n&quot;);
        else if(p[i]==q[i])    printf(&quot;true\n&quot;);
        else if(mp[p[i]]&amp;&amp;mp[q[i]])
        {
            if(mp[p[i]]&lt;mp[q[i]])    printf(&quot;false\n&quot;);
            else
            {
                if(findmax(1,s,1,L+1,R-1)&lt;mp[q[i]])
                {
                    if(findsiz(1,s,1,L,R)==R-L+1)    printf(&quot;true\n&quot;);
                    else    printf(&quot;maybe\n&quot;);
                }
                else    printf(&quot;false\n&quot;);
            }
        }
        else if(mp[p[i]])
        {
            if(findmax(1,s,1,L+1,R)&gt;=mp[p[i]])    printf(&quot;false\n&quot;);
            else    printf(&quot;maybe\n&quot;);
        }
        else if(mp[q[i]])
        {
            if(findmax(1,s,1,L,R-1)&gt;=mp[q[i]])    printf(&quot;false\n&quot;);
            else    printf(&quot;maybe\n&quot;);
        }
        else    printf(&quot;maybe\n&quot;);
    }
    return 0;
}
</code></pre>
<h1 id="33-P2824-HEOI2016-TJOI2016-排序"><a href="#33-P2824-HEOI2016-TJOI2016-排序" class="headerlink" title="33.P2824 [HEOI2016/TJOI2016]排序"></a>33.P2824 [HEOI2016/TJOI2016]排序</h1><p>在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  </p>
<p>这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  </p>
<ul>
<li><code>0 l r</code> 表示将区间 $[l,r]$ 的数字升序排序  </li>
<li><code>1 l r</code> 表示将区间 $[l,r]$ 的数字降序排序  </li>
</ul>
<p>注意，这里是对<strong>下标</strong>在区间 $[l,r]$ 内的数排序。<br>最后询问第 $q$ 位置上的数字。</p>
<hr>
<p>这道题很有意思，需要一定的技巧。</p>
<p>首先我们知道，对于一个长度为 $n$ 整数序列排序需要 $\Theta(n\log n)$ 的时间。</p>
<p>但是，如果我们把序列中的数字从所有的数转移到0和1两个数上，是不是就容易很多呢？</p>
<p>对于一个01串升序排序显然只需要 $\Theta(n)$ 的时间。我们只需要统计出序列中所以1的个数 $cnt$。</p>
<p>然后把 $A_{i},i\in [1,n-cnt]$ 改为零，把 $A_{i},i\in [n-cnt+1,n]$ 改为1即可。</p>
<p>降序排序则完全同理。</p>
<p>不仅如此，我们还可以把时间从 $\Theta(n)$ 降到 $\Theta(\log n)$。</p>
<p>我们可以把统计区间中1的个数看作区间求和，那么我们就可以用线段树来维护区间赋值和区间求和的操作，复杂度 $\Theta(\log n)$。</p>
<p>好，接下来我们思考一个问题——如何把一个普通的序列转化为01序列呢？我们可以按大小来划分。</p>
<p>假设我们现在正在二分，那么我们不妨把所有大于等于 $mid$ 的数置为1，否则置为0。这样整个序列就变成了一个01序列。</p>
<p>排序后判断第 $q$ 个位置是不是1就行了。</p>
<p>这里还有一个问题——为什么这个二分是满足单调性的呢？</p>
<p>其实这个问题很简单，就留给大家吧）））</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)

template &lt; typename Type &gt;
void read(Type&amp; a) {
    a = 0; bool f = 0; char ch;
    while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1;
    while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc();
    a = (f ? -a : a);
}

template &lt; typename Type, typename... Args &gt;
void read(Type&amp; t, Args&amp;... args) {
    read(t), read(args...);
}

#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
// #define mid ((l + r) &gt;&gt; 1)
const int MAXN = 1e5 + 5;
int nodes[MAXN &lt;&lt; 2];
int marks[MAXN &lt;&lt; 2];
int ints[MAXN], bit[MAXN];
int n, m, q;
struct QueryNode {
    int l, r;
    int type;
    QueryNode(){}
    QueryNode(int L, int R, int T) : l(L), r(R), type(T) {}
} asks[MAXN];

void pushdown(int k, int l, int r) {
    if (~marks[k]) {
        int mid = (l + r) &gt;&gt; 1;
        nodes[ls] = (mid - l + 1) * marks[k];
        marks[ls] = marks[k];
        nodes[rs] = (r - mid) * marks[k];
        marks[rs] = marks[k];
        marks[k] = -1;
    }
}

void construct(int k, int l, int r) {
    int mid = ((l + r) &gt;&gt; 1);
    if (l ^ r) {
        construct(ls, l, mid);
        construct(rs, mid + 1, r);
        nodes[k] = nodes[ls] + nodes[rs];
    }
    else
        nodes[k] = bit[l];
}

void update(int k, int l, int r, int x, int y, int v) {
    int mid = ((l + r) &gt;&gt; 1);
    if (l &gt; y || r &lt; x) return ;
    if (l &gt;= x &amp;&amp; r &lt;= y) nodes[k] = (r - l + 1) * v, marks[k] = v;
    else {
        pushdown(k, l, r);
        if (mid &gt;= x) update(ls, l, mid, x, y, v);
        if (mid &lt; y) update(rs, mid + 1, r, x, y, v);
        nodes[k] = nodes[ls] + nodes[rs];
    }
}

int queryf(int k, int l, int r, int x, int y) {
    int mid = ((l + r) &gt;&gt; 1);
    pushdown(k, l, r);
    if (l &gt; y || r &lt; x) return 0;
    else if (l &gt;= x &amp;&amp; r &lt;= y) return nodes[k];
    else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y);
}

bool check(int x) {
    for (int i = 1; i &lt;= n; ++i) bit[i] = (ints[i] &gt;= x);
    memset(marks, -1, sizeof marks);
    memset(nodes, 0, sizeof nodes);
    construct(1, 1, n);
    for (int i = 1; i &lt;= m; ++i) {
        int sum = queryf(1, 1, n, asks[i].l, asks[i].r);
        if (asks[i].type == 1) update(1, 1, n, asks[i].l, asks[i].l + sum - 1, 1), update(1, 1, n, asks[i].l + sum, asks[i].r, 0);
        else update(1, 1, n, asks[i].l, asks[i].r - sum, 0), update(1, 1, n, asks[i].r - sum + 1, asks[i].r, 1);
    }
    return queryf(1, 1, n, q, q);
}

signed main() {
    read(n, m);
    for (int i = 1; i &lt;= n; ++i) read(ints[i]);
    for (int i = 1; i &lt;= m; ++i) read(asks[i].type, asks[i].l, asks[i].r);
    read(q);
    int l = 1, r = n, ans = 0;
    while (l &lt;= r) {
        int mid = ((l + r) &gt;&gt; 1);
        if (check(mid)) l = mid + 1, ans = mid;
        else r = mid - 1;
    }
    printf(&quot;%d\n&quot;, ans);
    return 0;
}
</code></pre>
<h1 id="34-P1712-NOI2016-区间"><a href="#34-P1712-NOI2016-区间" class="headerlink" title="34.P1712 [NOI2016]区间"></a>34.P1712 [NOI2016]区间</h1><p>在数轴上有 $N$ 个闭区间 $[l_1,r_1],[l_2,r_2],…,[l_n,r_n]$ 。现在要从中选出 $M$ 个区间，使得这 $M$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间$[l_i,r_i]$ ，都有 $l_i≤x≤r_i$ 。</p>
<p>对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间$[l_i,r_i]$ 的长度定义为$r_i-l_i$ ，即等于它的右端点的值减去左端点的值。</p>
<p>求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$ 。</p>
<hr>
<h2 id="题意简述"><a href="#题意简述" class="headerlink" title="题意简述"></a>题意简述</h2><p>题意已经很清楚了，就不再说了</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>我们首先考虑怎么去选择这 $M$ 个区间才能使得最终的花费最小。</p>
<p>不难想到我们需要尽量选择 <strong>长度尽量靠近</strong> 的 $M$ 个区间，换句话说就是我们需要按照区间的长度进行排序。</p>
<p>原因很显然，我们如果选择的区间的长度不靠近，那么就会造成最小的区间长度变小，最大的区间长度变大。然而答案就是长度最大的区间和长度最小的区间，所以我们需要让这两个区间的长度尽量靠近。</p>
<p>排完序后我们就依次把每个区间加入到答案所在的集合里。</p>
<p>具体来说就是维护一个数组 $A$，每当我们加入一个区间 $[l_{i},r_{i}]$，就令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部加一。如果存在某一个 $A_{p}$ 使得 $M\le A_{p}$，我们就更新答案，并且删除最先加入进来的区间，也就是令 $A_{l_{i}},A_{l_{i}+1},\cdots,A_{r_{i}}$ 全部减一。</p>
<p>一些细节：</p>
<ol>
<li><p>要离散化（废话</p>
</li>
<li><p>线段树开8倍（每个区间有两个端点</p>
</li>
<li><p>没了</p>
</li>
</ol>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int SIZE = 500000 + 5;
int MAX[SIZE &lt;&lt; 3];
int mark[SIZE &lt;&lt; 3];
vector &lt; int &gt; disc;
int n, m, holyans = -1;
struct interval {
    int l, r;
    int len;
    interval(){}
    interval(int L, int R, int S) : l(L), r(R), len(S){}
    bool operator &lt; (const interval&amp; rhs) const {
        return len &lt; rhs.len;
    }
} seg[SIZE];
#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
#define mid ((l + r) &gt;&gt; 1)

#define pushdown(k)             \
    if (mark[k]) {                \
        MAX[ls] += mark[k];        \
        MAX[rs] += mark[k];        \
        mark[ls] += mark[k];    \
        mark[rs] += mark[k];    \
        mark[k] = 0;            \
    }

#define pushup(k) MAX[k] = max(MAX[ls], MAX[rs])
#define GetID(x) (lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1)

void modify(int k, int l, int r, int x, int y, int v) {
    if (l &gt;= x &amp;&amp; r &lt;= y) mark[k] += v, MAX[k] += v;
    else {
        pushdown(k);
        if (mid &gt;= x) modify(ls, l, mid, x, y, v);
        if (mid &lt; y) modify(rs, mid + 1, r, x, y, v);
        pushup(k);
    }
}

void discretization() {
    for (int i = 1; i &lt;= n; ++i) disc.push_back(seg[i].l), disc.push_back(seg[i].r);
    sort(disc.begin(), disc.end());
    sort(seg + 1, seg + 1 + n);
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    for (int i = 1; i &lt;= n; ++i) seg[i].l = GetID(seg[i].l), seg[i].r = GetID(seg[i].r);
}

signed main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1, x, y; i &lt;= n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), seg[i] = interval(x, y, y - x + 1);
    discretization();
    int size = disc.size();
    int max_id = n;
    for (int i = n; i &gt;= 1; --i) {
        while (MAX[1] &gt;= m &amp;&amp; max_id &gt; i) {
            modify(1, 1, size, seg[max_id].l, seg[max_id].r, -1);
            --max_id;
            if (MAX[1] &gt;= m) {
                if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
                else holyans = seg[max_id].len - seg[i].len;
            }
        }
        modify(1, 1, size, seg[i].l, seg[i].r, 1);
        if (MAX[1] &gt;= m) {
            if (~holyans) holyans = min(holyans, seg[max_id].len - seg[i].len);
            else holyans = seg[max_id].len - seg[i].len;
        }
    }
    printf(&quot;%d\n&quot;, holyans);
    return 0;
}
</code></pre>
<h1 id="P5524-Ynoi2012-NOIP2015洋溢着希望"><a href="#P5524-Ynoi2012-NOIP2015洋溢着希望" class="headerlink" title="P5524 [Ynoi2012]NOIP2015洋溢着希望"></a>P5524 [Ynoi2012]NOIP2015洋溢着希望</h1><p>给出一个长度为 $n$ 的整数序列 $a_1,a_2,\ldots,a_n$，进行 $m$ 次操作，操作分为两类。</p>
<p>操作 $1$：给出 $l,r,v$，将 $a_l,a_{l+1},\ldots,a_r$ 分别加上 $v$。</p>
<p>操作 $2$：给出 $l,r$，询问 $\sum\limits_{i=l}^{r}\sin(a_i)$。</p>
<hr>
<p>唯一一道我能做的Ynoi……</p>
<p>修改操作很模板，略。</p>
<p>对于询问，直接维护是不理智的。相信大家都学过三角函数，和差角公式应该很熟悉。</p>
<p>对于这道题我们可以用这两个公式来维护询问：</p>
<script type="math/tex; mode=display">
\sin(\alpha+\beta)=\sin\ \alpha\times\cos\ \beta+\cos\ \alpha\times\sin\ \beta</script><script type="math/tex; mode=display">
\cos(\alpha+\beta)=\cos\ \alpha\times\cos\ \beta-\sin\ \alpha\times\sin\ \beta</script><p>这样，我们再维护一个加法标记，就能解决询问了。</p>
<p>挺水的对吧。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

const int MAXN = 2e5 + 5;
int n, m, integer[MAXN];
long long nodes[MAXN &lt;&lt; 2];
double sum_sinx[MAXN &lt;&lt; 2];
double sum_cosx[MAXN &lt;&lt; 2];

#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
#define mid ((l + r) &gt;&gt; 1)

void update(int k, double sinx, double cosx) {
    double tsum_sinx = sum_sinx[k];
    double tsum_cosx = sum_cosx[k];
    sum_sinx[k] = tsum_sinx * cosx + tsum_cosx * sinx;
    sum_cosx[k] = tsum_cosx * cosx - tsum_sinx * sinx;
}

void pushup(int k) {
    sum_sinx[k] = sum_sinx[ls] + sum_sinx[rs];
    sum_cosx[k] = sum_cosx[ls] + sum_cosx[rs];
}

void pushdown(int k) {
    if (nodes[k]) {
        nodes[ls] += nodes[k];
        nodes[rs] += nodes[k];
        double t_sinx = sin(nodes[k]);
        double t_cosx = cos(nodes[k]);
        nodes[k] = 0;
        update(ls, t_sinx, t_cosx);
        update(rs, t_sinx, t_cosx);
    }
}

void build(int k, int l, int r) {
    if (l ^ r) build(ls, l, mid), build(rs, mid + 1, r), pushup(k);
    else sum_sinx[k] = sin(integer[l]), sum_cosx[k] = cos(integer[l]);
}

void modify(int k, int l, int r, int x, int y, int v, double sinx, double cosx) {
    if (l &gt;= x &amp;&amp; r &lt;= y) update(k, sinx, cosx), nodes[k] += v;
    else {
        pushdown(k);
        if (mid &gt;= x) modify(ls, l, mid, x, y, v, sinx, cosx);
        if (mid &lt; y) modify(rs, mid + 1, r, x, y, v, sinx, cosx);
        pushup(k);
    }
}

double queryf(int k, int l, int r, int x, int y) {
    if (l &gt;= x &amp;&amp; r &lt;= y) return sum_sinx[k];
    else {
        pushdown(k);
        double res = 0;
        if (mid &gt;= x) res += queryf(ls, l, mid, x, y);
        if (mid &lt; y) res += queryf(rs, mid + 1, r, x, y);
        return res;
    }
}
signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;integer[i]);
    build(1, 1, n);
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 0, opt, x, y, v; i &lt; m; ++i) {
        scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;x, &amp;y);
        if (opt == 1) scanf(&quot;%d&quot;, &amp;v), modify(1, 1, n, x, y, v, sin(v), cos(v));
        else printf(&quot;%.1lf\n&quot;, queryf(1, 1, n, x, y));
    }
    return 0;
}
</code></pre>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-21-30-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-21-30-P/" itemprop="url">数据结构100题 21~30题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:31+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-33.png" rel="gallery_ck8wtux7v005nxgvrwifbchqt" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-33.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="21-P4172-WC2006-水管局长"><a href="#21-P4172-WC2006-水管局长" class="headerlink" title="21.P4172 [WC2006]水管局长"></a>21.P4172 [WC2006]水管局长</h1><p>SC 省 MY 市有着庞大的地下水管网络，嘟嘟是 MY 市的水管局长（就是管水管的啦），嘟嘟作为水管局长的工作就是：每天供水公司可能要将一定量的水从 $x$ 处送往 $y$ 处，嘟嘟需要为供水公司找到一条从 $A$ 至 $B$ 的水管的路径，接着通过信息化的控制中心通知路径上的水管进入准备送水状态，等到路径上每一条水管都准备好了，供水公司就可以开始送水了。嘟嘟一次只能处理一项送水任务，等到当前的送水任务完成了，才能处理下一项。</p>
<p>在处理每项送水任务之前，路径上的水管都要进行一系列的准备操作，如清洗、消毒等等。嘟嘟在控制中心一声令下，这些水管的准备操作同时开始，但由于各条管道的长度、内径不同，进行准备操作需要的时间可能不同。供水公司总是希望嘟嘟能找到这样一条送水路径，路径上的所有管道全都准备就绪所需要的时间尽量短。嘟嘟希望你能帮助他完成这样的一个选择路径的系统，以满足供水公司的要求。另外，由于 MY 市的水管年代久远，一些水管会不时出现故障导致不能使用，你的程序必须考虑到这一点。</p>
<p>不妨将 MY 市的水管网络看作一幅简单无向图（即没有自环或重边）：水管是图中的边，水管的连接处为图中的结点。</p>
<hr>
<p>这道题只有删边操作，我们可以把这个过程看做是加边操作，这样好处理一点。</p>
<p>题目保证了图无论怎么删边都保证联通，所以我们可以先把图删完。删完后我们呢求出图的MST, 那么任意两点在这颗MST上走都是最优的<del>别问我怎么证贪心是用来证的吗</del>。我们可以用LCT来维护这颗MST，Splay维护区间最大值(也就是链上的最大值)</p>
<p>考虑加边操作。上面我提到了一个贪心：任意两点在这颗MST上走都是最优的。如果此时我们在MST上任意加一条边都会形成一个环。我们可以从任意一点入环，任意一点出环，方向随意。可以发现我们的最优解始终能避开最长的一条边！</p>
<p>考察这个环，用lct的split操作提出<code>链</code>的信息，查出最大的权值。发现我们可以通过删除权值最大的边来保证<code>环</code>上的最优。</p>
<p>怎么求出这条边呢？显然我们可以二分来找</p>
<p>再来考虑一个问题：如何维护边呢？</p>
<p>考虑用一个点来表示一条边。</p>
<p>最后<code>逆序</code>加边，把答案<code>逆序</code>输出即可</p>
<p>(<del>良心题解</del>)</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
#ifndef _DEBUG_
    #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
#else
    #define gc() getchar()
#endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

namespace LinkCutTree {
    const int SIZE = 12e4 + 5;
    struct SPLAY {
        int ch[2];
        int fa;
        int key;
        int maxValue;
        int lazyTag;
    } T[SIZE];
    stack &lt; int &gt; MemoryWaste; 
    #define ls T[x].ch[0]
    #define rs T[x].ch[1]
    #define WhichSon(x) (T[T[x].fa].ch[1] == x)
    #define IsRoot(x) (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x)

    void UpdateMessage(int x) {
        T[x].maxValue = max(max(T[ls].maxValue, T[x].key), T[rs].maxValue);
    }

    void UpdateSons(int x) {
        if (T[x].lazyTag) {
            ls ^= rs ^= ls ^= rs;
            T[x].lazyTag = 0;
            T[ls].lazyTag ^= 1;
            T[rs].lazyTag ^= 1;
        }
    }

    void RotateNode(int x) {
        int y = T[x].fa;
        if (!IsRoot(y)) T[T[y].fa].ch[WhichSon(y)] = x;
        bool k = WhichSon(x);
        T[x].fa = T[y].fa;
        T[y].fa = x;
        T[y].ch[k] = T[x].ch[k ^ 1];
        T[T[y].ch[k]].fa = y;
        T[x].ch[k ^ 1] = y;
        UpdateMessage(y);
        UpdateMessage(x);
    }

    void LinkSplay(int x) {
        int u = x;
        while (!IsRoot(u)) MemoryWaste.push(u), u = T[u].fa;
        MemoryWaste.push(u);
        while (MemoryWaste.size()) UpdateSons(MemoryWaste.top()), MemoryWaste.pop();
        for (; !IsRoot(x); RotateNode(x)) {
            int y = T[x].fa;
            if (!IsRoot(y))
                RotateNode(WhichSon(x) ^ WhichSon(y) ? x : y);
        }
    }
    void AccessEdge(int x) {
        for (int u = x, y = 0; u; y = u, u = T[u].fa) {
            LinkSplay(u);
            T[u].ch[1] = y;
            UpdateMessage(u);
        }
    }

    void MakeRoot(int x) {
        AccessEdge(x);
        LinkSplay(x);
        T[x].lazyTag ^= 1;
    }

    void SplitTree(int x, int y) {
        MakeRoot(x);
        AccessEdge(y);
        LinkSplay(y);
    }

    void LinkTree(int x, int y) {
        MakeRoot(x);
        T[x].fa = y;
    }

    void CutTree(int x, int y) {
        MakeRoot(x);
        AccessEdge(y);
        LinkSplay(y);
        T[x].fa = T[y].ch[0] = 0;
    }

    int FindByKey(int x, int u) {
        if (T[x].key == u) return x;
        else if (T[ls].maxValue == u) return FindByKey(ls, u);
        else return FindByKey(rs, u);
    }
} // namespace LinkCutTree

using namespace LinkCutTree;

int F[1005][1005], U[101000], V[101000];
int OP[101000], ans[101000], n, m, QueryNumber;
struct EdgeNode {
    int x, y;
    int val, key;
    EdgeNode() { key = 1; }
    friend bool operator &lt; (EdgeNode X, EdgeNode Y) {
        return X.val &lt; Y.val;
    }
} e[101000];
struct UnionFindSet {
    int fa[1010];

    int find(int x) {
        if (x ^ fa[x]) fa[x] = find(fa[x]);
        return fa[x];
    }

    void merge(int x, int y) {
        int u = find(x), v = find(y);
        if (u ^ v) fa[u] = v;
    }

    void init(int n, int m) {
        for (int i = 1; i &lt;= n; ++i)
            fa[i] = i;
        for (int i = 1; i &lt;= m; ++i) {
            if (e[i].key &amp;&amp; find(e[i].x) ^ find(e[i].y)) {
                merge(e[i].x, e[i].y);
                LinkTree(e[i].x, n + i);
                LinkTree(e[i].y, n + i);
            }
        }
    }
} ufs;

signed main() {
    read(n, m, QueryNumber);
    for (int i = 1; i &lt;= m; ++i)
        read(e[i].x, e[i].y, e[i].val);
    sort(e + 1, e + 1 + m);
    for (int i = 1; i &lt;= m; ++i) {
        F[e[i].x][e[i].y] = i;
        F[e[i].y][e[i].x] = i;
        T[n + i].key = e[i].val;
    }
    for (int i = 1; i &lt;= QueryNumber; ++i) {
        read(OP[i], U[i], V[i]);
        if (OP[i] == 2) e[F[U[i]][V[i]]].key = 0;
    }
    ufs.init(n, m);
    int EdgeCount = 0;
    for (int i = QueryNumber; i &gt;= 1; --i) {
        SplitTree(U[i], V[i]);
        if (OP[i] == 1) ans[++EdgeCount] = T[V[i]].maxValue;
        else {
            int Temporary = FindByKey(V[i], T[V[i]].maxValue);
            if (T[F[U[i]][V[i]] + n].key &lt; T[V[i]].maxValue) {
                CutTree(e[Temporary - n].x, Temporary);
                CutTree(e[Temporary - n].y, Temporary);
                LinkTree(U[i], F[U[i]][V[i]] + n);
                LinkTree(V[i], F[U[i]][V[i]] + n);
            }    
        }
    }
    for (int i = EdgeCount; i &gt;= 1; --i)
        write(io_l, ans[i]);
    return 0;
}
</code></pre>
<h1 id="22-P3302-SDOI2013-森林"><a href="#22-P3302-SDOI2013-森林" class="headerlink" title="22.P3302 [SDOI2013]森林"></a>22.P3302 [SDOI2013]森林</h1><p>小Z有一片森林，含有N个节点，每个节点上都有一个非负整数作为权值。初始的时候，森林中有M条边。</p>
<p>小Z希望执行T个操作，操作有两类：</p>
<ol>
<li><code>Q x y k</code>查询点x到点y路径上所有的权值中，第k小的权值是多少。此操作保证点x和点y连通，同时这两个节点的路径上至少有k个点。</li>
<li><code>L x y</code>在点x和点y之间连接一条边。保证完成此操作后，仍然是一片森林。</li>
</ol>
<p>为了体现程序的在线性，我们把输入数据进行了加密。设lastans为程序上一次输出的结果，初始的时候lastans为0。</p>
<ul>
<li>对于一个输入的操作<code>Q x y k</code>,其真实操作为<code>Q x^lastans y^lastans k^lastans</code>。</li>
<li>对于一个输入的操作<code>L x y</code>，其真实操作为<code>L x^lastans y^lastans</code>。其中^运算符表示异或，等价于pascal中的xor运算符。</li>
</ul>
<p>请写一个程序來帮助小Z完成这些操作。</p>
<hr>
<p>查询操作显然可以用主席树来完成，然而连接树的操作又让我们想到了lct。怎么办呢？<del>主席树+LCT？</del>(据说还真有人这么干)</p>
<p>启发式合并！</p>
<p>没错，我们用选择用主席树来完成这道题，合并时采用启发式合并。</p>
<p>具体来说就是每次合并时都用大小较小的树往大的合并，然后暴力遍历大小较小的树更新倍增数组和主席树即可</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define _size_ (tr[tr[x].l].size + tr[tr[y].l].size - tr[tr[lca].l].size - tr[tr[fa_lca].l].size)
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
#define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 9e4 + 5;
const int LSIZE = SIZE &lt;&lt; 7;
const int GSIZE = SIZE &lt;&lt; 1;
int n, m, q, waste;
int tot, rt[LSIZE], b[SIZE];
int pri_n, edge_tot, a[SIZE];
int Head[GSIZE], Next[GSIZE];
int Vertex[GSIZE], Weight[GSIZE];
int f[SIZE][LSIZE / SIZE &gt;&gt; 2];
int dp[SIZE], fa[SIZE], id[SIZE];
int size[SIZE], vis[SIZE];
struct TreeNode {
    int l, r;
    int size;
} tr[LSIZE];

void add(int x, int y, int z = 1) {
    Vertex[++edge_tot] = y, Weight[edge_tot] = z;
    Next[edge_tot] = Head[x], Head[x] = edge_tot;
}

int find_set(int x) {
    return x == fa[x] ? x : fa[x] = find_set(fa[x]);
}

int make(int l, int r) {
    int u = ++tot;
    if (l ^ r) return tr[u].l = make(l, mid), tr[u].r = make(mid + 1, r), u;
    else return 0;
}

void modify(int &amp;u, int pre, int l, int r, int x) {
    u = ++tot;
    tr[u] = TreeNode{tr[pre].l, tr[pre].r, tr[pre].size + 1};
    if (l ^ r)
        if (mid &gt;= x) modify(tr[u].l, tr[pre].l, l, mid, x);
        else modify(tr[u].r, tr[pre].r, mid + 1, r, x);
    else return ;
}

int query(int x, int y, int lca, int fa_lca, int l, int r, int k) {
    if (l ^ r)
        if (_size_ &gt;= k) return query(tr[x].l, tr[y].l, tr[lca].l, tr[fa_lca].l, l, mid, k);
        else return query(tr[x].r, tr[y].r, tr[lca].r, tr[fa_lca].r, mid + 1, r, k - _size_);
    else return l;
}

void dfs(int x, int _rt_) {
    for (int i = 1; i &lt; 17; ++i) f[x][i] = f[f[x][i - 1]][i - 1];
    modify(rt[x], rt[f[x][0]], 1, pri_n, id[x]);
#define y Vertex[i]
    for (int i = Head[x]; i; i = Next[i]) if (y ^ fa[x]) f[y][0] = x, fa[y] = x, dp[y] = dp[x] + 1, vis[x] = true, size[_rt_]++, dfs(y, _rt_);
#undef y
}

int get_lca(int x, int y) {
    if (dp[x] &lt; dp[y]) x ^= y ^= x ^= y;
    for (int i = 16; i &gt;= 0; --i) if (f[x][i] &amp;&amp; dp[f[x][i]] &gt;= dp[y]) x = f[x][i];
    if (x == y) return x;
    for (int i = 16; i &gt;= 0; --i) if (f[x][i] ^ f[y][i]) x = f[x][i], y = f[y][i];
    return f[x][0];
}

signed main() {
    read(waste, n, m, q);
    for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i];
    sort(b + 1, b + 1 + n);
    pri_n = unique(b + 1, b + 1 + n) - b - 1;
    for (int i = 1; i &lt;= n; ++i) id[i] = lower_bound(b + 1, b + 1 + pri_n, a[i]) - b;
    for (int i = 1, x, y; i &lt;= m; ++i) read(x, y), add(x, y, 1), add(y, x, 1);
    *rt = make(1, pri_n);
    for (int i = 1; i &lt;= n; ++i) if (!vis[i]) dfs(i, i), fa[i] = i;
    int ans = 0, lastans = 0;
    for (int enum_q = 0; enum_q &lt; q; ++enum_q) {
        char opt[5];
        int x, y, k, lca;
        read(opt), read(x, y);
        x ^= lastans, y ^= lastans;
        if (*opt == &#39;Q&#39;) read(k), k ^= lastans, lca = get_lca(x, y), write(io_l, lastans = ans = b[query(rt[x], rt[y], rt[lca], rt[f[lca][0]], 1, pri_n, k)]);
        else {
            add(x, y, 1);
            add(y, x, 1);
            int u = find_set(x);
            int v = find_set(y);
            if (size[u] &lt; size[v]) x ^= y ^= x ^= y, u ^= v ^= u ^= v;
            f[y][0] = x;
            fa[y] = x;
            dp[y] = dp[x] + 1;
            vis[y] = true;
            size[u]++;
            dfs(y, v);
        }
    }
    return 0;
}
</code></pre>
<h1 id="23-P3250-HNOI2016-网络"><a href="#23-P3250-HNOI2016-网络" class="headerlink" title="23.P3250 [HNOI2016]网络"></a>23.P3250 [HNOI2016]网络</h1><p>一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。</p>
<p>由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：</p>
<ol>
<li><p>在某两个服务器之间出现一条新的数据交互请求；</p>
</li>
<li><p>某个数据交互结束请求；</p>
</li>
<li><p>某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。</p>
</li>
</ol>
<p>你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。</p>
<hr>
<p>提供 $\Theta(n\log^3n)$ 的暴力树剖打法。</p>
<p>本来我想搞树套树+树剖的，但发现Splay常数过大容易T爆，fhq-treap也炸了。</p>
<p>后来我幡然醒悟我们只需要开两个优先队列一个放添加的值，一个放删除的值。</p>
<p>碰到查询操作时先比较两个堆的堆顶，如果相同显然它被删掉了，两个栈同时弹出；不相同时添加元素队列的队首就是答案。</p>
<p>而且这道题开O2效果特别明显，2.x s 能变成 xxx ms!</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define CheckSize ((d[top[x]] &lt; d[top[y]]) &amp;&amp; (x ^= y ^= x ^= y))
#define ForGraph int i = Head[x], y = Vertex[i]; i; i = Next[i], y = Vertex[i]
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
// #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

namespace HNOI2016_Network {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    namespace IamJustForPlaying {
    const int SIZE = 2e5 + 5;
    const int GSIZE = SIZE &lt;&lt; 1;

    namespace SegmentTree {
        priority_queue &lt; int &gt; I[SIZE&lt;&lt;1], D[SIZE&lt;&lt;1];
        #define ls (k &lt;&lt; 1)
        #define rs (k &lt;&lt; 1 | 1)

        void DoModify(int k, int l, int r, int x, int y, int val, int opt) {
            if (!(l &gt; y || r &lt; x))
                if (l &gt;= x &amp;&amp; r &lt;= y)
                    if (opt) I[k].push(val);
                    else D[k].push(val);
                else DoModify(ls, l, mid, x, y, val, opt), DoModify(rs, mid + 1, r, x, y, val, opt);
        }

        int GetAnswer(int k, int l, int r, int x) {
            while (I[k].size() &amp;&amp; D[k].size() &amp;&amp; I[k].top() == D[k].top()) I[k].pop(), D[k].pop();
            int res = I[k].size() ? I[k].top() : -1;
            if (l ^ r)
                if (mid &gt;= x) res = max(res, GetAnswer(ls, l, mid, x));
                else res = max(res, GetAnswer(rs, mid + 1, r, x));
            return res;
        }
    } // namespace SegmentTree

    namespace TreeChainSplitting {
        int tx[SIZE], ty[SIZE], tk[SIZE];
        int Head[SIZE], Vertex[GSIZE];
        int Next[GSIZE], EdgeCount;
        int fa[SIZE], size[SIZE];
        int d[SIZE], son[SIZE];
        int dfn[SIZE], rnk[SIZE];
        int top[SIZE], tot;
        int edge_tot = 0, n, m;
        struct Vector2 {
            int x; int y;

            friend bool operator &lt; (Vector2 rhs1, Vector2 rhs2) { return rhs1.x &lt; rhs2.x; }
        } Vec2[SIZE];

        void add(int x, int y) {
            Vertex[++edge_tot] = y;
            Next[edge_tot] = Head[x];
            Head[x] = edge_tot;
        }

        void dfs1(int x, int fa) {
            size[x] = 1, TreeChainSplitting::fa[x] = fa, d[x] = d[fa] + 1;
            for (ForGraph) if (y ^ fa) dfs1(y, x), size[x] += size[y], ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y));
        }

        void dfs2(int x, int tp) {
            top[x] = tp, dfn[x] = ++tot, rnk[tot] = x;
            if (son[x]) dfs2(son[x], tp);
            for (ForGraph) if (y ^ fa[x] &amp;&amp; y ^ son[x]) dfs2(y, y);
        }

        void ModifySubTree(int x, int y, int val, int opt, int tp = 0) {
            while (top[x] ^ top[y]) CheckSize, Vec2[++tp] = {dfn[top[x]], dfn[x]}, x = fa[top[x]];
            if (dfn[x] &gt; dfn[y]) x ^= y ^= x ^= y;
            Vec2[++tp] = {dfn[x], dfn[y]};
            sort(Vec2 + 1, Vec2 + 1 + tp);
            int Sys = 1;
            for (int i = 1; i &lt;= tp; ++i) ((Sys &lt; Vec2[i].x) &amp;&amp; (SegmentTree::DoModify(1, 1, n, Sys, Vec2[i].x - 1, val, opt), 1)), Sys = Vec2[i].y + 1;
            if (Sys &lt;= n) SegmentTree::DoModify(1, 1, n, Sys, n, val, opt);
        }

        void main() {
            read(n, m);
            for (int i = 1, x, y; i &lt; n; ++i) read(x, y), add(x, y), add(y, x);
            dfs1(1, 0), dfs2(1, 1);
            for (int i = 1, x, y, k, t, opt; i &lt;= m; ++i) {
                read(opt);
                if (opt == 0) read(x, y, k), ModifySubTree(x, y, k, 1), tx[i] = x, ty[i] = y, tk[i] = k;
                else if (opt == 1) read(t), ModifySubTree(tx[t], ty[t], tk[t], 0);
                else if (opt == 2) read(x), write(io_l, SegmentTree::GetAnswer(1, 1, n, dfn[x]));
            }
        }
    } // namespace TreeChainSplittin
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
    } // namespace IamJustForPlaying
} // namespace HNOI2016_Network

signed main() {
    HNOI2016_Network::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::IamJustForPlaying::TreeChainSplitting::main();
}
</code></pre>
<h1 id="24-P4211-LNOI2014-LCA"><a href="#24-P4211-LNOI2014-LCA" class="headerlink" title="24.P4211 [LNOI2014]LCA"></a>24.P4211 [LNOI2014]LCA</h1><p>给出一个n个节点的有根树（编号为0到n-1，根节点为0）。一个点的深度定义为这个节点到根的距离+1。<br>设dep[i]表示点i的深度，LCA(i,j)表示i与j的最近公共祖先。<br>有q次询问，每次询问给出l r z，求$\sum_{l \leq i \leq r}dep[LCA(i,z)]$</p>
<hr>
<p>问题可以转化为求点到根的距离+1，询问l到r的结点到根的距离和。</p>
<p>这相当于是在求结点到根的点权+1的和。</p>
<p>那么该怎么办呢？</p>
<p>显然我们可以离线得到所有的询问，然后将差分询问，也就是查询 $[1,r]-[1,l-1]$</p>
<p>我们可以在l-1和r处打标记，然后遍历树的结点有标记就执行查询操作。</p>
<p>方便起见我们可以用树链剖分来维护，时间复杂度n乘上一个Log方n。</p>
<p>(对了我的代码特别玄学，查询部分循环版本在luogu上T了，在lojA了，递归版本在luoguA了，在lojT了！)</p>
<p>(我对这份代码除了缓缓地打出一个问号也不能说什么了)</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define IT vector &lt; int &gt;::iterator
#define ForGraph int i = Head[x], y = Vert[i]; i; i = Next[i], y = Vert[i]
#define CheckSize ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define TCS TreeChainSplitting
#define CFS ChainForwardStar
#define PS ProblemSolver
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e4 + 5;
namespace ChainForwardStar {
    const int SIZE = ::SIZE;
    int tot_, Vert[SIZE];
    int Head[SIZE], Next[SIZE];

    void AddLine(int x, int y) {
        Vert[++tot_] = y;
        Next[tot_] = Head[x];
        Head[x] = tot_;
    }
} // namespace ChainForwardStar

using CFS::Head;
using CFS::Vert;
using CFS::Next;
using CFS::AddLine;

namespace TreeChainSplitting {
    const int SIZE = ::SIZE;
    const int MOD = 201314;
    int n, m, tot, d[SIZE];
    int fa[SIZE], size[SIZE];
    int son[SIZE], top[SIZE];
    int dfn[SIZE], rnk[SIZE];
    int ask[SIZE], ans[SIZE];
    vector &lt; int &gt; GFY[SIZE];
    vector &lt; int &gt; FI[SIZE];
    int sum[SIZE &lt;&lt; 2], lf[SIZE &lt;&lt; 2];

    void Prepare(int x) {
        size[x] = 1, d[x] = d[fa[x]] + 1;
        for (ForGraph)
            Prepare(y), size[x] += size[y], CheckSize;
    }

    void Prepare(int x, int tp) {
        rnk[dfn[x] = ++tot] = x, top[x] = tp;
        if (son[x]) Prepare(son[x], tp);
        for (ForGraph) if (y ^ son[x]) Prepare(y, y);
    }

    #define ls (k &lt;&lt; 1)
    #define rs (k &lt;&lt; 1 | 1)
    #define L_RECUR ls, l, mid, x, y
    #define R_RECUR rs, mid + 1, r, x, y
    #define UpdateSons(k, l, r) if (lf[k]) sum[ls] = (sum[ls] + 1LL * lf[k] * (mid - l + 1) % MOD) % MOD,                    \
                                sum[rs] = (sum[rs] + 1LL * lf[k] * (r - mid) % MOD) % MOD, lf[ls] += lf[k],                    \
                                lf[rs] += lf[k], lf[k] = 0
    #define UpdateMessages(k) sum[k] = (sum[ls] + sum[rs]) % MOD
    void ModifyChain(int k, int l, int r, int x, int y) {
        if (l &gt;= x &amp;&amp; r &lt;= y) sum[k] = (sum[k] + r - l + 1) % MOD, ++lf[k];
        else {
            UpdateSons(k, l, r);
            if (mid &gt;= x) ModifyChain(L_RECUR);
            if (mid &lt; y) ModifyChain(R_RECUR);
            UpdateMessages(k);
        }
    }

    void ModifySubTree(int x) {
        if (x) ModifyChain(1, 1, n, dfn[top[x]], dfn[x]), ModifySubTree(x = fa[top[x]]);
    }

    int QueryChain(int k, int l, int r, int x, int y, int res = 0) {
        if (l &gt;= x &amp;&amp; r &lt;= y) return sum[k];
        UpdateSons(k, l, r);
        if (mid &gt;= x) res += QueryChain(L_RECUR, 0);
        if (mid &lt; y) res += QueryChain(R_RECUR, 0);
        return res;
    }

    int QuerySubTree(int x, int res = 0) { // luogu-only 
        if (x) QuerySubTree((res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]), x = fa[top[x]]), res); else return res;
    }

//    int QuerySubTree(int x, int res = 0) { // loj-only
//        while (x) {
//            res += QueryChain(1, 1, n, dfn[top[x]], dfn[x]);
//            x = fa[top[x]];
//        }
//        return res;
//    }
} // namespace TreeChainSplitting

namespace ProblemSolver {
    void main() {
        read(TCS::n), read(TCS::m);
        for (int i = 2; i &lt;= TCS::n; ++i) read(TCS::fa[i]), AddLine(++TCS::fa[i], i);
        TCS::Prepare(1), TCS::tot = 0, TCS::Prepare(1, 1);
        int L, R;
        for (int i = 1; i &lt;= TCS::m; ++i) read(L, R, TCS::ask[i]), TCS::FI[L].push_back(i), TCS::GFY[R + 1].push_back(i), ++TCS::ask[i];
        for (int i = 1; i &lt;= TCS::n; ++i) {
            TCS::ModifySubTree(i);
            for (auto it : TCS::GFY[i]) TCS::ans[it] += TCS::QuerySubTree(TCS::ask[it]);
            for (auto it : TCS::FI[i]) TCS::ans[it] -= TCS::QuerySubTree(TCS::ask[it]);
        }
        for (int i = 1; i &lt;= TCS::m; ++i) write(io_l, (TCS::ans[i] % TCS::MOD + TCS::MOD) % TCS::MOD);
    }
} // namespace ProblemSover

signed main() {
    PS::main();
}
</code></pre>
<h1 id="25-「2018-集训队互测-Day-3」北校门外的未来"><a href="#25-「2018-集训队互测-Day-3」北校门外的未来" class="headerlink" title="25.「2018 集训队互测 Day 3」北校门外的未来"></a>25.「2018 集训队互测 Day 3」北校门外的未来</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这道题绝对是我目前来说做题用时最长的一道题（总共花了我五天时间左右）</p>
<p>说一下我这几天的心路历程吧：</p>
<blockquote>
<p>Day1:嗯？我好像发现了一道有趣的题目？洛谷上好像没有。。算了，做一下试试。。。</p>
<p>Day2:cow，这道题是道什么题？口胡一下LCT？算了算了看看题解。。。笛卡尔树是什么？？学吧学吧。。。</p>
<p>Day3：上半天：cow学不动了。。。更一下博客吧(<a href="https://www.orchid-any.cf/">广告位</a>)；下半天：继续吧。。。</p>
<p>Day4:上半天：好像有点想法了。。。完善一下。。找找锅。。；下半天(确切的说是晚上。。)：开始码咯！</p>
<p>Day5：上半天：调了5个小时后过了；下半天：写写题解咯</p>
</blockquote>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><blockquote>
<p>如果你不想阅读故事，请直接跳到题意部分。</p>
</blockquote>
<p>转眼间，已是三年流转。</p>
<p>夏日法桐的绿荫，代替了秋季的萧索，衬托着 LCR 和神犇成长的背影。</p>
<p>身后的北校门，也不再是当年学生试图摧毁的，束缚自由的枷锁，而成了青春记忆的符号。</p>
<p>又到了神犇和 LCR 相遇的地方 —— 北校门外的树下。这棵神奇的树早已不是 K 项树的形态。每时每刻，它都以新的独特方式演绎着生命。</p>
<p>谁也没有开口，他和她静静地注视着魔法般生长的自然种子。初始时，这棵树只有一个点，LCR 将其标号为 $1$。此后，每过一段时间，就会有一个新节点从原有的某个点出生长出来，LCR 会给它分配一个尚未使用过的不超过 $n$ 的正整数编号。</p>
<p>树中生活着一些小精灵。它们总停留在节点上，如果一个精灵在编号 $u$ 的节点，那么它可以一步跳到任何编号 $v$ 的满足 $u,v$ 之间的简单路径上不存在异于 $u,v$ 的编号大于 $\min(u,v)$ 的点处。</p>
<p>在观察这棵树的过程中，LCR 产生了一些疑问。她想知道，对于一对节点编号 $u,v$，从节点 $u$ 跳到节点 $v$ 最少需要几步。</p>
<p>神犇轻松地解决了这些问题。最终，树渐渐停止了生长，但神犇仍然陶醉其中。</p>
<p>一只飘渺的手搭上了神犇的肩膀。他回过头，看到 LCR 正在微笑。</p>
<p><em>“亲爱的少年，神犇君。”</em></p>
<p><em>“你是否想过，为什么精灵会依照我编号的法则而运动呢？”</em></p>
<p>神犇一时语塞。瞬间，LCR 的手变得虚幻了起来，如同明灭的火炬。</p>
<p><em>“你的成长，是这变化世界的一个切面。感谢你与我度过的时光。不要留恋 …… 我的随风飘散，正是与你们同在。”</em></p>
<p><em>“再见了，神犇君。”</em></p>
<p>LCR 消失了，神犇机械地转过身，却发现背后的树也已消失无踪。</p>
<p><em>“神犇，神犇 ……”</em> 茫然若失的神犇背后传来了渐行渐近的呼叫。神犇转过身，发现机房里的蒟蒻 LCA 正向他跑来。</p>
<p><em>“又是一年毕业季了呢。学长你还好吗？”</em></p>
<p><em>“也许吧。”</em> 神犇望向校门外的树原先的位置，<em>“LCR 走了，但她的背影会吸引着我们的人生。”</em></p>
<p>LCA 沉默了。他和神犇一同望向树消失的地方，持续片刻。</p>
<p><em>“所谓中二的幻想，才是我们相对的有限的主观能动性唯一的立场吧，不要给自己设限啊，LCA。我们去追寻她 …… 追寻自然的精灵。也许这就是我们的初心也说不定。”</em></p>
<p>这次是 LCA 目送神犇的背影渐行渐远了。</p>
<p><em>“再见了，学长。”</em></p>
<p>某少女附中，又迎来了新的一年。</p>
<p>那么，你能够回答 LCR 提出的问题吗？</p>
<hr>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>对于一棵树 $T=(V,E)$，$V$ 中每个点有一个互不相同的正整数标号。我们用点 $i$ 表示编号为 $i$ 的点。</p>
<p>定义这棵树的<strong>谷图</strong>为 $G(T)=(V,E’)$。$G(T)$ 是无向简单图。存在边 $(u,v)\in E’$ 当且仅当在 $T$ 中，不存在一个异于 $u,v$ 的点 $x$ 满足 $x$ 在从 $u$ 到 $v$ 的简单路径上且其编号大于 $\min(u,v)$。</p>
<p>有一棵树 $T$，初始时只有一个点，编号为 $1$，接下来有 $q$ 次操作，操作有以下两种：</p>
<ul>
<li>$\texttt{1 u v}$ 表示加入一个编号为 $v$ 的节点并与当前编号为 $u$ 的节点相连（保证任何时刻不会有两个编号相同的节点）；</li>
<li>$\texttt{2 u v}$ 表示查询 $G(T)$ 中点 $u$ 到 $v$ 的最短路（每条边长度均为 $1$）。</li>
</ul>
<p>请你回答所有查询。</p>
<hr>
<p>题目好长咳咳咳。。。（最关键的是我读完过后重读一遍发现背景与题目无关。。。靠!</p>
<p>不扯了说正事儿。。。</p>
<p>动态问题其实很烦人对吧？这里我们可以假设原问题为静态问题。</p>
<p>静态问题就很好处理对吧？都是显然做法。那么问题又回到动态问题，对于加点操作，事实上我的做法十分**，利用Splay的性质乱搞。打出了一个像模拟一样的东西</p>
<p>其实我也不太清楚我是怎么过的。。。因为我的做法很玄学+暴力，所以。。。大家意会一下。</p>
<p>如果实在要看题解的话，我这里有一篇，不过估计也没人能看懂，反正你看了就知道了。至于其他的题解<del>想都别想了我翻墙去隔壁Google都没找到</del>，基本上是找不<br>道的。。。<a href="https://www.codeleading.com/article/774394821/" target="_blank" rel="noopener">Link</a></p>
<p>放个代码，大家意会一下。。。(404行好评)</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define SIZE_CHECKER ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define pii pair &lt; int , int &gt;
#define pll pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
//  #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e5 + 5;
vector &lt; vector &lt; int &gt; &gt; G(SIZE);
int n, m, st[SIZE], tp, F[SIZE];
int _time[SIZE], _down[SIZE];
int OP[SIZE], U[SIZE], V[SIZE];

void init(int n) {
    for (int i = 1; i &lt;= n; ++i)
        F[i] = i;
}

int find(int x) {
    if (x ^ F[x]) F[x] = find(F[x]);
    return F[x];
}

namespace CartesianTree {
    vector &lt; vector &lt; int &gt; &gt; GCT(SIZE);
    int son[SIZE], fa[SIZE];
    int top[SIZE], size[SIZE];
    int low[SIZE], d[SIZE];
    int tot, ls[SIZE], rs[SIZE];

    void Prepare1(int x) {
        while (_time[st[tp]] &gt; _time[x] &amp;&amp; tp) _down[st[tp--]] = x;
        st[++tp] = x;
        size[x] = 1;
        d[x] = d[fa[x]] + 1;
        for (auto y : GCT[x])
            Prepare1((fa[y] = x, y)), size[x] += size[y], SIZE_CHECKER;
    }

    void Prepare2(int x) {
        ls[x] = ++tot;
        if (!top[x]) top[x] = x;
        if (!son[x]) return (void)(rs[x] = tot);
        top[son[x]] = top[x];
        for (auto y : GCT[x]) Prepare2(y);
        rs[x] = tot;
    }

    int GetLCA(int x, int y) {
        while (top[x] ^ top[y])
            d[top[x]] &gt; d[top[y]] ? x = fa[top[x]] : y = fa[top[y]];
        return d[x] &lt; d[y] ? x : y;
    }

    int Behavior(int x, int y) {
        while (top[x] ^ top[y]) if (fa[x = top[x]] ^ y) x = fa[x]; else return x;
        return son[y];
    }

    bool FindRule(int x, int y) {
        return ls[x] &lt; ls[y];
    }

    bool CheckForFun(int x, int y) {
        int std = *(upper_bound(GCT[y].begin(), GCT[y].end(), x, FindRule) - 1);
        return !(ls[low[std]] &gt; rs[x] || ls[x] &gt; ls[low[std]]);
    }

    void Main() {
        init(n);
        for (int i = 1; i &lt;= n; ++i)
            for (auto j : G[i])
                if (i &gt; find(j)) GCT[i].pub(find(j)), F[find(j)] = i;
        Prepare1(n), Prepare2(n);
        for (int i = 1; i &lt;= n; ++i)
            for (auto j : G[i])
                if (i &gt; j) low[Behavior(j, i)] = j;
    }
} // namespace CartesianTree
#define CT CartesianTree

namespace LinkCutTree {
    struct SPLAY {
        int ch[2];
        int fa;
        int sum;
        int key;
    } data[SIZE];
    int next[SIZE], root[SIZE];
    #define WhichSon(x) (data[data[x].fa].ch[1] == x)

    void UpdateMessages(int x) {
        data[x].sum = data[data[x].ch[0]].sum + data[data[x].ch[1]].sum + data[x].key;
    }

    void RotateNode(int x) {
        int y = data[x].fa, z = data[y].fa;
        int k = WhichSon(x);
        if (root[y]) root[y] = 0, root[x] = root[y] ^ 1;
        else data[z].ch[data[z].ch[1] == y] = x;
        data[x].fa = data[y].fa;
        data[y].ch[k] = data[x].ch[k ^ 1];
        if (data[y].ch[k]) data[data[x].ch[k ^ 1]].fa = y;
        data[x].ch[k ^ 1] = y;
        data[y].fa = x;
        UpdateMessages(y), UpdateMessages(x);
    }

    void SplayToRoot(int x) {
        for (int y; !root[x]; RotateNode(x))
            if (!root[y = data[x].fa])
                RotateNode(data[data[y].fa].ch[0] ^ y ^ data[y].ch[0] ^ x ? x : y);
    }

    void AccessEdge(int x) {
        for (int y = 0; x; x = data[y = x].fa) {
            SplayToRoot(x);
            if (data[x].ch[1]) root[data[x].ch[1]] = 1;
            if (data[x].ch[1] = y) root[y] = 0;
            UpdateMessages(x);
        }
    }

    void Behavior(int u, int v) {
        if (u &gt; v) {
            F[v] = u;
            data[v].fa = u;
            data[v].key = 1;
            data[v].sum = 1;
            return ;
        }
        int x = _down[v], rhs = u;
        SplayToRoot(x);
        int rsp = 0, cpy = 0, now = data[x].ch[0];
        if (now) {
            while (data[now].ch[1]) now = data[now].ch[1];
            SplayToRoot(now);
            while (data[x].fa ^ now) RotateNode(x);
            root[x] = 1;
            data[now].ch[1] = 0;
            UpdateMessages(now);
        }
        now = data[x].fa;
        if (next[now] == x) next[now] = v;
        data[v].key = data[v].sum = data[x].key;
        if (now) next[v] = x;
        SplayToRoot(x);
        data[x].fa = v;
        data[v].fa = now;
        data[x].key = 0;
        UpdateMessages(x);

        while (u) {
            SplayToRoot(u);
            if (data[u].ch[1]) root[data[u].ch[1]] = 1;
            data[u].ch[1] = rsp;
            if (data[u].ch[1]) root[rsp] = 0;
            UpdateMessages(u);
            if (data[u].sum) {
                x = u;
                while (233)
                    if (data[x].ch[1] &amp;&amp; data[data[x].ch[1]].sum) x = data[x].ch[1];
                    else if (!data[x].key) x = data[x].ch[0];
                    else break;
                SplayToRoot(x);
                if (x &gt;= v) break;
                u = data[x].ch[0];
                if (u) {
                    while (data[u].ch[1]) u = data[u].ch[1];
                    SplayToRoot(u);
                    data[u].ch[1] = 0;
                    root[x] = 1;
                    UpdateMessages(u);
                }
                else u = data[x].fa;
                if (u &gt;= v) break;
                SplayToRoot(rhs);
                if (now = data[rhs].ch[1]) root[now] = 1, data[rhs].ch[1] = 0;
                if (now = next[rhs]) {
                    SplayToRoot(now);
                    data[now].fa = u;
                    data[now].key = 1;
                    UpdateMessages(now);
                    next[rhs] = 0;
                }
                u = F[x];
                rhs = F[x];
                data[x].key = 0;
                UpdateMessages(x);
                SplayToRoot(x);
                while (data[x].ch[1]) x = data[x].ch[1];
                SplayToRoot(x);
                data[x].ch[1] = cpy;
                if (data[x].ch[1]) {
                    data[cpy].fa = x, root[cpy] = 0, data[x].ch[1] = cpy;
                    while (data[cpy].ch[0]) cpy = data[cpy].ch[0];
                    next[x] = cpy;
                    SplayToRoot(cpy);
                }
                SplayToRoot(x);
                cpy = x;
                rsp = 0;
            }
            else rsp = u, u = data[u].fa;
        }
        F[v] = F[_down[v]];
        F[_down[v]] = v;
        if (!F[v]) {
            SplayToRoot(v);
            x = v;
            while (data[x].ch[1]) x = data[x].ch[1];
            if (cpy) {
                data[x].ch[1] = cpy;
                root[cpy] = 0;
                data[cpy].fa = x;
                while (data[cpy].ch[0]) cpy = data[cpy].ch[0];
                next[x] = cpy;
                SplayToRoot(cpy);
            }
            SplayToRoot(v);
            x = data[v].ch[1];
            while (data[x].ch[0]) x = data[x].ch[0];
            data[x].key = 1;
            UpdateMessages(x);
            SplayToRoot(x);
        }
        else if (cpy) {
            x = cpy;
            while (data[x].ch[0]) x = data[x].ch[0];
            data[x].key = 1;
            UpdateMessages(x);
            SplayToRoot(x);
            data[x].fa = v;
        }
    }

    pii GetDis(int x, int t) {
        if (x ^ t) {
            AccessEdge(x);
            SplayToRoot(x);
            int st = x;
            int fir = 0, sec = 0;
            while (x)
                if (x &lt; t) sec = x, x = data[x].ch[0];
                else x = data[x].ch[1];
            SplayToRoot(sec);
            x = data[sec].ch[1];
            fir = data[x].sum;
            if (!fir) return mp(0, st);
            while (233) {
                if (data[data[x].ch[0]].sum) x = data[x].ch[0];
                else if (!data[x].key) sec = x, x = data[x].ch[1];
                else {
                    if (data[x].ch[0]) {
                        x = data[x].ch[0];
                        while (data[x].ch[1]) x = data[x].ch[1];
                        sec = x;
                    }
                    break;
                }
            }
            return mp(fir, sec);
        }
        else return mp(0, x);
    }

    int GetAnswers(int x, int y) {
        if (x ^ y) {
            if (x &gt; y) x ^= y ^= x ^= y;
            int sys = CT::GetLCA(x, y);
            if (sys ^ y) {
                pii t1 = GetDis(x, sys);
                pii t2 = GetDis(y, sys);
                return t1.fir + t2.fir + ((CT::CheckForFun(t1.sec, sys)
                     &amp;&amp; CT::CheckForFun(t2.sec, sys)) ^ 1) + 2;
            }
            else {
                pii t = GetDis(x, sys);
                return t.fir + (CT::CheckForFun(t.sec, sys) ^ 1) + 1;
            }
        }
        else return 0;
    }
} // namespace LinkCutTree
#define LCT LinkCutTree

namespace SOLVER {
    void Main() {
        read(m), read(m);
        n = 1;
        for (int i = 1; i &lt;= m; ++i) {
            read(OP[i], U[i], V[i]);
            if (OP[i] ^ 1) continue;
            G[U[i]].pub(V[i]);
            G[V[i]].pub(U[i]);
            _time[V[i]] = i;
            n = max(n, V[i]);
        }
        for (int i = 1; i &lt;= n; ++i) LCT::root[i] = true;
        CT::Main();
        F[1] = 0;
        for (int i = 1; i &lt;= m; ++i) {
            if (OP[i] ^ 2) LCT::Behavior(U[i], V[i]);
            else write(io_l, LCT::GetAnswers(U[i], V[i]));
        }
    }
}

signed main() {
    SOLVER::Main();
}
</code></pre>
<h1 id="26-P1121-环状最大两段子段和"><a href="#26-P1121-环状最大两段子段和" class="headerlink" title="26.P1121 环状最大两段子段和"></a>26.P1121 环状最大两段子段和</h1><p>给出一段环状序列，即认为$A_1$和$A_N$是相邻的，选出其中连续不重叠且非空的两段使得这两段和最大。</p>
<hr>
<p>一共三个关键词:</p>
<blockquote>
<p>环状</p>
<p>最大</p>
<p>两段子段和</p>
</blockquote>
<p>显然这是一道DP题。。。然而我们可以把它搞成线段树!</p>
<p>普通的最大子段和相信大家都能够用线段树来完成。</p>
<p>无非就是记录区间和、区间最大子段和、区间最大前缀和、区间最大后缀和</p>
<p>然后合并时更新信息即可</p>
<p>那么两段子段和该怎么搞呢?</p>
<p>其实也不费脑子<del>废笔</del></p>
<p>首先套路的讨论这两段的位置，我们可以发现有5种情况（画画图示意一下可能很丑反正意思你们能懂就行</p>
<p><img src="https://i.loli.net/2020/02/07/cM8KnGyrefCLwRk.png" alt="Annotation 2020-02-07 210659.png"></p>
<p>总结出来我们需要在线段树里维护的东西有：</p>
<ol>
<li>区间和</li>
<li>区间最大前缀</li>
<li>区间最大后缀</li>
<li>区间最大子段和</li>
<li>区间最大前缀+后缀</li>
<li>区间最大中间+后缀</li>
<li>区间最大前缀+中间</li>
<li>区间两段最大子段和</li>
</ol>
<p><del>每行长度不下降看着还是很爽的。。。</del></p>
<p>具体实现看代码中的注释</p>
<pre><code class="lang-cpp">// 省略快读和一堆预处理命令

const int SIZE = 4e5 + 5;
const int INF = ~0U &gt;&gt; 1;
struct TreeNode { // 这里的意思应该很明确
    int sum;
    int maxSum;
    int maxSumDouble;
    int maxPrefixSum;
    int maxSuffixSum;
    int maxPrePlusSuf;
    int maxPrePlusMid;
    int maxSufPlusMid;
} data[SIZE&lt;&lt;2];
int ints[SIZE&lt;&lt;1], ans = -INF, n;

TreeNode UpdateMessages(TreeNode x, TreeNode y) { // 这是重点
    TreeNode res;
    res.sum = x.sum + y.sum; // 区间和标记上传
    res.maxSum = max(x.maxSum, y.maxSum); // // 区间最大子段和标记上传
    res.maxSum = max(res.maxSum, x.maxSuffixSum + y.maxPrefixSum); // 再把自己和两个儿子的最大前/后缀和的和比较
    res.maxPrefixSum = max(x.maxPrefixSum, x.sum + y.maxPrefixSum); // 其实下面都差不多
    res.maxSuffixSum = max(y.maxSuffixSum, y.sum + x.maxSuffixSum); // 实在不懂看上面的图
    res.maxPrePlusSuf = max(x.maxPrefixSum + y.maxSuffixSum, x.sum + y.maxPrePlusSuf); // 看了就明白了。。。
    res.maxPrePlusSuf = max(res.maxPrePlusSuf, y.sum + x.maxPrePlusSuf);
    res.maxPrePlusMid = max(x.maxPrePlusMid, x.sum + y.maxPrePlusMid);
    res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrefixSum + y.maxSum);
    res.maxPrePlusMid = max(res.maxPrePlusMid, x.maxPrePlusSuf + y.maxPrefixSum);
    res.maxSufPlusMid = max(y.maxSufPlusMid, y.sum + x.maxSufPlusMid);
    res.maxSufPlusMid = max(res.maxSufPlusMid, y.sum + x.maxSum);
    res.maxSufPlusMid = max(res.maxSufPlusMid, y.maxPrePlusSuf + x.maxSuffixSum);
    res.maxSumDouble = max(x.maxSumDouble, y.maxSumDouble);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSum + y.maxSum);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSufPlusMid + y.maxPrefixSum);
    res.maxSumDouble = max(res.maxSumDouble, x.maxSuffixSum + y.maxPrePlusMid);
    return res;
}

void Initialization(int k, int l) { // 给线段树结点赋初值
    data[k].sum = data[k].maxPrefixSum = data[k].maxSuffixSum = data[k].maxSum = ints[l];
    data[k].maxSumDouble = data[k].maxPrePlusSuf = data[k].maxPrePlusMid = data[k].maxSufPlusMid = -INF;
} 

void BuildTree(int k, int l, int r) {
    if (l ^ r) BuildTree(ls, l, mid), BuildTree(rs, mid + 1, r), data[k] = UpdateMessages(data[ls], data[rs]);
    else Initialization(k, l);
}

TreeNode GetAnswers(int k, int l, int r, int x, int y) {
    if (l ^ x || r ^ y) {
        if (mid &gt;= y) return GetAnswers(ls, l, mid, x, y);
        if (mid &lt; x) return GetAnswers(rs, mid + 1, r, x, y);
        return UpdateMessages(GetAnswers(ls, l, mid, x, mid), GetAnswers(rs, mid + 1, r, mid + 1, y));
    } else return data[k];
}

signed main() {
    read(n);
    for (int i = 1; i &lt;= n; ++i) read(ints[i]), ints[i + n] = ints[i];
    BuildTree(1, 1, n &lt;&lt; 1);
    for (int i = 1; i &lt;= n; ++i) ans = max(ans, GetAnswers(1, 1, n &lt;&lt; 1, i, i + n - 1).maxSumDouble);
    write(io_l, ans);
}
</code></pre>
<h1 id="27-【中午的题目】分糖果"><a href="#27-【中午的题目】分糖果" class="headerlink" title="27.【中午的题目】分糖果"></a>27.【中午的题目】分糖果</h1><p>小 Z 带着新买的糖果来拜访舅舅家，舅舅家的 $K$ 个孩子看见小 Z 带着糖果来拜访变得欣喜若狂，他们都希望吃到好吃的糖果。正当小 Z 准备给 $K$ 个孩子分糖果时，舅舅却让小 Z 尽量少分点，免得孩子们蛀牙。</p>
<p>小 Z 带来的糖果比较特别，一共有 $N$ 个糖果连成一串，编号为 $1\ldots N$，第 $i$ 个糖果有一个数值 $a[i]$ 表示蛀牙的可能性，数值越大的糖果越容易导致蛀牙，多个糖果的蛀牙值认为是各个糖果的蛀牙值之和。</p>
<p>现在小 Z 打算取 $N$ 个糖果的前若干个，分成 $K$ 段分给 $K$ 个孩子。小 Z 好奇，他该怎么分糖果，才能使得分到糖果蛀牙值最大的孩子尽可能不蛀牙</p>
<hr>
<p>首先暴力做法显然。</p>
<p>首先前缀和然后对前缀和离散化</p>
<p>二分答案然后check里面dp，$dp_i$ 为区间 $[1,i]$ 最多能分成的块数。</p>
<p>dp方程显然为 $dp_i=max{dp_j}+1$。</p>
<p>这样转移是 $\Theta(n^2)$ 的，显然T飞。</p>
<p>考虑树状数组优化，需要区间最大值和单点修改操作。</p>
<p>时间复杂度 $\Theta(n\log^2n)$</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define ls (k &lt;&lt; 1)
#define rs (k &lt;&lt; 1 | 1)
#define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define PII pair &lt; __int64 , __int64 &gt;
#define PLL pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
#define R register

using namespace std;
#ifndef __int8
    typedef char __int8;
#endif
#ifndef __uint8
    typedef unsigned char __uint8;
#endif
#ifndef __int16
    typedef short __int16;
#endif
#ifndef __uint16
    typedef unsigned short __uint16;
#endif
#ifndef __int32
    typedef int __int32;
#endif
#ifndef __int64
    typedef long long __int64;
#endif
#ifndef __uint32
    typedef unsigned int __uint32;
#endif
#ifndef __uint64
    typedef unsigned long long __uint64;
#endif

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const __int64 SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    __int64 fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register __int64 i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const __int64 SIZE = 1e6 + 5;
const __int64 INF = 0x7fffffff;
__int64 a[SIZE], bit[SIZE];
__int64 dp[SIZE], n, k, T;
vector &lt; __int64 &gt; disc;

void add(__int64 x, __int64 y) { for (; x &gt; 0; x -= x &amp; -x) bit[x] = max(bit[x], y); }
__int64 ask(__int64 x, __int64 lim, __int64 res = -INF) { for (; x &lt; lim; x += x &amp; -x) res = max(res, bit[x]); return res; }

void Discretization(__int64 x) {
    disc.clear();
    disc.pb(0);
    for (__int64 i = 1; i &lt;= n; ++i) disc.pb(a[i]);
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
} 

bool Check(__int64 x) {
    Discretization(x);
    for (__int64 i = 1; i &lt;= (__int64)disc.size(); ++i) {
        for (__int64 j = i; j &lt; (__int64)disc.size(); j += j &amp; -j) bit[i] = -INF;
        for (__int64 j = i; j &gt; 0; j -= j &amp; -j) bit[i] = -INF;
    }
    *dp = 0;
    add(lower_bound(disc.begin(), disc.end(), 0) - disc.begin() + 1, *dp);
    for (__int64 i = 1; i &lt;= n; ++i) {
        dp[i] = ask(lower_bound(disc.begin(), disc.end(), a[i] - x) - disc.begin() + 1, disc.size() + 1) + 1;
        add(lower_bound(disc.begin(), disc.end(), a[i]) - disc.begin() + 1, dp[i]);
        if (k &lt;= dp[i]) return 1;
    }
    return 0;
}

signed main() {
    for (read(T); T; --T) {
        read(n, k);
        for (__int64 i = 1; i &lt;= n; ++i) read(a[i]), a[i] += a[i - 1];
        __int64 l = -INF * SIZE, r = SIZE * INF;
        while (l &lt; r - 1)
            if (Check(mid)) r = mid;
            else l = mid;
        write(io_l, r);
    }
    return 0;
}
</code></pre>
<h1 id="28-P2163-SHOI2007-园丁的烦恼"><a href="#28-P2163-SHOI2007-园丁的烦恼" class="headerlink" title="28.P2163 [SHOI2007]园丁的烦恼"></a>28.P2163 [SHOI2007]园丁的烦恼</h1><p>很久很久以前，在遥远的大陆上有一个美丽的国家。统治着这个美丽国家的国王是一个园艺爱好者，在他的皇家花园里种植着各种奇花异草。</p>
<p>有一天国王漫步在花园里，若有所思，他问一个园丁道： “最近我在思索一个问题，如果我们把花坛摆成六个六角形，那么……”</p>
<p>“那么本质上它是一个深度优先搜索，陛下”，园丁深深地向国王鞠了一躬。</p>
<p>“嗯……我听说有一种怪物叫九头蛇，它非常贪吃苹果树……”</p>
<p>“是的，显然这是一道经典的动态规划题，早在N元4002年我们就已经发现了其中的奥秘了，陛下”。</p>
<p>“该死的，你究竟是什么来头？”</p>
<p>“陛下息怒，干我们的这行经常莫名其妙地被问到和OI有关的题目，我也是为了预防万一啊！” 王者的尊严受到了伤害，这是不可容忍的。</p>
<p>看来一般的难题是难不倒这位园丁的，国王最后打算用车轮战来消耗他的实力： “年轻人，在我的花园里的每一棵树可以用一个整数坐标来表示，一会儿，我的骑士们会来轮番询问你某一个矩阵内有多少树，如果你不能立即答对，你就准备走人吧！”说完，国王气呼呼地先走了。</p>
<p>这下轮到园丁傻眼了，他没有准备过这样的问题。所幸的是，作为“全国园丁保护联盟”的会长——你，可以成为他的最后一根救命稻草。</p>
<hr>
<p>。。。居然没有看到主席树题解。</p>
<p>这差不多就是一道主席树的板题了。</p>
<p>首先对x排序，然后动态开点一个一个的insert进去。</p>
<p>对于询问直接就二分取出横轴的范围l和r</p>
<p>然后询问root[r]-root[l-1]就好了</p>
<pre><code class="lang-cpp">#pragma GCC diagnostic error &quot;-std=c++11&quot;
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define ls (data[rt].l)
#define rs (data[rt].r)
#define SIZE_CHECKER(x, y) ((size[son[x]] &lt; size[y]) &amp;&amp; (son[x] = y))
#define PII pair &lt; int , int &gt;
#define PLL pair &lt; LL, LL &gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pb push_back
#define R register

using namespace std;
#ifndef __int8
    typedef char __int8;
#endif
#ifndef __uint8
    typedef unsigned char __uint8;
#endif
#ifndef __int16
    typedef short __int16;
#endif
#ifndef __uint16
    typedef unsigned short __uint16;
#endif
#ifndef __int32
    typedef int __int32;
#endif
#ifndef __int64
    typedef long long __int64;
#endif
#ifndef __uint32
    typedef unsigned int __uint32;
#endif
#ifndef __uint64
    typedef unsigned long long __uint64;
#endif

#define io_e &#39;\0&#39;
#define io_s &#39; &#39;
#define io_l &#39;\n&#39;
 #define _DEBUG_ 1 // debug toggle
namespace Fast_IO {
    #ifndef _DEBUG_
        #define gc() (iS == iT ? (iT = (iS = ibuff) + fread(ibuff, 1, SIZ, stdin), (iS == iT ? EOF : *iS++)) : *iS++)
    #else
        #define gc() getchar()
    #endif
    const int SIZ = 1 &lt;&lt; 21 | 1;
    char *iS, *iT, ibuff[SIZ], obuff[SIZ], *oS = obuff, *oT = oS + SIZ - 1, fu[110], c;
    int fr;
    inline void ioout() {
        fwrite(obuff, 1, oS - obuff, stdout);
        oS = obuff;
    }
    template &lt;class Type&gt;
    inline void read(Type&amp; x) {
        x = 0;
        Type y = 1;
        for (c = gc(); (c &gt; &#39;9&#39; || c &lt; &#39;0&#39;) &amp;&amp; c ^ &#39;-&#39;; c = gc())
            ;
        c == &#39;-&#39; ? y = -1 : x = (c &amp; 15);
        for (c = gc(); c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;; c = gc()) x = x * 10 + (c &amp; 15);
        x *= y;
    }
    inline bool blank(char ch) { return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;; }
    inline void read(char* s) {
        register char ch = gc();
        for (; blank(ch); ch = gc())
            ;
        for (; !blank(ch); ch = gc()) *s++ = ch;
        *s = 0;
    }
    inline void read(char&amp; c) {
        for (c = gc(); blank(c); c = gc())
            ;
    }
    template &lt;typename Type, typename... Args&gt;
    inline void read(Type&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char* t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;typename... Args&gt;
    inline void read(char&amp; t, Args&amp;... args) {
        read(t), read(args...);
    }
    template &lt;class Type&gt;
    inline void write(char lastChar, Type x) {
        if (x &lt; 0)
            *oS++ = &#39;-&#39;, x = -x;
        if (x == 0)
            *oS++ = &#39;0&#39;;
        while (x) fu[++fr] = x % 10 + &#39;0&#39;, x /= 10;
        while (fr) *oS++ = fu[fr--];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x[]) {
        for (register int i = 0; x[i]; ++i) *oS++ = x[i];
        *oS++ = lastChar;
        ioout();
    }
    inline void write(char lastChar, char x) {
        *oS++ = x;
        *oS++ = lastChar;
        ioout();
    }
    template &lt;typename Type, typename... Args&gt;
    inline void write(char midChar, Type t, Args... args) {
        write(midChar, t), write(midChar, args...);
    }
}  // namespace Fast_IO

using Fast_IO::read;
using Fast_IO::write;

const int SIZE = 5e5 + 5;
const int INF = 1e7;
int n, m, tot, rt[SIZE];
struct TreeNode {
    int l, r;
    int sum;
} data[SIZE &lt;&lt; 5];
struct TwoNode {
    int x, y;
} ints[SIZE];
struct BinarySeach {
    int upper_bound(int x) {
        int l = 1, r = n + 1;
        while (l &lt; r - 1) if (ints[mid].x &gt; x) r = mid; else l = mid;
        return l;
    }

    int lower_bound(int x) {
        int l = 0, r = n;
        while (l &lt; r - 1) if (ints[mid].x &gt;= x) r = mid; else l = mid;
        return r;
    }
} BS;

bool cmp(const TwoNode&amp; x, const TwoNode&amp; y) {
    return x.x &lt; y.x;
}

void update(int &amp;rt, int l, int r, int x) {
    data[++tot] = data[rt];
    ++data[rt = tot].sum;
    if (l ^ r) if (mid &gt;= x) update(ls, l, mid, x); else update(rs, mid + 1, r, x); else return ;
}

int queryf(int rt, int l, int r, int x, int y) {
    if (l &gt; y || r &lt; x || !rt) return 0;
    else if (l &gt;= x &amp;&amp; r &lt;= y) return data[rt].sum;
    else return queryf(ls, l, mid, x, y) + queryf(rs, mid + 1, r, x, y);
}

signed main() {
    read(n, m);
    for (int i = 1; i &lt;= n; ++i) read(ints[i].x, ints[i].y);
    sort(ints + 1, ints + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i) update(rt[i] = rt[i - 1], 0, INF, ints[i].y);
    for (int i = 1, a, b, c, d; i &lt;= m; ++i) {
        read(a, b, c, d);
        write(io_l, queryf(rt[BS.upper_bound(c)], 0, INF, b, d) - queryf(rt[BS.lower_bound(a) - 1], 0, INF, b, d));
    }
    return 0;
}
</code></pre>
<h1 id="29-P5220-特工的信息流"><a href="#29-P5220-特工的信息流" class="headerlink" title="29.P5220 特工的信息流"></a>29.P5220 特工的信息流</h1><p>$\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。<br>以及，每个城市都有一个信息流的流量 $a_i$。</p>
<p>$\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：<br>第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。<br>每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。<br>我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。</p>
<p>请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。</p>
<p>此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。</p>
<p>他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。</p>
<hr>
<h3 id="WGY：LCT"><a href="#WGY：LCT" class="headerlink" title="WGY：LCT"></a>WGY：LCT</h3><p>这道题的题意是真的绕，我前前后后读了不下五遍才大概意会。。。</p>
<p>做数据结构的题一般都要先浓缩题意。这道题是让我们求后缀积之和，再加上修改操作就基本上确定用LCT了</p>
<p>需要维护的信息有前缀积之和,后缀积之和，区间乘法三个信息。</p>
<p>对于修改操作，直接上LCT的套路makeroot和access。</p>
<p>对于询问操作，我们直接按照LCT的套路用makeroot和access把链给搞出来。</p>
<p>其实这就相当于一道LCT的板题吧。。。全部都是基础操作。。。</p>
<p>完整代码在这里<a href="https://paste.ubuntu.com/p/tsQ43Pvvg6/" target="_blank" rel="noopener">Link</a></p>
<p>如果链接失效了就这个<a href="https://www.luogu.com.cn/paste/gtishzfw" target="_blank" rel="noopener">Link</a></p>
<pre><code class="lang-cpp">const int SIZE = 1e5 + 5;
const int M_SIZE = 2e5 + 5;
const int MOD = 20924;
int head[M_SIZE], nxt[M_SIZE];
int to[M_SIZE], ints[SIZE];
int waste[SIZE], n, m, top, tot;
struct SPLAY {
    int fa;
    int ch[2];
    int prod;
    int preprod;
    int sufprod;
    int lztg;
} data[SIZE];

void AddEdge(int x, int y) {
    to[++tot] = y;
    nxt[tot] = head[x];
    head[x] = tot;
}

bool IsRoot(int x) {
    return ((data[data[x].fa].ch[1] ^ x) &amp;&amp; (data[data[x].fa].ch[0] ^ x));
}

bool WhichSon(int x) {
    return (data[data[x].fa].ch[1] == x);
}

void UpdateMessages(int x) {
    data[x].prod = data[data[x].ch[0]].prod * data[data[x].ch[1]].prod % MOD * ints[x] % MOD;
    data[x].preprod = (data[data[x].ch[0]].preprod + data[data[x].ch[0]].prod * ints[x] + data[data[x].ch[0]].prod * ints[x] % MOD * data[data[x].ch[1]].preprod) % MOD;
    data[x].sufprod = (data[data[x].ch[1]].sufprod + data[data[x].ch[1]].prod * ints[x] + data[data[x].ch[1]].prod * ints[x] % MOD * data[data[x].ch[0]].sufprod) % MOD;
}

void UpdateSons(int x) {
    if (data[x].lztg) {
        swap(data[data[x].ch[0]].ch[0], data[data[x].ch[0]].ch[1]);
        swap(data[data[x].ch[1]].ch[0], data[data[x].ch[1]].ch[1]);
        swap(data[data[x].ch[0]].preprod, data[data[x].ch[0]].sufprod);
        swap(data[data[x].ch[1]].preprod, data[data[x].ch[1]].sufprod);
        data[data[x].ch[0]].lztg ^= 1;
        data[data[x].ch[1]].lztg ^= 1;
        data[x].lztg = 0;
    }
}

void RotateNode(int x) {
    int y = data[x].fa;
    int z = data[y].fa;
    int k = WhichSon(x);
    if (!IsRoot(y)) data[z].ch[WhichSon(y)] = x;
    data[y].fa = x;
    data[data[y].fa].fa = z;
    if (data[x].ch[k ^ 1]) data[data[x].ch[k ^ 1]].fa = y;
    data[y].ch[k] = data[x].ch[k ^ 1];
    data[x].ch[k ^ 1] = y;
    UpdateMessages(y);
}

void SplayToRoot(int x) {
    int y = waste[top = 1] = x;
    while (!IsRoot(y)) waste[++top] = y = data[y].fa;
    while (top) UpdateSons(waste[top--]);
    for (; !IsRoot(x); RotateNode(x))
        if (!IsRoot((y = data[x].fa)))
            RotateNode((data[data[y].fa].ch[1] ^ y ^ data[y].ch[1] ^ x) ? x : y);
    UpdateMessages(x);
}

void AccessEdge(int x) {
    for (int y = 0; x; x = data[y = x].fa) {
        SplayToRoot(x);
        data[x].ch[1] = y;
        UpdateMessages(x);
    }
}

void MakeRoot(int x) {
    AccessEdge(x);
    SplayToRoot(x);
    swap(data[x].ch[0], data[x].ch[1]);
    swap(data[x].preprod, data[x].sufprod);
    data[x].lztg ^= 1;
    UpdateMessages(x);
}

void SplitTree(int x, int y) {
    MakeRoot(x);
    AccessEdge(y);
    SplayToRoot(y);
}

void Prepare(int x) {
    data[x].prod = ints[x];
    data[x].preprod = ints[x];
    data[x].sufprod = ints[x];
    for (int i = head[x]; i; i = nxt[i])
        if (to[i] ^ data[x].fa)
            data[to[i]].fa = x, Prepare(to[i]);
}

int GetAnswers(int x, int y) {
    SplitTree(x, y);
    UpdateSons(y);
    return data[y].sufprod;
}

void Behavior(int x, int y) {
    SplitTree(x, x);
    ints[x] += y;
    ints[x] %= MOD;
    data[x].prod = ints[x];
    data[x].preprod = ints[x];
    data[x].sufprod = ints[x];
}

signed main() {
    read(n, m);
    for (int i = 1; i &lt;= n; ++i) read(ints[i]);
    for (int i = 1, x, y; i &lt; n; ++i) read(x, y), AddEdge(x, y), AddEdge(y, x);
    (*data).prod = 1;
    Prepare(1);
    for (int i = 0, x, y; i &lt; m; ++i) {
        char opt[5];
        read(opt);
        read(x, y);
        if (*opt ^ &#39;C&#39;) write(io_l, GetAnswers(x, y));
        else Behavior(x, y);
    }
    return 0;
}
</code></pre>
<h3 id="LYC-TCS"><a href="#LYC-TCS" class="headerlink" title="LYC:TCS"></a>LYC:TCS</h3><pre><code class="lang-cpp">// 无情的LYC咕掉了这篇题解，快去打他！！！
</code></pre>
<h1 id="30-P5350-序列"><a href="#30-P5350-序列" class="headerlink" title="30.P5350 序列"></a>30.P5350 序列</h1><p>有一个序列$a_n$和若干操作。</p>
<ul>
<li>$\mathrm{1\  l \  r \ }$ 求$a_l$到$a_r$的和 </li>
<li>$\mathrm{2\  l \  r \ val \ }$ 将$a_l$到$a_r$赋值为$\mathrm{val}$ </li>
<li>$\mathrm{3\  l \  r \ val\ }$将$a_l$到$a_r$加上$\mathrm{val}$ </li>
<li>$\mathrm{4\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$复制到$a_{l_2}$到$a_{r_2}$处 </li>
<li>$\mathrm{5\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$与$a_{l_2}$到$a_{r_2}$交换 </li>
<li>$\mathrm{6\  l \  r \ }$将$a_l$到$a_r$翻转 </li>
</ul>
<hr>
<p>这道题有了区间推平基本就没什么悬念了。ODT，上！（雾</p>
<p>具体讲一下吧</p>
<p>求和操作、区间赋值操作、区间加法没什么技术含量，数据结构100题里有ODT，请自行翻阅。</p>
<p>区间反转也很显然，不再赘述。</p>
<p>复制区间操作，我们直接split出l1,r1,l2,l2，然后把复制看作删除l2,r2，把l1,r1放在上面。即l1,r1,val —&gt; l2-l1+l,l2-l1+r,val。</p>
<p>交换区间操作，本质就是复制区间操作做两次。</p>
<p>Code:</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;set&gt;

using namespace std;
typedef long long LL;

const int SIZE = 5e5 + 5;
const int MOD = 1e9 + 7;

char buf[1 &lt;&lt; 21], *p1 = buf, *p2 = buf;
#ifndef ONLINE_JUDGE
#define gc() getchar()
#else
#define gc() (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 1 &lt;&lt; 21, stdin), p1 == p2) ? EOF : *p1++)
#endif
#define is_number (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;)

template &lt; typename Type &gt;
void read(Type&amp; a) {
    a = 0; bool f = 0; char ch;
    while (!(ch = gc(), is_number)) if (ch == &#39;-&#39;) f = 1;
    while (is_number) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = gc();
    a = (f ? -a : a);
}

template &lt; typename Type, typename... Args &gt;
void read(Type&amp; t, Args&amp;... args) {
    read(t), read(args...);
}

struct CHTHOLLY {
    int l, r;
    mutable LL val;
    friend bool operator &lt; (const CHTHOLLY&amp; x, const CHTHOLLY&amp; y) {
        return x.l &lt; y.l;
    }
} a[SIZE], b[SIZE];
int n, q;
set &lt; CHTHOLLY &gt; st;
#define IT set &lt; CHTHOLLY &gt;::iterator

void split(int l, int r) {
    IT it = --st.upper_bound({l, l, 0});
    CHTHOLLY t = *it;
    if ((*it).l != l) st.erase(it), st.insert({t.l, l - 1, t.val}), st.insert({l, t.r, t.val});
    it = --st.upper_bound({r, r, 0});
    t = *it;
    if ((*it).r != r) st.erase(it), st.insert({t.l, r, t.val}), st.insert({r + 1, t.r, t.val});
}

void assign(int l, int r, int key) {
    split(l, r);
    st.erase(st.lower_bound({l, l, 0}), st.upper_bound({r, r, 0}));
    st.insert({l, r, key});
}

int queryf(int l, int r) {
    LL res = 0;
    split(l, r);
    IT it = st.lower_bound({l, l, 0});
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) res = (res + (*it).val * ((*it).r - (*it).l + 1)) % MOD;
    return res;
}

void update(int l, int r, int key) {
    split(l, r);
    IT it = st.lower_bound({l, l, 0});
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) (*it).val = ((*it).val + key) % MOD;
}

void copy(int l1, int r1, int l2, int r2) {
    split(l1, r1);
    split(l2, r2);
    st.erase(st.lower_bound({l2, l2, 0}), st.upper_bound({r2, r2, 0}));
    IT it = st.lower_bound({l1, l1, 0});
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r1; ++it) st.insert({l2 + (*it).l - l1, l2 + (*it).r - l1, (*it).val});
}

void exchange(int l1, int r1, int l2, int r2) {
    split(l1, r1);
    split(l2, r2);
    IT it = st.lower_bound({l1, l1, 0});
    int lenx = 0, leny = 0;
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r1; ++it) a[++lenx] = *it;
    it = st.lower_bound({l2, l2, 0});
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r2; ++it) b[++leny] = *it;
    st.erase(st.lower_bound({l1, l1, 0}), st.upper_bound({r1, r1, 0}));
    st.erase(st.lower_bound({l2, l2, 0}), st.upper_bound({r2, r2, 0}));
    for (int i = 1; i &lt;= lenx; ++i) st.insert({l2 - l1 + a[i].l, l2 - l1 + a[i].r, a[i].val});
    for (int i = 1; i &lt;= leny; ++i) st.insert({l1 - l2 + b[i].l, l1 - l2 + b[i].r, b[i].val});
}

void reverse(int l, int r) {
    split(l, r);
    IT it = st.lower_bound({l, l, 0});
    int lim = 0;
    for (; it != st.end() &amp;&amp; (*it).r &lt;= r; ++it) a[++lim] = *it;
    st.erase(st.lower_bound({l, l, 0}), st.upper_bound({r, r, 0}));
    for (int i = lim; i; --i) st.insert({l + r - a[i].r, l + r - a[i].l, a[i].val});
}

void Imomonalse() {
    int opt, l, r, l0, r0, key;
    read(opt, l, r);
    if (opt == 1) printf(&quot;%d\n&quot;, queryf(l, r));
    else if (opt == 2) read(key), assign(l, r, key);
    else if (opt == 3) read(key), update(l, r, key);
    else if (opt == 4) read(l0, r0), copy(l, r, l0, r0);
    else if (opt == 5) read(l0, r0), exchange(l, r, l0, r0);
    else if (opt == 6) reverse(l, r);
}

void init() {
    read(n, q);
    for (int i = 1, x; i &lt;= n; ++i) read(x), st.insert({i, i, x});
    for (int i = 0; i &lt; q; ++i) Imomonalse();
}

void write() {
    IT it = st.begin();
    for (; it != st.end(); ++it)
        for (int i = (*it).l; i &lt;= (*it).r; ++i)
            printf(&quot;%lld &quot;, (*it).val);
}

signed main() {
    init();
    write();
}
</code></pre>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/08/DS100P-11-20-P/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/DS100P-11-20-P/" itemprop="url">数据结构100题 11~20题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T14:03:29+08:00">2020-02-08</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Solution/" itemprop="url" rel="index"><span itemprop="name">Solution</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-32.png" rel="gallery_ck8wtuwty000jxgvrjfgiujrm" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn@1.2/images/posts/post-32.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="11-P3203-HNOI2010-弹飞绵羊"><a href="#11-P3203-HNOI2010-弹飞绵羊" class="headerlink" title="11.P3203 [HNOI2010]弹飞绵羊"></a>11.P3203 [HNOI2010]弹飞绵羊</h1><p>某天，$Lostmonkey$ 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。  </p>
<p>游戏一开始，$Lostmonkey$ 在地上沿着一条直线摆上 $n$ 个装置，每个装置设定初始弹力系数 $k_i$，当绵羊达到第 $i$ 个装置时，它会往后弹 $k_i$ 步，达到第 $i+k_i$ 个装置，若不存在第 $i+k_i$ 个装置，则绵羊被弹飞。  </p>
<p>绵羊想知道当它从第 $i$ 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，$Lostmonkey$ 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。</p>
<hr>
<p>每个弹力装置只会对应一个位置可以弹到，也就是说我们可以把它看作一条边，而且不会有环这种**玩意。</p>
<p>对于修改弹力系数，我们可以用断边连边来维护</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

const int SIZE = 2e5 + 5;
class LinkCutTree {
public:
    struct SPLAY {
        int val;
        int fa;
        int ch[2];
    } T[SIZE];
    inline bool isroot(int x) { return !(T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); }
    inline void push(int x) { T[x].val = T[T[x].ch[0]].val + T[T[x].ch[1]].val + 1; }
    inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, k = T[y].ch[1] == x, w = T[x].ch[!k]; (isroot(y)) &amp;&amp; (T[z].ch[T[z].ch[1] == y] = x); T[x].ch[!k] = y, T[y].ch[k] = w; (w) &amp;&amp; (T[w].fa = y); T[y].fa = x; T[x].fa = z; push(y); }
    inline void splay(int x) { for(; isroot(x); rotate(x)) { int y = T[x].fa, z = T[y].fa; (isroot(y)) &amp;&amp; (rotate(T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ?  x : y), 1); } push(x); }
    inline void access(int x) { for(int y = 0; x; x = T[y = x].fa) splay(x), T[x].ch[1] = y, push(x); }
} lct_mast;
int n, m;

signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    for(int i = 1, s; i &lt;= n; ++i) {
        lct_mast.T[i].val = 1;
        scanf(&quot;%d&quot;, &amp;s);
        (i + s &lt;= n) &amp;&amp; (lct_mast.T[i].fa = i + s);
    }
    for(scanf(&quot;%d&quot;, &amp;m); m; --m) {
        int opt, x, y;
        scanf(&quot;%d&quot;, &amp;opt), scanf(&quot;%d&quot;, &amp;x);
        if (opt ^ 2) {
            lct_mast.access(x + 1);
            lct_mast.splay(x + 1);
            printf(&quot;%d\n&quot;, lct_mast.T[x + 1].val);
        } else {
            scanf(&quot;%d&quot;, &amp;y);
            lct_mast.access(x + 1);
            lct_mast.splay(x + 1);
            lct_mast.T[x + 1].ch[0] = lct_mast.T[lct_mast.T[x + 1].ch[0]].fa = 0;
            (x + y + 1 &lt;= n) &amp;&amp; (lct_mast.T[x + 1].fa = x + y + 1);
            lct_mast.push(x + 1);
        }
    }
    return 0;
}
</code></pre>
<h1 id="12-SP4487-GSS6-Can-you-answer-these-queries-VI"><a href="#12-SP4487-GSS6-Can-you-answer-these-queries-VI" class="headerlink" title="12.SP4487 GSS6 - Can you answer these queries VI"></a>12.SP4487 GSS6 - Can you answer these queries VI</h1><p>The first line of the input contains an integer N.<br>The following line contains N integers, representing the starting<br>sequence A1..AN, _(|Ai| &lt;= 10000)_.  </p>
<p>The third line contains an integer Q. The next Q lines contains the operations in following form:  </p>
<p><strong>I x y</strong>: insert element y at position x _(between x - 1 and x)_.<br><strong>D x</strong> : delete the element at position x.<br><strong>R x y</strong>: replace element at position x with y.<br><strong>Q x y</strong>: print max{Ai + Ai+1 + .. + Aj | x &lt;= i &lt;= j &lt;= y}.  </p>
<p>All given positions are valid, and given values are between -10000 and +10000.  </p>
<p>The sequence will never be empty.</p>
<hr>
<p>这道题显然是一道平衡树的裸题，唯一的难度就是求最大子段和。</p>
<p>可以类比线段树维护最大子段和，维护$lmax$以x为根的前缀最大和、$rmax$以x为根的后缀最大和、$maxsum$最大子段和以及$sum$总和</p>
<p>对于$Update$我们可以对是否有左右孩子做讨论。</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;queue&gt;
#include &lt;utility&gt;

using namespace std;

const int SIZE = 2e5 + 5;
int n, m, tot, root, a[SIZE];
struct SPLAY {
    int fa;
    int ch[2];
    int siz;
    int val;
    int sum;
    int lmax;
    int rmax;
    int maxsum;
} T[SIZE];
vector &lt; int &gt; st;

inline int newnode(int v = 0) {
    int x;
    if (st.empty()) x = ++tot;
    else x = st.back(), st.pop_back();
    T[x].fa = T[x].ch[0] = T[x].ch[1] = 0;
    T[x].siz = 1;
    T[x].val = T[x].sum = T[x].maxsum = v;
    T[x].lmax = T[x].rmax = max(v, 0);
    return x;
}

inline void delnode(int x) {
    T[x].fa = T[x].ch[0] = T[x].ch[1] = 0;
    T[x].sum = T[x].lmax = T[x].rmax = T[x].maxsum = 0;
    T[x].siz = 1;
    st.push_back(x);
}

inline bool which(int x) {
    if (T[T[x].fa].ch[0] == x) return 0;
    if (T[T[x].fa].ch[1] == x) return 1;
    return -1;
}

inline void update(int x) {
    T[x].sum = T[x].val; T[x].siz = 1;
    if (T[x].ch[0]) T[x].sum += T[T[x].ch[0]].sum, T[x].siz += T[T[x].ch[0]].siz;
    if (T[x].ch[1]) T[x].sum += T[T[x].ch[1]].sum, T[x].siz += T[T[x].ch[1]].siz;
    if (T[x].ch[0] &amp;&amp; T[x].ch[1]) {
        T[x].lmax = max(T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val + T[T[x].ch[1]].lmax);
        T[x].rmax = max(T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val + T[T[x].ch[0]].rmax);
        T[x].maxsum = max({T[T[x].ch[0]].maxsum, T[T[x].ch[1]].maxsum, T[T[x].ch[0]].rmax + T[x].val + T[T[x].ch[1]].lmax});
    } else if (T[x].ch[0]) {
        T[x].lmax = max({T[T[x].ch[0]].lmax, T[T[x].ch[0]].sum + T[x].val, 0});
        T[x].rmax = max(T[x].val + T[T[x].ch[0]].rmax, 0);
        T[x].maxsum = max(T[T[x].ch[0]].maxsum, T[T[x].ch[0]].rmax + T[x].val);
    } else if (T[x].ch[1]) {
        T[x].lmax = max(T[x].val + T[T[x].ch[1]].lmax, 0);
        T[x].rmax = max({T[T[x].ch[1]].rmax, T[T[x].ch[1]].sum + T[x].val, 0});
        T[x].maxsum = max(T[T[x].ch[1]].maxsum, T[T[x].ch[1]].lmax + T[x].val);
    } else {
        T[x].maxsum = T[x].val;
        T[x].lmax = T[x].rmax = max(T[x].val, 0);
    }
}

inline void rotate(int x) {
    if (!x) return;
    int w = which(x), y = T[x].fa;
    if (~which(y)) T[T[y].fa].ch[which(y)] = x;
    T[x].fa = T[y].fa;
    T[y].ch[w] = T[x].ch[w ^ 1];
    if (T[x].ch[w ^ 1]) T[T[x].ch[w ^ 1]].fa = y;
    T[x].ch[w ^ 1] = y;
    T[y].fa = x;
    update(y), update(x);
}
inline void splay(int x, int &amp;goal) {
    if (x == goal) return;
    int p = T[goal].fa;
    for (int y; T[x].fa ^ p; rotate(x)) y = T[x].fa, (T[y].fa ^ p) &amp;&amp; (rotate(which(y) ^ which(x) ? x : y), 1);
    goal = x;
}

inline int kth_element(int x, int k) {
    while (233) {
        if (T[x].ch[0] &amp;&amp; k &lt;= T[T[x].ch[0]].siz) x = T[x].ch[0];
        else {
            if (T[x].ch[0]) k -= T[T[x].ch[0]].siz;
            if (!--k) return x;
            x = T[x].ch[1];
        }
    }
}

inline void insert(int &amp;rt, int p, int val) {
    int x = kth_element(rt, p);
    splay(x, rt);
    int y = kth_element(rt, p + 1);
    splay(y, T[rt].ch[1]);
    T[y].ch[0] = newnode(val);
    T[T[y].ch[0]].fa = y;
    update(T[y].ch[0]);
    update(y), update(x);
}

inline void erase(int &amp;rt, int p) {
    int y = kth_element(rt, p);
    splay(y, rt);
    int x = kth_element(rt, p + 1);
    splay(x, T[rt].ch[1]);
    int z = T[x].ch[1];
    T[z].fa = y;
    T[y].ch[1] = z;
    delnode(x);
    update(y);
}

inline void modify(int &amp;rt, int p, int val) {
    int x = kth_element(rt, p + 1);
    splay(x, rt);
    T[x].val = val;
    update(x);
}

inline int find(int &amp;rt, int l, int r) {
    int x = kth_element(rt, l);
    splay(x, rt);
    int y = kth_element(rt, r + 2);
    splay(y, T[rt].ch[1]);
    return T[T[y].ch[0]].maxsum;
}

inline void make(int p, int l, int r) {
    int mid = (l + r) &gt;&gt; 1;
    T[p].val = a[mid];
    if (mid - 1 &gt;= l) T[p].ch[0] = newnode(), T[T[p].ch[0]].fa = p, make(T[p].ch[0], l, mid - 1);
    if (mid + 1 &lt;= r) T[p].ch[1] = newnode(), T[T[p].ch[1]].fa = p, make(T[p].ch[1], mid + 1, r);
    update(p);
}

signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]);
    int root = newnode();
    make(root, 0, n + 1);
    scanf(&quot;%d&quot;, &amp;m);
    for (int i = 1; i &lt;= m; ++i) {
        char opt[2];
        int x, y;
        scanf(&quot;%s %d&quot;, opt, &amp;x);
        if (*opt ^ &#39;D&#39;) scanf(&quot;%d&quot;, &amp;y);
        if (*opt == &#39;I&#39;) insert(root, x, y);
        if (*opt == &#39;D&#39;) erase(root, x);
        if (*opt == &#39;R&#39;) modify(root, x, y);
        if (*opt == &#39;Q&#39;) printf(&quot;%d\n&quot;, find(root, x, y));
    }
    return 0;
}
</code></pre>
<h1 id="13-Count-on-a-tree"><a href="#13-Count-on-a-tree" class="headerlink" title="13.Count on a tree"></a>13.Count on a tree</h1><p>给定一棵 $n$ 个节点的树，每个点有一个权值。有 $m$ 个询问，每次给你 $u$,$v$,$k$ 你需要回答 $u \text{ xor last}$ 和 $v$ 这两个节点间第 $k$ 小的点权。</p>
<hr>
<h2 id="LYC"><a href="#LYC" class="headerlink" title="LYC"></a>LYC</h2><p>树上的路径问题，我们一般都要用树链剖分。</p>
<p>静态第$k$小的问题，我们一般用主席树。</p>
<p>经过<del>严谨</del>分析，我们得出，这道题是树剖加主席树。</p>
<p>把树剖成重链之后像主席树模板那样按$dfs$序插入每个数(让同一条重链在主席树的$root$数组中成为一个连续的区间，方便统计)，然后我们要查询$u$,$v$两个节点间的第$k$小。</p>
<p>和模板不一样的地方来了：这里的区间第$k$小的区间不连续。</p>
<p>我们回想模板的思想过程：</p>
<p>通过差分得出区间内每个数值出现的个数。</p>
<p>既然这次区间是不连续的，我们就每次都把这些不连续的子区间统计一遍，再加起来就好了，就相当于是把这些子区间合起来。</p>
<p>具体来说，就是树剖$LCA$时记录每个区间的左右端点。使用主席树查询时再把原来的对于一个区间的统计改为对很多区间的统计就好了。</p>
<p>剩下的就和模板一样了。</p>
<p>代码：</p>
<pre><code class="lang-cpp">#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,p,a[100010],last,u,v,w,fa[100010],dep[100010],son[100010],siz[100010],dfn[100010],ton[100010],hb[100010],tot,be[100010],en[100010],cnt,root[100010],cntot;
struct node
{
    int l,r,sum;
}nodes[4000010];
vector&lt;int&gt; e[100010],pri;
int getID(int val)
{
    return lower_bound(pri.begin(),pri.end(),val)-pri.begin()+1;
}//离散化
void dfs1(int x,int las)
{
    dep[x]=dep[las]+1;
    fa[x]=las;
    siz[x]=1;
    int b=-1e9,s=0;
    for(int i=0;i&lt;e[x].size();++i)
    {
        int y=e[x][i];
        if(y^las)
        {
            dfs1(y,x);
            siz[x]+=siz[y];
            if(siz[y]&gt;b)
            {
                b=siz[y];
                s=y;
            }
        }
    }
    son[x]=s;
}
void dfs2(int x,int las,int heavy)
{
    if(heavy)    hb[x]=hb[las];
    else    hb[x]=x;
    dfn[x]=++tot;
    ton[tot]=a[x];
    if(son[x])    dfs2(son[x],x,1);
    for(int i=0;i&lt;e[x].size();++i)
    {
        int y=e[x][i];
        if(y^las&amp;&amp;y^son[x])    dfs2(y,x,0);
    }
}
void LCA(int x,int y)
{
    int fx=hb[x],fy=hb[y];
    while(fx^fy)
    {
        if(dep[fx]&lt;dep[fy])
        {
            swap(fx,fy);
            swap(x,y);
        }
        be[++cnt]=root[dfn[fx]-1];
        en[cnt]=root[dfn[x]];//记录每一个区间的左端点-1和右端点，相当于原来find(int l,int r,int p1,int p2,int k)中的p1,p2。
        x=fa[fx];
        fx=hb[x];
    }
    be[++cnt]=root[min(dfn[x],dfn[y])-1];
    en[cnt]=root[max(dfn[x],dfn[y])];
    //所有的子区间中的数包含且仅包含了u到v的最短路径上的所有点。因为树剖LCA会用一个一个区间覆盖所有点，而我们记录了每一个区间。
}//树剖
void ins(int l,int r,int pre,int &amp;now,int pos)
{
    nodes[++cntot]=nodes[pre];
    now=cntot;
    ++nodes[now].sum;
    if(l==r)    return;
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)    ins(l,mid,nodes[pre].l,nodes[now].l,pos);
    else    ins(mid+1,r,nodes[pre].r,nodes[now].r,pos);
}
int find(int l,int r,int k)
{
    if(l==r)    return pri[l-1];//一直到确定第k小的位置；返回原值。
    int X=0;
    for(int i=1;i&lt;=cnt;++i)    X+=(nodes[nodes[en[i]].l].sum-nodes[nodes[be[i]].l].sum);
    //临时统计u到v的最短路径上的所有点权中在[l,mid]中的数的个数。
    int mid=(l+r)&gt;&gt;1;
    if(k&lt;=X)//k&lt;=X,说明第k小在左边
    {
        for(int i=1;i&lt;=cnt;++i)//把每个端点都往左下跳。使它代表的值为这个区间的元素值在[l,mid]的个数。
        {
            en[i]=nodes[en[i]].l;
            be[i]=nodes[be[i]].l;
        }
        //然后我们就可以去缩小范围，去查询[l,mid]这个区间了。
        return find(l,mid,k);
    }
    else//否则，第k小是右边的第k-X小
    {
        for(int i=1;i&lt;=cnt;++i)//把每个端点都往右下跳。道理同上。
        {
            en[i]=nodes[en[i]].r;
            be[i]=nodes[be[i]].r;
        }
        return find(mid+1,r,k-X);//继续查找
    }
}//主席树
int main()
{
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        pri.push_back(a[i]);
    }
    for(int i=1;i&lt;n;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;u,&amp;v);
        e[u].push_back(v);
        e[v].push_back(u);
    }
    sort(pri.begin(),pri.end());
    pri.erase(unique(pri.begin(),pri.end()),pri.end());
    dfs1(1,1); 
    dfs2(1,1,0);
    p=pri.size();
    for(int i=1;i&lt;=n;++i)    ins(1,p,root[i-1],root[i],getID(ton[i]));//按dfs序插入
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d %d %d&quot;,&amp;u,&amp;v,&amp;w);
        u^=last;
        cnt=0;
        LCA(u,v);
        last=find(1,p,w);
        printf(&quot;%d\n&quot;,last);
    }
    return 0;
}
</code></pre>
<h2 id="WGY"><a href="#WGY" class="headerlink" title="WGY"></a>WGY</h2><p>对于每一个节点$x$，先令$rt_x=rt_{x-1}$，然后在$rt_x$中插入$a_i$，这样其实每个节点维护的都是节点到根的信息</p>
<p>对于查询操作中的每一个$(x,y)$，我们可以用$rt_x+rt_y-rt_{lca_{x,y}}-rt_{fa_{lca_{x,y}}}$来得到答案</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define mid ((l + r) &gt;&gt; 1)

const int SIZE = 1e5 + 5;
struct TreeNode {
    int l, r;
    int size;
} fhq[SIZE &lt;&lt; 5];
int n, m, tot, fa[SIZE], rt[SIZE];
int a[SIZE], rnk[SIZE], dp[SIZE], inq[30][SIZE], lastans, Q[SIZE];
std::vector &lt; std::vector &lt; int &gt; &gt; G(SIZE);

inline bool cmp(int x, int y) { return a[x] &lt; a[y]; }

inline void newnode(int t, int p) {
    fhq[++tot] = fhq[rt[t]];
    rt[t] = tot;
    int u = rt[t], l = 1, r = n;
    while (l ^ r) {
        fhq[u].size++;
        if (p &lt;= mid) fhq[++tot] = fhq[fhq[u].l], fhq[u].l = tot, u = fhq[u].l, r = mid;
        else fhq[++tot] = fhq[fhq[u].r], fhq[u].r = tot, u = fhq[u].r, l = mid + 1;
    }
    fhq[u].size++;
}

inline int find(int a, int b, int c, int d, int l, int r, int u) {
    if (l ^ r)
        if (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size &gt;= u) return find(fhq[a].l, fhq[b].l, fhq[c].l, fhq[d].l, l, mid, u);
        else return find(fhq[a].r, fhq[b].r, fhq[c].r, fhq[d].r, mid + 1, r, u - (fhq[fhq[a].l].size + fhq[fhq[b].l].size - fhq[fhq[c].l].size - fhq[fhq[d].l].size));
    else return l;
}

inline void dfs(int x, int fa) {
    dp[x] = dp[fa] + 1;
    rt[x] = rt[fa];
    ::fa[x] = fa;
    newnode(x, a[x]);
    for (int i = 0; i &lt; (int)G[x].size(); ++i) if (G[x][i] ^ fa) dfs(G[x][i], x);
}
inline int lca_mast(int x, int y) {
    if (dp[x] &lt; dp[y]) std::swap(x, y);
    for (int i = 0; dp[x] - dp[y]; ++i) if ((1 &lt;&lt; i) &amp; (dp[x] - dp[y])) x = inq[i][x];
    if (x ^ y) { for (int i = 25; i &gt;= 0; --i) if (inq[i][x] ^ inq[i][y]) x = inq[i][x], y = inq[i][y]; return fa[x]; }
    else return x;
}

signed main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;m);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), Q[i] = i;
    std::sort(Q + 1, Q + 1 + n, cmp);
    for (int i = 1; i &lt;= n; ++i) rnk[i] = a[Q[i]], a[Q[i]] = i;
    for (int i = 1, x, y; i &lt; n; ++i) scanf(&quot;%d %d&quot;, &amp;x, &amp;y), G[x].push_back(y), G[y].push_back(x);
    dfs(1, 0);
    for (int i = 1; i &lt;= n; ++i) inq[0][i] = fa[i];
    for (int i = 1; i &lt; 26; ++i) for (int j = 1; j &lt;= n; ++j) inq[i][j] = inq[i - 1][inq[i - 1][j]];
    for (int i = 1; i &lt;= m; ++i) {
        int x, y, z;
        scanf(&quot;%d %d %d&quot;, &amp;x, &amp;y, &amp;z);
        x ^= lastans;
        int lca = lca_mast(x, y);
        printf(&quot;%d\n&quot;, lastans = rnk[find(rt[x], rt[y], rt[lca], rt[fa[lca]], 1, n, z)]);
    }
    return 0;
}
</code></pre>
<h1 id="14-P2486-SDOI2011-染色"><a href="#14-P2486-SDOI2011-染色" class="headerlink" title="14.P2486 [SDOI2011]染色"></a>14.P2486 [SDOI2011]染色</h1><p><img src="https://cdn.luogu.com.cn/upload/pic/1600.png" alt="spfa together"></p>
<hr>
<h2 id="WGY-1"><a href="#WGY-1" class="headerlink" title="WGY"></a>WGY</h2><p>可以把首先把连接不同色点的边权设置为1，同色的设为9，这样整个问题就变成了查询路径上的权值和。</p>
<p>显然，我们可以用暴力$LinkCutTree$或$TreeChainSplitting$来搞，这里给出$LCT$的做法。</p>
<p>维护每一个$Splay$节点的最左端点的值和最右端点的颜色，对于它的老汉节点，我们可以找出它的前驱和后继的颜色。这样就可以累计它和前驱和后继连边的权值和辣</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define lson (fhq[x].ch[0])
#define rson (fhq[x].ch[1])

using namespace std;


#define DEBUG 1 // debug toggle
struct IO {
#define MAXSIZE (1 &lt;&lt; 20)
#define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;)
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? &#39; &#39; : *p1++;
  }
  inline bool blank(char ch) {
    return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;;
  }
  template &lt;class T&gt;
  inline void read(T &amp;x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == &#39;-&#39;) sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;);
    if (ch == &#39;.&#39;)
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - &#39;0&#39;);
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &amp;c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &amp;c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template &lt;class T&gt;
  inline void write(T x) {
    if (x &lt; 0) x = -x, push(&#39;-&#39;);
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + &#39;0&#39;);
  }
  template &lt;class T&gt;
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 1e6 + 5;
int n, m;
class LinkCutTree {
public:
    struct SPLAY {
        int w, c;
        int l, r;
        int tag, rev;
        int fa, ch[2];
    } fhq[SIZE]; // The fhq-treap replaces the splay
    // Struct SPLAY
    int stack[SIZE], tp;

    inline bool isroot(int x) { return fhq[fhq[x].fa].ch[0] ^ x &amp;&amp; fhq[fhq[x].fa].ch[1] ^ x; }
    inline void tr_dn1(int x) { if (fhq[x].rev) swap(lson, rson), swap(fhq[lson].l, fhq[lson].r), swap(fhq[rson].l, fhq[rson].r), fhq[lson].rev ^= 1, fhq[rson].rev ^= 1, fhq[x].rev = 0; }
    inline void tr_dn2(int x) { if (fhq[x].tag) fhq[x].l = fhq[x].r = fhq[x].c = fhq[x].tag, fhq[lson].tag = fhq[rson].tag = fhq[x].tag, fhq[x].w = fhq[x].tag = 0; }
    inline void tr_dn(int x) { tr_dn1(x), tr_dn2(x); }
    inline void tr_up_(int x) { tr_dn(lson), tr_dn(rson); fhq[x].w = fhq[lson].w + fhq[rson].w; }
    inline void tr_up1(int x) { if (lson) fhq[x].l = fhq[lson].l, ((fhq[x].c ^ fhq[lson].r) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].l = fhq[x].c; }
    inline void tr_up2(int x) { if (rson) fhq[x].r = fhq[rson].r, ((fhq[x].c ^ fhq[rson].l) &amp;&amp; (++fhq[x].w, 1)); else fhq[x].r = fhq[x].c; }
    inline void tr_up(int x) { tr_up_(x); tr_up1(x); tr_up2(x); }
    inline void rotate(int x) { int y = fhq[x].fa, z = fhq[y].fa, k = fhq[y].ch[1] == x; if (!isroot(y)) fhq[z].ch[fhq[z].ch[1] == y] = x; fhq[x].fa = z; fhq[y].ch[k] = fhq[x].ch[k ^ 1], fhq[fhq[x].ch[k ^ 1]].fa = y; fhq[x].ch[k ^ 1] = y; fhq[y].fa = x; tr_up(y); }
    inline void splay1(int x) { stack[tp = 1] = x; for (int i = x; !isroot(i); i = fhq[i].fa) stack[++tp] = fhq[i].fa; while (tp) tr_dn(stack[tp--]); }
    inline void splay2(int x) { for (; !isroot(x); rotate(x)) { int y = fhq[x].fa, z = fhq[y].fa; if (!isroot(y)) (fhq[y].ch[1] ^ x ^ fhq[z].ch[1] ^ y) ? rotate(x) : rotate(y); } }
    inline void splay(int x) { splay1(x), splay2(x); tr_up(x); }
    inline void access(int x) { for (int y = 0; x; y = x, x = fhq[x].fa) splay(x), rson = y, tr_up(x); }
    inline void makeroot(int x) { access(x), splay(x), fhq[x].rev ^= 1; }
    inline int findroot(int x) { access(x), splay(x); while (lson) x = lson; return x; }
    inline void split(int x, int y) { makeroot(x), access(y), splay(y); }
    inline void connect(int x, int y) { makeroot(x), fhq[x].fa = y; }
} lct_mast; // Class LinkCutTree

signed main() {
    io.read(n), io.read(m);
    for (int i = 1, x; i &lt;= n; ++i) io.read(x), lct_mast.fhq[i].c = lct_mast.fhq[i].l = lct_mast.fhq[i].r = x;
    for (int i = 1, x, y; i &lt; n; ++i) io.read(x), io.read(y), lct_mast.connect(x, y);
    for (int i = 1, a, b, c; i &lt;= m; ++i) {
        char ch = getchar();
        while (ch ^ &#39;C&#39; &amp;&amp; ch ^ &#39;Q&#39;) ch = getchar();
        if (ch ^ &#39;Q&#39;) io.read(a), io.read(b), io.read(c), lct_mast.split(a, b), lct_mast.fhq[b].tag = c;
        else io.read(a), io.read(b), lct_mast.split(a, b), io.write(lct_mast.fhq[b].w + 1, &#39;\n&#39;);
    }
    return 0;
}
</code></pre>
<h2 id="LYC-1"><a href="#LYC-1" class="headerlink" title="LYC"></a>LYC</h2><h1 id="15-「ZJOI2017」树状数组"><a href="#15-「ZJOI2017」树状数组" class="headerlink" title="15.「ZJOI2017」树状数组"></a>15.「ZJOI2017」树状数组</h1><p>漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的OI比赛经历。那是一道基础的树状数组题。</p>
<p>给出一个长度为$n$的数组$A$，初始值都为0，接下来进行$m$次操作，操作有两种：</p>
<p>* 1 x，表示将 $A_{x}$ 变成 $\left ( A_{x}+ 1 \right )$ mod 2。</p>
<p>* 2 l r，表示询问 $ \left ( \sum_{i=l}^{r} A_{i}  \right )$ mod 2。</p>
<p>尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常young 的她写了如下的算法：</p>
<p> <img src="https://cdn.luogu.com.cn/upload/pic/4744.png" alt> </p>
<p>其中 lowbit($x$) 表示数字 $x$ <strong>最低</strong>的非 0 二进制位，例如 lowbit(5) = 1, lowbit(12) = 4。进行第一类操作的时候就调用 Add($x$)，第二类操作的时候答案就是 Query($l$,$r$)。</p>
<p>如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了： <strong>Add 和 Find 中</strong> $x$ <strong>变化的方向反了</strong>。因此这个程序在最终测试时华丽的爆 0 了。</p>
<p>然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对</p>
<p>拍的原因。</p>
<p>现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的</p>
<p>感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$</p>
<p>的值，因此她假定这次操作的 $x$ 是在 $\left [ l_{i},r_{i} \right ]$ 范围内 <strong>等概率随机</strong> 的。</p>
<p>具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 0，接下来进行了 $m$ 次操作：</p>
<p>* 1 $l$ $r$，表示在区间 $\left [ l, r \right ]$ 中等概率选取一个 $x$ 并执行 Add($x$)。</p>
<p>* 2 $l$ $r$，表示询问执行 Query$\left ( l, r \right )$得到的结果是正确的概率是多少。</p>
<hr>
<p>这道题$\cdots$，没什么可讲的吧？二维线段树蛮干就好了</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define mid ((l + r) &gt;&gt; 1)

using namespace std;
typedef long long int ull;

const int SIZE = 1e5 + 5;
const int MOD = 998244353;
struct TreeNode {
    int l, r;
    int val;
} tr[SIZE * 400];
int rt[SIZE * 20], n, q, tot;

inline ull result(ull p, ull q) {
    ull res = p * q; res %= MOD;
    return res = (res + (1 - p + MOD) * (1 - q + MOD) % MOD) % MOD;
}

inline ull fast_pow(ull x, ull y) {
    ull res = 1;
    for (; y; y &gt;&gt;= 1, (x *= x) %= MOD) if (y &amp; 1) (res *= x) %= MOD;
    return res % MOD;
}

inline void modifies(int l, int r, int &amp;rt, int x, int y, ull p) {
    if (!rt) rt = ++tot, tr[rt].val = 1;
    if (l &gt;= x &amp;&amp; r &lt;= y) return (void)(tr[rt].val = result(p, tr[rt].val));
    if (mid &gt;= x) modifies(l, mid, tr[rt].l, x, y, p);
    if (mid &lt; y) modifies(mid + 1, r, tr[rt].r, x, y, p);
}

inline void modify(int l, int r, int rt, int lx, int rx, int ly, int ry, ull p) {
    if (l &gt;= lx &amp;&amp; r &lt;= rx) return (void)(modifies(1, n, ::rt[rt], ly, ry, p));
    if (mid &gt;= lx) modify(l, mid, rt &lt;&lt; 1, lx, rx, ly, ry, p);
    if (mid &lt; rx) modify(mid + 1, r, rt &lt;&lt; 1 | 1, lx, rx, ly, ry, p);
}

inline ull finds(int l, int r, int rt, int x) {
    if (!rt) return 1;
    if (l ^ r)
        if (mid &gt;= x) return result(tr[rt].val, finds(l, mid, tr[rt].l, x));
        else return result(tr[rt].val, finds(mid + 1, r, tr[rt].r, x));
    else return tr[rt].val;
}

inline ull find(int l, int r, int rt, int x, int y) {
    if (l ^ r)
        if (mid &gt;= x) return result(finds(1, n, ::rt[rt], y), find(l, mid, rt &lt;&lt; 1, x, y));
        else return result(finds(1, n, ::rt[rt], y), find(mid + 1, r, rt &lt;&lt; 1 | 1, x, y));
    else return finds(1, n, ::rt[rt], y);
}

signed main() {
    scanf(&quot;%d %d&quot;, &amp;n, &amp;q);
    for (int i = 0; i &lt; q; ++i) {
        int opt, l, r;
        scanf(&quot;%d %d %d&quot;, &amp;opt, &amp;l, &amp;r);
        if (opt ^ 1) printf(&quot;%lld\n&quot;, find(0, n, 1, l - 1, r));
        else {
            ull p = fast_pow(r - l + 1, MOD - 2);
            if (l &gt; 1) modify(0, n, 1, 1, l - 1, l, r, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, 1, l - 1, 0);
            if (r &lt; n) modify(0, n, 1, l, r, r + 1, n, (1 - p + MOD) % MOD), modify(0, n, 1, 0, 0, r + 1, n, 0);
            modify(0, n, 1, l, r, l, r, (1 - p * 2 % MOD + MOD) % MOD), modify(0, n, 1, 0, 0, l, r, p);
        }
    }
    return 0;
}
</code></pre>
<h1 id="16-P2161-SHOI2009-会场预约"><a href="#16-P2161-SHOI2009-会场预约" class="headerlink" title="16.P2161 [SHOI2009]会场预约"></a>16.P2161 [SHOI2009]会场预约</h1><pre><code class="lang-cpp">// 未免LJS吐槽不贴题面了
</code></pre>
<hr>
<p>这道题正解应该是平衡树或者BIT，这里提供一种简便的STL做法。</p>
<p>对于第一个操作，我们可以令有冲突的预约相等，避免set特性坑死一票人</p>
<p>对于第二个操作直接输出set的大小即可</p>
<pre><code class="lang-cpp">// 省略头文件和快读

struct LaLaLand {
    int l, r;
    bool operator &lt; (const LaLaLand&amp; rhs) const { return r &lt; rhs.l; }
};
set &lt; LaLaLand &gt; st;
int T;

signed main() {
    for (read(T); T; --T) {
        char opt[5];
        read(opt);
        int l, r, cnt = 0;
        if (*opt == &#39;A&#39;) {
            read(l, r);
            LaLaLand tmp = {l, r};
            IT it = st.find(tmp);
            while (it != st.end()) ++cnt, st.erase(it), it = st.find(tmp);
            st.insert(tmp);
            write(io_l, cnt);
        }
        else write(io_l, st.size());
    }
    return 0;
}
</code></pre>
<h1 id="17-SP11470-TTM-To-the-moon"><a href="#17-SP11470-TTM-To-the-moon" class="headerlink" title="17.SP11470 TTM - To the moon"></a>17.SP11470 TTM - To the moon</h1><p>一个长度为n的数组，4种操作 ：</p>
<ul>
<li><p><code>C l r d</code>：区间 $[l,r]$ 中的数都加 $d$ ，同时当前的时间戳加 $1$。</p>
</li>
<li><p><code>Q l r</code>：查询当前时间戳区间 $[l,r]$ 中所有数的和 。</p>
</li>
<li><p><code>H l r t</code>：查询时间戳 $t$ 区间 $[l,r]$ 的和 。</p>
</li>
<li><p><code>B t</code>：将当前时间戳置为 $t$ 。</p>
</li>
</ul>
<hr>
<p>这道题正解应该是主席树+标记永久化，我来提供一种代码极短(压行后不到1K)的做法(怎么感觉我就没什么正经解法)</p>
<p>维护一个差分数组，将每次询问看作是两次前缀和相减</p>
<p>然后…就没有然后了，其它都是模板的主席树，只是修改用差分就好了</p>
<h1 id="18-P4168-Violet-蒲公英"><a href="#18-P4168-Violet-蒲公英" class="headerlink" title="18.P4168 [Violet]蒲公英"></a>18.P4168 [Violet]蒲公英</h1><p>在乡下的小路旁种着许多蒲公英，而我们的问题正是与这些蒲公英有关。</p>
<p>为了简化起见，我们把所有的蒲公英看成一个长度为n的序列 $(a_1,a_2..a_n)$，其中 $a_i$ 为一个正整数，表示第i棵蒲公英的种类编号。</p>
<p>而每次询问一个区间 [l,r]，你需要回答区间里出现次数最多的是哪种蒲公英，如果有若干种蒲公英出现次数相同，则输出种类编号最小的那个。</p>
<p>注意，你的算法必须是在线的</p>
<hr>
<h2 id="LYC-2"><a href="#LYC-2" class="headerlink" title="LYC:"></a>LYC:</h2><p><del>这就是传说中的分块打表了</del></p>
<p>由于强制在线，莫队是不可能的了</p>
<p>求区间众数，我们可以按之前讲的分块打表技术，处理出每两个特征点的每个元素的出现个数和当前众数。</p>
<p>对于每个询问，由于众数问题不容易往回收（要重新找众数），我们选取左右端点往内的最近的特征点</p>
<p><strong>继承</strong>（注意不是直接把这个区间的答案拿来接着用，因为不能回退，如果直接用又不回退，下次调用时会调到错误的结果）这个区间的答案，利用这个区间之前统计的元素出现个数</p>
<p>向外扩张，统计出要询问的答案</p>
<p>最后要把刚刚统计众数加上的元素个数清掉（回溯最初处理好的状态）</p>
<p>代码：（这里块大小我开的$n^{2/3}$，开$\sqrt n$好像开不下） </p>
<pre><code>#include&lt;cmath&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
vector&lt;int&gt; pri;
int n,m,a[40010],each,cnt[40][40][40010],MAX[40][40],lans,l,r,ans,tmp[40010];
int main()
{
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    each=pow(n,2.0/3);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        pri.push_back(a[i]);
    }
    sort(pri.begin(),pri.end());
    pri.erase(unique(pri.begin(),pri.end()),pri.end());
    for(int i=1;i&lt;=n;++i)    a[i]=lower_bound(pri.begin(),pri.end(),a[i])-pri.begin()+1;//离散化 
    for(int i=1,p=1;i&lt;=n;i+=each,++p)
    {
        for(int j=i+each-1,q=p;j&lt;=n;j+=each,++q)
        {
            for(int k=i;k&lt;=j;++k)
            {
                ++cnt[p][q][a[k]];
                if(cnt[p][q][a[k]]&gt;cnt[p][q][MAX[p][q]]||(cnt[p][q][a[k]]==cnt[p][q][MAX[p][q]]&amp;&amp;a[k]&lt;MAX[p][q]))    MAX[p][q]=a[k];
            }
        }
    }//初始化（打表） 
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d %d&quot;,&amp;l,&amp;r);
        l=(l+lans-1)%n+1;
        r=(r+lans-1)%n+1;
        if(l&gt;r)    swap(l,r);//强制在线 
        if(r-l&gt;2*each)
        {
            int p=ceil(1.0*(l-1)/each)+1;
            int q=ceil(1.0*(r+1)/each)-1;//得到向内收缩的端点
            ans=MAX[p][q];//继承答案 
            for(int i=(p-1)*each;i&gt;=l;--i)
            {
                ++cnt[p][q][a[i]];
                if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans))    ans=a[i];
            }
            for(int i=q*each+1;i&lt;=r;++i)
            {
                ++cnt[p][q][a[i]];
                if(cnt[p][q][a[i]]&gt;cnt[p][q][ans]||(cnt[p][q][a[i]]==cnt[p][q][ans]&amp;&amp;a[i]&lt;ans))    ans=a[i];
            }
            lans=pri[ans-1];//获得原值 
            printf(&quot;%d\n&quot;,lans);
            for(int i=(p-1)*each;i&gt;=l;--i)    --cnt[p][q][a[i]];
            for(int i=q*each+1;i&lt;=r;++i)    --cnt[p][q][a[i]];//回溯 
        }
        else//区间太小，如果两个端点在一个块内，向内收缩就会重复统计整个块，所以暴力统计 
        {
            ans=0;
            for(int i=l;i&lt;=r;++i)
            {
                ++tmp[a[i]];
                if(tmp[a[i]]&gt;tmp[ans]||(tmp[a[i]]==tmp[ans]&amp;&amp;a[i]&lt;ans))    ans=a[i];
            }
            lans=pri[ans-1];
            printf(&quot;%d\n&quot;,lans);
            for(int i=l;i&lt;=r;++i)    --tmp[a[i]];//回溯清零 
        }
    }
    return 0;
}
</code></pre><h2 id="WGY-2"><a href="#WGY-2" class="headerlink" title="WGY:"></a>WGY:</h2><p>这道题luogu的数据很水，于是…于是…我们直接离散化+暴力就能过！</p>
<p>然后….然后就没了(这次真的不是我不想写，是真的没什么写的…)</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

// #define DEBUG 1
struct IO {
#define MAXSIZE (1 &lt;&lt; 20)
#define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;)
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? &#39; &#39; : *p1++;
  }
  inline bool blank(char ch) {
    return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;;
  }
  template &lt;class T&gt;
  inline void read(T &amp;x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == &#39;-&#39;) sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;);
    if (ch == &#39;.&#39;)
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - &#39;0&#39;);
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &amp;c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &amp;c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template &lt;class T&gt;
  inline void write(T x) {
    if (x &lt; 0) x = -x, push(&#39;-&#39;);
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + &#39;0&#39;);
  }
  template &lt;class T&gt;
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 50000 + 5;
int a[SIZE], b[SIZE];
int cnt[SIZE], x;
int l, r, n, m, l0, r0;

signed main() {
    io.read(n), io.read(m);
    for (int i = 1; i &lt;= n; ++i) io.read(a[i]), b[i] = a[i];
    sort(b + 1, b + 1 + n);
    int len = unique(b + 1, b + 1 + n) - b - 1;
    for (int i = 1; i &lt;= n; ++i) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;
    while (m--) {
        io.read(l0), io.read(r0);
        l = (l0 + x - 1) % n + 1;
        r = (r0 + x - 1) % n + 1;
        if (l &gt; r) swap(l, r);
        for (int i = l; i &lt;= r; ++i) cnt[a[i]]++;
        int MAX = 0, pos = 0;
        for (int i = 1; i &lt;= len; ++i) if (MAX &lt; cnt[i]) MAX = cnt[i], pos = i;
        printf(&quot;%d\n&quot;, b[pos]);
        x = b[pos];
        memset(cnt, 0, sizeof cnt);
    }
}
</code></pre>
<h1 id="19-CQOI2014-排序机械臂"><a href="#19-CQOI2014-排序机械臂" class="headerlink" title="19.[CQOI2014]排序机械臂"></a>19.[CQOI2014]排序机械臂</h1><p>为了把工厂中高低不等的物品按从低到高排好序，工程师发明了一种排序机械臂。它遵循一个简单的排序规则，第一次操作找到高度最低的物品的位置 $P_1$ ，并把左起第一个物品至 $P_1$  间的物品 (即区间 $[1,P_1]$  间的物品) 反序；第二次找到第二低的物品的位置 $P_2$ ，并把左起第二个至 $P_2$  间的物品 (即区间 $[2,P_2]$  间的物品) 反序……最终所有的物品都会被排好序。</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/15642.png" alt="样例说明"></p>
<p>上图给出有六个物品的示例，第一次操作前，高度最低的物品在位置 $4$ ，于是把第一至第四的物品反序；第二次操作前，第二低的物品在位罝六，于是把第二至六的物品反序……</p>
<p>你的任务便是编写一个程序，确定一个操作序列，即每次操作前第 $i$  低的物品所在位置 $P_i$ ，以便机械臂工作。需要注意的是，如果有高度相同的物品，必须保证排序后它们的相对位置关系与初始时相同。</p>
<hr>
<h2 id="LYC："><a href="#LYC：" class="headerlink" title="LYC："></a>LYC：</h2><p>我们乍一看这道题</p>
<p>“哟！区间翻转平衡树裸题，还6倍经验？！”</p>
<p>再一看，每次翻转区间第一个到元素值最小的一个，再删除最小的一个</p>
<p>？？？</p>
<p>元素值最小的一个</p>
<p>应该怎么维护呢</p>
<p>我们可以在update里顺便维护这个子树中最小的值是第几个和它的大小（我脑残维护了前面有几个数）。</p>
<p>针对这个进行分类讨论：</p>
<p>1).当前结点的值比左右子树的最小值都小</p>
<p>那么最小值是当前结点的值。</p>
<p>它前面的元素个数是左子树的大小（中序遍历为原序列）</p>
<p>2).左子树的最小值最小</p>
<p>完美继承左子树的两个值。</p>
<p>3).右子树的最小值最小</p>
<p>最小值不用说了吧。</p>
<p>它前面的个数就是左子树的大小加一（当前结点）再加上右子树中在它前面的元素个数 </p>
<p>因为子树不变时，那我们维护的这个值也不变。子树变了，那就肯定要更新。</p>
<p>然后再每次都查询最小的元素在哪一个位置，删掉它再翻转前面的区间就好了</p>
<p>代码：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,tot,root,root1,root2,root3,c[100010];

struct node
{
    int l,r,num,key,sum;
    int s,smum;//最小值大小，前面的元素个数 
    bool rev;//翻转标记 
}nodes[100010];

struct laji
{
    int v,ID;
}a[100010];
bool cmp(laji one,laji two)
{
    if(one.v^two.v)    return one.v&lt;two.v;
    return one.ID&lt;two.ID;
}//离散化，顺便解决如果值相同，保持原有相对位置的问题 

int newnode(int val)
{
    nodes[++tot].s=val;//最小值设为自己，前面没有数 
    nodes[tot].num=val;
    nodes[tot].key=rand();
    nodes[tot].sum=1;
    return tot;
}
void pushdown(int x)
{
    swap(nodes[x].l,nodes[x].r);//首先交换左右儿子 
    nodes[x].smum=nodes[x].sum-(nodes[x].smum+1);//整个子树翻转过来，则最小值的位置就要翻过来 
    //原来前面的元素个数：nodes[x].smum
    //原位置: nodes[x].smum+1
    //翻转位置：nodes[x].sum-(nodes[x].smum+1)+1
    //翻转后前面的元素个数：nodes[x].sum-(nodes[x].smum+1)
    nodes[nodes[x].l].rev^=1;
    nodes[nodes[x].r].rev^=1;//下传标记 
    nodes[x].rev=0;//记得清空 
}
void update(int x)
{
    nodes[x].sum=nodes[nodes[x].l].sum+nodes[nodes[x].r].sum+1;
    if(nodes[nodes[x].l].rev)    pushdown(nodes[x].l);
    if(nodes[nodes[x].r].rev)    pushdown(nodes[x].r);//如果左右子树有标记，也要下传，否则更新出的值不对
    if(nodes[x].num&lt;nodes[nodes[x].l].s&amp;&amp;nodes[x].num&lt;nodes[nodes[x].r].s)//分类讨论情况1 
    {
        nodes[x].s=nodes[x].num;
        nodes[x].smum=nodes[nodes[x].l].sum;
    }
    else if(nodes[nodes[x].l].s&lt;nodes[nodes[x].r].s)//情况2 
    {
        nodes[x].s=nodes[nodes[x].l].s;
        nodes[x].smum=nodes[nodes[x].l].smum;
    }
    else//情况3 
    {
        nodes[x].s=nodes[nodes[x].r].s;
        nodes[x].smum=nodes[nodes[x].r].smum+nodes[nodes[x].l].sum+1;
    }
}
void split(int now,int siz,int &amp;x,int &amp;y)
{
    if(!now)    x=y=0;
    else
    {
        if(nodes[now].rev)    pushdown(now);//下面要用到它的儿子，所以我们要下传标记 
        if(nodes[nodes[now].l].sum&lt;siz)
        {
            x=now;
            split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y);
        }
        else
        {
            y=now;
            split(nodes[now].l,siz,x,nodes[y].l);
        }
        update(now);
    }
}
int merge(int x,int y)
{
    if(!x||!y)    return x+y;
    if(nodes[x].key&lt;nodes[y].key)
    {
        if(nodes[x].rev)    pushdown(x);
        nodes[x].r=merge(nodes[x].r,y);
        update(x);
        return x;
    }
    else
    {
        if(nodes[y].rev)    pushdown(y);
        nodes[y].l=merge(x,nodes[y].l);
        update(y);
        return y;
    }
}
int main()
{
    srand(20060515);
    nodes[0].num=nodes[0].s=1e9;//处理节点为空的特殊情况为极大值，使更新叶子节点时不会把0更新进去 
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d&quot;,&amp;a[i].v);
        a[i].ID=i;
    }
    sort(a+1,a+1+n,cmp);
    for(int i=1;i&lt;=n;++i)    c[a[i].ID]=i;//离散化 
    for(int i=1;i&lt;=n;++i)    root=merge(root,newnode(c[i]));//处理原序列，直接把当前元素插入到它前面元素的右边 
    for(int i=1;i&lt;=n;++i)
    {
        if(nodes[root].rev)    pushdown(root);//如果根节点有翻转标记要翻转，否则最小值的位置是反的。 
        printf(&quot;%d &quot;,nodes[root].smum+i);//还有之前的i-1个已经被删除的数 
        split(root,nodes[root].smum,root1,root2);
        split(root2,1,root2,root3);//删除这个数 
        nodes[root1].rev^=1;//翻转前面的区间 
        root=merge(root1,root3);
    }
    return 0;
}
</code></pre><h2 id="WGY-3"><a href="#WGY-3" class="headerlink" title="WGY:"></a>WGY:</h2><p>SplayNB！！！区间操作直接秒过！！(具体题解参考LYC，我就放个代码)</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define mid ((l + r) &gt;&gt; 1)

using namespace std;

// #define DEBUG 1
struct IO {
#define MAXSIZE (1 &lt;&lt; 20)
#define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;)
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? &#39; &#39; : *p1++;
  }
  inline bool blank(char ch) {
    return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;;
  }
  template &lt;class T&gt;
  inline void read(T &amp;x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == &#39;-&#39;) sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;);
    if (ch == &#39;.&#39;)
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - &#39;0&#39;);
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &amp;c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &amp;c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template &lt;class T&gt;
  inline void write(T x) {
    if (x &lt; 0) x = -x, push(&#39;-&#39;);
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + &#39;0&#39;);
  }
  template &lt;class T&gt;
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 100000 + 5;
struct SPLAY {
    int fa;
    int size;
    int val;
    int rev;
    int ch[2];
} t[SIZE];
int n, root, tot, pos[SIZE];
struct InputNode {
    int id;
    int val;
} a[SIZE];

bool cmp1(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.val ^ rsp.val ? rhs.val &lt; rsp.val : rhs.id &lt; rsp.id; }
bool cmp2(const InputNode&amp; rhs, const InputNode&amp; rsp) { return rhs.id &lt; rsp.id; }

void update(int x) {
    t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1;
}

void transf(int x) {
    if (t[x].rev) {
        swap(t[x].ch[0], t[x].ch[1]);
        t[t[x].ch[0]].rev ^= 1;
        t[t[x].ch[1]].rev ^= 1;
        t[x].rev = 0;
    }
}

int make(int fa, int l, int r) {
    if (l &gt; r) return 0;
    int p = ++tot;
    return(t[p].val = a[mid].val, t[p].fa = fa, pos[a[mid].val] = p, t[p].ch[0] = make(p, l, mid - 1), t[p].ch[1] = make(p, mid + 1, r), update(p), p);
}

void rotate(int x) {
    int y = t[x].fa, z = t[y].fa;
    transf(y), transf(x);
    int k = t[t[x].fa].ch[1] == x;
    t[y].ch[k] = t[x].ch[k ^ 1];
    t[t[y].ch[k]].fa = y;
    t[y].fa = x;
    t[x].ch[k ^ 1] = y;
    t[x].fa = z;
    if (z) t[z].ch[y == t[z].ch[1]] = x;
    update(y), update(x);
}

void splay(int x, int goal) {
    for (int y; (y = t[x].fa) ^ goal; rotate(x))
        if (t[y].fa ^ goal)
            rotate(t[t[x].fa].ch[1] ^ x ^ y ^ t[t[y].fa].ch[1] ? x : y);
    if (!goal) root = x;
}

int behavior() {
    transf(root);
    int x = t[root].ch[1];
    while (transf(x), t[x].ch[0]) x = t[x].ch[0];
    return x;
}

signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i + 1].val), a[i + 1].id = i + 1;
    a[1].val = 0, a[n + 2].val = n + 1;
    sort(a + 2, a + 2 + n, cmp1);
    for (int i = 2; i &lt;= n + 1; ++i) a[i].val = i - 1;
    sort(a + 2, a + 2 + n, cmp2);
    root = make(0, 1, n + 2);
    for (int i = 1; i &lt;= n; ++i) {
        int x = pos[i];
        splay(x, 0);
        printf(&quot;%d &quot;, t[t[x].ch[0]].size);
        x = behavior();
        int y = pos[i - 1];
        splay(y, 0);
        splay(x, y);
        t[t[x].ch[0]].rev ^= 1;
    }
    return 0;
}
</code></pre>
<h1 id="20-SHOI2013-扇形面积并-权值线段树-amp-扫描线"><a href="#20-SHOI2013-扇形面积并-权值线段树-amp-扫描线" class="headerlink" title="20.[SHOI2013]扇形面积并(权值线段树&amp;扫描线)"></a>20.[SHOI2013]扇形面积并(权值线段树&amp;扫描线)</h1><p><img src="https://cdn.luogu.com.cn/upload/pic/11825.png" alt> </p>
<p>给定 n 个同心的扇形，求有多少面积，被至少 $k$ 个扇形所覆盖。</p>
<hr>
<h2 id="LYC-3"><a href="#LYC-3" class="headerlink" title="LYC:"></a>LYC:</h2><p>这道题要用到扫描线的思想,那扫描线是什么呢?</p>
<p><strong>扫描线</strong>：</p>
<p>经典应用：给出一堆矩阵，求它们覆盖的总面积</p>
<p>数据范围<del>恶心死了</del>，$10^5$个矩阵，矩阵的坐标的绝对值小于$10^9$。</p>
<p>看到这个数据范围我们就知道：要离散化。</p>
<p>之后呢，我们把每个矩阵的左右边界都转换成添加和删除。</p>
<p>我们用一条扫描线从左到右扫过去，线段树来维护现在整条扫描线的被覆盖情况。</p>
<p>矩阵的左边就是添加以这个矩阵的上下边界点为端点的线段。</p>
<p>右边再右边一个就转换成删除。</p>
<p>每走过一个点，我们就用线段树统计当前扫描线被这些矩阵覆盖了多少，再把答案加上去就好了。</p>
<p>模板我就不写啦<del>其实是我不会</del></p>
<p>$\ $</p>
<p>好了那我们来看这道题吧。</p>
<p>一堆圆心相同的扇形，求被至少$k$个扇形覆盖的面积。</p>
<p>我们先单看一条从圆心射出的射线。</p>
<p>由于每个扇形的圆心是相同的。</p>
<p>所以覆盖每个地方的扇形数量是向外递减的。</p>
<p>那么被至少$k$个扇形覆盖的地方就在从外到内第$k$个扇形，它被刚好或者多于$k$个扇形所覆盖，更向内的地方的数量则更多，也是大于等于$k$。</p>
<p>所以我们可以用权值线段树来维护每个地方有多少个扇形边界。从而查找从外到内第$k$个扇形边界。</p>
<p>运用扫描线思想，把给出的扇形的两个角度值转换成添加和删除一个扇形边界。</p>
<p>实现有很多坑，自己看注释吧。</p>
<p>代码：</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
long long n,m,k,nodes[400010],a1,a2,ans,s,now;
struct cir
{
    long long r;
    bool insorex;//1为添加，2为删除
}cur;
vector&lt;cir&gt; op[2000010];//用来储存在每个角度的修改
void ins(long long l,long long r,long long x,long long pos)
{
    ++nodes[x];
    if(l^r)
    {
        long long mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    ins(l,mid,x&lt;&lt;1,pos);
        else    ins(mid+1,r,x&lt;&lt;1|1,pos);
    }
}
void exins(long long l,long long r,long long x,long long pos)//权值线段树删除
{
    --nodes[x];
    if(l^r)
    {
        long long mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    exins(l,mid,x&lt;&lt;1,pos);
        else    exins(mid+1,r,x&lt;&lt;1|1,pos);
    }
}
long long find(long long l,long long r,long long x,long long val)//权值线段树查找从外到内第k个
{
    if(l==r)    return l;
    long long mid=(l+r)&gt;&gt;1;
    if(val&lt;=nodes[x&lt;&lt;1|1])    return find(mid+1,r,x&lt;&lt;1|1,val);
    else    return find(l,mid,x&lt;&lt;1,val-nodes[x&lt;&lt;1|1]);
}
int main()
{
    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;m,&amp;k);
    for(long long i=1;i&lt;=n;++i)
    {
        scanf(&quot;%lld %lld %lld&quot;,&amp;cur.r,&amp;a1,&amp;a2);
        s=max(s,cur.r);
        a1+=m;
        a2+=m;//a1,a2可能是负数
               //转换成添加和修改
        if(a1&gt;a2)//这个扇形跨越了分界线，需要拆成两半
        {
            cur.insorex=1;
            op[a1+1].push_back(cur);
            op[1].push_back(cur);
            cur.insorex=0;
            op[a2+1].push_back(cur);
        }
        else
        {
            cur.insorex=1;
            op[a1+1].push_back(cur);
            cur.insorex=0;
            op[a2+1].push_back(cur);
        }
    }
    for(long long i=1;i&lt;=m*2;++i)//注意是半开区间(-Pi,Pi]
    {
        for(long long j=0;j&lt;op[i].size();++j)//进行修改操作
        {
            cur=op[i][j];
            if(cur.insorex)
            {
                ins(1,s,1,cur.r);
                ++now;
            }
            else
            {
                exins(1,s,1,cur.r);
                --now;//统计现在总共有多少个
            }
        }
        if(now&gt;=k)//有k个才统计，不然容易出锅
        {
            long long tmp=find(1,s,1,k);
            ans+=tmp*tmp;//圆面积公式：Pi*r*r
        }
    }
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre><h2 id="WGY-4"><a href="#WGY-4" class="headerlink" title="WGY"></a>WGY</h2><p>提供树状数组+二分做法，复杂度$O(n\log^2n)$</p>
<p><del>树状数组写起来短，常数小，动动脑子可以套在很多题目上，它不香嘛</del></p>
<p>题目让我们求目前覆盖的第 $k$ 大，我们可以把原来的覆盖位置差分一下，然后二分即可</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#define mid ((l + r) &gt;&gt; 1)
#define mp make_pair
#define fir first
#define sec second
#define pub push_back
#define pob pop_back

using namespace std;
typedef long long LL;

 #define DEBUG 1
struct IO {
#define MAXSIZE (1 &lt;&lt; 20)
#define isdigit(x) (x &gt;= &#39;0&#39; &amp;&amp; x &lt;= &#39;9&#39;)
  char buf[MAXSIZE], *p1, *p2;
  char pbuf[MAXSIZE], *pp;
#if DEBUG
#else
  IO() : p1(buf), p2(buf), pp(pbuf) {}
  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }
#endif
  inline char gc() {
#if DEBUG
    return getchar();
#endif
    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);
    return p1 == p2 ? &#39; &#39; : *p1++;
  }
  inline bool blank(char ch) {
    return ch == &#39; &#39; || ch == &#39;\n&#39; || ch == &#39;\r&#39; || ch == &#39;\t&#39;;
  }
  template &lt;class T&gt;
  inline void read(T &amp;x) {
    register double tmp = 1;
    register bool sign = 0;
    x = 0;
    register char ch = gc();
    for (; !isdigit(ch); ch = gc())
      if (ch == &#39;-&#39;) sign = 1;
    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - &#39;0&#39;);
    if (ch == &#39;.&#39;)
      for (ch = gc(); isdigit(ch); ch = gc())
        tmp /= 10.0, x += tmp * (ch - &#39;0&#39;);
    if (sign) x = -x;
  }
  inline void read(char *s) {
    register char ch = gc();
    for (; blank(ch); ch = gc())
      ;
    for (; !blank(ch); ch = gc()) *s++ = ch;
    *s = 0;
  }
  inline void read(char &amp;c) {
    for (c = gc(); blank(c); c = gc())
      ;
  }
  inline void push(const char &amp;c) {
#if DEBUG
    putchar(c);
#else
    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;
    *pp++ = c;
#endif
  }
  template &lt;class T&gt;
  inline void write(T x) {
    if (x &lt; 0) x = -x, push(&#39;-&#39;);
    static T sta[35];
    T top = 0;
    do {
      sta[top++] = x % 10, x /= 10;
    } while (x);
    while (top) push(sta[--top] + &#39;0&#39;);
  }
  template &lt;class T&gt;
  inline void write(T x, char lastChar) {
    write(x), push(lastChar);
  }
} io;

const int SIZE = 1e6 + 5;
int n, m, k, a[SIZE];
LL tree[SIZE], ans;
vector &lt; int &gt; In[SIZE&lt;&lt;1], Out[SIZE&lt;&lt;1];

void Add(int x, int y) { for (; x &lt; SIZE; x += x &amp; -x) tree[x] += y; }

int Ask(int x, int res = 0) { for (; x; x -= x &amp; -x) res += tree[x]; return res; }

int KthElement(int k) {
    int l = 1, r = SIZE - 5;
    while (l &lt; r)
        if (Ask(mid) &lt; k) l = mid + 1;
        else r = mid;
    return l;
}

signed main() {
    io.read(m), io.read(n), io.read(k);
    int L, R;
    for (int i = 1; i &lt;= m; ++i) {
        io.read(a[i]);
        io.read(L);
        io.read(R);
        if (L &lt; R) L += n + 1, R += n, In[L].pub(i), Out[R + 1].pub(i);
        else L ^= R ^= L ^= R, L += n, R += n + 1, In[1].pub(i), Out[L + 1].pub(i), In[R].pub(i);
    }
    int now = 0, x;
    for (int i = 1; i &lt;= (n&lt;&lt;1); ++i) {
        for (int j = 0; j &lt; In[i].size(); ++j) Add(a[In[i][j]], 1);
        for (int j = 0; j &lt; Out[i].size(); ++j) Add(a[Out[i][j]], -1);
        now += In[i].size() - Out[i].size();
        if (now &gt;= k) x = KthElement(now - k + 1), ans += (LL)x * x;
    }
    printf(&quot;%lld\n&quot;, ans);
    return 0;
}
</code></pre>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BoringHacker</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BoringHacker</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
