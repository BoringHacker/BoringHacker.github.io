<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-cn">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="Hexo, NexT">


<meta property="og:type" content="website">
<meta property="og:title" content="BoringHacker&#39;s Blog">
<meta property="og:url" content="www.orchid-any.cf/page/5/index.html">
<meta property="og:site_name" content="BoringHacker&#39;s Blog">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BoringHacker&#39;s Blog">



  <link rel="alternate" href="/atom.xml" title="BoringHacker's Blog" type="application/atom+xml">




  <link rel="canonical" href="www.orchid-any.cf/page/5/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>BoringHacker's Blog</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">BoringHacker's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Stay Hungry, Stay Foolish</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br>Home</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archives</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-KMP-STRING/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-KMP-STRING/" itemprop="url">数据结构100题 ---KMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-12.png" rel="gallery_ck8wtuwvc0020xgvrdjs28fol" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-12.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h1><p>upd:代码锅已补</p>
<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>本文和某播放软件KMPlayer没有一毛钱关系，并且：</p>
<p><img src="https://i.loli.net/2020/01/25/H7tNJjLzPlMeSun.png" alt="f.PNG"></p>
<p>伦家是数据结构！</p>
<h1 id="0x01-引入问题"><a href="#0x01-引入问题" class="headerlink" title="0x01 引入问题"></a>0x01 引入问题</h1><p>设想这样一个问题：</p>
<p>给你两个字符串，让你查找在文本串中模式串的位置。</p>
<p>暴力做法是显然的，举例来说：</p>
<p>文本串(text)：$\texttt{a b c b c g l x}$</p>
<p>模式串(pattern): $\texttt{b c g l}$</p>
<p>我们直接暴力枚举text中的每一个字符，并且依次与pattern中的字符从头开始匹配。时间复杂度为 $\Theta(nm)$</p>
<h1 id="0x02-发现问题"><a href="#0x02-发现问题" class="headerlink" title="0x02 发现问题"></a>0x02 发现问题</h1><p>这样做其实有很多冗余操作。比如说：$\texttt{b c g l}$ 与text中的 $\texttt{b c b c}$ 不匹配，又从第text的第五个字母 $\texttt{c}$ 开始匹配。这样做是显然不必要的。为什么呢？因为模式串是以  $\texttt{b}$ 开头的，对于text中第五个字母 $\texttt{c}$ 显然我们可以不去匹配。发现了什么吗？每次失配后我们只需要从两个字符串的最长公共部分开始匹配即可。这里看不懂没有什么关系，只要能理解后面的例子就可以了。</p>
<h1 id="0x03-解决一部分问题"><a href="#0x03-解决一部分问题" class="headerlink" title="0x03 解决一部分问题"></a>0x03 解决一部分问题</h1><p>$\qquad\qquad\quad\ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5\ \ 6\ \ 7\ \ 8\ \ 9\ 10\ 11$</p>
<p>文本串(text)： $\texttt{a b x a b c a b c a b y}$</p>
<p>$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$</p>
<p>模式串(pattern)： $\texttt{a b c a b y}$</p>
<p>我们有两个指针i和j，分别指向文本串和模式串。在i=0,j=0以及i=1,j=1的时候都匹配上了。但是在i=2,j=2时失配了。如果时朴素算法的话会令i=1,j=0重新开始匹配。然而我们发现我们完全可以令i=3,j=0来重新匹配。一直到i=8,j=5时，它们又失配了。我们令j等于模式串和文本串已经配对完成的部分(即pattern[0]~pattern[4])的最长公共前缀后缀(即pattern[0,1]和pattern[3,4])的前缀末尾部分+1(即1+1=2)的地方，此时的text[6,7]和pattern[0,1]都是ab也就是说我们可以直接从i=8,j=2开始匹配，就可以匹配到模式串了。这就是KMP玄妙的地方。</p>
<h1 id="0x04-解决另一部分问题"><a href="#0x04-解决另一部分问题" class="headerlink" title="0x04 解决另一部分问题"></a>0x04 解决另一部分问题</h1><p>那么问题来了：我们如何确定模式串最长公共前后缀的前缀末尾+1的位置呢？我们还是通过一个例子来感受。</p>
<p>$\qquad\qquad\qquad\ \ \ 0\ \ 1\ \ 2\ \ 3\ \ 4\ \ 5$</p>
<p>模式串(pattern)： $\texttt{a b c a b y}$ (没错就是上面那个我太懒了)</p>
<p>我们可以设数组$next_i$为以 $i$ 为结尾的模式串最长公共前后缀的前缀末尾+1的位置。</p>
<p>$next_0$显然为0。</p>
<p>我们依然设两个指针i和j，i初始化为0，即指向模式串的开头。j初始化1，即i后面一个。</p>
<p>pattern[i]不等于pattern[j]，令next[i]=0，j+=1</p>
<p>pattern[i]依然不等于pattern[j]，令next[i]=0，j+=1</p>
<p>此时pattern[i]等于pattern[j]，令next[i]=j+1=1，i+=1，j+=1</p>
<p>此时pattern[i]等于pettern[j]，令next[i]=j+1=2，i+=1,j+=1</p>
<p>此时pattern[i]不等于patter[j]，并且j不在模式串的开头，令j=next[j-1]=2</p>
<p>此时pattern[i]依然不等于pattern[j]，并且j不在模式串的开头，令j=next[j-1]=0</p>
<p>此时pattern[i]依然不等于pattern[j]，但是j已经跑到开头去了，令i+=1</p>
<p>此时pattern[i]依然不等于pattern[j]，并且i已经跑到了尽头，求解结束。</p>
<p>%出来next数组是这样的:$[0,0,0,1,2,0]$</p>
<h1 id="0x05-解决所有问题"><a href="#0x05-解决所有问题" class="headerlink" title="0x05 解决所有问题"></a>0x05 解决所有问题</h1><p><del>其实就是放一下代码</del></p>
<p>我自认为讲的还是比较清楚，<del>至少比蓝书好</del>。</p>
<p>代码虽然和网上其他人的不太一样，不太标准，但还算简洁，<del>至少比蓝书好</del>。</p>
<p>总之一句话，学KMP不要看书，不要看书，不要看书！！！会死人的！！！</p>
<p>对了还有一个坑点，我这份代码用std::string会RE，<del>鬼知道我调了一下午发现是这个原因时心里有多傻逼</del></p>
<pre><code class="lang-cpp">/*
 * P3375【模板】KMP字符串匹配.cpp
 * Created by boringhacker(c20220233wgy)
*/
#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;

using namespace std;

namespace MAIN {
    const int SIZE = 1000000 + 5;
    int next[SIZE], n, m;
    char Text[SIZE], Pattern[SIZE];
    // string Text, Pattern; 去你的std::string

    void GetNextVal() {
        int i = 1, j = 0;
        *next = 0;
        while (i &lt; n) {
            if (Pattern[i] == Pattern[j])
                next[i] = j + 1, ++i, ++j;
            else if (j) j = next[j - 1];
            else ++i;
        }
    }

    void GetAnswers() {
        int st = 0, res = -1;
        int i = 0, j = 0, flag = 0;
        while (true) {
            j = st;
            if (Text[i] == Pattern[j]) {
                if (!flag) res = i + 1 - st, flag = 1;
                // if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = 0, flag = 0; 这里出锅了，j应该赋为next[j-1]
                if (j == n - 1) cout &lt;&lt; res &lt;&lt; endl, j = next[j - 1], flag = 0;
                else ++i, ++j;
                st = j;
                if (i &gt;= m) return ;
            }
            else {
                if (j) st = next[j - 1];
                else ++i;
                flag = 0;
            }
        }
    }

    void MAIN() {
        cin &gt;&gt; Text;
        cin &gt;&gt; Pattern;
        m = strlen(Text);
        n = strlen(Pattern);
        GetNextVal();
        GetAnswers();
        for (int i = 0; i &lt; n; ++i) cout &lt;&lt; next[i] &lt;&lt; &#39; &#39;;
    }
}

signed main() {
    MAIN::MAIN();
    return 0;
}
</code></pre>
<h1 id="欢迎捉虫子"><a href="#欢迎捉虫子" class="headerlink" title="欢迎捉虫子"></a>欢迎捉虫子</h1>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-MO-ALGORITHM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-MO-ALGORITHM/" itemprop="url">数据结构100题 ---莫队</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-10.png" rel="gallery_ck8wtuwvk0029xgvrr2k46ey5" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-10.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="莫队"><a href="#莫队" class="headerlink" title="莫队"></a>莫队</h1><p>($n\sqrt{n}$)</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>考虑这样一个问题：</p>
<p>对于一个序列$A_1,A_2,\cdots,A_n$，有如下询问</p>
<p>形如$S\ \ l\ \ r$的命令表示对区间$[l,r]$求和，并输出</p>
<p>形如$Q\ \ l\ \ r$表示$\cdots$</p>
<p>本题不强制在线</p>
<p>对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改<del>但我太弱不会</del></p>
<p>现在你有区间$[3,5]$的和，可以求$[3,6]$的区间和吗？显然，将$[3,5]$的区间和加上$A_6$即可。类似的，求$[2,4]$的区间和，我们只需减去$A_5$即可。</p>
<p>可以结合下图感知一下</p>
<p><img src="https://i.loli.net/2020/01/05/b63tfzYDl7VwdXC.png" alt="spfa.png"></p>
<p><img src="https://i.loli.net/2020/01/05/uAa95JElrb7kCxQ.png" alt="spfa.png"></p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>好，接下来我们想一下如何维护这种询问之间的关系。</p>
<p>很容易想到排序，首先我们对询问的左端点进行排序。再把整个<code>询问</code>序列分为$\sqrt{n}$块，每块以内再按右端点排序。</p>
<p>所以我们可以得出以下结论：</p>
<ul>
<li>莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案</li>
</ul>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>来一道简单的例题</p>
<h3 id="小B的询问"><a href="#小B的询问" class="headerlink" title="小B的询问"></a>小B的询问</h3><p>小B 有一个长为 $n$ 的整数序列 $a$，值域为 $[1,k]$。<br>他一共有 $m$ 个询问，每个询问给定一个区间 $[l,r]$，求：  </p>
<p>其中 $c_i$ 表示数字 $i$ 在 $[l,r]$ 中的出现次数。<br>小B请你帮助他回答询问</p>
<hr>
<p>这道题让我们求</p>
<script type="math/tex; mode=display">\sum\limits_{i=1}^k c_i^2</script><p>开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;cmath&gt;

using namespace std;

const int SIZE = 5e4 + 5;
struct QueryNode {
    int l, r;
    int id; // 储存询问的顺序，方便输出
} Q[SIZE];
int a[SIZE], n, m, k, pos[SIZE];
int cnt[SIZE], ans[SIZE], res;

// a:原序列
// pos:每个位置所处的块
// cnt:桶
// ans:询问的答案
// res:每次调整所得到的贡献

inline void add(int x) { cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - 1) * (cnt[a[x]] - 1); }

inline void del(int x) { cnt[a[x]]--, res -= (cnt[a[x]] + 1) * (cnt[a[x]] + 1) - cnt[a[x]] * cnt[a[x]]; }

signed main() {
    scanf(&quot;%d %d %d&quot;, &amp;n, &amp;m, &amp;k);
    int block = sqrt(n);
    for (int i = 1; i &lt;= n; ++i) scanf(&quot;%d&quot;, &amp;a[i]), pos[i] = i / block;
    for (int i = 1; i &lt;= m; ++i) scanf(&quot;%d %d&quot;, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;
    sort(Q + 1, Q + 1 + m, [](QueryNode x, QueryNode y) { return pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; });
    int l = 1, r = 0;
    for (int i = 1; i &lt;= m; ++i) {
        while (l &gt; Q[i].l) add(--l); // 这四句都是在对当前的区间对于询问的区间进行调整
        while (r &lt; Q[i].r) add(++r); // 这三句都是在对当前的区间对于询问的区间进行调整
        while (l &lt; Q[i].l) del(l++); // 这二句都是在对当前的区间对于询问的区间进行调整
        while (r &gt; Q[i].r) del(r--); // 这一句都是在对当前的区间对于询问的区间进行调整
        ans[Q[i].id] = res;
    }
    for (int i = 1; i &lt;= m; ++i) printf(&quot;%d\n&quot;, ans[i]);
    return 0;
}
</code></pre>
<h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><p>其实莫队是有套路的，基本上莫队的题都是这样的:</p>
<pre><code class="lang-cpp">    for (int i = 1; i &lt;= m; ++i) {
        while (l &gt; Q[i].l) add(--l);
        while (r &lt; Q[i].r) add(++r);
        while (l &lt; Q[i].l) del(l++);
        while (r &gt; Q[i].r) del(r--);
        ans[Q[i].id] = res;
    }
</code></pre>
<p>我们只需考虑$add$函数以及$del$函数即可</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-LINK-CUT-TREE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-LINK-CUT-TREE/" itemprop="url">数据结构100题 ---Link-Cut Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-11.png" rel="gallery_ck8wtuwvn002cxgvreace08yx" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-11.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="Link-Cut-Tree"><a href="#Link-Cut-Tree" class="headerlink" title="Link-Cut Tree"></a>Link-Cut Tree</h1><h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>本文的图来自<a href="https://www.luogu.com.cn/blog/Qiu/qian-tan-link-cut-tree" target="_blank" rel="noopener">Qiuly的博客浅谈link-cut Tree</a></p>
<p>本文照搬<a href="https://www.luogu.com.cn/blog/Qiu/qian-tan-link-cut-tree" target="_blank" rel="noopener">Qiuly的博客浅谈link-cut Tree</a></p>
<p>lct这东西不好写，我这种蒟蒻写不好所以只能照搬Qiuly，跟Qiuly唯一的区别就是我字是自己打的……</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>LCT其实可以看做加强版的重链剖分，可以说重链剖分能做的LCT都能做。不仅如此，LCT代码比重链剖分短，常数<del>有时</del>比重链剖分小。</p>
<p>LCT由很多棵Splay组成，其中将Splay森林中的所有Splay连接起来的叫做 <strong>虚边</strong> 。Splay中边叫做实边。</p>
<p>原来的森林我们叫做原森林，用实边连起来的一棵树叫原树。Splay的关键字是节点在书中的深度。</p>
<p>Splay是LCT的辅助树。fhq-treap其实也可以，但均摊时间复杂度会多出一个\log</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>以下是一些LCT常用的基础操作</p>
<ol>
<li><code>access(x)</code>:将x到root的路径上的边全部变成实边，并断开与自己儿子的联系</li>
<li><code>findroot(x)</code>:找出x所在原树的root</li>
<li><code>makeroot(x)</code>:让x变为所在原树的root</li>
<li><code>connect(x,y)</code>:连接x和y所在的原树</li>
<li><code>erase(x,y)</code>:拆开x和y所在的原树</li>
<li><code>split(x,y)</code>:将x,y搞在一棵辅助树</li>
</ol>
<p><ul></ul></p>
<p><li></li></p>
<p></p><h1>Access(x):</h1><p></p>
<p></p><p>换句话来说就是将点x到原树中root之间的链丢到一个splay里</p><p></p>
<p></p><p>举个例子，现在有一个森林长成这样：</p><br>&lt;/li&gt;<br>&lt;/ul&gt;<p></p>
<p></p><p><img src="https://i.loli.net/2019/02/23/5c70a02e87a40.png" alt="LCT"></p><p></p>
<p></p><p>现在x为6。我们access(x)。</p><p></p>
<p></p><p>那么{1-3，3-6}会变为实边，1-2会变成<em>虚边</em>，假设6有一儿子n，之间用<strong>实边</strong>连着，那么这条边也将变成<strong>虚边</strong>。</p><p></p>
<p></p><p>每次将 x 点 <em>splay</em> 到当前所在辅助树的根节点，将它的右儿子更新为上一个 x ，然后令 x 跳到它的父节点，第一个 x 的右儿子设为0。</p><p></p>
<pre>为什么是右儿子而不是左儿子呢？

   因为fa[x]的深度小于x，而在Splay里面fa[x]是x的爸爸，所以x在Splay中是fa[x]的右儿子。</pre>
<p><img src="https://i.loli.net/2019/02/23/5c70a02e89ed1.png" alt="LCT"></p>
<p>我们将 x 旋转到辅助树的根节点，也就是将当前原树这条链上深度小于 x (在 x 上面的点)丢到了 x 的左子树上，将 x 的右子树设为上一个 x 点相当于将 x 原来的右子树丢到了新的 <em>splay</em> 里面(而它们之间用<strong>虚边</strong>相连)，并且将上一段链连接起来。</p>
<p>现在就可以了。这棵新 <em>Splay</em> 中只有这条链上的结点，没有其他任何的结点。如果我们指定要这三个结点同时进行操作，可以直接下传lazy_tag到这三个结点组成的 <em>Splay</em> 的根结点哦!到后面Splay的时候就可以直接下传跟新结点信息了。</p>
<p><strong>总体过程：</strong></p>
<p><img src="https://i.loli.net/2019/02/23/5c70a02e9f825.png" alt="LCT"></p>
<blockquote>
<p><strong>虚边：儿子认父，父不认子</strong></p>
<p><strong>实边：儿子认父，父也认子</strong></p>
</blockquote>
<p>用FlashHu的话来说：</p>
<blockquote>
<p>1.转到根。</p>
<p>2.换儿子。</p>
<p>3.更新信息。</p>
<p>4.当前操作点切换为轻边所指的父亲，转1。</p>
</blockquote>
<pre><code class="language-cpp">inline void Access(int x){
    for(register int y=0;x;y=x,x=fa[x]){
        Splay(x);//转    ch[x][1]=y;//认儿子了
        pushup(x);//儿子有变化，更新
    }
}</code></pre>
<hr>
<ul>
<li>
<h1>findroot(x):</h1>
</li>
<li>
<p>首先要明白：</p>
<ul>
<li>根节点是的深度最小的</li>
</ul>
</li>
</ul>
<p>我们可以通过x向上找，用 <em>Access</em> 操作可以将x和x的根结点搞到一个 <em>Splay</em> 里。</p>
<p>又因为有BST的性质：x的左子树所有结点的权值 &lt; x &lt; x右子树所有结点的权值。</p>
<p>而我们又知道，在执行完 <em>Access</em> 操作后，这课 <em>Splay</em> 里面的结点权值最大的(深度最大的)就是x。</p>
<p>于是我们可以将x <em>Splay</em> 到这棵 <em>Splay</em> 的根结点，那么现在最左边的节点便是这课树的根结点了。</p>
<pre><code class="language-cpp">inline int findroot(int x){
    Access(x);//Access将x和根结点搞到同一个Splay中
    Splay(x);//转到Splay的根结点
    while(ch[x][0])pushdown(x),x=ch[x][0];//不断的找左儿子&amp;更新节点信息
    return x;//最左边的就是根结点了。
}</code></pre>
<hr>
<ul>
<li>
<h1>makeroot(x):</h1>
<blockquote>
<p>将x到根结点的路径上的点全部翻转(即x变成了根节点)</p>
</blockquote>
</li>
</ul>
<p>具体操作是我们先将x点与原树中的根打通一条链，那么现在它们就在同一棵辅助树里面了，我们发现x一定是在它所在的辅助树的中序遍历的最后一个的(因为它是这条链上最深的点)，我们把x点 <em>splay</em> 到辅助树的根上，那么x显然是没有右子树的，我们要实现将x移到原树的根上，也就是将x到根的这条链的深度全部翻转一遍，在辅助树上的体现就是将整棵树翻转一遍，我们可以写个翻转标记来减少复杂度。</p>
<pre><code class="language-cpp">inline void filp(int x){//Splay普通区间翻转
    swap(ch[x][0],ch[x][1]);r[x]^=1;
} 
inline void makeroot(int x){
    Access(x);
    Splay(x);
    filp(x);//lazy_tag&amp;翻转区间
}</code></pre>
<hr>
<ul>
<li>
<h1>split(x,y)</h1>
</li>
</ul>
<p>这个操作是将x到y之间的那条路径丢到一棵辅助树里，并且这棵辅助树以y节点为根。</p>
<p><em>Splay</em> 维护的是原树中的一条链，我们不能保证x,y会在同一条链里。</p>
<p>所以我们可以先把x变成原树的根节点(这下子Access(y)就会将x到y之间的所有节点丢到一个 <em>Splay</em> 中了)。</p>
<pre><code class="language-cpp">inline void split(int x,int y){
    makeroot(x);Access(y);Splay(y);
} </code></pre>
<hr>
<ul>
<li>
<h1>connect(x,y):</h1>
<blockquote>
<p>将x和y所在原树合并起来</p>
</blockquote>
</li>
</ul>
<p>首先将x点丢到原树的根，然后去找找y的根是不是x，如果不是说明x,y不在一个原树内，我们将x的父节点设为y，也就相当于从y到x连了一条虚边。</p>
<pre><code class="language-cpp">inline void connect(int x,int y){
    makeroot(x);//转到根
    if(findroot(y)!=x)fa[x]=y;//连接一条虚边
    /</code></pre>
<p><img src="https://cdn.luogu.com.cn/upload/pic/49569.png" alt></p>
<hr>
<ul>
<li>
<h1>erase(x,y):</h1>
<p>首先我们先把x,y之间的那条边用split(x,y)拎出来，因为x,y是相邻的，所以y的左儿子一定是x，将它们的父子关系消灭掉即可。</p>
<p>消灭父子关系时一定满足以下条件：</p>
<p>1.x和y在一个原树里(不在一个树里面往哪儿切啊)</p>
<p>2.split之后x是y的左儿子</p>
<p>3.x的右儿子是空的(保证了中序遍历中y紧跟在x的后面，即深度相邻)(x的权值(深度)只比y小1，而x又正好是直接连着y的，所以我们无法再找到 &gt;x 而又 &lt;y 的整数了)</p>
</li>
</ul>
<pre><code class="language-cpp">inline void erase(int x,int y){
    split(x,y);
    if(findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1]  fa[x]=ch[y][0]=0;
    }return;
}</code></pre>
<p>但是如果我们在findroot中添加了Splay的话，erase中x和y的父子关系就变了，需要改为这样，否则会出现一些奇奇怪怪的错误：</p>
<pre><code class="language-cpp">inline void erase(int x,int y){
    split(x,y);
    if(findroot(y)==x&amp;&amp;fa[y]==x&amp;&amp;!  fa[y]=ch[x][1]=0;pushup(x);
 de></code></pre>
<hr>
<ul>
<li>
<h1>0X03 Splay的改动：</h1>
</li>
<li>
<h1>旋转的改动：</h1>
<p>这里需要注意一下，如果x的父亲节点的父亲节点y已经不在当前的这棵辅助树上，只需要连单向边(也就是虚边，认父不认子)，否则正常连就行，这里要和普通的rotate区分开来。</p>
</li>
</ul>
<h2>做个对比：</h2>
<p>现在的rotate(x):</p>
<p>这里的x可以不更新，因为会在下一次rotate时更新。
<pre><code class="language-cpp">inline void rotate(int x){
    int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; 
   x;ch[x][!k]=y,ch[y][k]=v;
    if(v)fa[v]=y;fa[y]=x,fa[x]=z;pushup(y);
}<rotate(x):< p>
<pre><code class="language-cpp">inline void rotate(int x){
    int y=fa[x],z=fa[y],k=chk(x),v=ch[x][!k]; 
   ]=y,ch[y][k]=v;
    fa[v]=y;fa[y]=x,fa[x]=z;pushup(y),pushup(xli>
<h1>Splay的改动</h1>
<p>同样要注意一下只能Splay到辅助树的根节点，Splay之前需先下传一下这一条链上需操作的所有的点，用栈来完成即可</p>


<pre><code class="language-cpp">inline void Splay(int x){
    int y=x,top=0;hep[++top]=y;
    while(get(y))hep[++top]=y=fa[y];
    while(top)pushdown( while(get(x)){//基本普通的Splay
        y=fa[x],top=fa[y];
        rotate((ch[y][0]==x)^(ch[top][0]==y)?x:y);
        rotate(x);
    }pushup(x);return; 
}</code></pre>

<p>最后放一下模板题代码</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
#include &lt;stack&gt;

using namespace std;

const int SIZE = 3e5 + 5;
struct ReadNode {
    template &lt; typename T&gt;
    void operator &gt;&gt; (T &amp;a) {
        a = 0; T f = 1; char ch;
        while (!isdigit(ch = getchar())) if (ch == &#39;-&#39;) f = -1;
        while (isdigit(ch)) a = (a &lt;&lt; 3) + (a &lt;&lt; 1) + (ch ^ &#39;0&#39;), ch = getchar();
        a *= f;
    }

    template &lt; typename T&gt;
    void write(T x) {
        if (x &lt; 0) x = -x, putchar(&#39;-&#39;);
        if (x &gt; 9) write(x / 10);
        putchar(x % 10 + &#39;0&#39;);
    }

    template &lt; typename T&gt;
    void operator &lt;&lt; (T x) {
        write(x);
    }
} win;
int n, q, dis[SIZE];

/******************LinkCutTree******************/

class LinkCutTree {
private:
    struct TreeNode {
        int ch[2];
        int val;
        int sum;
        int rev;
        int fa;
    } T[SIZE + 5];
    int st[SIZE + 5];

    inline void exch(int &amp;x, int &amp;y) { x ^= y ^= x ^= y; }
    inline void reverse(int x) { exch(T[x].ch[0], T[x].ch[1]); T[x].rev ^= 1; }
    inline void link(int x, int y, int w) { T[T[x].fa = y].ch[w] = x; }
    inline bool push_up(int x) { return (T[x].sum = T[x].val ^ T[T[x].ch[0]].sum ^ T[T[x].ch[1]].sum), 1; }
    inline void push_down(int x) { T[x].rev &amp;&amp; (reverse(T[x].ch[0]), reverse(T[x].ch[1]), T[x].rev = 0); }
    inline void makeroot(int x) { access(x); splay(x); reverse(x); }
    inline void split(int x, int y) { makeroot(x); access(y); splay(y); }
    inline bool isroot(int x) { return (T[T[x].fa].ch[0] ^ x &amp;&amp; T[T[x].fa].ch[1] ^ x); }
    inline bool which(int x) { return T[T[x].fa].ch[1] == x; }
    inline void rotate(int x) { int y = T[x].fa, z = T[y].fa, w = which(x); !isroot(y) &amp;&amp; (T[z].ch[which(y)] = x), T[x].fa = z, link(T[x].ch[w ^ 1], y, w), link(y, x, w ^ 1), push_up(y), push_up(x); }
    inline void splay(int x) { int y = x, top = 0; while (st[++top] = y, !isroot(y)) y = T[y].fa; while (top) push_down(st[top]), --top; while (!isroot(x)) y = T[x].fa, !isroot(y) &amp;&amp; (rotate(which(x) ^ which(y) ? x : y), 0), rotate(x); }
    inline void access(int x) { for (int son = 0; x; x = T[son = x].fa) splay(x), T[x].ch[1] = son, push_up(x); }
    inline int getroot(int x) { access(x), splay(x); while (T[x].ch[0]) push_down(x), x = T[x].ch[0]; return splay(x), x; }

public:
    inline void init(int length, int *data) { for (int i = 1; i &lt;= length; ++i) T[i].val = data[i]; }
    inline void connect(int x, int y) { makeroot(x), getroot(y) ^ x &amp;&amp; (T[x].fa = y); }
    inline void erase(int x, int y) { makeroot(x), !(getroot(y) ^ x) &amp;&amp; !(T[y].fa ^ x) &amp;&amp; !(T[y].ch[0]) &amp;&amp; (T[y].fa = T[x].ch[1] = 0, push_up(x)); }
    inline void insert(int x, int v) { splay(x), T[x].val = v; }
    inline int find(int x, int y) { return split(x, y), T[y].sum; }
} lct_mast;

/*****************EndLinkCutTree*****************/

signed main() {
    win &gt;&gt; n; win &gt;&gt; q;
    for (int i = 1; i &lt;= n; ++i) win &gt;&gt; dis[i];
    lct_mast.init(n, dis);
    for (int i = 1; i &lt;= q; ++i) {
        int opt, x, y;
        win &gt;&gt; opt; win &gt;&gt; x; win &gt;&gt; y;
        switch(opt) {
        case 0: win &lt;&lt; lct_mast.find(x, y), puts(&quot;&quot;); break;
        case 1: lct_mast.connect(x, y); break;
        case 2: lct_mast.erase(x, y); break;
        case 3: lct_mast.insert(x, y); break;
        }
    }
    return 0;
}
</code></pre>
</code></pre></rotate(x):<></code></pre></p>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-SPLAY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-SPLAY/" itemprop="url">数据结构100题 ---splay</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-8.png" rel="gallery_ck8wtuww0002sxgvrapcc9kqs" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-8.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="update"><a href="#update" class="headerlink" title="update:"></a>update:</h1><p>增加几道好一点的例题吧</p>
<p><a href="https://www.luogu.com.cn/problem/P1486" target="_blank" rel="noopener">[NOI2004]郁闷的出纳员</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3391" target="_blank" rel="noopener">[模板]文艺平衡树</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3988" target="_blank" rel="noopener">[SHOI2013]发牌</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3871" target="_blank" rel="noopener">[TJOI2010]中位数</a></p>
<p><a href="https://www.luogu.com.cn/problem/P3850" target="_blank" rel="noopener">[TJOI2007]书架</a></p>
<h1 id="正文：关于SPLAY"><a href="#正文：关于SPLAY" class="headerlink" title="正文：关于SPLAY"></a>正文：关于SPLAY</h1><p>其实我更偏向于把splay叫做<del>cosplay</del></p>
<p>讲平衡树总逃不过BST(Binary Search Tree)，二叉搜索树，以下是BST的性质：</p>
<p>一棵合法的BST每个节点上都带有一个数值，我们将其称为节点的“关键码”。那么对于一棵BST上的任意节点，满足：</p>
<ul>
<li><p>该节点的关键码不小于它左子树的任意结点的关键码</p>
</li>
<li><p>该结点的关键码不大于它右子树的任意结点的关键码</p>
</li>
</ul>
<p><code>显然</code>，BST的中序遍历是一个递增的序列</p>
<h2 id="建立一棵BST"><a href="#建立一棵BST" class="headerlink" title="建立一棵BST"></a>建立一棵BST</h2><p>因为笔者很懒，不想到处判边界，所以我们一般可以在一棵空的BST中预先插入两个结点，一个正无穷，一个负无穷，如图:</p>
<p><img src="https://i.loli.net/2019/12/13/V2N6AQUynRGvzYI.png" alt="img spfaed"></p>
<pre><code class="lang-cpp">const int SIZE = 1e5 + 5;
const int INF = 0x7fffffff;
struct BSTNode {
    int l, r; // 左右儿子的编号
   int val; // 关键码
} T[SIZE];
int tot, root;

int clone(int val) { // 新建节点
    T[++tot].val = val;
   return tot;
}

void build() {
    clone(-INF), clone(INF);
   root = 1, T[1].r = 2;
}
</code></pre>
<p>以上是建树的代码</p>
<p>那么，BST就讲到这里</p>
<h2 id="平衡树的诞生"><a href="#平衡树的诞生" class="headerlink" title="平衡树的诞生"></a>平衡树的诞生</h2><p>当BST形成一条链的时候，每次查询会变成$O(n^2)$</p>
<p>这种深度过深的BST是不平衡的。所以我们需要一种能保持树的深度在$\log(n)$的数据结构，于是便诞生了平衡树</p>
<h2 id="SPLAY"><a href="#SPLAY" class="headerlink" title="SPLAY"></a>SPLAY</h2><p>splay，又称<del>cosplay</del>伸展树，有“序列之王”的美称，<del>常数巨大</del>，跑的没有$fhq-treap$快，但这不在我们的讨论范围以内</p>
<p><img src="https://i.loli.net/2019/12/13/jFfZRvedxLYJg2y.png" alt="graph.png"></p>
<p>想象一下这样一颗BST，我们先把它们的大小关系列出来。</p>
<script type="math/tex; mode=display">
Y<Z, C>Y, X<Y,A<X,B>X</script><p>对于这样一颗BST，我们可以通过一些特殊的方式来改变它的形态保持中序序列不变，这也是平衡树的精髓。</p>
<p>怎么改变呢？</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转<del>不转不是中国人</del>，这是splay的精髓所在。</p>
<p>现在我们的目标是让X节点往上爬到它父亲节点Y处，让Y变成X的幺儿，也就是让Y节点下降。</p>
<p><code>这个过程首先要满足BST性质</code></p>
<p>通过例图来思考，此时的X节点是Y节点的左儿子，小于Y节点，为了不改变中序序列，我们可以让Y节点成为X的右儿子。那么问题来了：变换后的Y的确大于X，但X还有一颗右子树呢！</p>
<p>别急，再回想一下BST的性质，任意节点大于其左子树中的任意节点，也就是说我们可以把X的左子树B拿给Y当左子树。</p>
<p>好了！世界核平了！<del>Tarjan放心了</del></p>
<p>展示一下旋转的成果吧！</p>
<p>旋转前：</p>
<p><img src="https://i.loli.net/2019/12/13/jFfZRvedxLYJg2y.png" alt="graph.png"></p>
<p>旋转后</p>
<p><img src="https://i.loli.net/2019/12/13/Dr5IfBWVl7b6PTH.png" alt="graph _1_.png"></p>
<p>别高兴得太早！</p>
<p>这只是一种情况，我们需要的是<code>通用</code></p>
<p>这里有一个小技巧，即：</p>
<script type="math/tex; mode=display">
odd\bigoplus1=odd-1</script><script type="math/tex; mode=display">
even\bigoplus1=even+1</script><p>这个性质的证明很简单：</p>
<p><code>即得易见平凡，仿照上例显然。</code></p>
<p><code>留作习题答案略，读者自证不难。</code></p>
<p><code>反之亦然同理，推论自然成立，略去过程QED，由上可知证毕。</code></p>
<p>$Just$ $a$ $joke$</p>
<p>设节点Y为X的父亲，Y的w(0代表左儿子，1代表右儿子)儿子</p>
<ul>
<li>$step1$:将Y节点放到X节点的w$\bigoplus$1的位置</li>
<li>$step2$:如果X的w$\bigoplus$1位置上有一颗子树，放在Y的w位置上</li>
</ul>
<pre><code class="lang-cpp">inline void update(int x) { // 更新节点信息
    T[x].siz = T[T[x].ch[0]].siz + T[T[x].ch[1]].siz + T[x].cnt;
}

inline void rotate(int x) { // 旋转
    int y = T[x].fa; // X它爹
    int z = T[y].fa; // X它爹它爹
    int w = T[y].ch[1] == x; // X是它爹的左幺儿还是右幺儿
    T[z].ch[T[z].ch[1] == y] = x;
    T[x].fa = z;
    T[y].ch[w] = T[x].ch[w ^ 1];
    T[T[x].ch[w ^ 1]].fa = y;
    T[x].ch[w ^ 1] = y;
    T[y].fa = x;
    update(y), update(x);
}
</code></pre>
<p>仅仅有rotate操作还不够，splay到目前为止依然很容易被卡。</p>
<p>想象这样一棵树：</p>
<p><img src="https://i.loli.net/2019/12/13/6hBzE2UsC8oJXfu.png" alt="img spfaed"></p>
<p>发现无论怎么旋转X都不能使得这棵树最长的一条链变短。我们称这种X，X它爹，X它爹它爹在一条线上的情况称为三点共线。</p>
<p>怎么办呢？<del>可怜的splay被人溜了</del></p>
<p>办法还是有滴</p>
<ul>
<li>$step1$:如果三点共线，我们可以先旋转X它爹，这样便可以使其更加“平衡”</li>
<li>$step2$:如果不共线……不共线……那就旋转X就好了</li>
</ul>
<p>这便是splay操作</p>
<pre><code class="lang-cpp">inline void splay(int x, int goal) { //splay
    for (; T[x].fa ^ goal; rotate(x)) { // 一直旋转到x成为goal的儿子
        int y = T[x].fa;
        int z = T[y].fa;
        if (z ^ goal)
            T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y); //判断三点是否共线，如果是，就旋转Y，否则旋转X
    }
    if (!goal) root = x; // 把根节点设为X
}
</code></pre>
<p>至此，splay就差不多讲完了，那么再来一道例题吧</p>
<p><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">【模板】普通平衡树</a></p>
<ul>
<li>题面：</li>
</ul>
<pre><code>您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：
1.插入 x 数
2.删除 x 数(若有多个相同的数，因只删除一个)
3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1 )
4.查询排名为 x 的数
5.求 x 的前驱(前驱定义为小于 x，且最大的数)
6.求 x 的后继(后继定义为大于 x，且最小的数)
</code></pre><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>首先我们先查找BST当中有没有和需要插入的节点关键码相同的节点，如果有，就把当前节点的“副本”数+1</p>
<p>如果没有，就遍历到叶子节点，再新增一个节点就好了</p>
<pre><code class="lang-cpp">inline void insert(int x) {
    int u = root, fa = 0; // 从根节点开始找
    while (u &amp;&amp; x ^ T[u].val) // 找关键码相同的节点
        fa = u, u = T[u].ch[x &gt; T[u].val];
    if (u) T[u].cnt++; // 如果有，就增加一个副本
    else { // 否则新建一个节点
        u = ++tot;
        if (fa) T[fa].ch[x &gt; T[fa].val] = u;
        T[u].fa = fa;
        T[u].siz = T[u].cnt = 1;
        T[u].ch[0] = T[u].ch[1] = 0;
        T[u].val = x;
    }
    splay(u, 0);
}
</code></pre>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>设查找节点的关键码为x，如果x大于当前节点的关键码，就往右子树跑，否则往左子树找。找到后把当前节点splay到根，保证BST的平衡</p>
<pre><code class="lang-cpp">inline void find(int x) {
    int u = root;
    if (!u) return ; // BST空
    while (T[u].ch[x &gt; T[u].val] &amp;&amp; x ^ T[u].val)
        u = T[u].ch[x &gt; T[u].val];
    splay(u, 0);
}
</code></pre>
<h2 id="前驱-后继操作"><a href="#前驱-后继操作" class="headerlink" title="前驱/后继操作"></a>前驱/后继操作</h2><p>首先执行find操作。</p>
<p>以前驱为例，当前的根节点就是x的父节点，所以如果root的关键码大于x，那么root就是x的前驱。否则就跳到左儿子找，再反着跳就好了</p>
<pre><code class="lang-cpp">inline int next_bound(int x, int f) { // f=0前驱，f=1后继
    find(x);
    int u = root; // x的父节点
    if (T[u].val &gt; x &amp;&amp; f) return u;
    if (T[u].val &lt; x &amp;&amp; !f) return u;
    u = T[u].ch[f]; // 跳到对应的子树
    while (T[u].ch[f ^ 1]) u = T[u].ch[f ^ 1]; // 反着跳转
    return u;
}
</code></pre>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>找到这个数的last，把他splay到根节点</p>
<p>然后找到这个数next，把他splay到last的底下</p>
<p>然后……然后就没有了呀……</p>
<p>比last大是next</p>
<p>比next小的且比last大的只有当前的节点</p>
<p>在next的左幺儿上面，</p>
<p>だから直接把root右幺儿的左幺儿删掉就可以了</p>
<pre><code class="lang-cpp">inline void erase(int x) {
    int last = next_bound(x, 0);
    int next = next_bound(x, 1);
    splay(last, 0), splay(next, last);
    int del = T[next].ch[0];
    if (T[del].cnt &gt; 1) {
        T[del].cnt--;
        splay(del, 0);
    }
    else T[next].ch[0] = 0;
}
</code></pre>
<h2 id="第K大"><a href="#第K大" class="headerlink" title="第K大"></a>第K大</h2><p>现在再来看已经十分简单了</p>
<p>首先如果左子树的大小加上本身的个数大于k，直接在左子树里找就行了</p>
<p>否则就把k减去左子树大小再减去本身的个数，再在右子树里找就行了</p>
<pre><code class="lang-cpp">inline int kth_element(int x) {
    int u = root;
    if (T[u].siz &lt; x) return 0; // 没有那么多，直接死亡
    while (233) {
        int y = T[u].ch[0];
        if (x &gt; T[y].siz + T[u].cnt) {
            x -= T[y].siz + T[u].cnt;
            u = T[u].ch[1];
        }
        else if (T[y].siz &gt;= x) u = y;
        else return T[u].val;
    }
}
</code></pre>
<p>完整代码：</p>
<pre><code class="lang-cpp">#include &lt;cstdio&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;

using namespace std;

const int SIZE = 1e5 + 5;
int n, root, tot;
struct SPLAY {
    int fa;
    int siz;
    int cnt;
    int val;
    int ch[2];
} T[SIZE];

inline void update(int x) {
    T[x].siz = T[T[x].ch[0]].siz + T[T[x].ch[1]].siz + T[x].cnt;
}

inline void rotate(int x) {
    int y = T[x].fa;
    int z = T[y].fa;
    int w = T[y].ch[1] == x;
    T[z].ch[T[z].ch[1] == y] = x;
    T[x].fa = z;
    T[y].ch[w] = T[x].ch[w ^ 1];
    T[T[x].ch[w ^ 1]].fa = y;
    T[x].ch[w ^ 1] = y;
    T[y].fa = x;
    update(y), update(x);
}

inline void splay(int x, int goal) {
    for (; T[x].fa ^ goal; rotate(x)) {
        int y = T[x].fa;
        int z = T[y].fa;
        if (z ^ goal)
            T[y].ch[1] ^ x ^ T[z].ch[1] ^ y ? rotate(x) : rotate(y);
    }
    if (!goal) root = x;
}

inline void find(int x) {
    int u = root;
    if (!u) return ;
    while (T[u].ch[x &gt; T[u].val] &amp;&amp; x ^ T[u].val)
        u = T[u].ch[x &gt; T[u].val];
    splay(u, 0);
}

inline void insert(int x) {
    int u = root, fa = 0;
    while (u &amp;&amp; x ^ T[u].val)
        fa = u, u = T[u].ch[x &gt; T[u].val];
    if (u) T[u].cnt++;
    else {
        u = ++tot;
        if (fa) T[fa].ch[x &gt; T[fa].val] = u;
        T[u].fa = fa;
        T[u].siz = T[u].cnt = 1;
        T[u].ch[0] = T[u].ch[1] = 0;
        T[u].val = x;
    }
    splay(u, 0);
}

inline int next_bound(int x, int f) {
    find(x);
    int u = root;
    if (T[u].val &gt; x &amp;&amp; f) return u;
    if (T[u].val &lt; x &amp;&amp; !f) return u;
    u = T[u].ch[f];
    while (T[u].ch[f ^ 1]) u = T[u].ch[f ^ 1];
    return u;
}

inline void erase(int x) {
    int last = next_bound(x, 0);
    int next = next_bound(x, 1);
    splay(last, 0), splay(next, last);
    int del = T[next].ch[0];
    if (T[del].cnt &gt; 1) {
        T[del].cnt--;
        splay(del, 0);
    }
    else T[next].ch[0] = 0;
}

inline int kth_element(int x) {
    int u = root;
    if (T[u].siz &lt; x) return 0;
    while (233) {
        int y = T[u].ch[0];
        if (x &gt; T[y].siz + T[u].cnt) {
            x -= T[y].siz + T[u].cnt;
            u = T[u].ch[1];
        }
        else if (T[y].siz &gt;= x) u = y;
        else return T[u].val;
    }
}

signed main() {
    scanf(&quot;%d&quot;, &amp;n);
    insert(1e9);
    insert(-1e9);
    for (int i = 1; i &lt;= n; ++i) {
        int opt, x;
        scanf(&quot;%d %d&quot;, &amp;opt, &amp;x);
        if (opt == 1) insert(x);
        if (opt == 2) erase(x);
        if (opt == 3) {
            find(x);
            printf(&quot;%d\n&quot;, T[T[root].ch[0]].siz);
        }
        if (opt == 4) printf(&quot;%d\n&quot;, kth_element(x + 1));
        if (opt == 5) printf(&quot;%d\n&quot;, T[next_bound(x, 0)].val);
        if (opt == 6) printf(&quot;%d\n&quot;, T[next_bound(x, 1)].val);
    }
    return 0;
}
</code></pre>
<h1 id="欢迎捉虫子"><a href="#欢迎捉虫子" class="headerlink" title="欢迎捉虫子"></a>欢迎捉虫子</h1><p><img src="https://i.loli.net/2019/12/14/X5FNPW4wCqzgkQ9.png" alt="wd and noip.png"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-SEGMENT-TREE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-SEGMENT-TREE/" itemprop="url">数据结构100题 ---线段树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-9.png" rel="gallery_ck8wtuww3002vxgvrspfwx3re" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-9.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="线段树-—LYC-ZBing"><a href="#线段树-—LYC-ZBing" class="headerlink" title="线段树 —LYC(ZBing)"></a>线段树 —LYC(ZBing)</h1><p>($nlogn$)</p>
<p>线段树，顾名思义，就是每个树的节点记录一条线段上的一些信息，非常灵活，可以实现很多操作，但常数比树状数组大一点。</p>
<p>就像这样：</p>
<p><img src="https://i.loli.net/2019/12/28/qSIgzFlXGQ62xUi.png" alt></p>
<p>线段树的经典应用就是统计区间和，我们这里也用这个来进行线段树的讲解。</p>
<h4 id="1-建树"><a href="#1-建树" class="headerlink" title="1).建树"></a>1).建树</h4><p>我们先放代码吧，看代码理解。</p>
<pre><code>void build(int l,int r,int x)
{
    if(l==r)
    {
        nodes[x]=a[l];
        return; 
    }
    else
    {
        int mid=(l+r)&gt;&gt;1;
        build(l,mid,x&lt;&lt;1);
        build(mid+1,r,(x&lt;&lt;1)+1);
        nodes[x]=nodes[x&lt;&lt;1]+nodes[(x&lt;&lt;1)+1];
    }
}
</code></pre><p>首先，我们遍历到线段树的每一个叶子节点。线段树的每个节点都代表了一个区间，当这个区间的$l=r$时，说明我们到达了叶子节点。这个叶子节点代表的区间只包含了$a[l]$这一个数，所以我们只需要将这个节点的值置为$a[l]$。</p>
<p>然后我们递归回去，每一个非叶子节点都可以把它代表的区间分成两半，对应它的两个子节点（可能没有两个）。它两个子节点的值就是这两个较小区间的元素和。由这两个子节点的值也就是这两个小区间的元素和相加就可以得到当前节点代表区间的元素和。</p>
<p>时间复杂度($nlogn$)</p>
<h4 id="2-单点修改"><a href="#2-单点修改" class="headerlink" title="2).单点修改"></a>2).单点修改</h4><p>像这种区间和问题的单点修改一般都是给一个点加上一个值。</p>
<p>还是先放代码吧：</p>
<pre><code>void update(int l,int r,int x,int pos,int val)
{
    nodes[x]-=val;
    if(l==r)    return;
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)    update(l,mid,x&lt;&lt;1,pos,val);
    else    update(mid+1,r,(x&lt;&lt;1)+1,pos,val);
}
</code></pre><p>还是先递归找到要修改的叶子节点。先将它的值加上val。</p>
<p>然后再递归回去，因为往下找时找到的每一个节点代表的区间都包含这个叶子节点代表的区间，所以这些节点的值也要加上val。</p>
<p>时间复杂度($logn$)</p>
<h4 id="3-区间查询"><a href="#3-区间查询" class="headerlink" title="3).区间查询"></a>3).区间查询</h4><p>区间查询的本质就是把要查询的区间拆分成很多小区间，直接利用之前维护的节点的值进行查询。</p>
<pre><code>int find(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(l&gt;=fr||r&lt;=ba)    return nodes[x];
    int mid=(l+r)&gt;&gt;1;
    return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba);
}
</code></pre><p>我们对于当前递归查找到的节点所代表的区间与要查询的区间进行分类讨论：</p>
<p>$1$&gt;.毫无关联</p>
<p>即当前区间的左端点在查询区间右端点的右边或当前区间的右端点在查询区间左端点的左边。</p>
<p>既然他们毫无关联，那么我们就返回一个值0，因为他们对这个区间的和没有任何贡献。</p>
<p>$2$&gt;.被包含</p>
<p>即当前区间的左端点在查询区间的左端点的右边且当前区间的右端点在查询区间的右端点的左边。</p>
<p>既然这个节点代表的区间全部属于查询区间内，那么我们就没有必要再继续递归下去了，直接把这个节点的值加上去。</p>
<p>$3$&gt;.有部分重叠但不被包含</p>
<p>即上两种情况的剩余情况。</p>
<p>对于这种情况，我们没有办法把节点的值直接加上去，因为这个节点代表的区间不全属于查询区间。也不能直接跳过，因为有部分节点属于查询区间。所以我们继续向它的子节点递归，相当于把这个区间分成两半，查询两个子区间中属于查询区间的值加起来。</p>
<p>时间复杂度（$logn$）</p>
<h4 id="4-区间修改"><a href="#4-区间修改" class="headerlink" title="4).区间修改"></a>4).区间修改</h4><p>面对区间修改，如果我们继续用单点修改，时间复杂度会退回到（$n^2logn$）</p>
<p>所以我们引入<del>人类的本质</del>懒标记。</p>
<p>当我们找到了一个完全是要修改的区间，我们就直接把它的懒标记加上$val$。</p>
<p>对于中途遍历到的其他区间，我们直接计算修改这个区间的和。</p>
<p>代码：</p>
<pre><code>void update(int l,int r,int x,int fr,int ba,int val)
{
    if(l&gt;ba||r&lt;fr)    return;
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    lazy[x]+=val;
    else
    {
        nodes[x]+=val*max(0,min(r,ba)-max(l,fr)+1);
        int mid=(l+r)&gt;&gt;1;
        update(l,mid,x&lt;&lt;1,fr,ba,val);
        update(mid+1,r,(x&lt;&lt;1)+1,fr,ba,val);
    }
}
</code></pre><p><del>长得和区间查询很像对吧</del></p>
<p>改了修改之后，我们的查询也要进行修改。要把打上的懒标记进行下传，不然查询到下面的节点时，下面的节点没有被修改。</p>
<p>下传时只需要让当前节点加上原来应加而拖延了的值，让它的左右儿子的懒标记加上它的懒标记。因为当初修改时，并没有修改到左右节点。最后再把懒标记清零。</p>
<p>就像这样：</p>
<pre><code>void pushdown(int l,int r,int x)
{
    nodes[x]+=(r-l+1)*lazy[x];
    lazy[x&lt;&lt;1]+=lazy[x];
    lazy[(x&lt;&lt;1)+1]+=lazy[x];
    lazy[x]=0;
}
int find(int l,int r,int x,int fr,int ba)
{
    if(l&gt;ba||r&lt;fr)    return 0;
    if(lazy[x])    pushdown(l,r,x);
    if(l&gt;=fr&amp;&amp;r&lt;=ba)    return nodes[x];
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return find(l,mid,x&lt;&lt;1,fr,ba)+find(mid+1,r,(x&lt;&lt;1)+1,fr,ba);
    }
}
</code></pre><p>$\ $</p>
<p>线段树的讲解到这里就这么完了，但线段树的运用十分广泛，灵活。要熟练掌握并运用线段树，还要多动脑，想好题。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-SUFFIX-ARRAY/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-SUFFIX-ARRAY/" itemprop="url">数据结构100题 ---后缀全家桶 之 后缀数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-7.png" rel="gallery_ck8wtuww80031xgvr1ti3ocvh" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-7.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="后缀数组"><a href="#后缀数组" class="headerlink" title="后缀数组"></a>后缀数组</h1><h1 id="0x01-什么是后缀数组-Suffix-Array"><a href="#0x01-什么是后缀数组-Suffix-Array" class="headerlink" title="0x01 什么是后缀数组(Suffix Array)"></a>0x01 什么是后缀数组(Suffix Array)</h1><p>我们知道，对于一个长度为 $n$ 的字符串有 $n$ 个后缀，譬如对于字符串 $DCBAE$ 来说，它的后缀便是:</p>
<p><img src="https://i.loli.net/2020/01/30/uiheaoRLWdKEON6.png" alt="img spfaed"></p>
<p>那么什么是后缀数组( $SA$ )呢？在我们对字符串的 $n$ 个后缀排序过后，我们定义后缀数组：</p>
<blockquote>
<p>$SA$ 数组：排在第i位的是第 $SA$ [i]个后缀</p>
</blockquote>
<p>即后缀数组。</p>
<p>同时我们定义：</p>
<blockquote>
<p>RANK数组：排在第RANK[i]位的后缀是第i个后缀</p>
</blockquote>
<p>不难看出RANK和 $SA$ 互逆</p>
<p><img src="https://i.loli.net/2020/01/30/4jfIt1iy8V9XRPl.png" alt="img spfaed"></p>
<h1 id="0x02-如何求出-SA-数组-粗略的"><a href="#0x02-如何求出-SA-数组-粗略的" class="headerlink" title="0x02 如何求出 $SA$ 数组(粗略的)"></a>0x02 如何求出 $SA$ 数组(粗略的)</h1><p>朴素的做法是直接$sort$，$\Theta(n^2\log n)$ 爹妈恨铁不成钢。</p>
<p>稍微有点脑子都会想到$hash$但是依然爆炸。</p>
<p>如果深入思考的话很容易想到倍增，时间复杂度 $\Theta(n\log n)$ + 大常数碰上毒瘤题当场去世。</p>
<p>$DC3$？常数大，板子难背。</p>
<p>$LUOGU$ 日报曾经有过一片日报给出了一种诱导排序的解决方法，但是我不是很理解。</p>
<p>我在这里给出一种中文互联网上几乎没有任何资料的 $SA$ 数组线性时间复杂度构造方法(我也不知道叫什么名字)。</p>
<h1 id="0x03-如何求出-SA-数组-具体的"><a href="#0x03-如何求出-SA-数组-具体的" class="headerlink" title="0x03 如何求出 $SA$ 数组(具体的)"></a>0x03 如何求出 $SA$ 数组(具体的)</h1><p>首先定义文本串 $text$ 为我们的待求 $SA$ 的字符数组</p>
<p>其次定义 $suffix_i$ 为以 $i$ 起头的 $text$ 的后缀</p>
<p>然后定义 $type_i = \begin{cases}L, suffix_i &gt; suffix_{i+1} \\<br>\displaystyle S, suffix_i &lt; suffix_{i+1}\end{cases}$</p>
<p>参考图片(手写字可能有些看不清楚)：</p>
<p><img src="https://i.loli.net/2020/01/31/KYgnzM6IZJyoWtL.png" alt="img spfaed"></p>
<p>字符串最后的是什么？你可以认为这是因为作者懒不想到处判边界而加上的<strong>比字符串中任意一个字符的ASCLL码都小的字符</strong></p>
<p>再来定义 $dist_i$ 为 $text_i$ 距离上一个 $type_i$ 为 $S$ 的距离</p>
<p>参考图片(手写字可能有些看不清楚)：</p>
<p><img src="https://i.loli.net/2020/01/31/XE3QM7tsHuIPrhx.png" alt="img spfaed"></p>
<p>再定义一个桶 $bucket$，以 $text$ 中的字符为区别桶之间的“键值”。依然参考图片</p>
<p><img src="https://i.loli.net/2020/01/31/e5xzKhQsH39Ad17.png" alt="img spfaed"></p>
<p>我们其实可以发现此时的 $bucket$ 已经和我们要求的 $SA$ 差的不远了。为什么呢？桶排啊！此时的桶外部其实已经是有序的了，只是我们内部还无法确定顺序。比如 $I$ 这个桶里，我们无法确定 $suffix_{2},suffix_{5},suffix_{8},suffix_{11}$ 的排序顺序，因为他们开头的首字母不同。那该怎么办呢？请继续往下看。</p>
<p>我们再定义一个桶 $D_lists$ “键值” 为 $list_i$。参考图片(注意此时我们不考虑键值(即 $dist$ )为0的情况)</p>
<p><img src="https://i.loli.net/2020/01/31/HpJhDyjxR8u6iNC.jpg" alt="img spfaed"></p>
<p>以键值为1举一个例子。它的意思就是说 $dist$ 为1的情况有 $suffix_{9},suffix_{3,6}$ 这三种情况。与 $bucket$ 这个桶类似但不同的，我们能分清 $suffix_9$ 和 $sufiix_{3,6}$ 的顺序，但我们无法分清 $suffix_3$ 和 $suffix_6$ 的顺序。为什么呢？我们来看，下标为9的后缀是以 $P$ 开头的，然而下标为3和6的后缀却都是以 $S$ 开头的，所以 $suffix_9$ 一定排在 $suffix_{3,6}$ 的前面。$suffix_{3,6}$ 却因为首字母相同所以无法分清楚顺序。</p>
<p>下一步我们尝试将所有 $type$ 为 $S$ 的 $suffix$ 找出来</p>
<p>我们把 $bucket$ 扫一遍，即可得出：</p>
<p><img src="https://i.loli.net/2020/02/01/krfWd9FHhPqgtL2.png" alt="img spfaed"></p>
<p>图中的 $S-Substring$ 即为我们所求的所有 $type$ 为 $S$ 的 $suffix$。</p>
<p>同样，我们不知道 $suffix_{2,5,8}$ 哪个在前哪个在后。一种 $naive$ 的做法就是把 $[2,5,8]$ 依次+1，相当于直接暴力比较下一个字母，然后通过 $D_lists$ 来分析它们的先后关系。</p>
<p><img src="https://i.loli.net/2020/02/01/B6FUGwyXsdW4jkE.png" alt="img spfaed"></p>
<p>我们发现了一个悲剧的事实：已经加到3了，我们却依然无法分清 $[2,5]$ 的顺序。如果继续加下去或许可以分清它们的顺序，但时间复杂度就难以保持在 $\Theta(n)$，换句话说，它很容易被卡。</p>
<p><img src="https://i.loli.net/2020/02/01/nzZmpYLWh9gkwC8.jpg" alt="img spfaed"></p>
<p>怎么办呢？我们分析一下这种情况出现的原因。</p>
<p>显然此时两个后缀的部分前缀是相同的。即下图的情况：</p>
<p><img src="https://i.loli.net/2020/02/01/6jyL2qsZ9NMQecE.png" alt="img spfaed"></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-TREE-CHAIN-SPLITTING/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-TREE-CHAIN-SPLITTING/" itemprop="url">数据结构100题 ---树链剖分</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-5.png" rel="gallery_ck8wtuwwd0037xgvr8devyweh" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-5.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><p>($nlogn$)</p>
<p>树链剖分准确地说并不是数据结构，它只是数据结构的一种应用。</p>
<p>它用于将一棵树上的节点转换到一个序列中，然后用各种数据结构维护。</p>
<p>所以我只讲如何转换和使用，而维护就因题而异了。</p>
<p>树链剖分有好几种方法：重链剖分，长链剖分…</p>
<p>但我就讲最常用的重链剖分。</p>
<p>重链剖分，顾名思义，就是按照节点的子树大小来剖分这棵树。</p>
<p>一个节点子节点中子树大小最大的子节点叫做这个节点的重儿子。</p>
<p>以一个轻儿子为起点，其余全是重儿子的链叫做重链。</p>
<p>重链上的边叫做重边。</p>
<p>就像这样（红色的边为重边）</p>
<p><img src="https://i.loli.net/2020/01/01/Rgk2A5clbX96JQr.png" alt="树剖.png"></p>
<p>可以发现，每个节点都在且仅在一条重链上，我们就可以把这一条链转换到一个连续的区间来进行维护。</p>
<h4 id="dfs1"><a href="#dfs1" class="headerlink" title="dfs1"></a>dfs1</h4><p>我们采用dfs的形式来进行剖分，记录信息。</p>
<p>第一次dfs我们需要记录每个节点的父亲，子树大小，重儿子和深度。</p>
<p>很简单对吧，就是暴力$dfs$，但要注意不要搜回到父亲节点和一些其他的坑。</p>
<p>代码：</p>
<pre><code>void dfs1(int x,int last)
{
    fa[x]=last;//记录父亲节点。
    sum[x]=1;//初始化子树大小：该节点本身。
    depth[x]=depth[last]+1;//深度：父亲节点深度+1。
    int big=0,bi=0;//寻找重儿子
    for(int i=0;i&lt;e[x].size();++i)
    {
        if(e[x][i]^last)//避免重新回到父亲节点
        {
            dfs1(e[x][i],x);
            sum[x]+=sum[e[x][i]];
            if(sum[e[x][i]]&gt;big)
            {
                big=sum[e[x][i]];
                bi=e[x][i];
            }
        }
    }
    son[x]=bi;//记录重儿子。
}
//调用:dfs(root,root)
</code></pre><h4 id="dfs2"><a href="#dfs2" class="headerlink" title="dfs2"></a>dfs2</h4><p>经过刚刚$dfs1$的准备，我们可以进行剖分了，这次记录$dfs$序，转换出的序列上的每一个值，以及每个节点所在重链的起点。</p>
<p>我们在这次$dfs$时应该优先走重儿子，这样才能使一条重链上的值都在序列上连在一起，方便我们操作。</p>
<p>代码:</p>
<pre><code>void dfs2(int x,int last,bool heavier)
{
    dfn[x]=++tot;//记录dfs序
    turn[tot]=val[x];//记录序列
    if(heavier)    hb[x]=hb[fa[x]];//
    else    hb[x]=x;//记录所在重链起点
    if(b[x].son)    build2(b[x].son,1);//优先遍历重儿子
    for(int i=0;i&lt;e[x].size();++i)
    {
        if(e[x][i]^son[x]&amp;&amp;e[x][i]^fa[x])    build2(e[x][i],0);//避免重复遍历
    }
}
</code></pre><p>一个节点的$dfs$序就是它在序列中的位置。<del>对吧</del></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>对于一些子树上的操作，$dfs$序已经能够搞定了，我们只需要用剖出的重链对那些结点间路径的操作进行应对就好了。</p>
<p>对于两个节点间的路径，我们很容易想到$LCA$。而我们记录了重链的起点，可以处理这条重链，然后直接跳到上面一条重链的末端。</p>
<p>注意当两个节点在同一条重链时跳出循环，在最后处理他们之间的路径。</p>
<p>由于他们已经在同一条重链上了，他们及他们之间的节点$dfs$序是连续的，所以再处理这个连续区间就好了。</p>
<p>代码：</p>
<pre><code>//设solve(x,y)是对x到y区间的操作(因题而异) 
___ LCA(int x,int y)
{
    int fx=hb[x],fy=hb[y];//得到重链起点
    while(fx^fy)
    {
        if(depth[fx]&lt;depth[fy])//从深度大的往上跳
        {
            swap(fx,fy);
            swap(x,y);
        }
        solve(dfn[fx],dfn[x]);//处理这条重链的区间
        x=fa[fx];//跳到上面一条重链
        fx=hb[x];//更新重链起点
    }
    solve(min(dfn[x],dfn[y]),max(dfn[x],dfn[y]));//最后处理同一条重链上的剩余未处理部分。
    //return ans;
}
</code></pre><hr>
<h1 id="5-主席树"><a href="#5-主席树" class="headerlink" title="5.主席树"></a>5.主席树</h1><p>($nlogn$)</p>
<p>“你是主席树吗？有那么多爷爷！”——$LJS$。</p>
<p>这句话运用打比方的说明方法，生动形象地说明了主席树每个节点可能有很多父亲的特点，<del>体现说明语言的生动性</del>。</p>
<p>也就是说，主席树的几个节点可能共用一个子节点。</p>
<p>就像这样：</p>
<p><img src="https://i.loli.net/2020/01/11/RV3yh9uzBgWx2EZ.png" alt="主席树.png"></p>
<p>主席树可以用来查询静态区间第k小，静态区间前k大的和等等。（用法十分灵活）</p>
<p>我们会创建很多版本的树，一些版本会共用一些节点，以节省空间和时间。</p>
<p>主席树也叫可持久化线段树。但可持久化还有很多东西。我就讲可持久化线段树吧。</p>
<h3 id="1-如何共用节点"><a href="#1-如何共用节点" class="headerlink" title="1.如何共用节点"></a>1.如何共用节点</h3><p>我们考虑单点修改的线段树。</p>
<p>如果要得到这个序列某个元素$x$加上一个值$val$之后的新版本，我们发现，改变的只有对应元素$x$的节点和他的祖先会加上$val$。那么其他节点我们可以与上一个版本共用。</p>
<p>所以我们每次新建一个节点，继承之前该位置的值和左右儿子，然后更新值，再继续向下寻找元素$x$的位置，最后递归回来更新这个儿子。</p>
<p>我们使用$root$数组来记录每个版本的根节点编号。</p>
<p>代码：</p>
<pre><code>void ins(int l,int r,int pre,int &amp;now,int pos,int val)//区间左右端点，上一个版本中对应这个区间的点，当前版本中对应这个区间的点，修改位置，增加的值。
{
    nodes[++tot]=nodes[pre];//先整个复制
    now=tot;//更新上一个节点的儿子。
    nodes[now].sum+=val;//更新当前节点的值
    if(l==r)    return;
   //向下继续寻找
    int mid=(l+r)&gt;&gt;1;
    if(pos&lt;=mid)    ins(l,mid,nodes[pre].l,nodes[now].l,pos,val);
    else    ins(mid+1,r,nodes[pre].r,nodes[now].r,pos,val);
}
//调用：ins(1,n,root[i-1],root[i],p,v);
</code></pre><p>最后$root[i]$的引用就相当于记录了这个版本的根节点。</p>
<p>查询其实就和普通的线段树一样，但主席树的用途不止这个。</p>
<h3 id="2-例题"><a href="#2-例题" class="headerlink" title="2.例题"></a>2.例题</h3><p><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">【模板】可持久化线段树 1（主席树）</a></p>
<p>如题，给定 $n$ 个整数构成的序列，将对于指定的闭区间查询其区间内的第 $k$ 小值。</p>
<p><strong>权值线段树</strong>：</p>
<p>(线段树的另一种应用，只是每个节点维护整个序列值在$[l,r]$区间内的数的个数)</p>
<p>这道题要求查询静态区间第$k$小。那么对于第$k$小这种问题，我们要使用权值线段树</p>
<p><strong>离散化</strong>：$-1e9\leq a_i \leq1e9$ 的数据线段树肯定开不下，但这道题只需要求第k小，没有必要开那么大，可以对数据进行离散化。</p>
<p>我们按照序列的顺序插入$a_i$。得到每个$root[i]$代表的权值线段树代表从$a_1$到$a_i$的每个数值的出现次数。</p>
<p>那么根据前缀和的思想，区间$[l,r]$中每个数值的出现个数就是$[1,r]$的减去$[1,l-1]$的。那么数值的区间也具有这个性质。</p>
<p>所有对于每个询问，我们只需要查询一次，用$root[r]$和$root[l-1]$的权值线段树处理出区间$[l,r]$应有的权值线段树，就可以像正常的权值线段树一样查询第k小了。</p>
<p>代码：</p>
<pre><code>#include&lt;vector&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
using namespace std;
int n,m,a[200010],x,y,z,cnt,root[200010];
struct node
{
    int l,r,sum;
}nodes[8000010];//40*n
vector&lt;int&gt; v;
void ins(int l,int r,int pre,int &amp;now,int p)//插入，创建新版本
{
    nodes[++cnt]=nodes[pre];
    now=cnt;
    ++nodes[cnt].sum;
    if(l==r)    return;
    int m=(l+r)&gt;&gt;1;
    if(p&lt;=m)    ins(l,m,nodes[pre].l,nodes[cnt].l,p);
    else    ins(m+1,r,nodes[pre].r,nodes[cnt].r,p);
}
int find(int l,int r,int p1,int p2,int k)
{
    if(l==r)    return l;
    int m=(l+r)&gt;&gt;1;
    int X=nodes[nodes[p2].l].sum-nodes[nodes[p1].l].sum;//现场处理，得到[x,y]区间内，值在[l,mid]内的数的个数
    if(k&lt;=X)    return find(l,m,nodes[p1].l,nodes[p2].l,k);//如果k&lt;=X.说明第k小的数在左边。
    else    return find(m+1,r,nodes[p1].r,nodes[p2].r,k-X);//否则在右边。
}
int getid(int X)//得到离散化后的数值
{
    return lower_bound(v.begin(),v.end(),X)-v.begin()+1;
}
int main()
{
    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);
    for(int i=1;i&lt;=n;++i)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        v.push_back(a[i]);
    }
    sort(v.begin(),v.end());
    v.erase(unique(v.begin(),v.end()),v.end());//离散化
    for(int i=1;i&lt;=n;++i)    ins(1,n,root[i-1],root[i],getid(a[i]));//按顺序插入每个值，得到root[i]对应的权值线段树。
    for(int i=1;i&lt;=m;++i)
    {
        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);
        printf(&quot;%d\n&quot;,v[find(1,n,root[x-1],root[y],z)-1]);//查询区间[x,y]；输出原值
    }
    return 0;
}
</code></pre><h3 id="3-缺点及注意事项"><a href="#3-缺点及注意事项" class="headerlink" title="3.缺点及注意事项"></a>3.缺点及注意事项</h3><p><strong>内存池一般从1开始用</strong>，$nodes[0]$作为空白，值为$0$，儿子节点指向自己，值还是为$0$。</p>
<p>当你这个版本的树还没有改过某个节点的某个儿子时，这个节点的这个儿子会指向$nodes[0]$，也就相当于下面都是$0$，正好符合。</p>
<p><strong>数组一定要开大</strong>，如果开得不够大可能会出现$MLE$,$TLE$,$RE$,$WA$.</p>
<p><strong>但也不要开太大</strong>，不然会$MLE$,$CE$.</p>
<p><strong>主席树是静态的</strong>，遇到要动态修改而不是生成一个新版本的问题，就可能要用树套树了。</p>
<p><strong>可持久化可以用在很多数据结构上</strong>，平衡树，线段树，$trie$树……<del>可够得写</del>，但它们的思想都是相似的，都是每个版本与之前的版本共用节点以节省时间，空间。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-TREE-COVER-TREE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-TREE-COVER-TREE/" itemprop="url">数据结构100题 ---树套树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-6.png" rel="gallery_ck8wtuwwj003dxgvr7fzsw4xd" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-6.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="树套树"><a href="#树套树" class="headerlink" title="树套树"></a>树套树</h1><p>($nlog^2n$)</p>
<p>树套树也是一种<del>暴力</del>思想，它可以有很多实现：树状数组套平衡树，主席树套树状数组……</p>
<p>但是最常见的还是线段数套平衡树。</p>
<h4 id="1-思想-amp-amp-建树"><a href="#1-思想-amp-amp-建树" class="headerlink" title="1.思想&amp;&amp;建树"></a>1.思想&amp;&amp;建树</h4><p>标准说法：线段树的每个节点对应平衡树的一个节点。</p>
<p>???</p>
<p>其实还是线段树每个节点对应一个区间，但是我们把这个区间建成一棵平衡树就行了，线段树节点记录这个区间建成的平衡树的根节点就行了。</p>
<p>线段树有$logn$层，每层的节点对应的区间能够拼成一个完整的区间，即每层$n$个平衡树节点，平衡树每个节点插入是$logn$的，所以建树的时间复杂度是$nlog^2n$</p>
<p>fhq-treap示例</p>
<pre><code>void build(int l,int r,int x)
{
    for(int i=l;i&lt;=r;++i)
    {
        split(root[x],a[i],root1,root2);
        root[x]=merge(merge(root1,newnode(a[i])),root2);
    }
    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        build(l,mid,x&lt;&lt;1);
        build(mid+1,r,x&lt;&lt;1|1);
    }
}
</code></pre><h4 id="2-查询区间排名"><a href="#2-查询区间排名" class="headerlink" title="2.查询区间排名"></a>2.查询区间排名</h4><p>给定一个区间和一个值，查询区间中比他小的元素个数加1。</p>
<p>我们可以像线段树一样，先把这个区间拆分成一些能用我们之前建树建出的平衡树表示的小区间，再查询小区间中比这个值小的元素个数加起来的和。</p>
<p>很明显</p>
<script type="math/tex; mode=display">f[i,j]=f[i,k]+f[k+1,j]（i\leq k<j）</script><p>($f[l,r]$表示区间$[l,r]$中比某个值小的元素个数)</p>
<p>因为$[i,k]$和$[k+1,j]$的元素合在一起就是$[i,j]$的所有元素。</p>
<p>那$[i,k]$和$[k+1,j]$中比某个值小的元素合在一起就是$[i,j]$中比某个值小的元素。</p>
<p>所以上式成立。</p>
<p>时间复杂度：线段树查询$* $平衡树查询$=log^2n$</p>
<p>得出代码写法：</p>
<pre><code>int _rank(int &amp;_root,int val)
{
    split(_root,val-1,root1,root2);
    int res=nodes[root1].sum;
    _root=merge(root1,root2);
    return res;
}
int rank(int l,int r,int x,int fr,int ba,int val)
{
    if((l&gt;ba)|(r&lt;fr))    return 0;
    if((l&gt;=fr)&amp;(r&lt;=ba))    return _rank(root[x],val);
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return rank(l,mid,x&lt;&lt;1,fr,ba,val)+rank(mid+1,r,x&lt;&lt;1|1,fr,ba,val);
    }
}
</code></pre><h4 id="3-动态区间第k小"><a href="#3-动态区间第k小" class="headerlink" title="3.动态区间第k小"></a>3.动态区间第k小</h4><p>（模版题其实没说这个值要在这个区间内……）</p>
<p>区间动态第k小并不能直接解决。所以我们通过二分寻找这个第k小值。</p>
<p>对每一个二分到的值执行查询排名操作。如果它的排名小于等于k，那么让l等于这个值，否则r等于这个值。</p>
<p>因为第k小值及以下的值的排名都是小于等于k的，从小到大排列的值的排名满足单调性。</p>
<p>时间复杂度：线段树查询$<em> $平衡树查询$</em> $二分$=log^3n$</p>
<p>代码：</p>
<pre><code>int search(int fr,int ba,int k)
{
    int l=0,r=1e8+1;
    while(l+1&lt;r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(rank(1,n,1,fr,ba,mid)&lt;k)    l=mid;
        else    r=mid;
    }
    return l;
}
</code></pre><h4 id="4-区间前驱-后继"><a href="#4-区间前驱-后继" class="headerlink" title="4.区间前驱/后继"></a>4.区间前驱/后继</h4><p>与区间排名类似，只需查询各个分出的子区间中需查询值的前驱/后继，再求出它们的最大/最小值就行了。</p>
<p>时间复杂度：线段树查询$* $平衡树查询$=log^2n$</p>
<p>代码：</p>
<pre><code>const int AC=2147483647,WA=-2147483647;
int _pre(int &amp;_root,int val)
{
    split(_root,val-1,root1,root2);
    int now=root1;
    int res=WA;
    if(now)
    {
        while(nodes[now].r) now=nodes[now].r;
        res=nodes[now].num;
    }
    _root=merge(root1,root2);
    return res;
}
int pre(int l,int r,int x,int fr,int ba,int val)
{
    if((l&gt;ba)|(r&lt;fr))  return WA;    
    if((l&gt;=fr)&amp;(r&lt;=ba))    return _pre(root[x],val);
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return max(pre(l,mid,x&lt;&lt;1,fr,ba,val),pre(mid+1,r,x&lt;&lt;1|1,fr,ba,val));
    }
}
int _nxt(int &amp;_root,int val)
{
    split(_root,val,root1,root2);
    int now=root2;
    int res=AC;
    if(now)
    {
        while(nodes[now].l) now=nodes[now].l;
        res=nodes[now].num;
    }
    _root=merge(root1,root2);
    return res;
}
int nxt(int l,int r,int x,int fr,int ba,int val)
{
    if((l&gt;ba)|(r&lt;fr))  return AC;    
    if((l&gt;=fr)&amp;(r&lt;=ba))    return _nxt(root[x],val);
    else
    {
        int mid=(l+r)&gt;&gt;1;
        return min(nxt(l,mid,x&lt;&lt;1,fr,ba,val),nxt(mid+1,r,x&lt;&lt;1|1,fr,ba,val));
    }
}
</code></pre><h4 id="5-修改"><a href="#5-修改" class="headerlink" title="5.修改"></a>5.修改</h4><p>依旧是暴力，只需要把所有代表区间中包含需修改位置的节点都修改掉就好了。</p>
<p>如替换值，就把代表区间中包含这个位置的节点代表的平衡树中的原值删除，插入新值就好了。</p>
<p>时间复杂度：线段树寻找$* $平衡树修改$=log^2n$</p>
<p>代码：</p>
<pre><code>void modify(int l,int r,int x,int pos,int bef,int the)
{
    split(root[x],bef,root1,root2);
    split(root1,bef-1,root1,root3);
    root3=merge(nodes[root3].l,nodes[root3].r);
    root[x]=merge(merge(root1,root3),root2);

    split(root[x],the,root1,root2);
    root[x]=merge(merge(root1,newnode(the)),root2);

    if(l^r)
    {
        int mid=(l+r)&gt;&gt;1;
        if(pos&lt;=mid)    modify(l,mid,x&lt;&lt;1,pos,bef,the);
        else    modify(mid+1,r,x&lt;&lt;1|1,pos,bef,the);
    }
}
</code></pre><h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>关于第k小值的操作，据说可以用权值线段树套平衡树(线段树维护值域，平衡树维护在这个值域中的值的位置)在$log^2n$的时间解决。上面教的可能会被卡死。</p>
<p>总而言之，树套树的思想就是暴力。各种数据结构再套一个数据结构（<del>线段树套pb_ds</del>）。<del>其实我也没写过其他的</del>。</p>
<p>我这次写得像WGY一样是为什么……</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/07/DS100P-TRIE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/DS100P-TRIE/" itemprop="url">数据结构100题 ---trie树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T14:51:04+08:00">2020-02-07</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://i.loli.net/2020/02/06/FNESexpUAbiCBX4.jpg" rel="gallery_ck8wtuwwm003gxgvrm0agz7k2" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://i.loli.net/2020/02/06/FNESexpUAbiCBX4.jpg" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="trie树"><a href="#trie树" class="headerlink" title="trie树"></a>trie树</h1><p>($\sum{len}$)</p>
<p>$trie$树，不是一种二叉树，它是一种多叉树（其实也可以是二叉树）</p>
<p>可以用来求一堆数中两个（或三个）异或起来的最大值。</p>
<p>可以查找单词。</p>
<p>对于一些有前缀的单词，比如<em>WGY_2333</em>和<em>WGY_AND_LYC_WRITE_BLOG</em>。</p>
<p>它们就可以共用树上的一些节点（即<em>WGY_</em>），查询时就可以从$\ $<em>2</em>$\ $和$\ $<em>L</em>$\ $来对他们进行区分</p>
<p>所以我们还是看看它是怎么实现的吧。</p>
<h4 id="1-gt-插入"><a href="#1-gt-插入" class="headerlink" title="1&gt;.插入"></a>1&gt;.插入</h4><p>对于$trie$树，树上的每一条边都代表了一个字母或者一个数字。</p>
<p>所以一个节点会有很多儿子，我们就要开一个儿子数组$ch$。</p>
<p>要统计这个节点被经过了多少次，也就是多少单词有这个前缀，就要加一个$sum$。</p>
<p>要统计有多少个单词在这里结束，也就是要查询的单词有多少个已插入的单词作前缀，就要加一个$end$。</p>
<p>插入时，先看这个节点有没有你要走的那个儿子，如果没有，就新建一个，走下去。否则就直接走到这个儿子（共用节点嘛）。</p>
<p>代码：（以小写字母单词为例）</p>
<pre><code>struct node
{
    int ch[26],sum,end;
}nodes[MAXN];
int root=1,cnt=1;
void ins(int len)
{
    int x=root;
    for(int i=0;i&lt;len;++i)
    {
        if(!nodes[x].ch[str[i]-&#39;a&#39;])    nodes[x].ch[str[i]-&#39;a&#39;]=++cnt;
        x=nodes[x].ch[str[i]-&#39;a&#39;];
        ++nodes[x].sum;
    }
    ++nodes[x].end;
}
</code></pre><h4 id="2-gt-查询"><a href="#2-gt-查询" class="headerlink" title="2&gt;.查询"></a>2&gt;.查询</h4><p>$trie$树的查询有很多种，一般依照题目要求来自己定义。</p>
<p>我们这里又以小写字母单词查询存在性为例。</p>
<p>同样是从最上面的根节点开始。如果当前节点有这个单词现在位置字母的儿子，就走下去。否则就直接返回false，因为之前没有过单词走过这条路径,如果有过这个前缀的单词走过，肯定会创建这个节点。</p>
<p>最后再判断有没有单词在这个地方结束。</p>
<p>代码:</p>
<pre><code>bool find(int len)
{
    int x=root;
    for(int i=0;i&lt;len;++i)
    {
        if(!nodes[x].str[str[i]-&#39;a&#39;])    return false;
        x=nodes[x].str[str[i]-&#39;a&#39;];
    }
    return nodes[x].end;
}
</code></pre><p><del>trie树就只有这么点，惊不惊喜，意不意外</del></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.orchid-any.cf/2020/02/05/DS100P-FHQ-TREAP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="BoringHacker">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="BoringHacker's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/05/DS100P-FHQ-TREAP/" itemprop="url">数据结构100题 ---fhq-treap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-05T14:51:05+08:00">2020-02-05</time>
            

            
            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Note/" itemprop="url" rel="index"><span itemprop="name">Note</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      
        <div class="post-gallery" itemscope itemtype="http://schema.org/ImageGallery">
          
          
            <div class="post-gallery-row">
              <a class="post-gallery-img fancybox" href="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-3.png" rel="gallery_ck8wtuwv7001uxgvrxb85t9u8" itemscope itemtype="http://schema.org/ImageObject" itemprop="url">
                <img src="https://cdn.jsdelivr.net/gh/boringhacker/cdn/images/posts/post-3.png" itemprop="contentUrl">
              </a>
            
          

          
          </div>
        </div>
      

      
        
          
            <h1 id="fhq-treap"><a href="#fhq-treap" class="headerlink" title="fhq-treap"></a>fhq-treap</h1><p>($nlogn$)</p>
<p>$fhq-treap$是一种二叉搜索树。满足二叉搜索树的性质：中序遍历是一个不降序列。也就是说，一个节点的左儿子小于等于它，右儿子大于等于它。</p>
<p>但它和$treap$一样，都满足堆的性质：任意父节点的键值大于(等于)或小于(等于)子节点的键值。</p>
<p>它可以做普通平衡树（基本操作），文艺平衡树（区间操作），还可以可持久化。</p>
<p>但常数略大。</p>
<p>定义：</p>
<pre><code>struct node
{
    int l,r,num,key,cum;
       //左儿子，右儿子，本节点的值，键值，子树大小
}nodes[MAXN];
</code></pre><h3 id="1-权值fhq-treap"><a href="#1-权值fhq-treap" class="headerlink" title="1.权值fhq-treap"></a>1.权值fhq-treap</h3><p>权值$fhq-treap$的意思是，它这时候既满足二叉搜索树的性质，又满足堆的性质。</p>
<p>先讲讲辅助操作吧：</p>
<p><strong>update</strong>:用来更新当前节点的子树大小。</p>
<p>代码实现：</p>
<pre><code>void update(int x)
{
    nodes[x].cum=nodes[nodes[x].l].cum+nodes[nodes[x].r].cum+1;
}
</code></pre><p>因为一个节点的子树大小等于它左右儿子的子树大小加上它本身嘛。</p>
<p><strong>newnode</strong>:新建一个值为指定值的节点并返回它的编号。</p>
<p>代码实现：</p>
<pre><code>int newnode(int val)
{
    nodes[++tot].cum=1;
        nodes[tot].num=val;
        nodes[tot].key=rand();
        return tot;
}
</code></pre><p>主要操作有两个：</p>
<h4 id="1-gt-分裂split"><a href="#1-gt-分裂split" class="headerlink" title="1&gt;.分裂split"></a>1&gt;.分裂split</h4><p>这里的分裂按照权值分裂，即把原树按照权值$val$分成两棵树，一棵$X$中的权值全部小于等于$val$，另一棵y的权值全部大于$val$。而这两棵树都要满足两个性质。</p>
<p>要实现这个操作，我们要从根节点开始遍历，把整棵树分成两半。</p>
<p>我们进行分类讨论：现在遍历到的节点编号为$now$。</p>
<p>1).当$now=0$时</p>
<p>这时，now是一个空节点，没有办法分裂。</p>
<p>2).当$nodes[now].num\leq val$时</p>
<p>这个节点以及它的左子树的权值都小于等于$val$,那么他们全部都属于$X$。</p>
<p>那么它的右子树可能是$X$的，也可能是$Y$的。</p>
<p>所以我们需要继续分裂右子树，但由于右边的数要比$nodes[now].num$大，接下来分裂出的小于等于$val$的子树需要接在当前分出的$X$树的右子树上。</p>
<p>3).否则</p>
<p>这个时候这个节点和它的右子树的权值都大于$val$，那么他们全部属于$Y$。</p>
<p>但它的左子树可能有一部分属于$X$。</p>
<p>所以我们需要继续分裂左子树。道理同上。</p>
<p>上面操作已经保证了分出的二叉树满足二叉树性质。而堆性质也得到了满足，因为从原树上往下分，分到节点的键值也是有序的。</p>
<p>递归返回前还要记得$update$一下，更新分裂后的子树大小。</p>
<p>是不是还是不懂？还是看代码和代码注释吧：</p>
<pre><code>//x,y代表从now这个节点分裂出的两棵树的根节点，使用引用返回值。
void split(int now,int val,int &amp;x,int &amp;y)
{
    if(!now)    x=y=0;//情况1).无法继续分裂，所以两棵树都是空。
    else
    {
        if(nodes[now].num&lt;=val)//情况2).
        {
            x=now;//左子树和这个节点都属于X树，接到之前分裂到的地方。右子树在下面会受到修改，所以右子树并没有被直接包括。
            split(nodes[now].r,val,nodes[x].r,y);//继续分裂右子树。接下来分裂出属于X树的根节点位置应该是nodes[x].r，y的位置没有变动。
        }
        else//情况3).
        {
            y=now;
            split(nodes[now].l,val,x,nodes[y].l);//同上
        }
        update(now);
        //由于无论进入哪个判断，作了改变的节点都等于now,所以可以直接更新now。
    }
}
//调用：split(root,v,root1,root2)
</code></pre><p>最后传回的值就相当于给$root1$,$root2$赋值。</p>
<p>$root1$,$root2$就是分裂出的$X$树和$Y$树的根节点。</p>
<h4 id="2-gt-合并merge"><a href="#2-gt-合并merge" class="headerlink" title="2&gt;.合并merge"></a>2&gt;.合并merge</h4><p>即把两颗像刚刚上面分裂出来的两颗树合并成一棵满足两个性质的树。</p>
<p>我们又要分类讨论：现在需要合并的节点是$x$,$y$。（示例小根堆）</p>
<p>1).$x=0$|$\ $|$y=0$</p>
<p>只有一棵树，直接返回这棵树。</p>
<p>2).$nodes[x].key&lt;nodes[y].key$</p>
<p>$x$节点的键值更小，所以$x$应该在$y$的上面。</p>
<p>$y$的值一定大于$x$,所以把$y$和$x$的右子树进行合并。</p>
<p>3).否则</p>
<p>$y$应该在$x$的上面。</p>
<p>$x$的值一定小于$y$，所以把$y$的左儿子和$x$进行合并。</p>
<p>代码：</p>
<pre><code>int merge(int x,int y)
{
    if(!x||!y)    return x+y;
    if(nodes[x].key&lt;nodes[y].key)
    {
        nodes[x].r=merge(nodes[x].r,y);
        update(x);
        return x;
    }
    else
    {
        nodes[y].l=merge(x,nodes[y].l);
        update(y);
        return y;
    }
}
</code></pre><p>学会了这两个操作之后，就可以实现普通平衡树的所有操作了。</p>
<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3.插入"></a>3.插入</h4><p>插入的代码只有两行，非常简单。</p>
<p>只需要把原数按要插入的值$val$大小分裂，一边$x$小于等于$val$，另一边$y$大于$val$。</p>
<p>再把$x$与这个值节点合并（得到$z$），最后与$y$合并。</p>
<p>因为$x$的节点全部小于等于$val$,$z$的节点全部小于$y$。满足我们之前合并两棵树的条件。</p>
<p>代码：</p>
<pre><code>void ins(int val)
{
    split(root,val,root1,root2);
       root=merge(merge(root1,newnode(val)),root2);
}
</code></pre><h4 id="4-删除"><a href="#4-删除" class="headerlink" title="4.删除"></a>4.删除</h4><p>先把要删除的值$val$从原树中分裂出来，删掉一个再合并回去。</p>
<p>怎么在很多的$val$中删掉一个呢。</p>
<p>我们把$val$子树根节点的左右节点合并起来，就相当于抛弃了这个根节点。</p>
<p>这样保证了如果有这个值，一定会被删掉，因为如果有，那么根节点肯定有。</p>
<p>代码：</p>
<pre><code>void del(int val)
{
    split(root,val,root1,root2);
    split(root1,val-1,root1,root3);
    root3=merge(nodes[root3].l,nodes[root3].r);
    root=merge(merge(root1,root3),root2);
}
</code></pre><h4 id="5-前驱-后继"><a href="#5-前驱-后继" class="headerlink" title="5.前驱/后继"></a>5.前驱/后继</h4><p>我们把小于/大于查询值$val$的子树分裂出来，由于分裂出的子树依然满足二叉树性质，所以我们可以直接查询这个子树中的最大值/最小值，查询出的值就是答案。最后记得合并回去。</p>
<p>代码：</p>
<pre><code>int pre(int val)
{
    split(root,val-1,root1,root2);
    int now=root1,res=-INF;
    if(now)
    {
        while(nodes[now].r)    now=nodes[now].r;
        res=nodes[now].num;
    }
    root=merge(root1,root2);
    return res;
}
int nxt(int val)
{
    split(root,val,root1,root2);
    int now=root2,res=INF;
    if(now)
    {
        while(nodes[now].l)    now=nodes[now].l;
        res=nodes[now].num;
    }
    root=merge(root1,root2);
    return res;
}
</code></pre><h4 id="6-第k小"><a href="#6-第k小" class="headerlink" title="6.第k小"></a>6.第k小</h4><p>对于这个问题，$fhq-treap$没有特殊的解决方法。所以和$treap$一样。</p>
<p>由于二叉搜索树中序遍历为不降序列，我们分情况讨论：</p>
<p>1&gt;.左子树大小$+1$等于$k$。</p>
<p>说明当前节点就是第$k$小。</p>
<p>2&gt;.左子树大小小于等于$k$</p>
<p>说明第$k$大在左边，那么向左边继续寻找第k小。</p>
<p>3&gt;.否则</p>
<p>第$k$小在右边，但左边和当前结点都比第$k$小。所以第k小是在右边的第$k-nodes[nodes[x].l].sum-1$小。</p>
<p>代码：</p>
<pre><code>int top(int val)
{
    int x=root;
    while(x)
    {
        if(nodes[nodes[x].l].sum+1==val)    break;
        if(nodes[nodes[x].l].sum&gt;=val)    x=nodes[x].l;
        else
        {
            val-=(1+nodes[nodes[x].l].sum);
            x=nodes[x].r;
        }
    }
    return nodes[x].num;
}
</code></pre><h4 id="7-排名"><a href="#7-排名" class="headerlink" title="7.排名"></a>7.排名</h4><p>排名的定义是比一个数小的数的个数加$1$。</p>
<p>通过定义就能得出做法：</p>
<p>把比查询值小的子树分离出来，这棵子树的大小就是比这个数小的数的个数。再加$1$就能得到答案了。</p>
<p>代码：</p>
<pre><code>int rank(int val)
{
    split(root,val-1,root1,root2);
    int res=nodes[root1].sum+1;
    root=merge(root1,root2);
    return res;
}
</code></pre><h3 id="2-区间fhq-treap"><a href="#2-区间fhq-treap" class="headerlink" title="2.区间fhq-treap"></a>2.区间fhq-treap</h3><p>区间$fhq-treap$维护了一个区间，中序遍历整个$fhq-treap$就可以得到这个序列。当然，这时候它肯定就不能满足二叉搜索树的性质了。但它还可以满足堆的性质。</p>
<p>为了维护区间，我们的$split$操作需要更改：</p>
<p>每次分裂一个区间出来：把这个序列的前$siz$项分出来为一个子树$X$,剩余另一个子树$Y$。</p>
<p>又分类讨论：</p>
<p>1&gt;.$nodes[nodes[x].l].sum&lt;k$</p>
<p>这说明当前结点的左子树和自身都属于 $X$，我们再把右子树的前$k-nodes[nodes[x].l].sum-1$项分给$X$就好了。</p>
<p>2&gt;.否则</p>
<p>前$k$项在当前结点的左子树中，那么当前节点和它的右子树属于$Y$。</p>
<p>代码：</p>
<pre><code>  void split(int now,int siz,int &amp;x,int &amp;y)
{
    if(!now)    x=y=0;
    else
    {
        if(nodes[nodes[now].l].sum&lt;k)
        {
            x=now;
            split(nodes[now].r,siz-nodes[nodes[now].l].sum-1,nodes[x].r,y);
        }
        else
        {
            y=now;
            split(nodes[now].l,siz,x,nodes[y].l);
        }
        update(now);
    }
}
</code></pre><p>但$merge$操作不需要太大变动，只需要加上懒标记下传就行了（如果有的话）</p>
<p>其实区间操作的分裂除了标记下传之外与权值版没有什么差别，只是这里分裂的权值是第k小。</p>
<p>标记下传是个大坑，有标记时，每当你要对一个节点的子节点进行操作（无论是修改还是查询）时，要先下传标记，否则之后能会传错位置，因为你可能更改了它的子节点。</p>
<h4 id="1-区间和"><a href="#1-区间和" class="headerlink" title="1.区间和"></a>1.区间和</h4><p>我们在每个节点中再加上一个变量记录它和它子树的和。</p>
<p>那么每次子树大小更新时，子树和也要更新。</p>
<p>就在$update$里加一句话更新子树和就好。</p>
<p>查询区间和时就把这个区间分裂出来，直接查询这个区间根节点的子树和就行了。</p>
<h4 id="2-区间翻转"><a href="#2-区间翻转" class="headerlink" title="2.区间翻转"></a>2.区间翻转</h4><p>区间操作基本靠懒标记来完成。这些标记都会继续下传给子节点。</p>
<p>翻转就用一个$bool$懒标记就好了。</p>
<p>首先说明区间翻转的原理：</p>
<p>先把这个区间分裂出来。</p>
<p>要使区间翻转，就相当于要把这个区间倒着遍历。</p>
<p>左中右$-&gt;$右中左</p>
<p>即我们要对于每个节点遍历时先遍历右边，再遍历本节点，最后遍历左边。</p>
<p>那我们把每个节点的左右儿子交换就行了。</p>
<p>所以我们直接把这个区间剖出来，把它的根节点打上标记，再合并回去就好了。</p>
<h4 id="3-区间加法"><a href="#3-区间加法" class="headerlink" title="3.区间加法"></a>3.区间加法</h4><p>区间加法就像线段树一样的懒标记就好了。</p>
<p>其实与区间翻转的实现方式类似，我就不讲了。</p>
<h4 id="4-如何剖出区间-l-r"><a href="#4-如何剖出区间-l-r" class="headerlink" title="4.如何剖出区间[l,r]"></a>4.如何剖出区间[l,r]</h4><p>我们把序列$[1,n]$分成3段$[1,l-1]$,$[l,r]$,$[r+1,n]$</p>
<p>第一段的长度是$l-1$,第二段的长度是$r-l+1$</p>
<p>我们就挨个把它们$split$出来就好了。</p>
<p>代码:</p>
<pre><code>split(root,l-1,root1,root2);
split(root2,r-l+1,root2,root3);
</code></pre><p>$root2$即为$[l,r]$区间的根结点。</p>
<p>$\ $</p>
<p>由此判断，平衡树比线段树还要万能，但常数巨大。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">BoringHacker</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">52</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">BoringHacker</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Pisces</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.0.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
