<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>VSCode配置C++指北(硬盘便携版)</title>
    <url>/2020/01/16/VSCode%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8C%97/</url>
    <content><![CDATA[<h1 id="0x00-序言"><a href="#0x00-序言" class="headerlink" title="0x00 序言"></a>0x00 序言</h1><p>天天看着Dev-Cpp的somebody界面想不想换一个新的环境呢？VS太大，sublime也是一个不错的选择，但sublime的Ctrl+D实在是有些堪忧。今天我们就来尝试一下VSCode</p>
<h1 id="0x01-下载VSCode"><a href="#0x01-下载VSCode" class="headerlink" title="0x01 下载VSCode"></a>0x01 下载VSCode</h1><p>不要下官网的，下我给的VSCode Portable。链接：</p>
<p><a href="https://pan.baidu.com/s/1TSlDZe84mlXqx58mrLCE-Q" target="_blank" rel="noopener">某盘</a></p>
<p>提取码: m2p2</p>
<p>链接挂了评论区请</p>
<p>为什么不下载官网的呢？因为我们要制作的是随身携带的便携版。</p>
<p>本来我打算自己绿化的，但有现成的就懒了</p>
<h1 id="0x02-下载插件"><a href="#0x02-下载插件" class="headerlink" title="0x02 下载插件"></a>0x02 下载插件</h1><p>下载以后，先下载几个插件</p>
<p>1.<img src="https://i.loli.net/2020/01/16/teHNPsOaKYBu8CJ.png" alt="blog.png"></p>
<p>2.<img src="https://i.loli.net/2020/01/16/s5dnF8L6EXrlCOK.png" alt="blog.png"></p>
<p>3.<img src="https://i.loli.net/2020/01/16/Az2gW9vkny1j35O.png" alt="blog.png"></p>
<h1 id="0x03-配置文件"><a href="#0x03-配置文件" class="headerlink" title="0x03 配置文件"></a>0x03 配置文件</h1><p>在Code.exe所在的文件夹(也就是根目录)创建三个文件</p>
<p><code>c_cpp_properties.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Win32"</span>,</span><br><span class="line">      <span class="attr">"defines"</span>: [<span class="string">"_DEBUG"</span>, <span class="string">"UNICODE"</span>, <span class="string">"_UNICODE"</span>],</span><br><span class="line">      <span class="attr">"compilerPath"</span>: <span class="string">"C:\\Program Files (x86)\\Dev-Cpp\\MinGW64\\bin\\g++.exe"</span>,</span><br><span class="line">      <span class="attr">"windowsSdkVersion"</span>: <span class="string">"10.0.17763.0"</span>,</span><br><span class="line">      <span class="attr">"intelliSenseMode"</span>: <span class="string">"msvc-x64"</span>,</span><br><span class="line">      <span class="attr">"cStandard"</span>: <span class="string">"c11"</span>,</span><br><span class="line">      <span class="attr">"cppStandard"</span>: <span class="string">"c++17"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>launch.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"(msvc) Launch"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"cppvsdbg"</span>,</span><br><span class="line">        <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/1.exe"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [],</span><br><span class="line">        <span class="attr">"stopAtEntry"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">        <span class="attr">"environment"</span>: [],</span><br><span class="line">        <span class="attr">"externalConsole"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>tasks.json</code>:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"label"</span>: <span class="string">"msvc build"</span>,</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">        <span class="attr">"command"</span>: <span class="string">"cl.exe"</span>,</span><br><span class="line">        <span class="attr">"args"</span>: [<span class="string">"/EHsc"</span>, <span class="string">"/Zi"</span>, <span class="string">"/Fe:"</span>, <span class="string">"1.exe"</span>, <span class="string">"1.cpp"</span>],</span><br><span class="line">        <span class="attr">"group"</span>: &#123;</span><br><span class="line">          <span class="attr">"kind"</span>: <span class="string">"build"</span>,</span><br><span class="line">          <span class="attr">"isDefault"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"presentation"</span>: &#123;</span><br><span class="line">          <span class="attr">"reveal"</span>: <span class="string">"always"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"problemMatcher"</span>: <span class="string">"$msCompile"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>把你的MinGW的bin文件夹添加进环境变量，就可以按下F6编译运行你的C++文件了</p>
<h1 id="0x04-完全绿化"><a href="#0x04-完全绿化" class="headerlink" title="0x04 完全绿化"></a>0x04 完全绿化</h1><p>每次换电脑都要添加环境变量挺烦的对不对？其实，我们可以把VSCode根目录里的东西</p>
<p><img src="https://i.loli.net/2020/01/16/p3QmLVTfwy5God9.png" alt="blog.png"></p>
<p>Copy到MinGW的bin文件夹里</p>
<p><img src="https://i.loli.net/2020/01/16/yiH8KtpxRBYJhlq.png" alt="blog.png"></p>
<p>这样，不用添加环境变量我们就可以直接编译啦！</p>
<p>最后建议把VSCode和MinGW的文件隐藏一下，免得辣眼睛，最好创建一个Code.exe的快捷方式，方便打开</p>
<p>VSCode还可以装很多插件，下面给出几种大家自己慢慢摸索吧！</p>
<h2 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h2><ul>
<li>open the web page</li>
<li>C/C++</li>
<li>C/C++ Compile Run</li>
<li>Chinese</li>
<li>filesize</li>
<li>Markdown All in One</li>
<li>Markdown PDF</li>
<li>Open In Default Browser</li>
<li>vscode icons</li>
<li>Better Comments</li>
<li>Auto Close Tag</li>
<li>Windows opacity</li>
<li>Background</li>
</ul>
<h2 id="Themes"><a href="#Themes" class="headerlink" title="Themes"></a>Themes</h2><ul>
<li>Bimbo</li>
<li>One Dark Pro</li>
<li>Dracula Official</li>
</ul>
]]></content>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title>莫队教程</title>
    <url>/2020/01/11/%E8%8E%AB%E9%98%9F%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>考虑这样一个问题：</p>
<p>对于一个序列A_1,A_2,…,A_n，有如下询问</p>
<p>形如S l r的命令表示对区间[l,r]求和，并输出</p>
<p>形如Q l r表示…</p>
<p>本题不强制在线</p>
<p>对于这样的静态问题，我们可以考虑用莫队来解决。据说莫队支持修改<del>但我太弱不会</del></p>
<p>现在你有区间[3,5]的和，可以求[3,6]的区间和吗？显然，将[3,5]的区间和加上A_6即可。类似的，求[2,4]的区间和，我们只需减去A_5即可。</p>
<p>可以结合下图感知一下</p>
<p><img src="https://i.loli.net/2020/01/05/b63tfzYDl7VwdXC.png" alt="spfa.png"></p>
<p><img src="https://i.loli.net/2020/01/05/uAa95JElrb7kCxQ.png" alt="spfa.png"></p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>好，接下来我们想一下如何维护这种询问之间的关系。</p>
<p>很容易想到排序，首先我们对询问的左端点进行排序。再把整个<code>询问</code>序列分为\sqrt{n}块，每块以内再按右端点排序。</p>
<p>所以我们可以得出以下结论：</p>
<ul>
<li>莫队就是对于一系列的询问，通过排序减小询问的之间的差距，然后以计算贡献的方法离线的得出答案</li>
</ul>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>来一道简单的例题</p>
<h3 id="小B的询问"><a href="#小B的询问" class="headerlink" title="小B的询问"></a>小B的询问</h3><p>小B 有一个长为 n 的整数序列 a，值域为 [1,k]。<br>他一共有 m 个询问，每个询问给定一个区间 [l,r]，求：  </p>
<p>其中 c_i 表示数字 i 在 [l,r] 中的出现次数。<br>小B请你帮助他回答询问</p>
<hr>
<p>这道题让我们求</p>
<p>\sum\limits_{i=1}^k c_i^2</p>
<p>开一个桶，计算每个数出现的次数，所以我们可以由此计算答案的贡献，就可以写出以下的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueryNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r;</span><br><span class="line">	<span class="keyword">int</span> id; <span class="comment">// 储存询问的顺序，方便输出</span></span><br><span class="line">&#125; Q[SIZE];</span><br><span class="line"><span class="keyword">int</span> a[SIZE], n, m, k, pos[SIZE];</span><br><span class="line"><span class="keyword">int</span> cnt[SIZE], ans[SIZE], res;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a:原序列</span></span><br><span class="line"><span class="comment">// pos:每个位置所处的块</span></span><br><span class="line"><span class="comment">// cnt:桶</span></span><br><span class="line"><span class="comment">// ans:询问的答案</span></span><br><span class="line"><span class="comment">// res:每次调整所得到的贡献</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; cnt[a[x]]++, res += cnt[a[x]] * cnt[a[x]] - (cnt[a[x]] - <span class="number">1</span>) * (cnt[a[x]] - <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; cnt[a[x]]--, res -= (cnt[a[x]] + <span class="number">1</span>) * (cnt[a[x]] + <span class="number">1</span>) - cnt[a[x]] * cnt[a[x]]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">	<span class="keyword">int</span> block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]), pos[i] = i / block;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i;</span><br><span class="line">	sort(Q + <span class="number">1</span>, Q + <span class="number">1</span> + m, [](QueryNode x, QueryNode y) &#123; <span class="keyword">return</span> pos[x.l] ^ pos[y.l] ? pos[x.l] &lt; pos[y.l] : x.r &lt; y.r; &#125;);</span><br><span class="line">	<span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">while</span> (l &gt; Q[i].l) add(--l); <span class="comment">// 这四句都是在对当前的区间对于询问的区间进行调整</span></span><br><span class="line">		<span class="keyword">while</span> (r &lt; Q[i].r) add(++r); <span class="comment">// 这三句都是在对当前的区间对于询问的区间进行调整</span></span><br><span class="line">		<span class="keyword">while</span> (l &lt; Q[i].l) del(l++); <span class="comment">// 这二句都是在对当前的区间对于询问的区间进行调整</span></span><br><span class="line">		<span class="keyword">while</span> (r &gt; Q[i].r) del(r--); <span class="comment">// 这一句都是在对当前的区间对于询问的区间进行调整</span></span><br><span class="line">		ans[Q[i].id] = res;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><p>其实莫队是有套路的，基本上莫队的题都是这样的:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">	<span class="keyword">while</span> (l &gt; Q[i].l) add(--l);</span><br><span class="line">	<span class="keyword">while</span> (r &lt; Q[i].r) add(++r);</span><br><span class="line">	<span class="keyword">while</span> (l &lt; Q[i].l) del(l++);</span><br><span class="line">	<span class="keyword">while</span> (r &gt; Q[i].r) del(r--);</span><br><span class="line">	ans[Q[i].id] = res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需考虑add函数以及del函数即可</p>
<hr>

<center><h1>The End</h1></center>]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>实用网站收集</title>
    <url>/2020/01/04/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<p><a href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">图论神器</a></p>
<p><a href="https://gcc.godbolt.org/" target="_blank" rel="noopener">在线转汇编</a></p>
<p><a href="https://blog.csdn.net/garfielder007/article/details/51646604" target="_blank" rel="noopener">LaTex公式大全</a></p>
<p><a href="https://oi-wiki.org/" target="_blank" rel="noopener">OI Wiki</a></p>
<p><a href="https://yhx-12243.github.io/OI-transit/" target="_blank" rel="noopener">OI中转站</a></p>
<p><a href="https://paintschainer.preferred.tech/index_zh.html" target="_blank" rel="noopener">线段上色</a></p>
<p><a href="https://csacademy.com/app/geometry_widget/" target="_blank" rel="noopener">几何</a></p>
<p><a href="http://oeis.org/" target="_blank" rel="noopener">数列规律</a></p>
<p><a href="https://suulnnka.github.io/BullshitGenerator/index.html" target="_blank" rel="noopener">狗屁不通生成器</a></p>
<p><a href="https://ruhu.app/" target="_blank" rel="noopener">算法竞赛</a></p>
<p><a href="https://github.com/StableAgOH/Code-Warehouse-for-AgOH" target="_blank" rel="noopener">AgOH代码仓库</a></p>
<p><a href="http://tool.uixsj.cn" target="_blank" rel="noopener">某奆佬博客</a></p>
<p><a href="https://www.itdaan.com/" target="_blank" rel="noopener">开发者知识库</a></p>
]]></content>
      <tags>
        <tag>实用</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-J 2019 题解</title>
    <url>/2019/12/28/CSP-J-2019-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<a id="more"></a>
<p>这次的CSP是十分伤心的，考试的状态不好，导致分数不理想。</p>
<p>睡了一觉后我重做了一下这四道题，觉得还是蛮简单的，于是便有了这篇题解。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>统计1的数量，字符串模拟即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">233</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fgets(buf, <span class="number">233</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">        res += (buf[i] == <span class="string">'1'</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>这道题是最亏的，STL是个好东西，但容易遗忘一些细节。比如erase后没有减掉下标。</p>
<p>模拟即可，用一个数组或vector存储优惠票，每次坐地铁的时候扫描一下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; pair &lt; <span class="keyword">int</span> , <span class="keyword">int</span> &gt; &gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">int</span> Pri;</span><br><span class="line">    <span class="keyword">int</span> Tim;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        a[i] = NODE&#123;x, y, z&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!a[i].ID) &#123;</span><br><span class="line">            ans += a[i].Pri;</span><br><span class="line">            vec.push_back(make_pair(a[i].Pri, a[i].Tim));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].Tim - vec[j].second) &lt;= <span class="number">45</span> &amp;&amp; vec[j].first &gt;= a[i].Pri) &#123;</span><br><span class="line">                vec.erase(vec.begin() + j);</span><br><span class="line">                --j;</span><br><span class="line">                Flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].Tim - vec[j].second) &gt; <span class="number">45</span>)</span><br><span class="line">                vec.erase(vec.begin() + j), --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) ans += a[i].Pri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>完全背包的题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_T x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, <span class="built_in">putchar</span>(<span class="string">'-'</span>);</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) write(x /<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">233333</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> T = read();</span><br><span class="line"><span class="keyword">int</span> n = read();</span><br><span class="line"><span class="keyword">int</span> m = read();</span><br><span class="line"><span class="keyword">int</span> o233[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			o233[i][j] = read();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> ans = m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++i) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(dp, ~~(<span class="number">0</span>^_^<span class="number">0</span>), <span class="keyword">sizeof</span> dp);</span><br><span class="line">		dp[ans] = ans;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = ans; k &gt;= o233[i][j]; --k)</span><br><span class="line">				dp[k - o233[i][j]] = max(dp[k - o233[i][j]], dp[k] + o233[i + <span class="number">1</span>][j] - o233[i][j]);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> maxNum = <span class="number">-2333333</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> ljs = ~~(<span class="number">0</span>^_^<span class="number">0</span>); ljs &lt;= ans; ++ljs)</span><br><span class="line">			maxNum = max(maxNum, dp[ljs]);</span><br><span class="line">		ans = maxNum;</span><br><span class="line">	&#125;</span><br><span class="line">	write(ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><p>这道题还没有T3难</p>
<p>对这个图跑一遍Dijkstra或SPFA，（这次的数据不知道有没有卡SPFA）处理出所有点到原点的奇数最短路和偶数最短路。</p>
<p>因为边权一直为1，所以只需要用当前的奇数最短路更新偶数最短路，用当前的偶数最短路更新奇数最短路就行了。</p>
<p>有一个坑点在于，若源点是独立的，也就是说若1号结点没有出入度，那么这种情况是一直输出No</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_T x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), x = -x;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">9</span> &lt; x) write(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UndirectedGraph</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> OddDis;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> EvenDis;</span><br><span class="line">&#125; dis[MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], _next[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ver[MAXN &lt;&lt; <span class="number">1</span>], edge[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"><span class="keyword">int</span> n = read();</span><br><span class="line"><span class="keyword">int</span> m = read();</span><br><span class="line"><span class="keyword">int</span> q = read();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	ver[++tot] = y, edge[tot] = z;</span><br><span class="line">	_next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		dis[i].EvenDis = dis[i].OddDis = <span class="number">0x7fffffff</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(<span class="number">1</span>);</span><br><span class="line">	dis[<span class="number">1</span>].EvenDis = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (Q.size()) &#123;</span><br><span class="line">		<span class="keyword">int</span> x = Q.front(); Q.pop();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = _next[i]) &#123;</span><br><span class="line">			<span class="keyword">int</span> y = ver[i];</span><br><span class="line">			<span class="keyword">int</span> z = edge[i];</span><br><span class="line">			<span class="keyword">int</span> OddDis = dis[y].OddDis;</span><br><span class="line">			<span class="keyword">int</span> EvenDis = dis[y].EvenDis;</span><br><span class="line">			dis[y].OddDis = min(dis[y].OddDis, dis[x].EvenDis + z);</span><br><span class="line">			dis[y].EvenDis = min(dis[y].EvenDis, dis[x].OddDis + z);</span><br><span class="line">			<span class="keyword">if</span> (dis[y].EvenDis ^ EvenDis || dis[y].OddDis ^ OddDis)</span><br><span class="line">				Q.push(y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> from = read();</span><br><span class="line">		<span class="keyword">int</span> to = read();</span><br><span class="line">		addEdge(from, to, <span class="number">1</span>);</span><br><span class="line">		addEdge(to, from, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (from == <span class="literal">true</span> || to == <span class="literal">true</span>) flag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SPFA();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> ID = read();</span><br><span class="line">		<span class="keyword">int</span> wanted = read();</span><br><span class="line">		<span class="keyword">if</span> (ID == <span class="number">1</span> &amp;&amp; !flag) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dis[ID].OddDis == <span class="number">0x7fffffff</span> &amp;&amp; dis[ID].EvenDis == <span class="number">0x7fffffff</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (((wanted &amp; <span class="number">1</span>) &amp;&amp; dis[ID].OddDis &lt;= wanted) || ((~wanted &amp; <span class="number">1</span>) &amp;&amp; dis[ID].EvenDis &lt;= wanted)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> _ 0</span></span><br><span class="line">	<span class="keyword">return</span> ~~(<span class="number">0</span>^_^<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P3988 【[SHOI2013]发牌】</title>
    <url>/2019/12/28/%E9%A2%98%E8%A7%A3-P3988-%E3%80%90-SHOI2013-%E5%8F%91%E7%89%8C%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>找到1-x的区间，然后转到后面，在删除第一个就好了</p>
<p><del>需吸氧</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">7e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPLAY</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> fa;</span><br><span class="line">&#125; T[SIZE];</span><br><span class="line"><span class="keyword">int</span> root, n, R[SIZE], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">	T[u].siz = T[T[u].ch[<span class="number">0</span>]].siz + T[T[u].ch[<span class="number">1</span>]].siz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = ++tot;</span><br><span class="line">	T[u].siz = <span class="number">1</span>;</span><br><span class="line">	T[u].val = mid;</span><br><span class="line">	T[u].ch[<span class="number">0</span>] = T[u].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">	T[u].fa = fa;</span><br><span class="line">	<span class="keyword">if</span> (mid &gt; l) T[u].ch[<span class="number">0</span>] = make(l, mid - <span class="number">1</span>, u);</span><br><span class="line">	<span class="keyword">if</span> (mid &lt; r) T[u].ch[<span class="number">1</span>] = make(mid + <span class="number">1</span>, r, u);</span><br><span class="line">	update(u);</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = T[x].fa;</span><br><span class="line">	<span class="keyword">int</span> z = T[y].fa;</span><br><span class="line">	<span class="keyword">int</span> w = T[y].ch[<span class="number">1</span>] == x;</span><br><span class="line">	T[z].ch[T[z].ch[<span class="number">1</span>] == y] = x;</span><br><span class="line">	T[x].fa = z;</span><br><span class="line">	T[y].ch[w] = T[x].ch[w ^ <span class="number">1</span>];</span><br><span class="line">	T[T[x].ch[w ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">	T[x].ch[w ^ <span class="number">1</span>] = y;</span><br><span class="line">	T[y].fa = x;</span><br><span class="line">	update(y), update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; T[x].fa ^ goal; rotate(x)) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = T[x].fa;</span><br><span class="line">		<span class="keyword">int</span> z = T[y].fa;</span><br><span class="line">		<span class="keyword">if</span> (z ^ goal)</span><br><span class="line">			T[y].ch[<span class="number">1</span>] ^ x ^ T[z].ch[<span class="number">1</span>] ^ y ? rotate(x) : rotate(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!goal) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getRank</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (x &lt;= T[T[u].ch[<span class="number">0</span>]].siz) u = T[u].ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			x -= T[T[u].ch[<span class="number">0</span>]].siz + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (!x) <span class="keyword">return</span> u;</span><br><span class="line">			u = T[u].ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getcard</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x) &#123;</span><br><span class="line">		splay(getRank(x), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> u = root;</span><br><span class="line">		root = T[u].ch[<span class="number">1</span>];</span><br><span class="line">		T[root].fa = <span class="number">0</span>;</span><br><span class="line">		T[u].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		update(u);</span><br><span class="line">		splay(getRank(T[root].siz), <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (u) T[u].fa = root;</span><br><span class="line">		<span class="keyword">if</span> (root) T[root].ch[<span class="number">1</span>] = u, update(root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> ranker = getRank(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> res = T[ranker].val;</span><br><span class="line">	splay(ranker, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (T[ranker].ch[<span class="number">1</span>])</span><br><span class="line">		T[root = T[ranker].ch[<span class="number">1</span>]].fa = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	root = make(<span class="number">1</span>, n, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;R[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getcard(R[i] % T[root].siz));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>SPLAY教程</title>
    <url>/2019/12/14/SPLAY%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="本文参考资料"><a href="#本文参考资料" class="headerlink" title="本文参考资料:"></a>本文参考资料:</h2><p>From yyb:<a href="https://www.cnblogs.com/cjyyb/p/7499020.html" target="_blank" rel="noopener">Link</a></p>
<hr>
<h1 id="正文：关于SPLAY"><a href="#正文：关于SPLAY" class="headerlink" title="正文：关于SPLAY"></a>正文：关于SPLAY</h1><p>其实我更偏向于把splay叫做cosplay</p>
<p>讲平衡树总逃不过BST(Binary Search Tree)，二叉搜索树，以下是BST的性质：</p>
<p>一棵合法的BST每个节点上都带有一个数值，我们将其称为节点的“关键码”。那么对于一棵BST上的任意节点，满足：</p>
<ul>
<li><p>该节点的关键码不小于它左子树的任意结点的关键码</p>
</li>
<li><p>该结点的关键码不大于它右子树的任意结点的关键码</p>
</li>
</ul>
<p><code>显然</code>，BST的中序遍历是一个递增的序列</p>
<h2 id="建立一棵BST"><a href="#建立一棵BST" class="headerlink" title="建立一棵BST"></a>建立一棵BST</h2><p>因为笔者很懒，不想到处判边界，所以我们一般可以在一棵空的BST中预先插入两个结点，一个正无穷，一个负无穷，如图:</p>
<p><img src="https://i.loli.net/2019/12/13/V2N6AQUynRGvzYI.png" alt="img spfaed"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l, r; <span class="comment">// 左右儿子的编号</span></span><br><span class="line">   <span class="keyword">int</span> val; <span class="comment">// 关键码</span></span><br><span class="line">&#125; T[SIZE];</span><br><span class="line"><span class="keyword">int</span> tot, root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">clone</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; <span class="comment">// 新建节点</span></span><br><span class="line">	T[++tot].val = val;</span><br><span class="line">   <span class="keyword">return</span> tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	clone(-INF), clone(INF);</span><br><span class="line">   root = <span class="number">1</span>, T[<span class="number">1</span>].r = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是建树的代码</p>
<p>那么，BST就讲到这里</p>
<h2 id="平衡树的诞生"><a href="#平衡树的诞生" class="headerlink" title="平衡树的诞生"></a>平衡树的诞生</h2><p>当BST形成一条链的时候，每次查询会变成O(n^2)</p>
<p>这种深度过深的BST是不平衡的。所以我们需要一种能保持树的深度在\log(n)的数据结构，于是便诞生了平衡树</p>
<h2 id="SPLAY"><a href="#SPLAY" class="headerlink" title="SPLAY"></a>SPLAY</h2><p>splay，又称<del>cosplay</del>伸展树，有“序列之王”的美称，<del>常数巨大</del>，跑的没有fhq-treap快，但这不在我们的讨论范围以内</p>
<p><img src="https://i.loli.net/2019/12/13/jFfZRvedxLYJg2y.png" alt="graph.png"></p>
<p>想象一下这样一颗BST，我们先把它们的大小关系列出来。</p>
<p>Y<Z, C>Y, X<Y,A<X,B>X</p>
<p>对于这样一颗BST，我们可以通过一些特殊的方式来改变它的形态保持中序序列不变，这也是平衡树的精髓。</p>
<p>怎么改变呢？</p>
<h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2><p>旋转<del>不转不是中国人</del>，这是splay的精髓所在。</p>
<p>现在我们的目标是让X节点往上爬到它父亲节点Y处，让Y变成X的幺儿，也就是让Y节点下降。</p>
<p><code>这个过程首先要满足BST性质</code></p>
<p>通过例图来思考，此时的X节点是Y节点的左儿子，小于Y节点，为了不改变中序序列，我们可以让Y节点成为X的右儿子。那么问题来了：变换后的Y的确大于X，但X还有一颗右子树呢！</p>
<p>别急，再回想一下BST的性质，任意节点大于其左子树中的任意节点，也就是说我们可以把X的左子树B拿给Y当左子树。</p>
<p>好了！世界核平了！<del>Tarjan放心了</del></p>
<p>展示一下旋转的成果吧！</p>
<p>旋转前：</p>
<p><img src="https://i.loli.net/2019/12/13/jFfZRvedxLYJg2y.png" alt="graph.png"></p>
<p>旋转后</p>
<p><img src="https://i.loli.net/2019/12/13/Dr5IfBWVl7b6PTH.png" alt="graph _1_.png"></p>
<p>别高兴得太早！</p>
<p>这只是一种情况，我们需要的是<code>通用</code></p>
<p>这里有一个小技巧，即：</p>
<p>odd\bigoplus1=odd-1</p>
<p>even\bigoplus1=even+1</p>
<p>这个性质的证明很简单：</p>
<p><code>即得易见平凡，仿照上例显然。</code></p>
<p><code>留作习题答案略，读者自证不难。</code></p>
<p><code>反之亦然同理，推论自然成立，略去过程QED，由上可知证毕。</code></p>
<p>Just a joke</p>
<p>设节点Y为X的父亲，Y的w(0代表左儿子，1代表右儿子)儿子</p>
<ul>
<li>step1:将Y节点放到X节点的w\bigoplus1的位置</li>
<li>step2:如果X的w\bigoplus1位置上有一颗子树，放在Y的w位置上</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 更新节点信息</span></span><br><span class="line">	T[x].siz = T[T[x].ch[<span class="number">0</span>]].siz + T[T[x].ch[<span class="number">1</span>]].siz + T[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// 旋转</span></span><br><span class="line">	<span class="keyword">int</span> y = T[x].fa; <span class="comment">// X它爹</span></span><br><span class="line">	<span class="keyword">int</span> z = T[y].fa; <span class="comment">// X它爹它爹</span></span><br><span class="line">	<span class="keyword">int</span> w = T[y].ch[<span class="number">1</span>] == x; <span class="comment">// X是它爹的左幺儿还是右幺儿</span></span><br><span class="line">	T[z].ch[T[z].ch[<span class="number">1</span>] == y] = x;</span><br><span class="line">	T[x].fa = z;</span><br><span class="line">	T[y].ch[w] = T[x].ch[w ^ <span class="number">1</span>];</span><br><span class="line">	T[T[x].ch[w ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">	T[x].ch[w ^ <span class="number">1</span>] = y;</span><br><span class="line">	T[y].fa = x;</span><br><span class="line">	update(y), update(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅有rotate操作还不够，splay到目前为止依然很容易被卡。</p>
<p>想象这样一棵树：</p>
<p><img src="https://i.loli.net/2019/12/13/6hBzE2UsC8oJXfu.png" alt="img spfaed"></p>
<p>发现无论怎么旋转X都不能使得这棵树最长的一条链变短。我们称这种X，X它爹，X它爹它爹在一条线上的情况称为三点共线。</p>
<p>怎么办呢？<del>可怜的splay被人溜了</del></p>
<p>办法还是有滴</p>
<ul>
<li>step1:如果三点共线，我们可以先旋转X它爹，这样便可以使其更加“平衡”</li>
<li>step2:如果不共线……不共线……那就旋转X就好了</li>
</ul>
<p>这便是splay操作</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span> </span>&#123; <span class="comment">//splay</span></span><br><span class="line">	<span class="keyword">for</span> (; T[x].fa ^ goal; rotate(x)) &#123; <span class="comment">// 一直旋转到x成为goal的儿子</span></span><br><span class="line">		<span class="keyword">int</span> y = T[x].fa;</span><br><span class="line">		<span class="keyword">int</span> z = T[y].fa;</span><br><span class="line">		<span class="keyword">if</span> (z ^ goal)</span><br><span class="line">			T[y].ch[<span class="number">1</span>] ^ x ^ T[z].ch[<span class="number">1</span>] ^ y ? rotate(x) : rotate(y); <span class="comment">//判断三点是否共线，如果是，就旋转Y，否则旋转X</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!goal) root = x; <span class="comment">// 把根节点设为X</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，splay就差不多讲完了，那么再来一道例题吧</p>
<p><a href="https://www.luogu.com.cn/problem/P3369" target="_blank" rel="noopener">【模板】普通平衡树</a></p>
<ul>
<li>题面：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：</span><br><span class="line">1.插入 x 数</span><br><span class="line">2.删除 x 数(若有多个相同的数，因只删除一个)</span><br><span class="line">3.查询 x 数的排名(排名定义为比当前数小的数的个数 +1 )</span><br><span class="line">4.查询排名为 x 的数</span><br><span class="line">5.求 x 的前驱(前驱定义为小于 x，且最大的数)</span><br><span class="line">6.求 x 的后继(后继定义为大于 x，且最小的数)</span><br></pre></td></tr></table></figure>
<h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>首先我们先查找BST当中有没有和需要插入的节点关键码相同的节点，如果有，就把当前节点的“副本”数+1</p>
<p>如果没有，就遍历到叶子节点，再新增一个节点就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root, fa = <span class="number">0</span>; <span class="comment">// 从根节点开始找</span></span><br><span class="line">	<span class="keyword">while</span> (u &amp;&amp; x ^ T[u].val) <span class="comment">// 找关键码相同的节点</span></span><br><span class="line">		fa = u, u = T[u].ch[x &gt; T[u].val];</span><br><span class="line">	<span class="keyword">if</span> (u) T[u].cnt++; <span class="comment">// 如果有，就增加一个副本</span></span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">// 否则新建一个节点</span></span><br><span class="line">		u = ++tot;</span><br><span class="line">		<span class="keyword">if</span> (fa) T[fa].ch[x &gt; T[fa].val] = u;</span><br><span class="line">		T[u].fa = fa;</span><br><span class="line">		T[u].siz = T[u].cnt = <span class="number">1</span>;</span><br><span class="line">		T[u].ch[<span class="number">0</span>] = T[u].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		T[u].val = x;</span><br><span class="line">	&#125;</span><br><span class="line">	splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h2><p>设查找节点的关键码为x，如果x大于当前节点的关键码，就往右子树跑，否则往左子树找。找到后把当前节点splay到根，保证BST的平衡</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">if</span> (!u) <span class="keyword">return</span> ; <span class="comment">// BST空</span></span><br><span class="line">	<span class="keyword">while</span> (T[u].ch[x &gt; T[u].val] &amp;&amp; x ^ T[u].val)</span><br><span class="line">		u = T[u].ch[x &gt; T[u].val];</span><br><span class="line">	splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前驱-后继操作"><a href="#前驱-后继操作" class="headerlink" title="前驱/后继操作"></a>前驱/后继操作</h2><p>首先执行find操作。</p>
<p>以前驱为例，当前的根节点就是x的父节点，所以如果root的关键码大于x，那么root就是x的前驱。否则就跳到左儿子找，再反着跳就好了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next_bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123; <span class="comment">// f=0前驱，f=1后继</span></span><br><span class="line">	find(x);</span><br><span class="line">	<span class="keyword">int</span> u = root; <span class="comment">// x的父节点</span></span><br><span class="line">	<span class="keyword">if</span> (T[u].val &gt; x &amp;&amp; f) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">if</span> (T[u].val &lt; x &amp;&amp; !f) <span class="keyword">return</span> u;</span><br><span class="line">	u = T[u].ch[f]; <span class="comment">// 跳到对应的子树</span></span><br><span class="line">	<span class="keyword">while</span> (T[u].ch[f ^ <span class="number">1</span>]) u = T[u].ch[f ^ <span class="number">1</span>]; <span class="comment">// 反着跳转</span></span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>找到这个数的last，把他splay到根节点</p>
<p>然后找到这个数next，把他splay到last的底下</p>
<p>然后……然后就没有了呀……</p>
<p>比last大是next</p>
<p>比next小的且比last大的只有当前的节点</p>
<p>在next的左幺儿上面，</p>
<p>だから直接把root右幺儿的左幺儿删掉就可以了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = next_bound(x, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> next = next_bound(x, <span class="number">1</span>);</span><br><span class="line">	splay(last, <span class="number">0</span>), splay(next, last);</span><br><span class="line">	<span class="keyword">int</span> del = T[next].ch[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (T[del].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		T[del].cnt--;</span><br><span class="line">		splay(del, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> T[next].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第K大"><a href="#第K大" class="headerlink" title="第K大"></a>第K大</h2><p>现在再来看已经十分简单了</p>
<p>首先如果左子树的大小加上本身的个数大于k，直接在左子树里找就行了</p>
<p>否则就把k减去左子树大小再减去本身的个数，再在右子树里找就行了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth_element</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">if</span> (T[u].siz &lt; x) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有那么多，直接死亡</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = T[u].ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (x &gt; T[y].siz + T[u].cnt) &#123;</span><br><span class="line">			x -= T[y].siz + T[u].cnt;</span><br><span class="line">			u = T[u].ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T[y].siz &gt;= x) u = y;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> T[u].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SIZE = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, root, tot;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SPLAY</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> fa;</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">	<span class="keyword">int</span> cnt;</span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="keyword">int</span> ch[<span class="number">2</span>];</span><br><span class="line">&#125; T[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	T[x].siz = T[T[x].ch[<span class="number">0</span>]].siz + T[T[x].ch[<span class="number">1</span>]].siz + T[x].cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> y = T[x].fa;</span><br><span class="line">	<span class="keyword">int</span> z = T[y].fa;</span><br><span class="line">	<span class="keyword">int</span> w = T[y].ch[<span class="number">1</span>] == x;</span><br><span class="line">	T[z].ch[T[z].ch[<span class="number">1</span>] == y] = x;</span><br><span class="line">	T[x].fa = z;</span><br><span class="line">	T[y].ch[w] = T[x].ch[w ^ <span class="number">1</span>];</span><br><span class="line">	T[T[x].ch[w ^ <span class="number">1</span>]].fa = y;</span><br><span class="line">	T[x].ch[w ^ <span class="number">1</span>] = y;</span><br><span class="line">	T[y].fa = x;</span><br><span class="line">	update(y), update(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (; T[x].fa ^ goal; rotate(x)) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = T[x].fa;</span><br><span class="line">		<span class="keyword">int</span> z = T[y].fa;</span><br><span class="line">		<span class="keyword">if</span> (z ^ goal)</span><br><span class="line">			T[y].ch[<span class="number">1</span>] ^ x ^ T[z].ch[<span class="number">1</span>] ^ y ? rotate(x) : rotate(y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!goal) root = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">if</span> (!u) <span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">while</span> (T[u].ch[x &gt; T[u].val] &amp;&amp; x ^ T[u].val)</span><br><span class="line">		u = T[u].ch[x &gt; T[u].val];</span><br><span class="line">	splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root, fa = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (u &amp;&amp; x ^ T[u].val)</span><br><span class="line">		fa = u, u = T[u].ch[x &gt; T[u].val];</span><br><span class="line">	<span class="keyword">if</span> (u) T[u].cnt++;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		u = ++tot;</span><br><span class="line">		<span class="keyword">if</span> (fa) T[fa].ch[x &gt; T[fa].val] = u;</span><br><span class="line">		T[u].fa = fa;</span><br><span class="line">		T[u].siz = T[u].cnt = <span class="number">1</span>;</span><br><span class="line">		T[u].ch[<span class="number">0</span>] = T[u].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">		T[u].val = x;</span><br><span class="line">	&#125;</span><br><span class="line">	splay(u, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next_bound</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">	find(x);</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">if</span> (T[u].val &gt; x &amp;&amp; f) <span class="keyword">return</span> u;</span><br><span class="line">	<span class="keyword">if</span> (T[u].val &lt; x &amp;&amp; !f) <span class="keyword">return</span> u;</span><br><span class="line">	u = T[u].ch[f];</span><br><span class="line">	<span class="keyword">while</span> (T[u].ch[f ^ <span class="number">1</span>]) u = T[u].ch[f ^ <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> last = next_bound(x, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> next = next_bound(x, <span class="number">1</span>);</span><br><span class="line">	splay(last, <span class="number">0</span>), splay(next, last);</span><br><span class="line">	<span class="keyword">int</span> del = T[next].ch[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (T[del].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		T[del].cnt--;</span><br><span class="line">		splay(del, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> T[next].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">kth_element</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = root;</span><br><span class="line">	<span class="keyword">if</span> (T[u].siz &lt; x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">233</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> y = T[u].ch[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">if</span> (x &gt; T[y].siz + T[u].cnt) &#123;</span><br><span class="line">			x -= T[y].siz + T[u].cnt;</span><br><span class="line">			u = T[u].ch[<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (T[y].siz &gt;= x) u = y;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> T[u].val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	insert(<span class="number">1e9</span>);</span><br><span class="line">	insert(<span class="number">-1e9</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> opt, x;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;opt, &amp;x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">1</span>) insert(x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">2</span>) erase(x);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">			find(x);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[T[root].ch[<span class="number">0</span>]].siz);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, kth_element(x + <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[next_bound(x, <span class="number">0</span>)].val);</span><br><span class="line">		<span class="keyword">if</span> (opt == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, T[next_bound(x, <span class="number">1</span>)].val);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="欢迎捉虫子"><a href="#欢迎捉虫子" class="headerlink" title="欢迎捉虫子"></a>欢迎捉虫子</h1><p><img src="https://i.loli.net/2019/12/14/X5FNPW4wCqzgkQ9.png" alt="wd and noip.png"></p>
]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>OldDriveTree(ChthollyTree)学习笔记</title>
    <url>/2019/11/30/OldDriveTree-ChthollyTree-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="众所周知，数据结构-算法-程序，可见数据结构的重要性"><a href="#众所周知，数据结构-算法-程序，可见数据结构的重要性" class="headerlink" title="众所周知，数据结构+算法=程序，可见数据结构的重要性"></a>众所周知，数据结构+算法=程序，可见数据结构的重要性</h2><p>数据结构占了我们编程的一大部分。数据结构的大家族中，有优美的线段树、树状数组等。但我们今天的主角却十分暴力。她的名字叫珂朵莉树</p>
<p><code>珂朵莉树是基于C++STL库中的set的数据结构。与线段树、平衡树等树形结构类似，珂朵莉树是用来解决区间问题的很暴力的树形结构。</code></p>
<p>她的特点是能够进行区间推平操作，并且时间复杂度接近O(n log m) 。但前提是数据随机。但一般不会有哪个出题人去卡这样一个并不出名的数据结构。并且要有区间推平操作，否则光是一个split时间复杂度会炸。</p>
<p>珂朵莉树的构造长成这个亚子:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Chtholly</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LL L;</span><br><span class="line">    LL R;		<span class="comment">//区间</span></span><br><span class="line">    <span class="keyword">mutable</span> LL _val; <span class="comment">//值，注意，关键字mutable是必需的，否则会在add函数里CE</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    node(LL l, LL r = <span class="number">-1</span>, LL V = <span class="number">0</span>) : L(l), R(r), _val(V) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> L &lt; rhs.L; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Split操作:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> IT <span class="title">split</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    IT it = st.lower_bound(node(k));</span><br><span class="line">    <span class="keyword">if</span> (it != st.end() &amp;&amp; it-&gt;L == k)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    LL l = it-&gt;L, r = it-&gt;R;</span><br><span class="line">    LL v = it-&gt;_val;</span><br><span class="line">    st.erase(it);</span><br><span class="line">    st.insert(node(l, k - <span class="number">1</span>, v));</span><br><span class="line">    <span class="keyword">return</span> st.insert(node(k, r, v)).first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了操作方便我们这里有一个define:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IT set<span class="meta-string">&lt;Chtholly&gt;::iterator</span></span></span><br></pre></td></tr></table></figure>
<p>assign区间推平操作，这也是珂朵莉树的时间复杂度保证</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(LL ll, LL rr, LL val)</span> </span>&#123;</span><br><span class="line">    IT itr = split(rr + <span class="number">1</span>), itl = split(ll);</span><br><span class="line">    st.erase(itl, itr);</span><br><span class="line">    st.insert(node(ll, rr, val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举几个例子吧</p>
<h3 id="区间求和"><a href="#区间求和" class="headerlink" title="区间求和:"></a>区间求和:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Qsum</span><span class="params">(LL ll, LL rr)</span> </span>&#123;</span><br><span class="line">    LL res = <span class="number">0</span>;</span><br><span class="line">    IT itr = split(rr + <span class="number">1</span>), itl = split(ll);</span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl) res += (itl-&gt;R - itl-&gt;L + <span class="number">1</span>) * itl-&gt;_val;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间第K小"><a href="#区间第K小" class="headerlink" title="区间第K小:"></a>区间第K小:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">kth</span><span class="params">(LL ll, LL rr, LL k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;LL, LL&gt; &gt; vec;</span><br><span class="line">    IT itr = split(rr + <span class="number">1</span>), itl = split(ll);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; itl != itr; ++itl) vec.push_back(pair&lt;LL, LL&gt;(itl-&gt;_val, itl-&gt;R - itl-&gt;L + <span class="number">1</span>));</span><br><span class="line">    sort(vec.begin(), vec.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.begin(); it != vec.end(); ++it) &#123;</span><br><span class="line">        k -= it-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区间加"><a href="#区间加" class="headerlink" title="区间加"></a>区间加</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL ll, LL rr, LL ad)</span> </span>&#123;</span><br><span class="line">    IT itr = split(rr + <span class="number">1</span>), itl = split(ll);</span><br><span class="line">    <span class="keyword">for</span> (; itr != itl; ++itl) itl-&gt;_val += ad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>平时大家还是尽量少用······</p>
]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>图论最短路(Dijkstra、SPFA)模板</title>
    <url>/2019/11/30/%E5%9B%BE%E8%AE%BA%E6%9C%80%E7%9F%AD%E8%B7%AF-Dijkstra%E3%80%81SPFA-%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<a id="more"></a>
<p>nlogn堆优化邻接表</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> _INF = <span class="number">0x3F</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _Pos;</span><br><span class="line">	<span class="keyword">int</span> _Val;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> _Node &amp;rhs)	<span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> _Val &gt; rhs._Val;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> _To;</span><br><span class="line">	<span class="keyword">int</span> _Val;</span><br><span class="line">&#125; Edge[MAXN];</span><br><span class="line"><span class="built_in">vector</span>&lt;_Edge&gt; G[MAXN];</span><br><span class="line"><span class="keyword">bool</span> isVis[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"><span class="keyword">int</span> nowRhs[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushEdge</span><span class="params">(<span class="keyword">int</span> _From, <span class="keyword">int</span> _To, <span class="keyword">int</span> _Val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[_From].push_back(_Edge&#123;_To, _Val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Dijkstra(<span class="keyword">int</span> k)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(nowRhs, _INF, <span class="keyword">sizeof</span> nowRhs);</span><br><span class="line">	nowRhs[k] = <span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;_Node&gt; Q;</span><br><span class="line">	Q.push(_Node&#123;k, <span class="number">0</span>&#125;);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		_Node _next = Q.top();</span><br><span class="line">		Q.pop();</span><br><span class="line">		<span class="keyword">int</span> _Pos = _next._Pos;</span><br><span class="line">		<span class="keyword">if</span> (isVis[_Pos]) <span class="keyword">continue</span>;</span><br><span class="line">		isVis[_Pos] = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[_Pos].size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			_Edge _nextE = G[_Pos][i];</span><br><span class="line">			<span class="keyword">if</span> (nowRhs[_nextE._To] &gt; nowRhs[_Pos] + _nextE._Val)</span><br><span class="line">			&#123;</span><br><span class="line">				nowRhs[_nextE._To] = nowRhs[_Pos] + _nextE._Val;</span><br><span class="line">				Q.push(_Node&#123;_nextE._To, nowRhs[_nextE._To]&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//	freopen("test.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//	freopen("test.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> _From, _To;</span><br><span class="line">		<span class="keyword">int</span> _Val;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;_From, &amp;_To, &amp;_Val);</span><br><span class="line">		pushEdge(_From, _To, _Val);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_Dijkstra(s);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, nowRhs[i]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>n^2邻接矩阵</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];  <span class="comment">//一个点是否被访问过</span></span><br><span class="line"><span class="keyword">int</span> dis[MAXN];   <span class="comment">//源点到一个节点的目前最小权重</span></span><br><span class="line"><span class="keyword">int</span> n, m, s, t, INF;</span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN];  <span class="comment">//邻接矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (G[k][i] ^ INF)</span><br><span class="line">            dis[i] = G[k][i];</span><br><span class="line">    vis[k] = <span class="literal">true</span>;</span><br><span class="line">    dis[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> minx = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; dis[j] &lt; minx) &#123;</span><br><span class="line">                minx = dis[j];</span><br><span class="line">                tmp = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!tmp)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[tmp] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (G[tmp][j] ^ INF)</span><br><span class="line">                dis[j] = min(dis[j], dis[tmp] + G[tmp][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dis[t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    s = <span class="number">1</span>;</span><br><span class="line">    t = n;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;INF, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    fill(G[<span class="number">0</span>], G[<span class="number">0</span>] + MAXN * MAXN, INF);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">       G[u][v] = w;</span><br><span class="line">       G[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(dis, dis + MAXN, INT_MAX);</span><br><span class="line">    Dijkstra(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>

<h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>链式前向星版:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = getInt();</span><br><span class="line"><span class="keyword">int</span> m = getInt();</span><br><span class="line"><span class="keyword">int</span> s = getInt();</span><br><span class="line"><span class="keyword">int</span> head[MAXN], _next[MAXM];</span><br><span class="line"><span class="keyword">int</span> ver[MAXM], edge[MAXM], tot;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    _next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x7F</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    priority_queue &lt; pair &lt; <span class="keyword">int</span> , <span class="keyword">int</span> &gt; &gt; Q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    Q.push(make_pair(<span class="number">0</span>, s));</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.top().second; Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[x]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[x] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = _next[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i];</span><br><span class="line">            <span class="keyword">int</span> z = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + z) &#123;</span><br><span class="line">                dis[y] = dis[x] + z;</span><br><span class="line">                Q.push(make_pair(-dis[y], y));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getInt();</span><br><span class="line">        <span class="keyword">int</span> y = getInt();</span><br><span class="line">        <span class="keyword">int</span> z = getInt();</span><br><span class="line">        addEdge(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><del>SPFA</del> </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = MAXN &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n = getInt();</span><br><span class="line"><span class="keyword">int</span> m = getInt();</span><br><span class="line"><span class="keyword">int</span> s = getInt();</span><br><span class="line"><span class="keyword">int</span> head[MAXN], _next[MAXM];</span><br><span class="line"><span class="keyword">int</span> ver[MAXM], edge[MAXM], tot;</span><br><span class="line"><span class="keyword">int</span> dis[MAXN], vis[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">    ver[++tot] = y, edge[tot] = z;</span><br><span class="line">    _next[tot] = head[x], head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fill(dis, dis + MAXN, <span class="number">2147483647</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    vis[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(s);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        vis[x] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = _next[i]) &#123;</span><br><span class="line">            <span class="keyword">int</span> y = ver[i];</span><br><span class="line">            <span class="keyword">int</span> z = edge[i];</span><br><span class="line">            <span class="keyword">if</span> (dis[y] &gt; dis[x] + z) &#123;</span><br><span class="line">                dis[y] = dis[x] + z;</span><br><span class="line">                <span class="keyword">if</span> (!vis[y]) Q.push(y), vis[y] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = getInt();</span><br><span class="line">        <span class="keyword">int</span> y = getInt();</span><br><span class="line">        <span class="keyword">int</span> z = getInt();</span><br><span class="line">        addEdge(x, y, z);</span><br><span class="line">    &#125;</span><br><span class="line">    spfa();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, dis[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>233</tag>
      </tags>
  </entry>
  <entry>
    <title>O(n)的排序算法</title>
    <url>/2019/11/30/O-n-%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="珠排序是一种时间复杂度为O-n-的排序算法，他的来历可能是创始人脑子一抽想出来的"><a href="#珠排序是一种时间复杂度为O-n-的排序算法，他的来历可能是创始人脑子一抽想出来的" class="headerlink" title="珠排序是一种时间复杂度为O(n)的排序算法，他的来历可能是创始人脑子一抽想出来的"></a>珠排序是一种时间复杂度为O(n)的排序算法，他的来历<del>可能是创始人脑子一抽想出来的</del></h3><p>珠排序的思想是模拟，只不过不是我们平时做题的那种照题意模拟。他是模拟的现实生活。</p>
<p>就像这个亚子：</p>
<p><img src="http://images.cnblogs.com/cnblogs_com/kkun/201111/201111231440215046.png" alt=" 图片SPFA了"></p>
<p><img src="http://images.cnblogs.com/cnblogs_com/kkun/201111/201111231440225536.png" alt="图片SPFA了"></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/kkun/201111/201111231440236309.png" alt="This image was SPFAed"></p>
<p>e.g:</p>
<p><img src="https://images.cnblogs.com/cnblogs_com/kkun/201111/201111231440234848.png" alt="This image was SPFAed"></p>
<p><img src="https://images.cnblogs.com/cnblogs_com/kkun/201111/201111231440245621.png" alt="This image was SPAFed"></p>
<p>This image was SPFAed</p>
<p>是不是特别神奇！</p>
<p>给个代码实现吧，代码和图是我从网上找的，侵删</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> temp1,temp2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> times = <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;times);</span><br><span class="line">	<span class="keyword">int</span> numbers[times];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; times; k++) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;numbers[k]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> max = numbers[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; times; h++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(max &lt; numbers[h]) &#123;</span><br><span class="line">			max = numbers[h];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> temp3 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> numbers1[max];</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		temp3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; times; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(numbers[j] &lt; i + <span class="number">1</span>) &#123;</span><br><span class="line">				temp3++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		numbers1[i] = temp3;</span><br><span class="line">		i++;</span><br><span class="line">	&#125; <span class="keyword">while</span>(i &lt; max);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> numbers2[times];</span><br><span class="line">	<span class="keyword">int</span> temp4 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; times; l++) &#123;</span><br><span class="line">		<span class="keyword">for</span>(n = <span class="number">0</span>; n &lt; i; n++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(numbers1[n] &lt; l + <span class="number">1</span>) &#123;</span><br><span class="line">				temp4++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		numbers2[l] = temp4;</span><br><span class="line">		temp4 = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; times; m++) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d , "</span>,numbers2[m]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这份代码完全可以用vector优化</p>
<p>这个算法平时不建议大家使用，至于原因相信看懂了代码都清楚</p>
]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>NO题解 IP2015——sum 求和T3简单版题解(花样优化卡常)</title>
    <url>/2019/11/30/NO%E9%A2%98%E8%A7%A3-IP2015%E2%80%94%E2%80%94sum-%E6%B1%82%E5%92%8CT3%E7%AE%80%E5%8D%95%E7%89%88%E9%A2%98%E8%A7%A3-%E8%8A%B1%E6%A0%B7%E4%BC%98%E5%8C%96%E5%8D%A1%E5%B8%B8/</url>
    <content><![CDATA[<a id="more"></a>
<p>昨天这道题也是难倒了很多同学，但这并没有妨碍的某LJS AK(顺便%一波)</p>
<p>但是LJS的题解对我这种数学渣到不行蒟蒻实在不太友好，于是我干脆不看了。</p>
<p><a href="http://61.186.173.89:1024/article/253" target="_blank" rel="noopener">LJS题解传送门</a></p>
<p>于是我就想，这道题既然能够用暴力，那么就一定能够用各种奇淫技巧优化。</p>
<h1 id="O-N-3"><a href="#O-N-3" class="headerlink" title="O(N^3)"></a>O(N^3)</h1><p>首先我们只考虑 O(N^3) 的裸暴力，枚举每个x,y,z。这样就有20分了。</p>
<h1 id="O-N-2"><a href="#O-N-2" class="headerlink" title="O(N^2)"></a>O(N^2)</h1><p>接下来仔细观察题目，发现题目限制 y-x=z-y ，通过移项，可以得到 z+x=2y </p>
<p>那么我们就可以去掉枚举 y 的循环，时间复杂度 O(N^2) </p>
<p>这样就有40分了，再加上一些花里胡哨的优化，可以骗到60分</p>
<h1 id="歪正解"><a href="#歪正解" class="headerlink" title="歪正解"></a>歪正解</h1><p>再来观察 z+x=2y 这个式子， 2y 一定是一个偶数，那么则 z 和 x 满足同奇偶。</p>
<p>再次阅读题目，观察三元组的限制条件，我们很容易就可以想到按照颜色和每个格子的下标进行分组，那么像这样看来，我们就应该把重点放在cmp排序函数上。</p>
<p>既然 z 和 x 满足同奇偶，那么我们就可以按照这个来进行排序。</p>
<p>排序后，我们就可以很方便的判断哪些情况是不可能的，则枚举每一个 z 和 x ，判断不可能的情况，然后直接 break ，听起来有些像搜索的剪枝</p>
<h2 id="照这个思路写出来的40分代码"><a href="#照这个思路写出来的40分代码" class="headerlink" title="照这个思路写出来的40分代码:"></a>照这个思路写出来的40分代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> color;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color != a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="https://i.loli.net/2019/07/23/5d36530d59c3c82269.png" alt=""></p>
<p>这是为什么呢？原来没开 long   long 见祖宗了</p>
<p>90分代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color != a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://i.loli.net/2019/07/23/5d36530d6c6cc42741.png" alt=""></p>
<p>有一个点超时了，于是开始卡常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color ^ a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧是90分，脑子快爆了的我只好祭出这个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize (2)</span></span><br></pre></td></tr></table></figure>
<p>AC代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color ^ a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/23/5d36530d6cc2083763.png" alt=""></p>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 引水入城</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-%E5%BC%95%E6%B0%B4%E5%85%A5%E5%9F%8E/</url>
    <content><![CDATA[<a id="more"></a>
<p>这道题很明显的贪心+搜索</p>
<p>但我不会……</p>
<p>我认为不能放弃，于是继续分析。</p>
<p>我们可以简单的通过搜索判断是否有解，</p>
<p>然后对于第一行的每个点我们再次通过搜索遍历计算出它能够流到的最后一行所有的点，并且这些点一定是连续的。</p>
<p>假设这些点中间如果有断开的话，设不能走到的那个点为x,那么x必定会大于左、右、上层的高度，即无解</p>
<p>我们再次算出第一行每个点对应的最后一行的区间，然后记录左边边界和右边边界，然后……</p>
<p>然后就是明显的不要<del>bFace</del>的线段覆盖dp了。</p>
<p>　　　　if (Lover[j] &lt;= i &amp;&amp; Fucker[j] &gt;= i)<br>        dp[i] = min(dp[i],dp[Lover[j] - 1] + 1);</p>
<p>　　做后直接输出dp[m]就可以了!</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> G++ optimize (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> a[MAXN][MAXN], vis[MAXN][MAXN], Lover[MAXN], Fucker[MAXN], dp[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">firstDepthFirstSearch</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[x][y])</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	vis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; a[x][y] &gt; a[x + <span class="number">1</span>][y]) firstDepthFirstSearch(x + <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &gt; a[x - <span class="number">1</span>][y]) firstDepthFirstSearch(x - <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; a[x][y] &gt; a[x][y + <span class="number">1</span>]) firstDepthFirstSearch(x, y + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &gt; a[x][y - <span class="number">1</span>]) firstDepthFirstSearch(x, y - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">secondDepthFirstSearch</span><span class="params">(<span class="keyword">int</span> back, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[x][y])</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">		Lover[y] = back;</span><br><span class="line">	vis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x + <span class="number">1</span> &lt;= n &amp;&amp; a[x][y] &lt; a[x + <span class="number">1</span>][y]) secondDepthFirstSearch(back, x + <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (x - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &lt; a[x - <span class="number">1</span>][y]) secondDepthFirstSearch(back, x - <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (y + <span class="number">1</span> &lt;= m &amp;&amp; a[x][y] &lt; a[x][y + <span class="number">1</span>]) secondDepthFirstSearch(back, x, y + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (y - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &lt; a[x][y - <span class="number">1</span>]) secondDepthFirstSearch(back, x, y - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thirtiethDepthFirstSearch</span><span class="params">(<span class="keyword">int</span> back, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (vis[x][y])</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">		Fucker[y] = back;</span><br><span class="line">	vis[x][y] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (x+<span class="number">1</span> &lt;= n &amp;&amp; a[x][y] &lt; a[x + <span class="number">1</span>][y]) thirtiethDepthFirstSearch(back, x + <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (x<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &lt; a[x - <span class="number">1</span>][y]) thirtiethDepthFirstSearch(back, x - <span class="number">1</span>, y);</span><br><span class="line">	<span class="keyword">if</span> (y+<span class="number">1</span> &lt;= m &amp;&amp; a[x][y] &lt; a[x][y + <span class="number">1</span>]) thirtiethDepthFirstSearch(back, x, y + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (y<span class="number">-1</span> &gt;= <span class="number">1</span> &amp;&amp; a[x][y] &lt; a[x][y - <span class="number">1</span>]) thirtiethDepthFirstSearch(back, x, y - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	freopen("flow.in", "r", stdin);</span></span><br><span class="line"><span class="comment">//	freopen("flow.out", "w", stdout);</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		firstDepthFirstSearch(<span class="number">1</span>, i);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!vis[n][i])</span><br><span class="line">			ans++;</span><br><span class="line">	<span class="keyword">if</span> (ans) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"0\n%d"</span>,ans);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		secondDepthFirstSearch(i, n, i);</span><br><span class="line">	<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">		thirtiethDepthFirstSearch(i, n, i);</span><br><span class="line">	<span class="built_in">memset</span>(dp, Inf, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			<span class="keyword">if</span> (Lover[j] &lt;= i &amp;&amp; Fucker[j] &gt;= i)</span><br><span class="line">				dp[i] = min(dp[i],dp[Lover[j] - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1\n%d"</span>,dp[m]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2672 【推销员】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P2672-%E3%80%90%E6%8E%A8%E9%94%80%E5%91%98%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="首先，这是一道贪心的绝世好题"><a href="#首先，这是一道贪心的绝世好题" class="headerlink" title="首先，这是一道贪心的绝世好题"></a>首先，这是一道贪心的绝世好题</h3><h2 id="其次，这道题要用到结构体这门高深的知识"><a href="#其次，这道题要用到结构体这门高深的知识" class="headerlink" title="其次，这道题要用到结构体这门高深的知识"></a>其次，这道题要用到结构体这门高深的知识</h2><h1 id="最后，这道题我样例2没有过但是我交了4个OJ都AC了"><a href="#最后，这道题我样例2没有过但是我交了4个OJ都AC了" class="headerlink" title="最后，这道题我样例2没有过但是我交了4个OJ都AC了"></a>最后，这道题我样例2没有过但是我交了4个OJ都AC了</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">??????????????????_______????????????????????</span><br></pre></td></tr></table></figure>
<hr>
<p>不bb了，上思路吧</p>
<p>这道题主要用到了瞪眼大法以及贪心大法</p>
<p>我们可以记录下往返距离加上自身疲劳值最高的一个崽儿，以下就简称ze。</p>
<p>然后通过观察样例，可以发现ze每次都会参与输出，即每次都会向ze这个点进行推销，但不一定每次都把ze这个点当作终点。因为我们的排序规则是往返距离加上自身疲劳值按降序进行排序，所以ze不一定就是最远的那一户人家。</p>
<p>通过以上的<del>瞪眼</del>观察，我们发现，既然每一次都会有ze这个点，那么我们就可以划分子问题了，符合了贪心的定义。</p>
<p>其实这个思路也不是我独立思考出来的，而是我们机房大佬写了一篇题解。<br>但是这篇题解简直不要太精简，我是完全没有看懂。而代码我也没有去看</p>
<h2 id="给大家观摩一下"><a href="#给大家观摩一下" class="headerlink" title="给大家观摩一下:"></a>给大家观摩一下:</h2><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">一道贪心的题</span><br><span class="line"></span><br><span class="line">其实找到距离较远但疲劳值(往返+当前位置的疲劳值）最大的那个位置</span><br><span class="line"></span><br><span class="line">让它C位出道</span><br><span class="line"></span><br><span class="line">再排序排出疲劳值高的</span><br><span class="line"></span><br><span class="line">前缀和+当前最远距离*<span class="number">2</span></span><br></pre></td></tr></table></figure></h2><p>不知道大家看懂没有，反正我这个人一向看不懂别人的思路。不过这也给了我一点启发</p>
<p>Q:为什么不用DP？</p>
<p>A:因为DP会超时，而且看这道题目只是15年普及组的T3，用不着</p>
<p><del>你们最爱的完整代码</del><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> Far, Cost;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, maxValue, <span class="built_in">list</span>[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span></span></span><br><span class="line"><span class="function">	</span>&#123; <span class="keyword">return</span> ((a.Cost == b.Cost) &amp;&amp; (a.Far &gt; b.Far)) || (a.Cost &gt; b.Cost); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].Far);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].Cost);</span><br><span class="line">		<span class="keyword">if</span> ((a[i].Far &lt;&lt; <span class="number">1</span>) + a[i].Cost &gt; (a[maxValue].Far &lt;&lt; <span class="number">1</span>) + a[i].Cost)</span><br><span class="line">			maxValue = i;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	a[<span class="number">0</span>] = a[maxValue];</span><br><span class="line">	a[maxValue] = Node&#123;-Inf, -Inf&#125;;</span><br><span class="line">	stable_sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">		<span class="built_in">list</span>[i] = max(<span class="built_in">list</span>[i - <span class="number">1</span>], a[i].Far);</span><br><span class="line">	<span class="keyword">int</span> and_ = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		and_ += a[i].Cost;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, and_ + (<span class="built_in">list</span>[i] &lt;&lt; <span class="number">1</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>一份神奇的树剖</title>
    <url>/2019/11/30/%E4%B8%80%E4%BB%BD%E7%A5%9E%E5%A5%87%E7%9A%84%E6%A0%91%E5%89%96/</url>
    <content><![CDATA[<a id="more"></a>
<p>我的树剖有点神奇</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson (k &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson (k &lt;&lt; 1 | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l + r &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MID (T[k].l + T[k].r &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2</span> * <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> head[MAXN &lt;&lt; <span class="number">1</span>], _next[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ver[MAXN &lt;&lt; <span class="number">1</span>], edge[MAXN &lt;&lt; <span class="number">1</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m, root, mod, sum;</span><br><span class="line"><span class="keyword">int</span> deep[MAXN], fa[MAXN];</span><br><span class="line"><span class="keyword">int</span> son[MAXN], tot[MAXN];</span><br><span class="line"><span class="keyword">int</span> top[MAXN], idx[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> l;</span><br><span class="line">	<span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	<span class="keyword">int</span> f;</span><br><span class="line">	<span class="keyword">int</span> siz;</span><br><span class="line">&#125; T[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">getcHar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> buf[MAXN], *p1 = buf, *p2 = buf;</span><br><span class="line">	<span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, MAXN, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>), x = -x;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; <span class="number">9</span>) write(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	ver[++sum] = y, edge[sum] = z;</span><br><span class="line">	_next[sum] = head[x], head[x] = sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DepthFirstSearchAtFirst_233_TwoThreeThree</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f, <span class="keyword">int</span> dp)</span> </span>&#123;</span><br><span class="line">	deep[now] = dp;</span><br><span class="line">	fa[now] = f;</span><br><span class="line">	tot[now] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = _next[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (ver[i] == f) <span class="keyword">continue</span>;</span><br><span class="line">		tot[now] += DepthFirstSearchAtFirst_233_TwoThreeThree(ver[i], now, dp + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span> (tot[ver[i]] &gt; maxson) maxson = tot[ver[i]] , son[now] = ver[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tot[now];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WhatIsTheFuncionOfThisFunction_Upgrade</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	T[k].w = (T[lson].w + T[rson].w + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BuildSegmentTree_sFunction</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	T[k].l = l, T[k].r = r;</span><br><span class="line">	T[k].siz = r - l + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (!(l ^ r)) &#123;</span><br><span class="line">		T[k].w = a[l];</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	BuildSegmentTree_sFunction(lson, l, mid);</span><br><span class="line">	BuildSegmentTree_sFunction(rson, mid + <span class="number">1</span>, r);</span><br><span class="line">	WhatIsTheFuncionOfThisFunction_Upgrade(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DepthFirstSearchAtSecond_233_TwoThreeThree</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> topf)</span> </span>&#123;</span><br><span class="line">	idx[now] = ++cnt;</span><br><span class="line">	a[cnt] = b[now];</span><br><span class="line">	top[now] = topf;</span><br><span class="line">	<span class="keyword">if</span> (!son[now]) <span class="keyword">return</span> ;</span><br><span class="line">	DepthFirstSearchAtSecond_233_TwoThreeThree(son[now], topf);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = _next[i]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!idx[ver[i]])</span><br><span class="line">			DepthFirstSearchAtSecond_233_TwoThreeThree(ver[i], ver[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WhatIsTheFuncionOfThisFunction_PushDown</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!T[k].f) <span class="keyword">return</span> ;</span><br><span class="line">    T[lson].w = (T[lson].w + T[lson].siz * T[k].f) % mod;</span><br><span class="line">    T[rson].w = (T[rson].w + T[rson].siz * T[k].f) % mod;</span><br><span class="line">    T[lson].f = (T[lson].f + T[k].f) % mod;</span><br><span class="line">    T[rson].f = (T[rson].f + T[k].f) % mod;</span><br><span class="line">    T[k].f = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">WhatIsTheFuncionOfThisFunction_IntervalAdd</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= T[k].l &amp;&amp; T[k].r &lt;= r) &#123;</span><br><span class="line">		T[k].w += T[k].siz * val;</span><br><span class="line">		T[k].f += val;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	WhatIsTheFuncionOfThisFunction_PushDown(k);</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= MID) WhatIsTheFuncionOfThisFunction_IntervalAdd(lson, l, r, val);</span><br><span class="line">	<span class="keyword">if</span> (r &gt; MID) WhatIsTheFuncionOfThisFunction_IntervalAdd(rson, l, r, val);</span><br><span class="line">	WhatIsTheFuncionOfThisFunction_Upgrade(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IWantToAddTree_DoWhatYouWantToDo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (top[x] ^ top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">		WhatIsTheFuncionOfThisFunction_IntervalAdd(<span class="number">1</span>, idx[top[x]], idx[x], val);</span><br><span class="line">		x = fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (deep[x] &gt; deep[y]) swap(x, y);</span><br><span class="line">	WhatIsTheFuncionOfThisFunction_IntervalAdd(<span class="number">1</span>, idx[x], idx[y], val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">WhatIsTheFuncionOfThisFunction_IntervalQuery</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= T[k].l &amp;&amp; T[k].r &lt;= r)</span><br><span class="line">		<span class="keyword">return</span> T[k].w;</span><br><span class="line">	WhatIsTheFuncionOfThisFunction_PushDown(k);</span><br><span class="line">	<span class="keyword">if</span> (l &lt;= MID) res = (res + WhatIsTheFuncionOfThisFunction_IntervalQuery(lson, l, r)) % mod;</span><br><span class="line">	<span class="keyword">if</span> (r &gt; MID) res = (res + WhatIsTheFuncionOfThisFunction_IntervalQuery(rson, l, r)) % mod;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IWantToQueryTree_StayHungryStayFoolish</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (top[x] ^ top[y]) &#123;</span><br><span class="line">		<span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]]) swap(x, y);</span><br><span class="line">		res = (res + WhatIsTheFuncionOfThisFunction_IntervalQuery(<span class="number">1</span>, idx[top[x]], idx[x])) % mod;</span><br><span class="line">		x = fa[top[x]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (deep[x] &gt; deep[y])	swap(x, y);</span><br><span class="line">	write(res = (res + WhatIsTheFuncionOfThisFunction_IntervalQuery(<span class="number">1</span>, idx[x], idx[y])) % mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	m = read();</span><br><span class="line">	root = read();</span><br><span class="line">	mod = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) b[i] = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> from = read();</span><br><span class="line">		<span class="keyword">int</span> to = read();</span><br><span class="line">		addEdge(from, to, <span class="number">0</span>);</span><br><span class="line">		addEdge(to, from, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	DepthFirstSearchAtFirst_233_TwoThreeThree(root, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	DepthFirstSearchAtSecond_233_TwoThreeThree(root, root);</span><br><span class="line">	BuildSegmentTree_sFunction(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">	<span class="keyword">while</span> (m--) &#123;</span><br><span class="line">		<span class="keyword">int</span> op = read();</span><br><span class="line">		<span class="keyword">int</span> x, y, z;</span><br><span class="line">		<span class="keyword">switch</span> (op) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">			x = read();</span><br><span class="line">			y = read();</span><br><span class="line">			z = read();</span><br><span class="line">			z %= mod;</span><br><span class="line">			IWantToAddTree_DoWhatYouWantToDo(x, y, z);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">			x = read();</span><br><span class="line">			y = read();</span><br><span class="line">			IWantToQueryTree_StayHungryStayFoolish(x, y);</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">			x = read();</span><br><span class="line">			z = read();</span><br><span class="line">			WhatIsTheFuncionOfThisFunction_IntervalAdd(<span class="number">1</span>, idx[x], idx[x] + tot[x] - <span class="number">1</span>, z % mod);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">			x = read();</span><br><span class="line">			write(WhatIsTheFuncionOfThisFunction_IntervalQuery(<span class="number">1</span>, idx[x], idx[x] + tot[x] - <span class="number">1</span>));</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5661 【公交换乘【民间数据】】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P5661-%E3%80%90%E5%85%AC%E4%BA%A4%E6%8D%A2%E4%B9%98%E3%80%90%E6%B0%91%E9%97%B4%E6%95%B0%E6%8D%AE%E3%80%91%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>这道题我用的是vector，然后没有—j导致爆零，特此提醒…</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt; pair &lt; <span class="keyword">int</span> , <span class="keyword">int</span> &gt; &gt; vec;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ID;</span><br><span class="line">    <span class="keyword">int</span> Pri;</span><br><span class="line">    <span class="keyword">int</span> Tim;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        a[i] = NODE&#123;x, y, z&#125;;</span><br><span class="line">        <span class="keyword">if</span> (!a[i].ID) &#123;</span><br><span class="line">            ans += a[i].Pri;</span><br><span class="line">            vec.push_back(make_pair(a[i].Pri, a[i].Tim));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> Flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec.size(); ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].Tim - vec[j].second) &lt;= <span class="number">45</span> &amp;&amp; vec[j].first &gt;= a[i].Pri) &#123;</span><br><span class="line">                vec.erase(vec.begin() + j);</span><br><span class="line">                --j;	<span class="comment">//就是因为这句...</span></span><br><span class="line">                Flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].Tim - vec[j].second) &gt; <span class="number">45</span>)</span><br><span class="line">                vec.erase(vec.begin() + j), --j<span class="comment">//就是因为这句...;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Flag) ans += a[i].Pri;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯消元学习</title>
    <url>/2019/11/30/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<a id="more"></a>
<p>啃了半天了，终于把高斯消元搞懂了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/trie_policy.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/priority_queue.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ext/pb_ds/hash_policy.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-16</span>;</span><br><span class="line"><span class="keyword">double</span> equ[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">f_abs</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"> </span>&#123; <span class="keyword">return</span> x &gt; <span class="number">0</span> ? x : -x; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	n = read();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">			equ[i][j] = read() * <span class="number">1.0</span>;</span><br><span class="line">		equ[i][n] = read() * <span class="number">1.0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> arv = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++j)</span><br><span class="line">			<span class="keyword">if</span> (f_abs(equ[j][i] - equ[arv][i]) &lt;= eps) arv = j;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; ++j)</span><br><span class="line">			swap(equ[i][j], equ[arv][j]);</span><br><span class="line">		<span class="keyword">if</span> (f_abs(equ[i][i]) &lt;= eps)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution"</span>) &amp; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j) equ[i][j] /= equ[i][i];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)</span><br><span class="line">			<span class="keyword">if</span> (i != j)	<span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) equ[j][k] -= equ[j][i] * equ[i][k];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, equ[i][n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2639 【[USACO09OCT]Bessie的体重问题Bessie&#39;s We…】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P2639-%E3%80%90-USACO09OCT-Bessie%E7%9A%84%E4%BD%93%E9%87%8D%E9%97%AE%E9%A2%98Bessie-s-We%E2%80%A6%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>这是一道很好的背包练手题。</p>
<p>细读题目，可以发现题目中并没有给定每捆干草的价值，只给出了每捆干草的重量。</p>
<p>再读题目，我们发现题目求Bessie不超过节食的限制的前提下可以吃掉多少干草，所以，我们可以把每堆干草的重量看作它的的价值，这就成了一个01背包的模板了</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> solv</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">50000</span> + <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> F[MAXN], w[MAXN];</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> n, m, c[MAXN];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> T <span class="title">getMax</span><span class="params">(T x, T y)</span></span></span><br><span class="line"><span class="function">		</span>&#123; <span class="keyword">return</span> x &gt; y ? x : y; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;m, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;w[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> j = m; j &gt;= w[i]; --j)</span><br><span class="line">				F[j] = solv::getMax(F[j], F[j - w[i]] + w[i]);</span><br><span class="line">		</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, F[m]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	solv::Solve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>A+B Problem Solution</title>
    <url>/2019/11/30/A-B-Problem-Solution/</url>
    <content><![CDATA[<a id="more"></a>
<p>区间求和，可蒟蒻的我不会线段树，只能写个ODT啦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IT set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> L;</span><br><span class="line">	<span class="keyword">int</span> R;</span><br><span class="line">	<span class="keyword">mutable</span> <span class="keyword">int</span> val;</span><br><span class="line">	</span><br><span class="line">	node(<span class="keyword">int</span> l, <span class="keyword">int</span> r = <span class="number">-1</span>,<span class="keyword">int</span> v = <span class="number">0</span>) : L(l), R(r), val(v) &#123;&#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> L &lt; rhs.L; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch = getchar())) <span class="keyword">if</span> (ch == <span class="string">'-'</span>) f = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) a = (a &lt;&lt; <span class="number">3</span>) + (a &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="string">'0'</span>), ch = getchar();</span><br><span class="line">	<span class="keyword">return</span> a * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> IT <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IT it = st.lower_bound(node(pos));</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (it != st.end() &amp;&amp; it-&gt;L == pos)</span><br><span class="line">		<span class="keyword">return</span> it;</span><br><span class="line">	it--;</span><br><span class="line">	<span class="keyword">int</span> l = it-&gt;L, r = it-&gt;R;</span><br><span class="line">	<span class="keyword">int</span> val = it-&gt;val;</span><br><span class="line">	st.insert(node(l, pos - <span class="number">1</span>, val));</span><br><span class="line">	<span class="keyword">return</span> st.insert(node(pos, r, val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Qsum</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	IT itl = split(l), itr = split(r + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (; itl != itr; ++itl) res += itl-&gt;val;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; ++i)</span><br><span class="line">		st.insert(node(i, i, read()));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Qsum(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 新初二NOIP国庆热身水题赛</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-%E6%96%B0%E5%88%9D%E4%BA%8CNOIP%E5%9B%BD%E5%BA%86%E7%83%AD%E8%BA%AB%E6%B0%B4%E9%A2%98%E8%B5%9B/</url>
    <content><![CDATA[<a id="more"></a>
<h3 id="今天的热身赛的题很有质量"><a href="#今天的热身赛的题很有质量" class="headerlink" title="今天的热身赛的题很有质量!"></a>今天的热身赛的题很有质量!</h3><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p><code>题面：</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">现在，存在一组激光编号，需要从中挑选出来k个组成素数，并且可能存在多种方案，所以你需要知道至少要尝</span><br><span class="line"></span><br><span class="line">试多少种组合才能破解这个机关，至于如何破解，那就是神兽的程序的问题了。</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h3><p>​        暴搜没得说</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k, ans;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span> + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= x; ++i)</span><br><span class="line">		<span class="keyword">if</span> (!(x % i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> sum, <span class="keyword">int</span> tot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (tot == k)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (isPrime(sum))</span><br><span class="line">			ans++;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (now == n + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	DFS(now + <span class="number">1</span>, sum + a[now], tot + <span class="number">1</span>);</span><br><span class="line">	DFS(now + <span class="number">1</span>, sum, tot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">	DFS(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p><code>题面:</code></p>
<p><code>这里的防御系统要求所有的资料会在第k次全部弹出，但是每份资料的重量可能不同，且必须按照既定的顺序选择每一次弹出的资料，每一次至少弹出一份资料，上不封顶，但是神兽希望最重的那组资料重量在他们的承受范围之内，所以要求最重的那组资料尽可能轻。</code></p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">虽然读题读了很久，但还好看出了这是一道二分答案的题目</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, k;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">check</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> rhs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tot + a[i] &gt; rhs) &#123;</span><br><span class="line">            tot = <span class="number">0</span>;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        tot += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> l = <span class="number">0</span>, r = <span class="number">1e16</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a[i]),</span><br><span class="line">        l = max(l, a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid) &lt;= k) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><code>神兽思考片刻，突然想到了自己设计的一套程序就是针对自动化武器的，而且如果这些武器联网，还能达到传播歼灭所有网内系统的效果，但是每次传播都需要神兽亲自完成，并花费大量时间，当然每次部署一个武器也会花费大量时间，神兽可以选择联网系统中的一部分系统进行部署，剩下的可以由他来传播(由于只能由神兽完成部署和传播，所以所有操作不能同时进行)</code></p>
<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这道题一看就是最小生成树。板子题没什么可讲的</span><br></pre></td></tr></table></figure>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">90000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cost[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> u;</span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> w;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; rhs.w; &#125;</span><br><span class="line">&#125; edge[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)	fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x ^ fa[x]) fa[x] = find(fa[x]);</span><br><span class="line">	<span class="keyword">return</span> fa[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">union_</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> u = find(x), v = find(y);</span><br><span class="line">	<span class="keyword">if</span> (u ^ v) fa[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> cost;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cost);</span><br><span class="line">		edge[m++] = Edge&#123;<span class="number">0</span>, i, cost&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> cost;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;cost);</span><br><span class="line">			<span class="keyword">if</span> (j &gt; i) edge[m++] = Edge&#123;i, j, cost&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	++n;</span><br><span class="line">	sort(edge, edge + m);</span><br><span class="line">	init(n);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>, src = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (find(edge[i].u) != find(edge[i].v))</span><br><span class="line">		&#123;</span><br><span class="line">			union_(edge[i].u, edge[i].v);</span><br><span class="line">			ans += edge[i].w;</span><br><span class="line">			src++;</span><br><span class="line">			<span class="keyword">if</span> (src == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h3><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p><code>小L在上学路上不幸掉入了一口井深D英尺的深井中，不幸的是，他只能靠吃掉到井里的东西来维持生命了，但幸运的是，每隔一段时间小T就会往井里丢东西，小L可以选择用这些东西垫在脚下尝试着爬出井口或者吃掉它们来续命，被垫在脚下的东西就不能再吃了，当然吃过的东西也不能再垫在脚下。当小L的高度和井口高度一样高的时候，他就可以爬出井口了。小L预先知道了一共会有N个东西被丢下来，并且他还知道了他们的掉落时间，高度以及能够维持生命的时间长度。
　　一开始，小L体内的能量能够维持10个单位时间的生命。</code></p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>`<br>这是一道dp题。似乎贪心也能过？？</p>
<p>设dp[i][j]为第i个物品掉下时，小L的高度为j时的最大生命值</p>
<p>可推出转移方程：</p>
<p>dp[i + 1][j + A[i].height] = max(dp[i + 1][j + A[i].height], dp[i][j] - qq);</p>
<p>dp[i + 1][j] = max(dp[i + 1][j], dp[i][j] - qq + A[i].life_num);</p>
<p>其中qq为后一个物品掉落的时间与当前凋落物出现时间差<br>`</p>
<h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> High, n;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][MAXN / <span class="number">3</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> app_tim;</span><br><span class="line">	<span class="keyword">int</span> life_num;</span><br><span class="line">	<span class="keyword">int</span> height;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> app_tim &lt; rhs.app_tim; &#125;</span><br><span class="line">&#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;High, &amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i].app_tim);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i].life_num);</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i].height);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(A + <span class="number">1</span>, A + <span class="number">1</span> + n);</span><br><span class="line">	<span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">	dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> qq = A[i + <span class="number">1</span>].app_tim - A[i].app_tim;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= High; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dp[i][j] &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">			dp[i + <span class="number">1</span>][j + A[i].height] = max(dp[i + <span class="number">1</span>][j + A[i].height], dp[i][j] - qq);</span><br><span class="line">			dp[i + <span class="number">1</span>][j] = max(dp[i + <span class="number">1</span>][j], dp[i][j] - qq + A[i].life_num);</span><br><span class="line">			<span class="keyword">if</span> (j + A[i].height &gt;= High)</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, A[i].app_tim) &amp; <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (dp[i][<span class="number">0</span>] &gt;= <span class="number">0</span>)</span><br><span class="line">			ans = max(ans, dp[i][<span class="number">0</span>] + A[i].life_num + A[i].app_tim);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T5"><a href="#T5" class="headerlink" title="T5"></a>T5</h3><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p><code>首先这肯定是一个图，因为A, B, C点的位置不确定。
所以我们先跑一个最短路确定C点，然后再跑两个最短路确定B,
 C点的位置，最后统计A~C和B~C谁的距离比较小输出即可</code></p>
<h3 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo LONG_LONG_MAX</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	Int w;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Edge&gt; G[MAXN];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line">Int dis[<span class="number">3</span>][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, Int w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	G[u].push_back(Edge&#123;v, w&#125;);</span><br><span class="line">	G[v].push_back(Edge&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[k][i] = oo;</span><br><span class="line">		vis[i] = <span class="number">0</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init(s);</span><br><span class="line">	dis[s][t] = <span class="number">0</span>;</span><br><span class="line">	vis[t] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">	Q.push(t);</span><br><span class="line">	<span class="keyword">while</span> (!Q.empty())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u = Q.front();</span><br><span class="line">		Q.pop();</span><br><span class="line">		vis[u] = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[u].size(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> v = G[u][i].v;</span><br><span class="line">			<span class="keyword">int</span> w = G[u][i].w;</span><br><span class="line">			<span class="keyword">if</span> (dis[s][v] &gt; dis[s][u] + w)</span><br><span class="line">			&#123;</span><br><span class="line">				dis[s][v] = dis[s][u] + w;</span><br><span class="line">				<span class="keyword">if</span> (!vis[v])</span><br><span class="line">				&#123;</span><br><span class="line">					vis[v] = <span class="literal">true</span>;</span><br><span class="line">					Q.push(v);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> u, v;</span><br><span class="line">		Int w;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%lld"</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">		pushEdge(u, v, w);</span><br><span class="line">	&#125;</span><br><span class="line">	Int ans1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Node1 = <span class="number">0</span>;</span><br><span class="line">	BFS(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (dis[<span class="number">0</span>][i] &gt; ans1)</span><br><span class="line">			ans1 = dis[<span class="number">0</span>][i],</span><br><span class="line">			Node1 = i;</span><br><span class="line">	BFS(<span class="number">1</span>, Node1);</span><br><span class="line">	Int ans2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> Node2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (dis[<span class="number">1</span>][i] &gt; ans2)</span><br><span class="line">			ans2 = dis[<span class="number">1</span>][i],</span><br><span class="line">			Node2 = i;</span><br><span class="line">	BFS(<span class="number">2</span>, Node2);</span><br><span class="line">	Int ans3 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">if</span> (i != Node1 &amp;&amp; i != Node2)</span><br><span class="line">			ans3 = max(ans3, min(dis[<span class="number">1</span>][i], dis[<span class="number">2</span>][i]));</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans3 + ans2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T7"><a href="#T7" class="headerlink" title="T7"></a>T7</h3><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>`<br>这道题…做过的吧？</p>
<p>没错就是那个泥泞的牧场。</p>
<p>没有做的同学看了这篇题解估计两道题都能做。</p>
<p>首先我们从泥泞的牧场讲起:</p>
<p>   此题的难点在于如何去建图。</p>
<p>   很显然我们需要把行和列分别当成二分图的两部分<br>   。<br>   所以我们可以分别把一个点行的连通块和列的连通块处理出来。</p>
<p>   每次发现一个点就把编一个号，然后就可以把图构建出来了！</p>
<p>T7只是在泥泞的牧场上加了一个判断而已<br>`</p>
<h3 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, R, C;</span><br><span class="line"><span class="keyword">char</span> str[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> G[MAXN][MAXN], match[MAXN];</span><br><span class="line"><span class="keyword">int</span> row[MAXN][MAXN];</span><br><span class="line"><span class="keyword">int</span> vis[MAXN], col[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= C; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (G[k][i] &amp;&amp; !vis[i])</span><br><span class="line">		&#123;</span><br><span class="line">			vis[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!match[i] || DFS(match[i]))</span><br><span class="line">				<span class="keyword">return</span> (match[i] = k) * <span class="number">0</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, str[i] + <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> t_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'*'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++t_sum;</span><br><span class="line">				<span class="keyword">while</span> ((str[i][j] == <span class="string">'x'</span> || str[i][j] == <span class="string">'*'</span>) &amp;&amp; j &lt;= m) row[i][j] = t_sum, ++j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	R = t_sum;</span><br><span class="line">	t_sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'*'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				++t_sum;</span><br><span class="line">				<span class="keyword">while</span> ((str[i][j] == <span class="string">'x'</span> || str[i][j] == <span class="string">'*'</span>) &amp;&amp; i &lt;= n) col[i][j] = t_sum, ++i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	C = t_sum;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">			<span class="keyword">if</span> (str[i][j] == <span class="string">'*'</span>)</span><br><span class="line">				G[row[i][j]][col[i][j]] = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">		<span class="keyword">if</span> (DFS(i)) ans++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="T7-1"><a href="#T7-1" class="headerlink" title="T7"></a>T7</h3><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这题似乎是一个分治？？</span><br><span class="line">但经过观察我们可以发现以下规律：</span><br><span class="line">    如果最后的温度大于等于最大的温度值，输出possible和最后的温度</span><br><span class="line">	如果最后的温度不大于最小的温度值，输出possible和最小值</span><br><span class="line">	否则输出Impossible。</span><br></pre></td></tr></table></figure>
<h3 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> T, C;</span><br><span class="line"><span class="keyword">double</span> t, c;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> MAX = <span class="number">1e17</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> _min = MAX, _max = -MAX;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;T, &amp;C);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;t, &amp;c);</span><br><span class="line">		T = (T * C + t * c) / (c + C);</span><br><span class="line">		C += c;</span><br><span class="line">		_min = min(_min, t);</span><br><span class="line">		_max = max(_max, t);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (T &gt;= _max) <span class="built_in">printf</span>(<span class="string">"Possible\n%.4lf"</span>, T);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (T &lt;= _min) <span class="built_in">printf</span>(<span class="string">"Possible\n%.4lf"</span>, _min);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"Impossible"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2482 【[SDOI2010]猪国杀】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P2482-%E3%80%90-SDOI2010-%E7%8C%AA%E5%9B%BD%E6%9D%80%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="一个正常人是不会做这种题的…"><a href="#一个正常人是不会做这种题的…" class="headerlink" title="一个正常人是不会做这种题的…"></a>一个正常人是不会做这种题的…</h2><p>某年某月某天，我校机房有个可怜人被人强行立了个flag:9月月底做不出来luoguP2482就女装！于是他拼命的调代码。5分，10分，25分……95分。最后实在不行了求救了机房大佬WY才AC。</p>
<p>这位同志的精神感动了机房，于是全机房都开始疯狂的调这道题。我也<del>不幸</del>幸运的成为了其中的一员。</p>
<p>其实这道题就是模拟，大概是因为我平时闲的没事喜欢做游戏，所以感觉挺简单的。</p>
<p>把各种行为封装成自由函数，当然如果你想建class也没有问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_PLAYER_NUM = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_CARD_NUM = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PIG</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span>		card_num;</span><br><span class="line">	<span class="keyword">int</span>		life_num;</span><br><span class="line">	<span class="keyword">int</span>		_next;</span><br><span class="line">	<span class="keyword">int</span>		_last;</span><br><span class="line">	<span class="keyword">char</span>	identity;</span><br><span class="line">	<span class="keyword">char</span>	card[MAX_CARD_NUM];</span><br><span class="line">	<span class="keyword">bool</span>	isGetedZgln;</span><br><span class="line">&#125; A[MAX_PLAYER_NUM];</span><br><span class="line"><span class="keyword">char</span>	id_in_king[MAX_PLAYER_NUM]; 	<span class="comment">//在主公眼里诸猪的身份</span></span><br><span class="line"><span class="keyword">char</span>	card_set[MAX_CARD_NUM];</span><br><span class="line"><span class="keyword">char</span>	scanner[MAX_PLAYER_NUM];</span><br><span class="line"><span class="keyword">int</span>		n, m, bad_man_num;</span><br><span class="line"><span class="keyword">bool</span>	GG;  <span class="comment">//主公是否GG</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">initt</span><span class="params">(	 	 		   	    )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">start</span><span class="params">(		  	 	 	    )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">mopai</span><span class="params">(       <span class="keyword">int</span> fuck       )</span></span>;  <span class="comment">//不知道怎么命名了...</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">nmrqq</span><span class="params">(		 <span class="keyword">int</span> fuck       )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">wjqff</span><span class="params">(		 <span class="keyword">int</span> fuck       )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">jisha</span><span class="params">( <span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">killl</span><span class="params">( <span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">void</span>		<span class="title">jdddd</span><span class="params">( <span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span>	 <span class="keyword">bool</span>		<span class="title">wxkjj</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3)</span></span>;   <span class="comment">//为了对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	initt();</span><br><span class="line">	start();</span><br><span class="line">	<span class="keyword">if</span> (A[<span class="number">1</span>].life_num &lt;= <span class="number">0</span>)	<span class="built_in">puts</span>(<span class="string">"FP"</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"MP"</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i].life_num &lt;= <span class="number">0</span>)	<span class="built_in">puts</span>(<span class="string">"DEAD"</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[i].card_num; ++j)</span><br><span class="line">				<span class="keyword">if</span> (A[i].card[j] != <span class="string">'U'</span>)	<span class="built_in">printf</span>(<span class="string">"%c "</span>, A[i].card[j]);</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>	<span class="title">initt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)	A[i]._next = i + <span class="number">1</span>, A[i]._last = i - <span class="number">1</span>;</span><br><span class="line">	A[n]._next = <span class="number">1</span>, A[<span class="number">1</span>]._last = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; MAX_CARD_NUM; ++j)	A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>, scanner);</span><br><span class="line">		A[i].identity = scanner[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">5</span>; ++j)	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, scanner), A[i].card[j] = scanner[<span class="number">0</span>];</span><br><span class="line">		A[i].life_num = A[i].card_num = <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">if</span> (A[i].identity == <span class="string">'F'</span>)	bad_man_num++;</span><br><span class="line">		A[i].isGetedZgln = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	id_in_king[<span class="number">1</span>] = <span class="string">'M'</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)	id_in_king[i] = <span class="string">'U'</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)	<span class="built_in">scanf</span>(<span class="string">"%s"</span>, scanner), card_set[m - i + <span class="number">1</span>] = scanner[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> now_card;</span><br><span class="line">	GG = <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (bad_man_num) GG = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (GG)		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i; i = A[i]._next)</span><br><span class="line">	&#123;</span><br><span class="line">		mopai(i), mopai(i);</span><br><span class="line">		<span class="keyword">bool</span> isKilled = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[i].card_num; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i].card[j] != <span class="string">'U'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!A[i].life_num)	<span class="keyword">break</span>;</span><br><span class="line">				now_card = A[i].card[j];</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'P'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (A[i].life_num != <span class="number">4</span>)	A[i].life_num++, A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'K'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (!isKilled &amp;&amp; !A[i].isGetedZgln)	<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> ((A[i].identity == <span class="string">'M'</span>) &amp;&amp; (id_in_king[A[i]._next] != <span class="string">'L'</span>) &amp;&amp; (id_in_king[A[i]._next] != <span class="string">'F'</span>))</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> ((A[i].identity == <span class="string">'Z'</span>) &amp;&amp; (id_in_king[A[i]._next] != <span class="string">'F'</span>))</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span> ((A[i].identity == <span class="string">'F'</span>) &amp;&amp; (id_in_king[A[i]._next] != <span class="string">'Z'</span>) &amp;&amp; (id_in_king[A[i]._next] != <span class="string">'M'</span>))</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">					killl(i, A[i]._next);</span><br><span class="line">					id_in_king[i] = A[i].identity;</span><br><span class="line">					isKilled = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'F'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (A[i].identity == <span class="string">'F'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">						jdddd(i, <span class="number">1</span>);</span><br><span class="line">						id_in_king[i] = A[i].identity;</span><br><span class="line">						<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">						j = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> k = A[i]._next; k != i; k = A[k]._next)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span> ((A[i].identity == <span class="string">'M'</span> &amp;&amp; (id_in_king[k] == <span class="string">'L'</span> || id_in_king[k] == <span class="string">'F'</span>)) || (A[i].identity == <span class="string">'Z'</span> &amp;&amp; id_in_king[k] == <span class="string">'F'</span>))</span><br><span class="line">						&#123;</span><br><span class="line">							A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">							jdddd(i, k);</span><br><span class="line">							id_in_king[i] = A[i].identity;</span><br><span class="line">							<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">							j = <span class="number">0</span>;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">					</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'N'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">					nmrqq(i);</span><br><span class="line">					<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'W'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">					wjqff(i);</span><br><span class="line">					<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (now_card == <span class="string">'Z'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					A[i].isGetedZgln = <span class="literal">true</span>;</span><br><span class="line">					A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">					j = <span class="number">0</span>;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mopai</span><span class="params">(<span class="keyword">int</span> fuck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!m)	m++;</span><br><span class="line">	A[fuck].card[++A[fuck].card_num] = card_set[m];</span><br><span class="line">	m--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">nmrqq</span><span class="params">(<span class="keyword">int</span> fuck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> shit = A[fuck]._next; shit != fuck; shit = A[shit]._next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!wxkjj(fuck, shit, <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= A[shit].card_num; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (A[shit].card[i] == <span class="string">'K'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					A[shit].card[i] = <span class="string">'U'</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; A[shit].card_num)</span><br><span class="line">			&#123;</span><br><span class="line">				A[shit].life_num--;</span><br><span class="line">				<span class="keyword">if</span> (shit == <span class="number">1</span> &amp;&amp; id_in_king[fuck] == <span class="string">'U'</span>)	id_in_king[fuck] = <span class="string">'L'</span>;</span><br><span class="line">				<span class="keyword">if</span> (!A[shit].life_num) jisha(fuck, shit);</span><br><span class="line">				<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">wjqff</span><span class="params">(<span class="keyword">int</span> fuck)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> shit = A[fuck]._next; shit != fuck; shit = A[shit]._next)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!wxkjj(fuck, shit, <span class="number">1</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> i;</span><br><span class="line">			<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= A[shit].card_num; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (A[shit].card[i] == <span class="string">'D'</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					A[shit].card[i] = <span class="string">'U'</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (i &gt; A[shit].card_num)</span><br><span class="line">			&#123;</span><br><span class="line">				A[shit].life_num--;</span><br><span class="line">				<span class="keyword">if</span> (shit == <span class="number">1</span> &amp;&amp; id_in_king[fuck] == <span class="string">'U'</span>)	id_in_king[fuck] = <span class="string">'L'</span>;</span><br><span class="line">				<span class="keyword">if</span> (!A[shit].life_num)	jisha(fuck, shit);</span><br><span class="line">				<span class="keyword">if</span> (GG)	<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">jisha</span><span class="params">(<span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[GGer].card_num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[GGer].card[i] == <span class="string">'P'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			A[GGer].card[i] = <span class="string">'U'</span>;</span><br><span class="line">			A[GGer].life_num++;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	A[A[GGer]._next]._last = A[GGer]._last;</span><br><span class="line">	A[A[GGer]._last]._next = A[GGer]._next;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (GGer == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GG = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (A[GGer].identity == <span class="string">'F'</span>)	bad_man_num--;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (!bad_man_num)</span><br><span class="line">	&#123;</span><br><span class="line">		GG = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (A[GGer].identity == <span class="string">'F'</span>)	mopai(Killer), mopai(Killer), mopai(Killer);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (A[GGer].identity == <span class="string">'Z'</span> &amp;&amp; A[Killer].identity == <span class="string">'M'</span>)	A[Killer].card_num = <span class="number">0</span>, A[Killer].isGetedZgln = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">killl</span><span class="params">(<span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A[GGer].card_num; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[GGer].card[i] == <span class="string">'D'</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			A[GGer].card[i] = <span class="string">'U'</span>;</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[GGer].life_num--;</span><br><span class="line">	<span class="keyword">if</span> (!A[GGer].life_num)	jisha(Killer, GGer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">jdddd</span><span class="params">(<span class="keyword">int</span> Killer, <span class="keyword">int</span> GGer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fuck, shit;</span><br><span class="line">	<span class="keyword">if</span> (wxkjj(Killer, GGer, <span class="number">1</span>))	<span class="keyword">return</span> ;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (Killer == <span class="number">1</span> &amp;&amp; A[GGer].identity == <span class="string">'Z'</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		A[GGer].life_num--;</span><br><span class="line">		<span class="keyword">if</span> (!A[GGer].life_num)	jisha(Killer, GGer);</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	fuck = shit = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">233</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (A[GGer].card[fuck] != <span class="string">'K'</span> &amp;&amp; fuck &lt;= A[GGer].card_num)	++fuck;</span><br><span class="line">		<span class="keyword">if</span> (fuck &gt; A[GGer].card_num)</span><br><span class="line">		&#123;</span><br><span class="line">			A[GGer].life_num--;</span><br><span class="line">			<span class="keyword">if</span> (!A[GGer].life_num)	jisha(Killer, GGer);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> A[GGer].card[fuck] = <span class="string">'U'</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span> (A[Killer].card[shit] != <span class="string">'K'</span> &amp;&amp; shit &lt;= A[Killer].card_num)	++shit;</span><br><span class="line">		<span class="keyword">if</span> (shit &gt; A[Killer].card_num)</span><br><span class="line">		&#123;</span><br><span class="line">			A[Killer].life_num--;</span><br><span class="line">			<span class="keyword">if</span> (!A[Killer].life_num)	jisha(GGer, Killer);</span><br><span class="line">			<span class="keyword">return</span> ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> A[Killer].card[shit] = <span class="string">'U'</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">wxkjj</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> x2, <span class="keyword">int</span> x3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = x1;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">233</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (x3 == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (id_in_king[x2] == A[i].identity || (id_in_king[x2] == <span class="string">'M'</span> &amp;&amp; A[i].identity == <span class="string">'Z'</span>) || (id_in_king[x2] == <span class="string">'Z'</span> &amp;&amp; A[i].identity == <span class="string">'M'</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[i].card_num; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (A[i].card[j] == <span class="string">'J'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">						id_in_king[i] = A[i].identity;</span><br><span class="line">						<span class="keyword">return</span> !wxkjj(i, x1, <span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (((A[i].identity == <span class="string">'M'</span> || A[i].identity == <span class="string">'Z'</span>) &amp;&amp; id_in_king[x1] == <span class="string">'F'</span>) || (A[i].identity == <span class="string">'F'</span> &amp;&amp; (id_in_king[x1] == <span class="string">'M'</span> || id_in_king[x1] == <span class="string">'Z'</span>)))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= A[i].card_num; ++j)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (A[i].card[j] == <span class="string">'J'</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						A[i].card[j] = <span class="string">'U'</span>;</span><br><span class="line">						id_in_king[i] = A[i].identity;</span><br><span class="line">						<span class="keyword">return</span> !wxkjj(i, x1, <span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		i = A[i]._next;</span><br><span class="line">		<span class="keyword">if</span> (i == x1)	<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1540 【机器翻译】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P1540-%E3%80%90%E6%9C%BA%E5%99%A8%E7%BF%BB%E8%AF%91%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>这是一道水题。</p>
<p>那为什么我还要来发这一篇题解呢？</p>
<p>故事要说到我刚学OI的时候。</p>
<p>那时的我，看到这道题，觉得自己一辈子也做不出来。但现在来看看，不过就是队列模拟而已。但这却能让我怀念许久。或许这就是OI的魔力吧</p>
<p>code:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; dic;</span><br><span class="line"><span class="keyword">int</span> n, m, x, ans;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">50000</span> + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">		<span class="keyword">if</span> (!vis[x])</span><br><span class="line">		&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			vis[x] = <span class="literal">true</span>;</span><br><span class="line">			dic.push(x);</span><br><span class="line">			<span class="keyword">if</span> (dic.size() &gt; n)</span><br><span class="line">			&#123;</span><br><span class="line">				vis[dic.front()] = <span class="literal">false</span>;</span><br><span class="line">				dic.pop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1516 【青蛙的约会】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P1516-%E3%80%90%E9%9D%92%E8%9B%99%E7%9A%84%E7%BA%A6%E4%BC%9A%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<h2 id="首先声明，这道题我并没有AC"><a href="#首先声明，这道题我并没有AC" class="headerlink" title="首先声明，这道题我并没有AC"></a>首先声明，这道题我并没有AC</h2><p>这是一道<code>Ex_gcd</code>的模版题</p>
<p>但我这个数学已经差的一定地步的人来说，不可能用<code>ex_gcd</code>来做。</p>
<p><img src="https://c-ssl.duitang.com/uploads/item/201607/24/20160724155346_QU3FC.jpeg" alt=""></p>
<p>··············································································</p>
<h2 id="其实这道题可以换一个思路来做。"><a href="#其实这道题可以换一个思路来做。" class="headerlink" title="其实这道题可以换一个思路来做。"></a>其实这道题可以换一个思路来做。</h2><p>如果不用<code>exgcd</code>的话，模拟也是一个不错的选择</p>
<p>但两只青蛙的情况不好模拟，而且时间复杂度肯定会到达一个十分恐怖的地步</p>
<p>那么我们就来思考一下如何将两只青蛙变为一只青蛙(同桌:<del>连体婴儿</del>)</p>
<p>不难想到把青蛙的速度定为<code>x - y</code>，起点定为<code>m - n</code>，这样就可以愉快的模拟啦(其实蒟蒻的我还是想了半天)</p>
<p>但这样只有50分，<del>我也算不来时间复杂度</del></p>
<p>如果同学能算出时间复杂度或者知道如何优化我的代码评论区请</p>
<p>下面是50分代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> m, n, l;</span><br><span class="line"><span class="keyword">int</span> sp, st, mod_, div_;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>, &amp;x, &amp;y, &amp;m, &amp;n, &amp;l);</span><br><span class="line">	<span class="keyword">if</span> (!(m ^ n))	<span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Impossible"</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (m &gt; n) sp = m - n, st = (y - x + l) % l; </span><br><span class="line">	<span class="keyword">else</span> sp = n - m, st = (x - y + l) % l;</span><br><span class="line">	mod_ = st % sp;</span><br><span class="line">	div_ = st / sp;</span><br><span class="line">	<span class="keyword">int</span> cxk = <span class="number">0x9C74FC</span>;</span><br><span class="line">	<span class="keyword">for</span> (; ; cxk &amp;= <span class="number">0x76FC44</span>, cxk ^= ((<span class="number">0xFD962C</span> | <span class="number">0x19AC5F</span>) &amp; <span class="number">0x79C74A</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(st % sp)) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, div_) &amp; <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">register</span> <span class="keyword">int</span> meta = (st % sp) + l;</span><br><span class="line">		div_ += meta / sp;</span><br><span class="line">		st = meta % sp;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (!(st ^ mod_)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Impossible"</span>) &amp; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P2671 【求和】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P2671-%E3%80%90%E6%B1%82%E5%92%8C%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>昨天考试这道题也是难倒了很多同学，但这并没有妨碍的某LJS AK(顺便%一波)</p>
<p>但是LJS的题解对我这种数学渣到不行蒟蒻实在不太友好，于是我干脆不看了。</p>
<p><a href="http://61.186.173.89:1024/article/253" target="_blank" rel="noopener">LJS题解传送门</a></p>
<p>于是我就想，这道题既然能够用暴力，那么就一定能够用各种奇淫技巧优化。</p>
<h1 id="O-N-3"><a href="#O-N-3" class="headerlink" title="O(N^3)"></a>O(N^3)</h1><p>首先我们只考虑$O(N^3)$的裸暴力，枚举每个x,y,z。这样就有20分了。</p>
<h1 id="O-N-2"><a href="#O-N-2" class="headerlink" title="O(N^2)"></a>O(N^2)</h1><p>接下来仔细观察题目，发现题目限制$y-x=z-y$，通过移项，可以得到$z+x=2y$</p>
<p>那么我们就可以去掉枚举$y$的循环，时间复杂度$O(N^2)$</p>
<p>这样就有40分了，再加上一些花里胡哨的优化，可以骗到60分</p>
<h1 id="歪正解"><a href="#歪正解" class="headerlink" title="歪正解"></a>歪正解</h1><p>再来观察$z+x=2y$这个式子，$2y$一定是一个偶数，那么则$z$和$x$满足同奇偶。</p>
<p>再次阅读题目，观察三元组的限制条件，我们很容易就可以想到按照颜色和每个格子的下标进行分组，那么像这样看来，我们就应该把重点放在cmp排序函数上。</p>
<p>既然$z$和$x$满足同奇偶，那么我们就可以按照这个来进行排序。</p>
<p>排序后，我们就可以很方便的判断哪些情况是不可能的，则枚举每一个$z$和$x$，判断不可能的情况，然后直接$break$，听起来有些像搜索的剪枝</p>
<h2 id="照这个思路写出来的40分代码"><a href="#照这个思路写出来的40分代码" class="headerlink" title="照这个思路写出来的40分代码:"></a>照这个思路写出来的40分代码:</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> color;</span><br><span class="line">	<span class="keyword">int</span> number;</span><br><span class="line">	<span class="keyword">int</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color != a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:<br><img src="https://i.loli.net/2019/07/23/5d36530d59c3c82269.png" alt=""></p>
<p>这是为什么呢？原来没开$long$ $long$见祖宗了</p>
<p>90分代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> <span class="keyword">long</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color != a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果:</p>
<p><img src="https://i.loli.net/2019/07/23/5d36530d6c6cc42741.png" alt=""></p>
<p>有一个点超时了，于是开始卡常:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color ^ a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依旧是90分，脑子快爆了的我只好祭出这个</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize (2)</span></span><br></pre></td></tr></table></figure>
<p>AC代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize (2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 10007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> color;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> number;</span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">long</span> ID;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Rule</span><span class="params">(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color == b.color) &amp;&amp; (a.ID &lt; b.ID)) </span><br><span class="line">		|| ((a.ID % <span class="number">2</span> == b.ID % <span class="number">2</span>) &amp;&amp; (a.color &lt; b.color)) || (a.ID % <span class="number">2</span> &lt; b.ID % <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">result</span><span class="params">(<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> z)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a[x].ID + a[z].ID) * (a[x].number + a[z].number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].number), a[i].ID = i;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].color);</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">	sort(a + <span class="number">1</span>, a + <span class="number">1</span> + n, Rule);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n; ++k) &#123;</span><br><span class="line">				<span class="keyword">if</span> ((a[i].ID + a[k].ID) &amp; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[i].color ^ a[k].color) <span class="keyword">break</span>; </span><br><span class="line">				ans += result(i, k) % MOD;</span><br><span class="line">			&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans % MOD);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/23/5d36530d6cc2083763.png" alt=""></p>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1087 【FBI树】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P1087-%E3%80%90FBI%E6%A0%91%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>最近才学了树形结构，个人认为这是一道很适合新手拿来练手的题目。</p>
<p>因为题目没有规定给出的二进制串是按照POT、IOT、TOT顺序的，所以只需要通过简单单的分治思想便可解决。</p>
<p>具体注释我会写在代码里</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> *str = <span class="keyword">new</span> <span class="keyword">char</span>[(<span class="number">1</span> &lt;&lt; <span class="number">10</span>) + <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FBI_WARNING</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);      <span class="comment">//据说这样求mid可以使（INT_MAX - 5 + INT_MAX) / 2的溢出悲剧避免发生</span></span><br><span class="line">	<span class="keyword">if</span> (left != right)</span><br><span class="line">		FBI_WARNING(left, mid), FBI_WARNING(mid + <span class="number">1</span>, right); <span class="comment">//建树</span></span><br><span class="line">	<span class="keyword">int</span> Japan = <span class="number">0</span>, America = <span class="number">0</span>;				<span class="comment">//分别统计0、1的出现次数</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">		str[i] == <span class="string">'0'</span> ? Japan++ : America++;</span><br><span class="line">	<span class="keyword">if</span> (Japan &amp;&amp; America) <span class="built_in">putchar</span>(<span class="string">'F'</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (Japan) <span class="built_in">putchar</span>(<span class="string">'B'</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">putchar</span>(<span class="string">'I'</span>);				<span class="comment">//判断输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; str + <span class="number">1</span>;			<span class="comment">//这样可以让字符串从下标1开始输入，我学了这么久的OI还是不习惯从0开始233</span></span><br><span class="line">	FBI_WARNING(<span class="number">1</span>, <span class="number">1</span> &lt;&lt; n);		<span class="comment">//1 &lt;&lt; n是二的N次方，也就是str的长度。因为strlen的常数有点大，所以干脆直接位运算</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P5018 【对称二叉树】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P5018-%E3%80%90%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>说实话，我真的不认为这是T4的难度，暴力解决一切</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> LeftChild;</span><br><span class="line">    <span class="keyword">int</span> RightChild;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">&#125; a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">st</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a[x].LeftChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        st(a[x].LeftChild);</span><br><span class="line">        a[x].value += a[a[x].LeftChild].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[x].RightChild != <span class="number">-1</span>) &#123;</span><br><span class="line">        st(a[x].RightChild);</span><br><span class="line">        a[x].value += a[a[x].RightChild].value;</span><br><span class="line">    &#125;</span><br><span class="line">    a[x].value++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">-1</span> &amp;&amp; y == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[x].value ^ a[y].value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[x].root ^ a[y].root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> check(a[x].LeftChild, a[y].RightChild) &amp;&amp; check(a[x].RightChild, a[y].LeftChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i].root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a[i].LeftChild, &amp;a[i].RightChild);</span><br><span class="line">    st(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-0x10086001</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].value &lt; ans) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(a[i].LeftChild, a[i].RightChild)) ans = a[i].value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
  <entry>
    <title>题解 P1056 【排座椅】</title>
    <url>/2019/11/30/%E9%A2%98%E8%A7%A3-P1056-%E3%80%90%E6%8E%92%E5%BA%A7%E6%A4%85%E3%80%91/</url>
    <content><![CDATA[<a id="more"></a>
<p>贪心</p>
<p>策略很简单，就是判断一个过道安排在哪能排除最多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ArrSize = <span class="number">2000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> m, n, k, l, d;</span><br><span class="line"><span class="keyword">int</span> x[ArrSize], y[ArrSize];</span><br><span class="line"><span class="keyword">int</span> a[ArrSize], b[ArrSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;m, &amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;k, &amp;l, &amp;d);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">		<span class="keyword">if</span> (x1 == x2)</span><br><span class="line">			x[<span class="built_in">std</span>::min(y1, y2)]++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			y[<span class="built_in">std</span>::min(x1, x2)]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> Maxx = <span class="number">-10086</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">			<span class="keyword">if</span> (y[j] &gt; Maxx) &#123;</span><br><span class="line">				Maxx = y[j];</span><br><span class="line">				tmp = j;</span><br><span class="line">			&#125;</span><br><span class="line">		y[tmp] = <span class="number">0</span>;</span><br><span class="line">		a[tmp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> Maxx = <span class="number">-10086</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">			<span class="keyword">if</span> (x[j] &gt; Maxx) &#123;</span><br><span class="line">				Maxx = x[j];</span><br><span class="line">				tmp = j;</span><br><span class="line">			&#125;</span><br><span class="line">		x[tmp] = <span class="number">0</span>;</span><br><span class="line">		b[tmp]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ArrSize; ++i)</span><br><span class="line">		<span class="keyword">if</span> (a[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ArrSize; ++i)</span><br><span class="line">		<span class="keyword">if</span> (b[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">	<span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Solution</tag>
      </tags>
  </entry>
</search>
